var $NGL_shaderTextHash = {};

$NGL_shaderTextHash['SphereImpostor.frag'] = ["#define STANDARD",
"#define IMPOSTOR",
"",
"uniform vec3 diffuse;",
"uniform vec3 emissive;",
"uniform float roughness;",
"uniform float metalness;",
"uniform float opacity;",
"uniform float nearClip;",
"uniform mat4 projectionMatrix;",
"uniform float ortho;",
"",
"varying float vRadius;",
"varying float vRadiusSq;",
"varying vec3 vPoint;",
"varying vec3 vPointViewPosition;",
"",
"#ifdef PICKING",
"    uniform float objectId;",
"    varying vec3 vPickingColor;",
"#else",
"    #include common",
"    #include color_pars_fragment",
"    #include fog_pars_fragment",
"    #include bsdfs",
"    #include lights_pars_begin",
"    #include lights_physical_pars_fragment",
"#endif",
"",
"bool flag2 = false;",
"bool interior = false;",
"vec3 cameraPos;",
"vec3 cameraNormal;",
"",
"// Calculate depth based on the given camera position.",
"float calcDepth( in vec3 cameraPos ){",
"    vec2 clipZW = cameraPos.z * projectionMatrix[2].zw + projectionMatrix[3].zw;",
"    return 0.5 + 0.5 * clipZW.x / clipZW.y;",
"}",
"",
"float calcClip( vec3 cameraPos ){",
"    return dot( vec4( cameraPos, 1.0 ), vec4( 0.0, 0.0, 1.0, nearClip - 0.5 ) );",
"}",
"",
"bool Impostor( out vec3 cameraPos, out vec3 cameraNormal ){",
"",
"    vec3 cameraSpherePos = -vPointViewPosition;",
"    cameraSpherePos.z += vRadius;",
"",
"    vec3 rayOrigin = mix( vec3( 0.0, 0.0, 0.0 ), vPoint, ortho );",
"    vec3 rayDirection = mix( normalize( vPoint ), vec3( 0.0, 0.0, 1.0 ), ortho );",
"    vec3 cameraSphereDir = mix( cameraSpherePos, rayOrigin - cameraSpherePos, ortho );",
"",
"    float B = dot( rayDirection, cameraSphereDir );",
"    float det = B * B + vRadiusSq - dot( cameraSphereDir, cameraSphereDir );",
"",
"    if( det < 0.0 ){",
"        discard;",
"        return false;",
"    }",
"        float sqrtDet = sqrt( det );",
"        float posT = mix( B + sqrtDet, B + sqrtDet, ortho );",
"        float negT = mix( B - sqrtDet, sqrtDet - B, ortho );",
"",
"        cameraPos = rayDirection * negT + rayOrigin;",
"",
"        #ifdef NEAR_CLIP",
"if( calcDepth( cameraPos ) <= 0.0 ){",
"    cameraPos = rayDirection * posT + rayOrigin;",
"    interior = true;",
"    return false;",
"}else if( calcClip( cameraPos ) > 0.0 ){",
"    cameraPos = rayDirection * posT + rayOrigin;",
"    interior = true;",
"    flag2 = true;",
"    return false;",
"}else{",
"    cameraNormal = normalize( cameraPos - cameraSpherePos );",
"}",
"        #else",
"if( calcDepth( cameraPos ) <= 0.0 ){",
"    cameraPos = rayDirection * posT + rayOrigin;",
"    interior = true;",
"    return false;",
"}else{",
"    cameraNormal = normalize( cameraPos - cameraSpherePos );",
"}",
"        #endif",
"",
"        cameraNormal = normalize( cameraPos - cameraSpherePos );",
"        cameraNormal *= float(!interior) * 2.0 - 1.0;",
"         return !interior;",
"",
"}",
"",
"void main(void){",
"",
"    bool flag = Impostor( cameraPos, cameraNormal );",
"",
"    #ifdef NEAR_CLIP",
"        if( calcClip( cameraPos ) > 0.0 )",
"            discard;",
"    #endif",
"",
"    // FIXME not compatible with custom clipping plane",
"    //Set the depth based on the new cameraPos.",
"    gl_FragDepthEXT = calcDepth( cameraPos );",
"    if( !flag ){",
"",
"        // clamp to near clipping plane and add a tiny value to",
"        // make spheres with a greater radius occlude smaller ones",
"        #ifdef NEAR_CLIP",
"if( flag2 ){",
"    gl_FragDepthEXT = max( 0.0, calcDepth( vec3( - ( nearClip - 0.5 ) ) ) + ( 0.0000001 / vRadius ) );",
"}else if( gl_FragDepthEXT >= 0.0 ){",
"    gl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );",
"}",
"        #else",
"if( gl_FragDepthEXT >= 0.0 ){",
"    gl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );",
"}",
"        #endif",
"",
"    }",
"",
"    // bugfix (mac only?)",
"    if (gl_FragDepthEXT < 0.0)",
"        discard;",
"    if (gl_FragDepthEXT > 1.0)",
"        discard;",
"",
"    #ifdef PICKING",
"",
"        gl_FragColor = vec4( vPickingColor, objectId );",
"",
"    #else",
"",
"        vec3 vNormal = cameraNormal;",
"        vec3 vViewPosition = -cameraPos;",
"",
"        vec4 diffuseColor = vec4( diffuse, opacity );",
"        ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
"        vec3 totalEmissiveLight = emissive;",
"",
"        #include color_fragment",
"        #include roughnessmap_fragment",
"        #include metalnessmap_fragment",
"",
"        // don't use include normal_fragment",
"        vec3 normal = normalize( vNormal );",
"",
"        #include lights_physical_fragment",
"        //include lights_template",
"        #include lights_fragment_begin",
"        #include lights_fragment_end",
"",
"        vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;",
"",
"        gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
"        //gl_FragColor = vec4( reflectedLight.directSpecular, diffuseColor.a );",
"",
"        #include premultiplied_alpha_fragment",
"        #include tonemapping_fragment",
"        #include encodings_fragment",
"        //include fog_fragment",
"        #ifdef USE_FOG",
"            #ifdef USE_LOGDEPTHBUF_EXT",
"                float depth = gl_FragDepthEXT / gl_FragCoord.w;",
"            #else",
"                float depth = gl_FragCoord.z / gl_FragCoord.w;",
"            #endif",
"            #ifdef FOG_EXP2",
"                float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );",
"            #else",
"                float fogFactor = smoothstep( fogNear, fogFar, depth );",
"            #endif",
"            gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );",
"        #endif",
"",
"    #endif",
"",
"}"
].join("\n");

$NGL_shaderTextHash['SphereImpostor.vert'] = ["uniform mat4 projectionMatrixInverse;",
"uniform float nearClip;",
"",
"varying float vRadius;",
"varying float vRadiusSq;",
"varying vec3 vPoint;",
"varying vec3 vPointViewPosition;",
"varying float fogDepth;",
"varying float fogNear;",
"varying float fogFar;",
"",
"attribute vec2 mapping;",
"//attribute vec3 position;",
"attribute float radius;",
"",
"#ifdef PICKING",
"    #include unpack_clr",
"    attribute float primitiveId;",
"    varying vec3 vPickingColor;",
"#else",
"    #include color_pars_vertex",
"#endif",
"",
"//include matrix_scale",
"float matrixScale( in mat4 m ){",
"    vec4 r = m[ 0 ];",
"    return sqrt( r[ 0 ] * r[ 0 ] + r[ 1 ] * r[ 1 ] + r[ 2 ] * r[ 2 ] );",
"}",
"",
"const mat4 D = mat4(",
"    1.0, 0.0, 0.0, 0.0,",
"    0.0, 1.0, 0.0, 0.0,",
"    0.0, 0.0, 1.0, 0.0,",
"    0.0, 0.0, 0.0, -1.0",
");",
"",
"mat4 transposeTmp( in mat4 inMatrix ) {",
"    vec4 i0 = inMatrix[0];",
"    vec4 i1 = inMatrix[1];",
"    vec4 i2 = inMatrix[2];",
"    vec4 i3 = inMatrix[3];",
"",
"    mat4 outMatrix = mat4(",
"        vec4(i0.x, i1.x, i2.x, i3.x),",
"        vec4(i0.y, i1.y, i2.y, i3.y),",
"        vec4(i0.z, i1.z, i2.z, i3.z),",
"        vec4(i0.w, i1.w, i2.w, i3.w)",
"    );",
"    return outMatrix;",
"}",
"",
"//------------------------------------------------------------------------------",
"// Compute point size and center using the technique described in:",
"// 'GPU-Based Ray-Casting of Quadratic Surfaces'",
"// by Christian Sigg, Tim Weyrich, Mario Botsch, Markus Gross.",
"//",
"// Code based on",
"/*=========================================================================",
"",
" Program:   Visualization Toolkit",
" Module:    Quadrics_fs.glsl and Quadrics_vs.glsl",
"",
" Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen",
" All rights reserved.",
" See Copyright.txt or http://www.kitware.com/Copyright.htm for details.",
"",
" This software is distributed WITHOUT ANY WARRANTY; without even",
" the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR",
" PURPOSE.  See the above copyright notice for more information.",
"",
" =========================================================================*/",
"",
"// .NAME Quadrics_fs.glsl and Quadrics_vs.glsl",
"// .SECTION Thanks",
"// <verbatim>",
"//",
"//  This file is part of the PointSprites plugin developed and contributed by",
"//",
"//  Copyright (c) CSCS - Swiss National Supercomputing Centre",
"//                EDF - Electricite de France",
"//",
"//  John Biddiscombe, Ugo Varetto (CSCS)",
"//  Stephane Ploix (EDF)",
"//",
"// </verbatim>",
"//",
"// Contributions by Alexander Rose",
"// - ported to WebGL",
"// - adapted to work with quads",
"void ComputePointSizeAndPositionInClipCoordSphere(){",
"",
"    vec2 xbc;",
"    vec2 ybc;",
"",
"    mat4 T = mat4(",
"        radius, 0.0, 0.0, 0.0,",
"        0.0, radius, 0.0, 0.0,",
"        0.0, 0.0, radius, 0.0,",
"        position.x, position.y, position.z, 1.0",
"    );",
"",
"    mat4 R = transposeTmp( projectionMatrix * modelViewMatrix * T );",
"    float A = dot( R[ 3 ], D * R[ 3 ] );",
"    float B = -2.0 * dot( R[ 0 ], D * R[ 3 ] );",
"    float C = dot( R[ 0 ], D * R[ 0 ] );",
"    xbc[ 0 ] = ( -B - sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );",
"    xbc[ 1 ] = ( -B + sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );",
"    float sx = abs( xbc[ 0 ] - xbc[ 1 ] ) * 0.5;",
"",
"    A = dot( R[ 3 ], D * R[ 3 ] );",
"    B = -2.0 * dot( R[ 1 ], D * R[ 3 ] );",
"    C = dot( R[ 1 ], D * R[ 1 ] );",
"    ybc[ 0 ] = ( -B - sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );",
"    ybc[ 1 ] = ( -B + sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );",
"    float sy = abs( ybc[ 0 ] - ybc[ 1 ]  ) * 0.5;",
"",
"    gl_Position.xy = vec2( 0.5 * ( xbc.x + xbc.y ), 0.5 * ( ybc.x + ybc.y ) );",
"    gl_Position.xy -= mapping * vec2( sx, sy );",
"    gl_Position.xy *= gl_Position.w;",
"",
"}",
"",
"void main(void){",
"",
"    #ifdef PICKING",
"        vPickingColor = unpackColor( primitiveId );",
"    #else",
"        #include color_vertex",
"    #endif",
"",
"    vRadius = radius * matrixScale( modelViewMatrix );",
"",
"    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
"    // avoid clipping, added again in fragment shader",
"    mvPosition.z -= vRadius;",
"",
"    gl_Position = projectionMatrix * vec4( mvPosition.xyz, 1.0 );",
"    ComputePointSizeAndPositionInClipCoordSphere();",
"",
"",
"    vRadiusSq = vRadius * vRadius;",
"    vec4 vPoint4 = projectionMatrixInverse * gl_Position;",
"    vPoint = vPoint4.xyz / vPoint4.w;",
"    vPointViewPosition = -mvPosition.xyz / mvPosition.w;",
"",
"}"
].join("\n");

$NGL_shaderTextHash['CylinderImpostor.frag'] = ["#define STANDARD",
"#define IMPOSTOR",
"",
"// Open-Source PyMOL is Copyright (C) Schrodinger, LLC.",
"//",
"//  All Rights Reserved",
"//",
"//  Permission to use, copy, modify, distribute, and distribute modified",
"//  versions of this software and its built-in documentation for any",
"//  purpose and without fee is hereby granted, provided that the above",
"//  copyright notice appears in all copies and that both the copyright",
"//  notice and this permission notice appear in supporting documentation,",
"//  and that the name of Schrodinger, LLC not be used in advertising or",
"//  publicity pertaining to distribution of the software without specific,",
"//  written prior permission.",
"//",
"//  SCHRODINGER, LLC DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,",
"//  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN",
"//  NO EVENT SHALL SCHRODINGER, LLC BE LIABLE FOR ANY SPECIAL, INDIRECT OR",
"//  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS",
"//  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE",
"//  OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE",
"//  USE OR PERFORMANCE OF THIS SOFTWARE.",
"",
"// Contributions by Alexander Rose",
"// - ported to WebGL",
"// - dual color",
"// - pk color",
"// - custom clipping",
"// - three.js lighting",
"",
"uniform vec3 diffuse;",
"uniform vec3 emissive;",
"uniform float roughness;",
"uniform float metalness;",
"uniform float opacity;",
"uniform float nearClip;",
"uniform mat4 projectionMatrix;",
"uniform float ortho;",
"",
"varying vec3 axis;",
"varying vec4 base_radius;",
"varying vec4 end_b;",
"varying vec3 U;",
"varying vec3 V;",
"varying vec4 w;",
"",
"#ifdef PICKING",
"    uniform float objectId;",
"    varying vec3 vPickingColor;",
"#else",
"    varying vec3 vColor1;",
"    varying vec3 vColor2;",
"    #include common",
"    #include fog_pars_fragment",
"    #include bsdfs",
"    #include lights_pars_begin",
"    #include lights_physical_pars_fragment",
"#endif",
"",
"bool interior = false;",
"",
"float distSq3( vec3 v3a, vec3 v3b ){",
"    return (",
"        ( v3a.x - v3b.x ) * ( v3a.x - v3b.x ) +",
"        ( v3a.y - v3b.y ) * ( v3a.y - v3b.y ) +",
"        ( v3a.z - v3b.z ) * ( v3a.z - v3b.z )",
"    );",
"}",
"",
"// Calculate depth based on the given camera position.",
"float calcDepth( in vec3 cameraPos ){",
"    vec2 clipZW = cameraPos.z * projectionMatrix[2].zw + projectionMatrix[3].zw;",
"    return 0.5 + 0.5 * clipZW.x / clipZW.y;",
"}",
"",
"float calcClip( vec3 cameraPos ){",
"    return dot( vec4( cameraPos, 1.0 ), vec4( 0.0, 0.0, 1.0, nearClip - 0.5 ) );",
"}",
"",
"void main(){",
"",
"    vec3 point = w.xyz / w.w;",
"",
"    // unpacking",
"    vec3 base = base_radius.xyz;",
"    float vRadius = base_radius.w;",
"    vec3 end = end_b.xyz;",
"    float b = end_b.w;",
"",
"    vec3 end_cyl = end;",
"    vec3 surface_point = point;",
"",
"    vec3 ray_target = surface_point;",
"    vec3 ray_origin = vec3(0.0);",
"    vec3 ray_direction = mix(normalize(ray_origin - ray_target), vec3(0.0, 0.0, 1.0), ortho);",
"    mat3 basis = mat3( U, V, axis );",
"",
"    vec3 diff = ray_target - 0.5 * (base + end_cyl);",
"    vec3 P = diff * basis;",
"",
"    // angle (cos) between cylinder cylinder_axis and ray direction",
"    float dz = dot( axis, ray_direction );",
"",
"    float radius2 = vRadius*vRadius;",
"",
"    // calculate distance to the cylinder from ray origin",
"    vec3 D = vec3(dot(U, ray_direction),",
"                dot(V, ray_direction),",
"                dz);",
"    float a0 = P.x*P.x + P.y*P.y - radius2;",
"    float a1 = P.x*D.x + P.y*D.y;",
"    float a2 = D.x*D.x + D.y*D.y;",
"",
"    // calculate a dicriminant of the above quadratic equation",
"    float d = a1*a1 - a0*a2;",
"    if (d < 0.0)",
"        // outside of the cylinder",
"        discard;",
"",
"    float dist = (-a1 + sqrt(d)) / a2;",
"",
"    // point of intersection on cylinder surface",
"    vec3 new_point = ray_target + dist * ray_direction;",
"",
"    vec3 tmp_point = new_point - base;",
"    vec3 _normal = normalize( tmp_point - axis * dot(tmp_point, axis) );",
"",
"    ray_origin = mix( ray_origin, surface_point, ortho );",
"",
"    // test caps",
"    float front_cap_test = dot( tmp_point, axis );",
"    float end_cap_test = dot((new_point - end_cyl), axis);",
"",
"    // to calculate caps, simply check the angle between",
"    // the point of intersection - cylinder end vector",
"    // and a cap plane normal (which is the cylinder cylinder_axis)",
"    // if the angle < 0, the point is outside of cylinder",
"    // test front cap",
"",
"    #ifndef CAP",
"        vec3 new_point2 = ray_target + ( (-a1 - sqrt(d)) / a2 ) * ray_direction;",
"        vec3 tmp_point2 = new_point2 - base;",
"    #endif",
"",
"    // flat",
"    if (front_cap_test < 0.0)",
"    {",
"        // ray-plane intersection",
"        float dNV = dot(-axis, ray_direction);",
"        if (dNV < 0.0)",
"            discard;",
"        float near = dot(-axis, (base)) / dNV;",
"        vec3 front_point = ray_direction * near + ray_origin;",
"        // within the cap radius?",
"        if (dot(front_point - base, front_point-base) > radius2)",
"            discard;",
"",
"        #ifdef CAP",
"            new_point = front_point;",
"            _normal = axis;",
"        #else",
"            new_point = ray_target + ( (-a1 - sqrt(d)) / a2 ) * ray_direction;",
"            dNV = dot(-axis, ray_direction);",
"            near = dot(axis, end_cyl) / dNV;",
"            new_point2 = ray_direction * near + ray_origin;",
"            if (dot(new_point2 - end_cyl, new_point2-base) < radius2)",
"                discard;",
"            interior = true;",
"        #endif",
"    }",
"",
"    // test end cap",
"",
"",
"    // flat",
"    if( end_cap_test > 0.0 )",
"    {",
"        // ray-plane intersection",
"        float dNV = dot(axis, ray_direction);",
"        if (dNV < 0.0)",
"            discard;",
"        float near = dot(axis, end_cyl) / dNV;",
"        vec3 end_point = ray_direction * near + ray_origin;",
"        // within the cap radius?",
"        if( dot(end_point - end_cyl, end_point-base) > radius2 )",
"            discard;",
"",
"        #ifdef CAP",
"            new_point = end_point;",
"            _normal = axis;",
"        #else",
"            new_point = ray_target + ( (-a1 - sqrt(d)) / a2 ) * ray_direction;",
"            dNV = dot(-axis, ray_direction);",
"            near = dot(-axis, (base)) / dNV;",
"            new_point2 = ray_direction * near + ray_origin;",
"            if (dot(new_point2 - base, new_point2-base) < radius2)",
"                discard;",
"            interior = true;",
"        #endif",
"    }",
"",
"    gl_FragDepthEXT = calcDepth( new_point );",
"",
"    #ifdef NEAR_CLIP",
"        if( calcClip( new_point ) > 0.0 ){",
"            dist = (-a1 - sqrt(d)) / a2;",
"            new_point = ray_target + dist * ray_direction;",
"            if( calcClip( new_point ) > 0.0 )",
"                discard;",
"            interior = true;",
"            gl_FragDepthEXT = calcDepth( new_point );",
"            if( gl_FragDepthEXT >= 0.0 ){",
"                gl_FragDepthEXT = max( 0.0, calcDepth( vec3( - ( nearClip - 0.5 ) ) ) + ( 0.0000001 / vRadius ) );",
"            }",
"        }else if( gl_FragDepthEXT <= 0.0 ){",
"            dist = (-a1 - sqrt(d)) / a2;",
"            new_point = ray_target + dist * ray_direction;",
"            interior = true;",
"            gl_FragDepthEXT = calcDepth( new_point );",
"            if( gl_FragDepthEXT >= 0.0 ){",
"                gl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );",
"            }",
"        }",
"    #else",
"        if( gl_FragDepthEXT <= 0.0 ){",
"            dist = (-a1 - sqrt(d)) / a2;",
"            new_point = ray_target + dist * ray_direction;",
"            interior = true;",
"            gl_FragDepthEXT = calcDepth( new_point );",
"            if( gl_FragDepthEXT >= 0.0 ){",
"                gl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );",
"            }",
"        }",
"    #endif",
"",
"    // this is a workaround necessary for Mac",
"    // otherwise the modified fragment won't clip properly",
"    if (gl_FragDepthEXT < 0.0)",
"        discard;",
"    if (gl_FragDepthEXT > 1.0)",
"        discard;",
"",
"    #ifdef PICKING",
"",
"        gl_FragColor = vec4( vPickingColor, objectId );",
"",
"    #else",
"",
"        vec3 vViewPosition = -new_point;",
"        vec3 vNormal = _normal;",
"        vec3 vColor;",
"",
"        if( distSq3( new_point, end_cyl ) < distSq3( new_point, base ) ){",
"            if( b < 0.0 ){",
"                vColor = vColor1;",
"            }else{",
"                vColor = vColor2;",
"            }",
"        }else{",
"            if( b > 0.0 ){",
"                vColor = vColor1;",
"            }else{",
"                vColor = vColor2;",
"            }",
"        }",
"",
"        vec4 diffuseColor = vec4( diffuse, opacity );",
"        ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
"        vec3 totalEmissiveLight = emissive;",
"",
"        #include color_fragment",
"     //ifdef USE_COLOR",
"     //diffuseColor.r *= vColor[0];",
"     //diffuseColor.g *= vColor[1];",
"     //diffuseColor.b *= vColor[2];",
"     //endif",
"        #include roughnessmap_fragment",
"        #include metalnessmap_fragment",
"",
"        // don't use include normal_fragment",
"        vec3 normal = normalize( vNormal );",
"",
"        #include lights_physical_fragment",
"        //include lights_template",
"        #include lights_fragment_begin",
"        #include lights_fragment_end",
"",
"        vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;",
"",
"        gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
"        //gl_FragColor = vec4( reflectedLight.directSpecular, diffuseColor.a );",
"",
"        #include premultiplied_alpha_fragment",
"        #include tonemapping_fragment",
"        #include encodings_fragment",
"        //include fog_fragment",
"        #ifdef USE_FOG",
"            #ifdef USE_LOGDEPTHBUF_EXT",
"                float depth = gl_FragDepthEXT / gl_FragCoord.w;",
"            #else",
"                float depth = gl_FragCoord.z / gl_FragCoord.w;",
"            #endif",
"            #ifdef FOG_EXP2",
"                float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );",
"            #else",
"                float fogFactor = smoothstep( fogNear, fogFar, depth );",
"            #endif",
"            gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );",
"        #endif",
"",
"    #endif",
"",
"}"
].join("\n");

$NGL_shaderTextHash['CylinderImpostor.vert'] = ["// Open-Source PyMOL is Copyright (C) Schrodinger, LLC.",
"//",
"//  All Rights Reserved",
"//",
"//  Permission to use, copy, modify, distribute, and distribute modified",
"//  versions of this software and its built-in documentation for any",
"//  purpose and without fee is hereby granted, provided that the above",
"//  copyright notice appears in all copies and that both the copyright",
"//  notice and this permission notice appear in supporting documentation,",
"//  and that the name of Schrodinger, LLC not be used in advertising or",
"//  publicity pertaining to distribution of the software without specific,",
"//  written prior permission.",
"//",
"//  SCHRODINGER, LLC DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,",
"//  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN",
"//  NO EVENT SHALL SCHRODINGER, LLC BE LIABLE FOR ANY SPECIAL, INDIRECT OR",
"//  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS",
"//  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE",
"//  OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE",
"//  USE OR PERFORMANCE OF THIS SOFTWARE.",
"",
"// Contributions by Alexander Rose",
"// - ported to WebGL",
"// - dual color",
"// - pk color",
"// - shift",
"",
"attribute vec3 mapping;",
"attribute vec3 position1;",
"attribute vec3 position2;",
"attribute float radius;",
"",
"varying vec3 axis;",
"varying vec4 base_radius;",
"varying vec4 end_b;",
"varying vec3 U;",
"varying vec3 V;",
"varying vec4 w;",
"varying float fogDepth;",
"varying float fogNear;",
"varying float fogFar;",
"",
"#ifdef PICKING",
"    #include unpack_clr",
"    attribute float primitiveId;",
"    varying vec3 vPickingColor;",
"#else",
"    //attribute vec3 color;",
"    attribute vec3 color2;",
"    varying vec3 vColor1;",
"    varying vec3 vColor2;",
"#endif",
"",
"uniform mat4 modelViewMatrixInverse;",
"uniform float ortho;",
"",
"//include matrix_scale",
"float matrixScale( in mat4 m ){",
"    vec4 r = m[ 0 ];",
"    return sqrt( r[ 0 ] * r[ 0 ] + r[ 1 ] * r[ 1 ] + r[ 2 ] * r[ 2 ] );",
"}",
"",
"void main(){",
"",
"    #ifdef PICKING",
"        vPickingColor = unpackColor( primitiveId );",
"    #else",
"        vColor1 = color;",
"        vColor2 = color2;",
"    #endif",
"",
"    // vRadius = radius;",
"    base_radius.w = radius * matrixScale( modelViewMatrix );",
"",
"    //vec3 center = position;",
"    vec3 center = ( position2 + position1 ) / 2.0;",
"    vec3 dir = normalize( position2 - position1 );",
"    float ext = length( position2 - position1 ) / 2.0;",
"",
"    // using cameraPosition fails on some machines, not sure why",
"    // vec3 cam_dir = normalize( cameraPosition - mix( center, vec3( 0.0 ), ortho ) );",
"    vec3 cam_dir;",
"    if( ortho == 0.0 ){",
"        cam_dir = ( modelViewMatrixInverse * vec4( 0, 0, 0, 1 ) ).xyz - center;",
"    }else{",
"        cam_dir = ( modelViewMatrixInverse * vec4( 0, 0, 1, 0 ) ).xyz;",
"    }",
"    cam_dir = normalize( cam_dir );",
"",
"    vec3 ldir;",
"",
"    float b = dot( cam_dir, dir );",
"    end_b.w = b;",
"    // direction vector looks away, so flip",
"    if( b < 0.0 )",
"        ldir = -ext * dir;",
"    // direction vector already looks in my direction",
"    else",
"        ldir = ext * dir;",
"",
"    vec3 left = normalize( cross( cam_dir, ldir ) );",
"    left = radius * left;",
"    vec3 up = radius * normalize( cross( left, ldir ) );",
"",
"    // transform to modelview coordinates",
"    axis = normalize( normalMatrix * ldir );",
"    U = normalize( normalMatrix * up );",
"    V = normalize( normalMatrix * left );",
"",
"    vec4 base4 = modelViewMatrix * vec4( center - ldir, 1.0 );",
"    base_radius.xyz = base4.xyz / base4.w;",
"",
"    vec4 top_position = modelViewMatrix * vec4( center + ldir, 1.0 );",
"    vec4 end4 = top_position;",
"    end_b.xyz = end4.xyz / end4.w;",
"",
"    w = modelViewMatrix * vec4(",
"        center + mapping.x*ldir + mapping.y*left + mapping.z*up, 1.0",
"    );",
"",
"    gl_Position = projectionMatrix * w;",
"",
"    // avoid clipping (1.0 seems to induce flickering with some drivers)",
"    gl_Position.z = 0.99;",
"",
"}"
].join("\n");

$NGL_shaderTextHash['SphereInstancing.frag'] = $NGL_shaderTextHash['SphereImpostor.frag'];

$NGL_shaderTextHash['SphereInstancing.vert'] = ["uniform mat4 projectionMatrixInverse;",
"uniform float nearClip;",
"",
"varying float vRadius;",
"varying float vRadiusSq;",
"varying vec3 vPoint;",
"varying vec3 vPointViewPosition;",
"varying float fogDepth;",
"varying float fogNear;",
"varying float fogFar;",
"",
"attribute vec2 mapping;",
"//attribute vec3 position;",
"attribute float radius;",
"attribute vec4 matrix1;",
"attribute vec4 matrix2;",
"attribute vec4 matrix3;",
"attribute vec4 matrix4;",
"",
"#ifdef PICKING",
"    #include unpack_clr",
"    attribute float primitiveId;",
"    varying vec3 vPickingColor;",
"#else",
"    #include color_pars_vertex",
"#endif",
"",
"//include matrix_scale",
"float matrixScale( in mat4 m ){",
"    vec4 r = m[ 0 ];",
"    return sqrt( r[ 0 ] * r[ 0 ] + r[ 1 ] * r[ 1 ] + r[ 2 ] * r[ 2 ] );",
"}",
"",
"const mat4 D = mat4(",
"    1.0, 0.0, 0.0, 0.0,",
"    0.0, 1.0, 0.0, 0.0,",
"    0.0, 0.0, 1.0, 0.0,",
"    0.0, 0.0, 0.0, -1.0",
");",
"",
"mat4 transposeTmp( in mat4 inMatrix ) {",
"    vec4 i0 = inMatrix[0];",
"    vec4 i1 = inMatrix[1];",
"    vec4 i2 = inMatrix[2];",
"    vec4 i3 = inMatrix[3];",
"",
"    mat4 outMatrix = mat4(",
"        vec4(i0.x, i1.x, i2.x, i3.x),",
"        vec4(i0.y, i1.y, i2.y, i3.y),",
"        vec4(i0.z, i1.z, i2.z, i3.z),",
"        vec4(i0.w, i1.w, i2.w, i3.w)",
"    );",
"    return outMatrix;",
"}",
"",
"//------------------------------------------------------------------------------",
"// Compute point size and center using the technique described in:",
"// 'GPU-Based Ray-Casting of Quadratic Surfaces'",
"// by Christian Sigg, Tim Weyrich, Mario Botsch, Markus Gross.",
"//",
"// Code based on",
"/*=========================================================================",
"",
" Program:   Visualization Toolkit",
" Module:    Quadrics_fs.glsl and Quadrics_vs.glsl",
"",
" Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen",
" All rights reserved.",
" See Copyright.txt or http://www.kitware.com/Copyright.htm for details.",
"",
" This software is distributed WITHOUT ANY WARRANTY; without even",
" the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR",
" PURPOSE.  See the above copyright notice for more information.",
"",
" =========================================================================*/",
"",
"// .NAME Quadrics_fs.glsl and Quadrics_vs.glsl",
"// .SECTION Thanks",
"// <verbatim>",
"//",
"//  This file is part of the PointSprites plugin developed and contributed by",
"//",
"//  Copyright (c) CSCS - Swiss National Supercomputing Centre",
"//                EDF - Electricite de France",
"//",
"//  John Biddiscombe, Ugo Varetto (CSCS)",
"//  Stephane Ploix (EDF)",
"//",
"// </verbatim>",
"//",
"// Contributions by Alexander Rose",
"// - ported to WebGL",
"// - adapted to work with quads",
"void ComputePointSizeAndPositionInClipCoordSphere(vec4 updatePosition){",
"",
"    vec2 xbc;",
"    vec2 ybc;",
"",
"    mat4 T = mat4(",
"        radius, 0.0, 0.0, 0.0,",
"        0.0, radius, 0.0, 0.0,",
"        0.0, 0.0, radius, 0.0,",
"        updatePosition.x, updatePosition.y, updatePosition.z, 1.0",
"    );",
"",
"    mat4 R = transposeTmp( projectionMatrix * modelViewMatrix * T );",
"    float A = dot( R[ 3 ], D * R[ 3 ] );",
"    float B = -2.0 * dot( R[ 0 ], D * R[ 3 ] );",
"    float C = dot( R[ 0 ], D * R[ 0 ] );",
"    xbc[ 0 ] = ( -B - sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );",
"    xbc[ 1 ] = ( -B + sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );",
"    float sx = abs( xbc[ 0 ] - xbc[ 1 ] ) * 0.5;",
"",
"    A = dot( R[ 3 ], D * R[ 3 ] );",
"    B = -2.0 * dot( R[ 1 ], D * R[ 3 ] );",
"    C = dot( R[ 1 ], D * R[ 1 ] );",
"    ybc[ 0 ] = ( -B - sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );",
"    ybc[ 1 ] = ( -B + sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );",
"    float sy = abs( ybc[ 0 ] - ybc[ 1 ]  ) * 0.5;",
"",
"    gl_Position.xy = vec2( 0.5 * ( xbc.x + xbc.y ), 0.5 * ( ybc.x + ybc.y ) );",
"    gl_Position.xy -= mapping * vec2( sx, sy );",
"    gl_Position.xy *= gl_Position.w;",
"",
"}",
"",
"  mat4 computeMat(vec4 v1, vec4 v2, vec4 v3, vec4 v4) {",
"    return mat4(",
"      v1.x, v1.y, v1.z, v1.w,",
"      v2.x, v2.y, v2.z, v2.w,",
"      v3.x, v3.y, v3.z, v3.w,",
"      v4.x, v4.y, v4.z, v4.w",
"    );",
"  }",
"",
"void main(void){",
"",
"    #ifdef PICKING",
"        vPickingColor = unpackColor( primitiveId );",
"    #else",
"        #include color_vertex",
"    #endif",
"",
"    vRadius = radius * matrixScale( modelViewMatrix );",
"",
"    mat4 matrix = computeMat(matrix1, matrix2, matrix3, matrix4);",
"    vec4 updatePosition = matrix * vec4(position, 1.0);",
"",
"//    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
"    vec4 mvPosition = modelViewMatrix * vec4( updatePosition.xyz, 1.0 );",
"    // avoid clipping, added again in fragment shader",
"    mvPosition.z -= vRadius;",
"",
"//    gl_Position = projectionMatrix * vec4( mvPosition.xyz, 1.0 );",
"    gl_Position = projectionMatrix * vec4( mvPosition.xyz, 1.0 );",
"    ComputePointSizeAndPositionInClipCoordSphere(updatePosition);",
"",
"",
"    vRadiusSq = vRadius * vRadius;",
"    vec4 vPoint4 = projectionMatrixInverse * gl_Position;",
"    vPoint = vPoint4.xyz / vPoint4.w;",
"    vPointViewPosition = -mvPosition.xyz / mvPosition.w;",
"",
"}"
].join("\n");

$NGL_shaderTextHash['CylinderInstancing.frag'] = $NGL_shaderTextHash['CylinderImpostor.frag'];
$NGL_shaderTextHash['CylinderInstancing.vert'] = ["// Open-Source PyMOL is Copyright (C) Schrodinger, LLC.",
"//",
"//  All Rights Reserved",
"//",
"//  Permission to use, copy, modify, distribute, and distribute modified",
"//  versions of this software and its built-in documentation for any",
"//  purpose and without fee is hereby granted, provided that the above",
"//  copyright notice appears in all copies and that both the copyright",
"//  notice and this permission notice appear in supporting documentation,",
"//  and that the name of Schrodinger, LLC not be used in advertising or",
"//  publicity pertaining to distribution of the software without specific,",
"//  written prior permission.",
"//",
"//  SCHRODINGER, LLC DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,",
"//  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN",
"//  NO EVENT SHALL SCHRODINGER, LLC BE LIABLE FOR ANY SPECIAL, INDIRECT OR",
"//  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS",
"//  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE",
"//  OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE",
"//  USE OR PERFORMANCE OF THIS SOFTWARE.",
"",
"// Contributions by Alexander Rose",
"// - ported to WebGL",
"// - dual color",
"// - pk color",
"// - shift",
"",
"attribute vec3 mapping;",
"attribute vec3 position1;",
"attribute vec3 position2;",
"attribute float radius;",
"attribute vec4 matrix1;",
"attribute vec4 matrix2;",
"attribute vec4 matrix3;",
"attribute vec4 matrix4;",
"",
"varying vec3 axis;",
"varying vec4 base_radius;",
"varying vec4 end_b;",
"varying vec3 U;",
"varying vec3 V;",
"varying vec4 w;",
"varying float fogDepth;",
"varying float fogNear;",
"varying float fogFar;",
"",
"#ifdef PICKING",
"    #include unpack_clr",
"    attribute float primitiveId;",
"    varying vec3 vPickingColor;",
"#else",
"    //attribute vec3 color;",
"    attribute vec3 color2;",
"    varying vec3 vColor1;",
"    varying vec3 vColor2;",
"#endif",
"",
"uniform mat4 modelViewMatrixInverse;",
"uniform float ortho;",
"",
"//include matrix_scale",
"float matrixScale( in mat4 m ){",
"    vec4 r = m[ 0 ];",
"    return sqrt( r[ 0 ] * r[ 0 ] + r[ 1 ] * r[ 1 ] + r[ 2 ] * r[ 2 ] );",
"}",
"",
"  mat4 computeMat(vec4 v1, vec4 v2, vec4 v3, vec4 v4) {",
"    return mat4(",
"      v1.x, v1.y, v1.z, v1.w,",
"      v2.x, v2.y, v2.z, v2.w,",
"      v3.x, v3.y, v3.z, v3.w,",
"      v4.x, v4.y, v4.z, v4.w",
"    );",
"  }",
"",
"void main(){",
"",
"    #ifdef PICKING",
"        vPickingColor = unpackColor( primitiveId );",
"    #else",
"        vColor1 = color;",
"        vColor2 = color2;",
"    #endif",
"",
"    // vRadius = radius;",
"    base_radius.w = radius * matrixScale( modelViewMatrix );",
"",
"    //vec3 center = ( position2 + position1 ) / 2.0;",
"",
"    mat4 matrix = computeMat(matrix1, matrix2, matrix3, matrix4);",
"    vec4 updatePosition1 = matrix * vec4(position1, 1.0);",
"    vec4 updatePosition2 = matrix * vec4(position2, 1.0);",
"    vec3 center = ( updatePosition2.xyz + updatePosition1.xyz ) / 2.0;",
"",
"    //vec3 dir = normalize( position2 - position1 );",
"    vec3 dir = normalize( updatePosition2.xyz - updatePosition1.xyz );",
"    float ext = length( position2 - position1 ) / 2.0;",
"",
"    // using cameraPosition fails on some machines, not sure why",
"    // vec3 cam_dir = normalize( cameraPosition - mix( center, vec3( 0.0 ), ortho ) );",
"    vec3 cam_dir;",
"    if( ortho == 0.0 ){",
"        cam_dir = ( modelViewMatrixInverse * vec4( 0, 0, 0, 1 ) ).xyz - center;",
"    }else{",
"        cam_dir = ( modelViewMatrixInverse * vec4( 0, 0, 1, 0 ) ).xyz;",
"    }",
"    cam_dir = normalize( cam_dir );",
"",
"    vec3 ldir;",
"",
"    float b = dot( cam_dir, dir );",
"    end_b.w = b;",
"    // direction vector looks away, so flip",
"    if( b < 0.0 )",
"        ldir = -ext * dir;",
"    // direction vector already looks in my direction",
"    else",
"        ldir = ext * dir;",
"",
"    vec3 left = normalize( cross( cam_dir, ldir ) );",
"    left = radius * left;",
"    vec3 up = radius * normalize( cross( left, ldir ) );",
"",
"    // transform to modelview coordinates",
"    axis = normalize( normalMatrix * ldir );",
"    U = normalize( normalMatrix * up );",
"    V = normalize( normalMatrix * left );",
"",
"    vec4 base4 = modelViewMatrix * vec4( center - ldir, 1.0 );",
"    base_radius.xyz = base4.xyz / base4.w;",
"",
"    vec4 top_position = modelViewMatrix * vec4( center + ldir, 1.0 );",
"    vec4 end4 = top_position;",
"    end_b.xyz = end4.xyz / end4.w;",
"",
"    w = modelViewMatrix * vec4(",
"        center + mapping.x*ldir + mapping.y*left + mapping.z*up, 1.0",
"    );",
"",
"    gl_Position = projectionMatrix * w;",
"",
"    // avoid clipping (1.0 seems to induce flickering with some drivers)",
"    gl_Position.z = 0.99;",
"",
"}"
].join("\n");

$NGL_shaderTextHash['Instancing.frag'] = ["#define STANDARD",
"uniform vec3 diffuse;",
"uniform vec3 emissive;",
"uniform float roughness;",
"uniform float metalness;",
"uniform float opacity;",
"uniform float nearClip;",
"uniform float clipRadius;",
"uniform mat4 projectionMatrix;",
"uniform float ortho;",
"varying float bCylinder;",
"",
"#if defined( NEAR_CLIP ) || defined( RADIUS_CLIP ) || ( !defined( PICKING ) && !defined( NOLIGHT ) )",
"    varying vec3 vViewPosition;",
"#endif",
"",
"#if defined( RADIUS_CLIP )",
"    varying vec3 vClipCenter;",
"#endif",
"",
"#if defined( PICKING )",
"    uniform float objectId;",
"    varying vec3 vPickingColor;",
"#elif defined( NOLIGHT )",
"    varying vec3 vColor;",
"#else",
"    #ifndef FLAT_SHADED",
"        varying vec3 vNormal;",
"    #endif",
"    #include common",
"    #include color_pars_fragment",
"    #include fog_pars_fragment",
"    #include bsdfs",
"    #include lights_pars_begin",
"    #include lights_physical_pars_fragment",
"#endif",
"",
"void main(){",
"    #include nearclip_fragment",
"    #include radiusclip_fragment",
"",
"    #if defined( PICKING )",
"",
"        gl_FragColor = vec4( vPickingColor, objectId );",
"",
"    #elif defined( NOLIGHT )",
"",
"        gl_FragColor = vec4( vColor, opacity );",
"",
"    #else",
"",
"        vec4 diffuseColor = vec4( diffuse, opacity );",
"        ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
"        vec3 totalEmissiveLight = emissive;",
"",
"        #include color_fragment",
"        #include roughnessmap_fragment",
"        #include metalnessmap_fragment",
"        #include normal_flip",
"        #include normal_fragment_begin",
"",
"        //include dull_interior_fragment",
"",
"        #include lights_physical_fragment",
"        //include lights_template",
"        #include lights_fragment_begin",
"        #include lights_fragment_end",
"",
"        vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;",
"",
"        #include interior_fragment",
"",
"        gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
"",
"        #include premultiplied_alpha_fragment",
"        #include tonemapping_fragment",
"        #include encodings_fragment",
"        #include fog_fragment",
"",
"        #include opaque_back_fragment",
"",
"    #endif",
"",
"}"
].join("\n");

$NGL_shaderTextHash['Instancing.vert'] = ["#define STANDARD",
"",
"uniform mat4 projectionMatrixInverse;",
"uniform float nearClip;",
"uniform vec3 clipCenter;",
"attribute vec4 matrix1;",
"attribute vec4 matrix2;",
"attribute vec4 matrix3;",
"attribute vec4 matrix4;",
"attribute float cylinder;",
"varying float bCylinder;",
"",
"#if defined( NEAR_CLIP ) || defined( RADIUS_CLIP ) || ( !defined( PICKING ) && !defined( NOLIGHT ) )",
"    varying vec3 vViewPosition;",
"#endif",
"",
"#if defined( RADIUS_CLIP )",
"    varying vec3 vClipCenter;",
"#endif",
"",
"#if defined( PICKING )",
"    #include unpack_color",
"    attribute float primitiveId;",
"    varying vec3 vPickingColor;",
"#elif defined( NOLIGHT )",
"    varying vec3 vColor;",
"#else",
"    #include color_pars_vertex",
"    #ifndef FLAT_SHADED",
"        varying vec3 vNormal;",
"    #endif",
"#endif",
"",
"#include common",
"",
"  mat4 computeMat(vec4 v1, vec4 v2, vec4 v3, vec4 v4) {",
"    return mat4(",
"      v1.x, v1.y, v1.z, v1.w,",
"      v2.x, v2.y, v2.z, v2.w,",
"      v3.x, v3.y, v3.z, v3.w,",
"      v4.x, v4.y, v4.z, v4.w",
"    );",
"  }",
"",
"void main(){",
"    bCylinder = cylinder;",
"",
"    mat4 matrix = computeMat(matrix1, matrix2, matrix3, matrix4);",
"    vec4 updatePosition = matrix * vec4(position, 1.0);",
"",
"    #if defined( PICKING )",
"        vPickingColor = unpackColor( primitiveId );",
"    #elif defined( NOLIGHT )",
"        vColor = color;",
"    #else",
"        #include color_vertex",
"        //include beginnormal_vertex",
"        //vec3 objectNormal = vec3( normal );",
"        vec3 objectNormal = vec3(matrix * vec4(normal,0.0));",
"        #include defaultnormal_vertex",
"        // Normal computed with derivatives when FLAT_SHADED",
"        #ifndef FLAT_SHADED",
"            vNormal = normalize( transformedNormal );",
"        #endif",
"    #endif",
"",
"    //include begin_vertex",
"    vec3 transformed = updatePosition.xyz;",
"    //include project_vertex",
"    vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );",
"    gl_Position = projectionMatrix * mvPosition;",
"",
"    #if defined( NEAR_CLIP ) || defined( RADIUS_CLIP ) || ( !defined( PICKING ) && !defined( NOLIGHT ) )",
"        vViewPosition = -mvPosition.xyz;",
"    #endif",
"",
"    #if defined( RADIUS_CLIP )",
"        vClipCenter = -( modelViewMatrix * vec4( clipCenter, 1.0 ) ).xyz;",
"    #endif",
"",
"    #include nearclip_vertex",
"",
"}"
].join("\n");

/* Projector.js from http://threejs.org/
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author julianwa / https://github.com/julianwa
 */



THREE.RenderableObject = function () {
    "use strict";

    this.id = 0;

    this.object = null;
    this.z = 0;

};

//

THREE.RenderableFace = function () {
    "use strict";

    this.id = 0;

    this.v1 = new THREE.RenderableVertex();
    this.v2 = new THREE.RenderableVertex();
    this.v3 = new THREE.RenderableVertex();

    this.normalModel = new THREE.Vector3();

    this.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];
    this.vertexNormalsLength = 0;

    this.color = new THREE.Color();
    this.material = null;
    this.uvs = [ new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() ];

    this.z = 0;

};

//

THREE.RenderableVertex = function () {
    "use strict";

    this.position = new THREE.Vector3();
    this.positionWorld = new THREE.Vector3();
    this.positionScreen = new THREE.Vector4();

    this.visible = true;

};

THREE.RenderableVertex.prototype.copy = function ( vertex ) {
    "use strict";

    this.positionWorld.copy( vertex.positionWorld );
    this.positionScreen.copy( vertex.positionScreen );

};

//

THREE.RenderableLine = function () {
    "use strict";

    this.id = 0;

    this.v1 = new THREE.RenderableVertex();
    this.v2 = new THREE.RenderableVertex();

    this.vertexColors = [ new THREE.Color(), new THREE.Color() ];
    this.material = null;

    this.z = 0;

};

//

THREE.RenderableSprite = function () {
    "use strict";

    this.id = 0;

    this.object = null;

    this.x = 0;
    this.y = 0;
    this.z = 0;

    this.rotation = 0;
    this.scale = new THREE.Vector2();

    this.material = null;

};

//

THREE.Projector = function () {
    "use strict";

    var _object, _objectCount, _objectPool = [], _objectPoolLength = 0,
    _vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,
    _face, _faceCount, _facePool = [], _facePoolLength = 0,
    _line, _lineCount, _linePool = [], _linePoolLength = 0,
    _sprite, _spriteCount, _spritePool = [], _spritePoolLength = 0,

    _renderData = { objects: [], lights: [], elements: [] },

    _vA = new THREE.Vector3(),
    _vB = new THREE.Vector3(),
    _vC = new THREE.Vector3(),

    _vector3 = new THREE.Vector3(),
    _vector4 = new THREE.Vector4(),

    _clipBox = new THREE.Box3( new THREE.Vector3( - 1, - 1, - 1 ), new THREE.Vector3( 1, 1, 1 ) ),
    _boundingBox = new THREE.Box3(),
    _pnts3 = new Array( 3 ),
    _pnts4 = new Array( 4 ),

    _viewMatrix = new THREE.Matrix4(),
    _viewProjectionMatrix = new THREE.Matrix4(),

    _modelMatrix,
    _modelViewProjectionMatrix = new THREE.Matrix4(),

    _normalMatrix = new THREE.Matrix3(),

    _frustum = new THREE.Frustum(),

    _clippedVertex1PositionScreen = new THREE.Vector4(),
    _clippedVertex2PositionScreen = new THREE.Vector4();

    //

    this.projectVector = function ( vector, camera ) {

        console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
        vector.project( camera );

    };

    this.unprojectVector = function ( vector, camera ) {

        console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
        vector.unproject( camera );

    };

    this.pkRay = function ( vector, camera ) {

        console.error( 'THREE.Projector: .pkRay() is now raycaster.setFromCamera().' );

    };

    //

    var RenderList = function () {

        var normals = [];
        var uvs = [];

        var object = null;
        var material = null;

        var normalMatrix = new THREE.Matrix3();

        var setObject = function ( value ) {

            object = value;
            material = object.material;

            normalMatrix.getNormalMatrix( object.matrixWorld );

            normals.length = 0;
            uvs.length = 0;

        };

        var projectVertex = function ( vertex ) {

            var position = vertex.position;
            var positionWorld = vertex.positionWorld;
            var positionScreen = vertex.positionScreen;

            positionWorld.copy( position ).applyMatrix4( _modelMatrix );
            positionScreen.copy( positionWorld ).applyMatrix4( _viewProjectionMatrix );

            var invW = 1 / positionScreen.w;

            positionScreen.x *= invW;
            positionScreen.y *= invW;
            positionScreen.z *= invW;

            vertex.visible = positionScreen.x >= - 1 && positionScreen.x <= 1 &&
                     positionScreen.y >= - 1 && positionScreen.y <= 1 &&
                     positionScreen.z >= - 1 && positionScreen.z <= 1;

        };

        var pushVertex = function ( x, y, z ) {

            _vertex = getNextVertexInPool();
            _vertex.position.set( x, y, z );

            projectVertex( _vertex );

        };

        var pushNormal = function ( x, y, z ) {

            normals.push( x, y, z );

        };

        var pushUv = function ( x, y ) {

            uvs.push( x, y );

        };

        var checkTriangleVisibility = function ( v1, v2, v3 ) {

            if ( v1.visible === true || v2.visible === true || v3.visible === true ) return true;

            _pnts3[ 0 ] = v1.positionScreen;
            _pnts3[ 1 ] = v2.positionScreen;
            _pnts3[ 2 ] = v3.positionScreen;

            return _clipBox.isIntersectionBox( _boundingBox.setFromPoints( _pnts3 ) );

        };

        var checkBackfaceCulling = function ( v1, v2, v3 ) {

            return ( ( v3.positionScreen.x - v1.positionScreen.x ) *
                    ( v2.positionScreen.y - v1.positionScreen.y ) -
                    ( v3.positionScreen.y - v1.positionScreen.y ) *
                    ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;

        };

        var pushLine = function ( a, b ) {

            var v1 = _vertexPool[ a ];
            var v2 = _vertexPool[ b ];

            _line = getNextLineInPool();

            _line.id = object.id;
            _line.v1.copy( v1 );
            _line.v2.copy( v2 );
            _line.z = ( v1.positionScreen.z + v2.positionScreen.z ) / 2;

            _line.material = object.material;

            _renderData.elements.push( _line );

        };

        var pushTriangle = function ( a, b, c ) {

            var v1 = _vertexPool[ a ];
            var v2 = _vertexPool[ b ];
            var v3 = _vertexPool[ c ];

            if ( checkTriangleVisibility( v1, v2, v3 ) === false ) return;

            if ( material.side === THREE.DoubleSide || checkBackfaceCulling( v1, v2, v3 ) === true ) {

                _face = getNextFaceInPool();

                _face.id = object.id;
                _face.v1.copy( v1 );
                _face.v2.copy( v2 );
                _face.v3.copy( v3 );
                _face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;

                for ( var i = 0; i < 3; i ++ ) {

                    var offset = arguments[ i ] * 3;
                    var normal = _face.vertexNormalsModel[ i ];

                    normal.set( normals[ offset ], normals[ offset + 1 ], normals[ offset + 2 ] );
                    normal.applyMatrix3( normalMatrix ).normalize();

                    var offset2 = arguments[ i ] * 2;

                    var uv = _face.uvs[ i ];
                    uv.set( uvs[ offset2 ], uvs[ offset2 + 1 ] );

                }

                _face.vertexNormalsLength = 3;

                _face.material = object.material;

                _renderData.elements.push( _face );

            }

        };

        return {
            setObject: setObject,
            projectVertex: projectVertex,
            checkTriangleVisibility: checkTriangleVisibility,
            checkBackfaceCulling: checkBackfaceCulling,
            pushVertex: pushVertex,
            pushNormal: pushNormal,
            pushUv: pushUv,
            pushLine: pushLine,
            pushTriangle: pushTriangle
        }

    };

    var renderList = new RenderList();

    this.projectScene = function ( scene, camera, sortObjects, sortElements ) {

        _faceCount = 0;
        _lineCount = 0;
        _spriteCount = 0;

        _renderData.elements.length = 0;

        if ( scene.autoUpdate === true ) scene.updateMatrixWorld();
        if ( camera.parent === undefined ) camera.updateMatrixWorld();

        //_viewMatrix.copy( camera.matrixWorldInverse.getInverse( camera.matrixWorld ) );
        _viewMatrix.copy( camera.matrixWorldInverse.copy(camera.matrixWorld).invert() );
        _viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );

        _frustum.setFromMatrix( _viewProjectionMatrix );

        //

        _objectCount = 0;

        _renderData.objects.length = 0;
        _renderData.lights.length = 0;

        scene.traverseVisible( function ( object ) {

            if ( object instanceof THREE.Light ) {

                _renderData.lights.push( object );

            } else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Sprite ) {

                if ( object.material.visible === false ) return;

                if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {

                    _object = getNextObjectInPool();
                    _object.id = object.id;
                    _object.object = object;

                    _vector3.setFromMatrixPosition( object.matrixWorld );
                    _vector3.applyProjection( _viewProjectionMatrix );
                    _object.z = _vector3.z;

                    _renderData.objects.push( _object );

                }

            }

        } );

        if ( sortObjects === true ) {

            _renderData.objects.sort( painterSort );

        }

        //

        for ( var o = 0, ol = _renderData.objects.length; o < ol; o ++ ) {

            var object = _renderData.objects[ o ].object;
            var geometry = object.geometry;

            renderList.setObject( object );

            _modelMatrix = object.matrixWorld;

            _vertexCount = 0;

            if ( object instanceof THREE.Mesh ) {

                if ( geometry instanceof THREE.BufferGeometry ) {

                    var attributes = geometry.attributes;
                    var offsets = geometry.offsets;

                    if ( attributes.position === undefined ) continue;

                    var positions = attributes.position.array;

                    for ( var i = 0, l = positions.length; i < l; i += 3 ) {

                        renderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

                    }

                    if ( attributes.normal !== undefined ) {

                        var normals = attributes.normal.array;

                        for ( var i = 0, l = normals.length; i < l; i += 3 ) {

                            renderList.pushNormal( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] );

                        }

                    }

                    if ( attributes.uv !== undefined ) {

                        var uvs = attributes.uv.array;

                        for ( var i = 0, l = uvs.length; i < l; i += 2 ) {

                            renderList.pushUv( uvs[ i ], uvs[ i + 1 ] );

                        }

                    }

                    if ( attributes.index !== undefined ) {

                        var indices = attributes.index.array;

                        if ( offsets.length > 0 ) {

                            for ( var o = 0; o < offsets.length; o ++ ) {

                                var offset = offsets[ o ];
                                var index = offset.index;

                                for ( var i = offset.start, l = offset.start + offset.count; i < l; i += 3 ) {

                                    renderList.pushTriangle( indices[ i ] + index, indices[ i + 1 ] + index, indices[ i + 2 ] + index );

                                }

                            }

                        } else {

                            for ( var i = 0, l = indices.length; i < l; i += 3 ) {

                                renderList.pushTriangle( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

                            }

                        }

                    } else {

                        for ( var i = 0, l = positions.length / 3; i < l; i += 3 ) {

                            renderList.pushTriangle( i, i + 1, i + 2 );

                        }

                    }

                }
                /*
                else if ( geometry instanceof THREE.Geometry ) {

                    var vertices = geometry.vertices;
                    var faces = geometry.faces;
                    var faceVertexUvs = geometry.faceVertexUvs[ 0 ];

                    _normalMatrix.getNormalMatrix( _modelMatrix );

                    var isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;
                    var objectMaterials = isFaceMaterial === true ? object.material : null;

                    for ( var v = 0, vl = vertices.length; v < vl; v ++ ) {

                        var vertex = vertices[ v ];
                        renderList.pushVertex( vertex.x, vertex.y, vertex.z );

                    }

                    for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

                        var face = faces[ f ];

                        var material = isFaceMaterial === true
                             ? objectMaterials.materials[ face.materialIndex ]
                             : object.material;

                        if ( material === undefined ) continue;

                        var side = material.side;

                        var v1 = _vertexPool[ face.a ];
                        var v2 = _vertexPool[ face.b ];
                        var v3 = _vertexPool[ face.c ];

                        if ( material.morphTargets === true ) {

                            var morphTargets = geometry.morphTargets;
                            var morphInfluences = object.morphTargetInfluences;

                            var v1p = v1.position;
                            var v2p = v2.position;
                            var v3p = v3.position;

                            _vA.set( 0, 0, 0 );
                            _vB.set( 0, 0, 0 );
                            _vC.set( 0, 0, 0 );

                            for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

                                var influence = morphInfluences[ t ];

                                if ( influence === 0 ) continue;

                                var targets = morphTargets[ t ].vertices;

                                _vA.x += ( targets[ face.a ].x - v1p.x ) * influence;
                                _vA.y += ( targets[ face.a ].y - v1p.y ) * influence;
                                _vA.z += ( targets[ face.a ].z - v1p.z ) * influence;

                                _vB.x += ( targets[ face.b ].x - v2p.x ) * influence;
                                _vB.y += ( targets[ face.b ].y - v2p.y ) * influence;
                                _vB.z += ( targets[ face.b ].z - v2p.z ) * influence;

                                _vC.x += ( targets[ face.c ].x - v3p.x ) * influence;
                                _vC.y += ( targets[ face.c ].y - v3p.y ) * influence;
                                _vC.z += ( targets[ face.c ].z - v3p.z ) * influence;

                            }

                            v1.position.add( _vA );
                            v2.position.add( _vB );
                            v3.position.add( _vC );

                            renderList.projectVertex( v1 );
                            renderList.projectVertex( v2 );
                            renderList.projectVertex( v3 );

                        }

                        if ( renderList.checkTriangleVisibility( v1, v2, v3 ) === false ) continue;

                        var visible = renderList.checkBackfaceCulling( v1, v2, v3 );

                        if ( side !== THREE.DoubleSide ) {
                            if ( side === THREE.FrontSide && visible === false ) continue;
                            if ( side === THREE.BackSide && visible === true ) continue;
                        }

                        _face = getNextFaceInPool();

                        _face.id = object.id;
                        _face.v1.copy( v1 );
                        _face.v2.copy( v2 );
                        _face.v3.copy( v3 );

                        _face.normalModel.copy( face.normal );

                        if ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {

                            _face.normalModel.negate();

                        }

                        _face.normalModel.applyMatrix3( _normalMatrix ).normalize();

                        var faceVertexNormals = face.vertexNormals;

                        for ( var n = 0, nl = Math.min( faceVertexNormals.length, 3 ); n < nl; n ++ ) {

                            var normalModel = _face.vertexNormalsModel[ n ];
                            normalModel.copy( faceVertexNormals[ n ] );

                            if ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {

                                normalModel.negate();

                            }

                            normalModel.applyMatrix3( _normalMatrix ).normalize();

                        }

                        _face.vertexNormalsLength = faceVertexNormals.length;

                        var vertexUvs = faceVertexUvs[ f ];

                        if ( vertexUvs !== undefined ) {

                            for ( var u = 0; u < 3; u ++ ) {

                                _face.uvs[ u ].copy( vertexUvs[ u ] );

                            }

                        }

                        _face.color = face.color;
                        _face.material = material;

                        _face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;

                        _renderData.elements.push( _face );

                    }

                }
                */

            } else if ( object instanceof THREE.Line ) {

                if ( geometry instanceof THREE.BufferGeometry ) {

                    var attributes = geometry.attributes;

                    if ( attributes.position !== undefined ) {

                        var positions = attributes.position.array;

                        for ( var i = 0, l = positions.length; i < l; i += 3 ) {

                            renderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

                        }

                        if ( attributes.index !== undefined ) {

                            var indices = attributes.index.array;

                            for ( var i = 0, l = indices.length; i < l; i += 2 ) {

                                renderList.pushLine( indices[ i ], indices[ i + 1 ] );

                            }

                        } else {

                            var step = object.mode === THREE.LinePieces ? 2 : 1;

                            for ( var i = 0, l = ( positions.length / 3 ) - 1; i < l; i += step ) {

                                renderList.pushLine( i, i + 1 );

                            }

                        }

                    }

                }
                /*
                else if ( geometry instanceof THREE.Geometry ) {

                    _modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );

                    var vertices = object.geometry.vertices;

                    if ( vertices.length === 0 ) continue;

                    v1 = getNextVertexInPool();
                    v1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );

                    // Handle LineStrip and LinePieces
                    var step = object.mode === THREE.LinePieces ? 2 : 1;

                    for ( var v = 1, vl = vertices.length; v < vl; v ++ ) {

                        v1 = getNextVertexInPool();
                        v1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );

                        if ( ( v + 1 ) % step > 0 ) continue;

                        v2 = _vertexPool[ _vertexCount - 2 ];

                        _clippedVertex1PositionScreen.copy( v1.positionScreen );
                        _clippedVertex2PositionScreen.copy( v2.positionScreen );

                        if ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {

                            // Perform the perspective divide
                            _clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );
                            _clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );

                            _line = getNextLineInPool();

                            _line.id = object.id;
                            _line.v1.positionScreen.copy( _clippedVertex1PositionScreen );
                            _line.v2.positionScreen.copy( _clippedVertex2PositionScreen );

                            _line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );

                            _line.material = object.material;

                            if ( object.material.vertexColors === THREE.VertexColors ) {

                                _line.vertexColors[ 0 ].copy( object.geometry.colors[ v ] );
                                _line.vertexColors[ 1 ].copy( object.geometry.colors[ v - 1 ] );

                            }

                            _renderData.elements.push( _line );

                        }

                    }

                }
                */

            } else if ( object instanceof THREE.Sprite ) {

                _vector4.set( _modelMatrix.elements[ 12 ], _modelMatrix.elements[ 13 ], _modelMatrix.elements[ 14 ], 1 );
                _vector4.applyMatrix4( _viewProjectionMatrix );

                var invW = 1 / _vector4.w;

                _vector4.z *= invW;

                if ( _vector4.z >= - 1 && _vector4.z <= 1 ) {

                    _sprite = getNextSpriteInPool();
                    _sprite.id = object.id;
                    _sprite.x = _vector4.x * invW;
                    _sprite.y = _vector4.y * invW;
                    _sprite.z = _vector4.z;
                    _sprite.object = object;

                    _sprite.rotation = object.rotation;

                    _sprite.scale.x = object.scale.x * Math.abs( _sprite.x - ( _vector4.x + camera.projectionMatrix.elements[ 0 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 12 ] ) );
                    _sprite.scale.y = object.scale.y * Math.abs( _sprite.y - ( _vector4.y + camera.projectionMatrix.elements[ 5 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 13 ] ) );

                    _sprite.material = object.material;

                    _renderData.elements.push( _sprite );

                }

            }

        }

        if ( sortElements === true ) {

            _renderData.elements.sort( painterSort );

        }

        return _renderData;

    };

    // Pools

    function getNextObjectInPool() {

        if ( _objectCount === _objectPoolLength ) {

            var object = new THREE.RenderableObject();
            _objectPool.push( object );
            _objectPoolLength ++;
            _objectCount ++;
            return object;

        }

        return _objectPool[ _objectCount ++ ];

    }

    function getNextVertexInPool() {

        if ( _vertexCount === _vertexPoolLength ) {

            var vertex = new THREE.RenderableVertex();
            _vertexPool.push( vertex );
            _vertexPoolLength ++;
            _vertexCount ++;
            return vertex;

        }

        return _vertexPool[ _vertexCount ++ ];

    }

    function getNextFaceInPool() {

        if ( _faceCount === _facePoolLength ) {

            var face = new THREE.RenderableFace();
            _facePool.push( face );
            _facePoolLength ++;
            _faceCount ++;
            return face;

        }

        return _facePool[ _faceCount ++ ];


    }

    function getNextLineInPool() {

        if ( _lineCount === _linePoolLength ) {

            var line = new THREE.RenderableLine();
            _linePool.push( line );
            _linePoolLength ++;
            _lineCount ++
            return line;

        }

        return _linePool[ _lineCount ++ ];

    }

    function getNextSpriteInPool() {

        if ( _spriteCount === _spritePoolLength ) {

            var sprite = new THREE.RenderableSprite();
            _spritePool.push( sprite );
            _spritePoolLength ++;
            _spriteCount ++
            return sprite;

        }

        return _spritePool[ _spriteCount ++ ];

    }

    //

    function painterSort( a, b ) {

        if ( a.z !== b.z ) {

            return b.z - a.z;

        } else if ( a.id !== b.id ) {

            return a.id - b.id;

        } else {

            return 0;

        }

    }

    function clipLine( s1, s2 ) {

        var alpha1 = 0, alpha2 = 1,

        // Calculate the boundary coordinate of each vertex for the near and far clip planes,
        // Z = -1 and Z = +1, respectively.
        bc1near =  s1.z + s1.w,
        bc2near =  s2.z + s2.w,
        bc1far =  - s1.z + s1.w,
        bc2far =  - s2.z + s2.w;

        if ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {

            // Both vertices lie entirely within all clip planes.
            return true;

        } else if ( ( bc1near < 0 && bc2near < 0 ) || ( bc1far < 0 && bc2far < 0 ) ) {

            // Both vertices lie entirely outside one of the clip planes.
            return false;

        } else {

            // The line segment spans at least one clip plane.

            if ( bc1near < 0 ) {

                // v1 lies outside the near plane, v2 inside
                alpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );

            } else if ( bc2near < 0 ) {

                // v2 lies outside the near plane, v1 inside
                alpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );

            }

            if ( bc1far < 0 ) {

                // v1 lies outside the far plane, v2 inside
                alpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );

            } else if ( bc2far < 0 ) {

                // v2 lies outside the far plane, v2 inside
                alpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );

            }

            if ( alpha2 < alpha1 ) {

                // The line segment spans two boundaries, but is outside both of them.
                // (This can't happen when we're only clipping against just near/far but good
                //  to leave the check here for future usage if other clip planes are added.)
                return false;

            } else {

                // Update the s1 and s2 vertices to match the clipped line segment.
                s1.lerp( s2, alpha1 );
                s2.lerp( s1, 1 - alpha2 );

                return true;

            }

        }

    }

};

/* TrackballControls.js from http://threejs.org/
 * @author Eberhard Graether / http://egraether.com/
 * @author Mark Lundin  / http://mark-lundin.com
 * modified by Jiyao Wang
 */



THREE.TrackballControls = function ( object, domElement, icn3d ) {
    "use strict";

    var _this = this;

    this.STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };

    this.object = object;
    this.domElement = ( domElement !== undefined ) ? domElement : document;

    // API
    this.enabled = true;

    this.screen = { left: 0, top: 0, width: 0, height: 0 };

    this.rotateSpeed = 1.0;
    this.zoomSpeed = 1.2;
    this.panSpeed = 0.3;

    this.noRotate = false;
    this.noZoom = false;
    this.noPan = false;
    this.noRoll = false;

    this.staticMoving = false;
    this.dynamicDampingFactor = 0.2;

    this.minDistance = 0;
    this.maxDistance = Infinity;

    this.keys = [ 65 /*A*/, 83 /*S*/, 68 /*D*/ ];

    // internals

    this.target = new THREE.Vector3();

    var EPS = 0.000001;

    var lastPosition = new THREE.Vector3();

    this._state = this.STATE.NONE;
    var _prevState = this.STATE.NONE;

    var _eye = new THREE.Vector3();

    this._rotateStart = new THREE.Vector3();
    this._rotateEnd = new THREE.Vector3();

    this._zoomStart = new THREE.Vector2();
    this._zoomEnd = new THREE.Vector2();

    var _touchZoomDistanceStart = 0;
    var _touchZoomDistanceEnd = 0;

    this._panStart = new THREE.Vector2();
    this._panEnd = new THREE.Vector2();

    // for reset

    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.up0 = this.object.up.clone();

    // events

    var changeEvent = { type: 'change' };
    var startEvent = { type: 'start'};
    var endEvent = { type: 'end'};


    // methods

    this.handleResize = function () {

        if ( this.domElement === document ) {

            this.screen.left = 0;
            this.screen.top = 0;
            this.screen.width = window.innerWidth;
            this.screen.height = window.innerHeight;

        } else if(this.domElement) {

            var box = this.domElement.getBoundingClientRect();
            // adjustments come from similar code in the jquery offset() function
            var d = this.domElement.ownerDocument.documentElement;
            this.screen.left = box.left + window.pageXOffset - d.clientLeft;
            this.screen.top = box.top + window.pageYOffset - d.clientTop;
            this.screen.width = box.width;
            this.screen.height = box.height;

        }

    };

    this.handleEvent = function ( event ) {

        if ( typeof this[ event.type ] === 'function' ) {

            this[ event.type ]( event );

        }

    };

    var getMouseOnScreen = ( function () {

        var vector = new THREE.Vector2();

        return function ( pageX, pageY ) {

            vector.set(
                ( pageX - _this.screen.left ) / _this.screen.width,
                ( pageY - _this.screen.top ) / _this.screen.height
            );

            return vector;

        };

    }() );

    var getMouseProjectionOnBall = ( function () {

        var vector = new THREE.Vector3();
        var objectUp = new THREE.Vector3();
        var mouseOnBall = new THREE.Vector3();

        return function ( pageX, pageY ) {

            mouseOnBall.set(
                ( pageX - _this.screen.width * 0.5 - _this.screen.left ) / (_this.screen.width*.5),
                ( _this.screen.height * 0.5 + _this.screen.top - pageY ) / (_this.screen.height*.5),
                0.0
            );

            var length = mouseOnBall.length();

            if ( _this.noRoll ) {

                if ( length < Math.SQRT1_2 ) {

                    mouseOnBall.z = Math.sqrt( 1.0 - length*length );

                } else {

                    mouseOnBall.z = .5 / length;

                }

            } else if ( length > 1.0 ) {

                mouseOnBall.normalize();

            } else {

                mouseOnBall.z = Math.sqrt( 1.0 - length * length );

            }

            _eye.copy( _this.object.position ).sub( _this.target );

            vector.copy( _this.object.up ).setLength( mouseOnBall.y )
            vector.add( objectUp.copy( _this.object.up ).cross( _eye ).setLength( mouseOnBall.x ) );
            vector.add( _eye.setLength( mouseOnBall.z ) );

            return vector;

        };

    }() );

    this.rotateCamera = (function(quaternionIn, bUpdate){

        var axis = new THREE.Vector3(),
            quaternion = new THREE.Quaternion();


        return function (quaternionIn, bUpdate) {

            var angle;
            if(quaternionIn === undefined) {
              angle = Math.acos( _this._rotateStart.dot( _this._rotateEnd ) / _this._rotateStart.length() / _this._rotateEnd.length() );
            }

            //var angle = Math.acos( _this._rotateStart.dot( _this._rotateEnd ) / _this._rotateStart.length() / _this._rotateEnd.length() );

            if ( angle || quaternionIn !== undefined) {
                if(quaternionIn === undefined) {
                  axis.crossVectors( _this._rotateStart, _this._rotateEnd ).normalize();

                  angle *= _this.rotateSpeed;

                  quaternion.setFromAxisAngle( axis, -angle );
                }
                else {
                  quaternion.copy(quaternionIn);
                }

                // order matters in quaernion multiplication: http://www.cprogramming.com/tutorial/3d/quaternions.html
                if(icn3d !== undefined && icn3d.quaternion !== undefined && (bUpdate === undefined || bUpdate === true)) {
                    icn3d.quaternion.multiplyQuaternions(quaternion, icn3d.quaternion);
                }

                _eye.applyQuaternion( quaternion );
                _this.object.up.applyQuaternion( quaternion );

                _this._rotateEnd.applyQuaternion( quaternion );

                if ( _this.staticMoving ) {

                    _this._rotateStart.copy( _this._rotateEnd );

                } else {

                    quaternion.setFromAxisAngle( axis, angle * ( _this.dynamicDampingFactor - 1.0 ) );
                    _this._rotateStart.applyQuaternion( quaternion );

                }
            }

        }

    }());

    this.zoomCamera = function (zoomFactor, bUpdate) {
        if ( _this._state === _this.STATE.TOUCH_ZOOM_PAN ) {

            var factor;

            if(zoomFactor !== undefined) {
              factor = zoomFactor;
            }
            else {

              factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
              _touchZoomDistanceStart = _touchZoomDistanceEnd;
            }

            _eye.multiplyScalar( factor );

            if(icn3d !== undefined && icn3d._zoomFactor !== undefined && (bUpdate === undefined || bUpdate === true)) {
                icn3d._zoomFactor *= factor;
                icn3d.fogCls.setFog();
            }

        } else {

            var factor;

            if(zoomFactor !== undefined) {
              factor = zoomFactor;
            }
            else {
              factor = 1.0 + ( _this._zoomEnd.y - _this._zoomStart.y ) * _this.zoomSpeed;
            }

            if(icn3d !== undefined && icn3d._zoomFactor !== undefined && (bUpdate === undefined || bUpdate === true)) {
                icn3d._zoomFactor *= factor;
                icn3d.fogCls.setFog();
            }

            //if ( factor !== 1.0 && factor > 0.0 ) {
            if ( factor !== 1.0 ) {

                _eye.multiplyScalar( factor );

                if ( _this.staticMoving ) {

                    _this._zoomStart.copy( _this._zoomEnd );

                } else {

                    _this._zoomStart.y += ( _this._zoomEnd.y - _this._zoomStart.y ) * this.dynamicDampingFactor;
                }
            }

        }

    };

    this.panCamera = (function(mouseChangeIn, bUpdate){

        var mouseChange = new THREE.Vector2(),
            objectUp = new THREE.Vector3(),
            pan = new THREE.Vector3();

        return function (mouseChangeIn, bUpdate) {

            if(mouseChangeIn !== undefined) {
              mouseChange = mouseChangeIn;

              if(icn3d !== undefined && icn3d.mouseChange !== undefined && (bUpdate === undefined || bUpdate === true)) icn3d.mouseChange.add(mouseChangeIn);
            }
            else {
              mouseChange.copy( _this._panEnd ).sub( _this._panStart );

              if(icn3d !== undefined && icn3d.mouseChange !== undefined && (bUpdate === undefined || bUpdate === true)) icn3d.mouseChange.add( _this._panEnd ).sub( _this._panStart );
            }

            if ( mouseChange.lengthSq() ) {
                mouseChange.multiplyScalar( _eye.length() * _this.panSpeed );

                pan.copy( _eye ).cross( _this.object.up ).setLength( mouseChange.x );
                pan.add( objectUp.copy( _this.object.up ).setLength( mouseChange.y ) );

                _this.object.position.add( pan );
                _this.target.add( pan );

                if ( _this.staticMoving ) {

                    _this._panStart.copy( _this._panEnd );

                } else {

                    _this._panStart.add( mouseChange.subVectors( _this._panEnd, _this._panStart ).multiplyScalar( _this.dynamicDampingFactor ) );

                }
            }
        }

    }());

    this.checkDistances = function () {

        if ( !_this.noZoom || !_this.noPan ) {

            if ( _eye.lengthSq() > _this.maxDistance * _this.maxDistance ) {

                _this.object.position.addVectors( _this.target, _eye.setLength( _this.maxDistance ) );

            }

            if ( _eye.lengthSq() < _this.minDistance * _this.minDistance ) {

                _this.object.position.addVectors( _this.target, _eye.setLength( _this.minDistance ) );

            }

        }

    };

    this.update = function (para) {

        _eye.subVectors( _this.object.position, _this.target );

        if ( !_this.noRotate ) {

            if(para !== undefined && para.quaternion !== undefined) {
              _this.rotateCamera(para.quaternion, para.update);
            }
            else {
              _this.rotateCamera();
            }

        }

        if ( !_this.noZoom ) {

            if(para !== undefined && para._zoomFactor !== undefined) {
              _this.zoomCamera(para._zoomFactor, para.update);
            }
            else {
              _this.zoomCamera();
            }

        }

        if ( !_this.noPan ) {

            if(para !== undefined && para.mouseChange !== undefined) {
              _this.panCamera(para.mouseChange, para.update);
            }
            else {
              _this.panCamera();
            }

        }

        _this.object.position.addVectors( _this.target, _eye );

        _this.checkDistances();

        _this.object.lookAt( _this.target );

        if ( lastPosition.distanceToSquared( _this.object.position ) > EPS ) {

            _this.dispatchEvent( changeEvent );

            lastPosition.copy( _this.object.position );

        }

    };

    this.reset = function () {

        _this._state = _this.STATE.NONE;
        _prevState = _this.STATE.NONE;

        _this.target.copy( _this.target0 );
        _this.object.position.copy( _this.position0 );
        _this.object.up.copy( _this.up0 );

        _eye.subVectors( _this.object.position, _this.target );

        _this.object.lookAt( _this.target );

        _this.dispatchEvent( changeEvent );

        lastPosition.copy( _this.object.position );

    };

    // listeners

    function keydown( event ) {
//console.log("keydown");

        if ( _this.enabled === false || Object.keys(window).length < 2)  return;

        window.removeEventListener( 'keydown', keydown );

        _prevState = _this._state;


        if ( _this._state !== _this.STATE.NONE ) {

            return;

        } else if ( event.keyCode === _this.keys[ _this.STATE.ROTATE ] &&  !_this.noRotate) {

            _this._state = _this.STATE.ROTATE;

        } else if ( (event.keyCode === _this.keys[ _this.STATE.ZOOM ]) && !_this.noZoom ) {

            _this._state = _this.STATE.ZOOM;

        } else if ( (event.keyCode === _this.keys[ _this.STATE.PAN ]) && !_this.noPan ) {

            _this._state = _this.STATE.PAN;

        }


    }

    function keyup( event ) {
//console.log("keyup");

        if ( _this.enabled === false || Object.keys(window).length < 2)  return;

        _this._state = _prevState;

        window.addEventListener( 'keydown', keydown, false );

    }

    function mousedown( event ) {

        if ( _this.enabled === false || Object.keys(window).length < 2)  return;

        //event.preventDefault();
        event.stopPropagation();

        if ( _this._state === _this.STATE.NONE ) {

            _this._state = event.button;

        }

        if ( _this._state === _this.STATE.ROTATE && !_this.noRotate ) {

            _this._rotateStart.copy( getMouseProjectionOnBall( event.pageX, event.pageY ) );
            _this._rotateEnd.copy( _this._rotateStart );

        } else if ( _this._state === _this.STATE.ZOOM && !_this.noZoom ) {

            _this._zoomStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );
            _this._zoomEnd.copy(_this._zoomStart);

        } else if ( _this._state === _this.STATE.PAN && !_this.noPan ) {

            _this._panStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );
            _this._panEnd.copy(_this._panStart)

        }

        document.addEventListener( 'mousemove', mousemove, false );
        document.addEventListener( 'mouseup', mouseup, false );

        _this.dispatchEvent( startEvent );

    }

    function mousemove( event ) {

        if ( _this.enabled === false || Object.keys(window).length < 2)  return;

        //event.preventDefault();
        event.stopPropagation();

        if ( _this._state === _this.STATE.ROTATE && !_this.noRotate ) {

//console.log("ROTATE");
            _this._rotateEnd.copy( getMouseProjectionOnBall( event.pageX, event.pageY ) );

        } else if ( _this._state === _this.STATE.ZOOM && !_this.noZoom ) {

            _this._zoomEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );

        } else if ( _this._state === _this.STATE.PAN && !_this.noPan ) {

            _this._panEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );

        }

    }

    function mouseup( event ) {
        if ( _this.enabled === false || Object.keys(window).length < 2)  return;

        //event.preventDefault();
        event.stopPropagation();

        _this._state = _this.STATE.NONE;

        document.removeEventListener( 'mousemove', mousemove );
        document.removeEventListener( 'mouseup', mouseup );
        _this.dispatchEvent( endEvent );

    }

    function mousewheel( event ) {

        if ( _this.enabled === false || Object.keys(window).length < 2)  return;

        //event.preventDefault();
        event.stopPropagation();

        var delta = 0;

        if ( event.wheelDelta ) { // WebKit / Opera / Explorer 9

            delta = event.wheelDelta / 40;

        } else if ( event.detail ) { // Firefox

            delta = - event.detail / 3;

        }

        //_this._zoomStart.y += delta * 0.01;
        //_this._zoomStart.y = delta * 0.01;
        _this._zoomStart.y = delta * 0.005;
        _this.dispatchEvent( startEvent );
        _this.dispatchEvent( endEvent );

    }

    function touchstart( event ) {

        if ( _this.enabled === false || Object.keys(window).length < 2)  return;

        switch ( event.touches.length ) {
            case 1:
                _this._state = _this.STATE.TOUCH_ROTATE;
                _this._rotateStart.copy( getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );
                _this._rotateEnd.copy( _this._rotateStart );
                break;

            case 2:
                _this._state = _this.STATE.TOUCH_ZOOM_PAN;
                var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
                _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt( dx * dx + dy * dy );

                var x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;
                var y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;
                _this._panStart.copy( getMouseOnScreen( x, y ) );
                _this._panEnd.copy( _this._panStart );
                break;

            default:
                _this._state = _this.STATE.NONE;

        }
        _this.dispatchEvent( startEvent );


    }

    function touchmove( event ) {

        if ( _this.enabled === false || Object.keys(window).length < 2)  return;

        //event.preventDefault();
        event.stopPropagation();

        switch ( event.touches.length ) {

            case 1:
                _this._rotateEnd.copy( getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );
                break;

            case 2:
                var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
                _touchZoomDistanceEnd = Math.sqrt( dx * dx + dy * dy );

                var x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;
                var y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;
                _this._panEnd.copy( getMouseOnScreen( x, y ) );
                break;

            default:
                _this._state = _this.STATE.NONE;

        }

    }

    function touchend( event ) {

        if ( _this.enabled === false || Object.keys(window).length < 2)  return;

        switch ( event.touches.length ) {

            case 1:
                _this._rotateEnd.copy( getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );
                _this._rotateStart.copy( _this._rotateEnd );
                break;

            case 2:
                _touchZoomDistanceStart = _touchZoomDistanceEnd = 0;

                var x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;
                var y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;
                _this._panEnd.copy( getMouseOnScreen( x, y ) );
                _this._panStart.copy( _this._panEnd );
                break;

        }

        _this._state = _this.STATE.NONE;
        _this.dispatchEvent( endEvent );

    }

    if(Object.keys(window).length >= 2 && this.domElement) {
        this.domElement.addEventListener( 'contextmn', function ( event ) {
            //event.preventDefault();
        }, false );

        this.domElement.addEventListener( 'mousedown', mousedown, false );

        this.domElement.addEventListener( 'mousewheel', mousewheel, false );
        this.domElement.addEventListener( 'DOMMouseScroll', mousewheel, false ); // firefox

        this.domElement.addEventListener( 'touchstart', touchstart, false );
        this.domElement.addEventListener( 'touchend', touchend, false );
        this.domElement.addEventListener( 'touchmove', touchmove, false );

        if(Object.keys(window).length >= 2) window.addEventListener( 'keydown', keydown, false );
        if(Object.keys(window).length >= 2) window.addEventListener( 'keyup', keyup, false );
    }

    this.handleResize();

    // force an update at start
    this.update();

};

THREE.TrackballControls.prototype = Object.create( THREE.EventDispatcher.prototype );
THREE.TrackballControls.prototype.constructor = THREE.TrackballControls;

/* OrthographicTrackballControls.js from http://threejs.org/
 * @author Eberhard Graether / http://egraether.com/
 * @author Mark Lundin  / http://mark-lundin.com
 * @author Patrick Fuller / http://patrick-fuller.com
 * modified by Jiyao Wang
 */



THREE.OrthographicTrackballControls = function ( object, domElement, icn3d ) { var me = this, ic = me.icn3d; "use strict";
    var _this = this;
    var STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };

    this.object = object;
    this.domElement = ( domElement !== undefined ) ? domElement : document;

    // API
    this.enabled = true;

    this.screen = { left: 0, top: 0, width: 0, height: 0 };

    // JW: the rotation speed of orthographic should be much less than that of perspective
    //this.rotateSpeed = 1.0;
    this.rotateSpeed = 0.5;
    this.zoomSpeed = 1.2;

    var zoomSpeedAdjust = 0.01;
    this.zoomSpeed *= zoomSpeedAdjust;

    //this.panSpeed = 0.3;
    this.panSpeed = 0.03;

    this.noRotate = false;
    this.noZoom = false;
    this.noPan = false;
    this.noRoll = false;

    this.staticMoving = false;
    this.dynamicDampingFactor = 0.2;

    this.keys = [ 65 /*A*/, 83 /*S*/, 68 /*D*/ ];

    // internals

    this.target = new THREE.Vector3();

    var EPS = 0.000001;

    var lastPosition = new THREE.Vector3();

    this._state = STATE.NONE;
    var _prevState = STATE.NONE;

    var _eye = new THREE.Vector3();

    this._rotateStart = new THREE.Vector3();
    this._rotateEnd = new THREE.Vector3();

    this._zoomStart = new THREE.Vector2();
    this._zoomEnd = new THREE.Vector2();
    var _zoomFactor = 1;

    var _touchZoomDistanceStart = 0;
    var _touchZoomDistanceEnd = 0;

    this._panStart = new THREE.Vector2();
    this._panEnd = new THREE.Vector2();

    // for reset

    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.up0 = this.object.up.clone();

    this.left0 = this.object.left;
    this.right0 = this.object.right;
    this.top0 = this.object.top;
    this.bottom0 = this.object.bottom;
    this.center0 = new THREE.Vector2((this.left0 + this.right0) / 2.0, (this.top0 + this.bottom0) / 2.0);

    // events

    var changeEvent = { type: 'change' };
    var startEvent = { type: 'start'};
    var endEvent = { type: 'end'};


    // methods

    this.handleResize = function () {

        if ( this.domElement === document ) {

            this.screen.left = 0;
            this.screen.top = 0;
            this.screen.width = window.innerWidth;
            this.screen.height = window.innerHeight;

        } else if(this.domElement) {

            var box = this.domElement.getBoundingClientRect();
            // adjustments come from similar code in the jquery offset() function
            var d = this.domElement.ownerDocument.documentElement;
            this.screen.left = box.left + window.pageXOffset - d.clientLeft;
            this.screen.top = box.top + window.pageYOffset - d.clientTop;
            this.screen.width = box.width;
            this.screen.height = box.height;
        }

        this.left0 = this.object.left;
        this.right0 = this.object.right;
        this.top0 = this.object.top;
        this.bottom0 = this.object.bottom;
        this.center0.set((this.left0 + this.right0) / 2.0, (this.top0 + this.bottom0) / 2.0);

    };

    this.handleEvent = function ( event ) {

        if ( typeof this[ event.type ] === 'function' ) {

            this[ event.type ]( event );

        }

    };

    var getMouseOnScreen = ( function () {

        var vector = new THREE.Vector2();

        return function ( pageX, pageY ) {

            vector.set(
                ( pageX - _this.screen.left ) / _this.screen.width,
                ( pageY - _this.screen.top ) / _this.screen.height
            );

            return vector;

        };

    }() );

    var getMouseProjectionOnBall = ( function () {

        var vector = new THREE.Vector3();
        var objectUp = new THREE.Vector3();
        var mouseOnBall = new THREE.Vector3();

        return function ( pageX, pageY ) {

            mouseOnBall.set(
                ( pageX - _this.screen.width * 0.5 - _this.screen.left ) / (_this.screen.width*.5),
                ( _this.screen.height * 0.5 + _this.screen.top - pageY ) / (_this.screen.height*.5),
                0.0
            );

            var length = mouseOnBall.length();

            if ( _this.noRoll ) {

                if ( length < Math.SQRT1_2 ) {

                    mouseOnBall.z = Math.sqrt( 1.0 - length*length );

                } else {

                    mouseOnBall.z = .5 / length;

                }

            } else if ( length > 1.0 ) {

                mouseOnBall.normalize();

            } else {

                mouseOnBall.z = Math.sqrt( 1.0 - length * length );

            }

            _eye.copy( _this.object.position ).sub( _this.target );

            vector.copy( _this.object.up ).setLength( mouseOnBall.y )
            vector.add( objectUp.copy( _this.object.up ).cross( _eye ).setLength( mouseOnBall.x ) );
            vector.add( _eye.setLength( mouseOnBall.z ) );

            return vector;

        };

    }() );

    this.rotateCamera = (function(quaternionIn, bUpdate){

        var axis = new THREE.Vector3(),
            quaternion = new THREE.Quaternion();

        return function (quaternionIn, bUpdate) {

            var angle;
            if(quaternionIn === undefined) {
              angle = Math.acos( _this._rotateStart.dot( _this._rotateEnd ) / _this._rotateStart.length() / _this._rotateEnd.length() );
            }

            //var angle = Math.acos( _this._rotateStart.dot( _this._rotateEnd ) / _this._rotateStart.length() / _this._rotateEnd.length() );

            if ( angle || quaternionIn !== undefined) {
                if(quaternionIn === undefined) {
                  axis.crossVectors( _this._rotateStart, _this._rotateEnd ).normalize();

                  angle *= _this.rotateSpeed;

                  quaternion.setFromAxisAngle( axis, -angle );
                }
                else {
                  quaternion.copy(quaternionIn);
                }

                // order matters in quaernion multiplication: http://www.cprogramming.com/tutorial/3d/quaternions.html
                if(icn3d !== undefined && icn3d.quaternion !== undefined && (bUpdate === undefined || bUpdate === true)) icn3d.quaternion.multiplyQuaternions(quaternion, icn3d.quaternion);

                _eye.applyQuaternion( quaternion );
                _this.object.up.applyQuaternion( quaternion );

                _this._rotateEnd.applyQuaternion( quaternion );

                if ( _this.staticMoving ) {

                    _this._rotateStart.copy( _this._rotateEnd );

                } else {

                    quaternion.setFromAxisAngle( axis, angle * ( _this.dynamicDampingFactor - 1.0 ) );
                    _this._rotateStart.applyQuaternion( quaternion );

                }

            }
        }

    }());

    this.zoomCamera = function (zoomFactor, bUpdate) {

        var factor;
        if ( _this._state === STATE.TOUCH_ZOOM_PAN ) {

            if(zoomFactor !== undefined) {
              factor = zoomFactor;
            }
            else {

              factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
              _touchZoomDistanceStart = _touchZoomDistanceEnd;
            }

        } else {

            if(zoomFactor !== undefined) {
              factor = zoomFactor;
            }
            else {

              factor = 1.0 + ( _this._zoomEnd.y - _this._zoomStart.y ) * _this.zoomSpeed / zoomSpeedAdjust;
            }
        }

        if(icn3d !== undefined && icn3d._zoomFactor !== undefined && (bUpdate === undefined || bUpdate === true)) icn3d._zoomFactor *= factor;

        //if ( factor !== 1.0 && factor > 0.0 ) {
        if ( factor !== 1.0 ) {

            //_zoomFactor *= factor;
            _zoomFactor = factor;

            _this.object.left = _zoomFactor * _this.left0 + ( 1 - _zoomFactor ) *  _this.center0.x;
            _this.object.right = _zoomFactor * _this.right0 + ( 1 - _zoomFactor ) *  _this.center0.x;
            _this.object.top = _zoomFactor * _this.top0 + ( 1 - _zoomFactor ) *  _this.center0.y;
            _this.object.bottom = _zoomFactor * _this.bottom0 + ( 1 - _zoomFactor ) *  _this.center0.y;

            if ( _this.staticMoving ) {

                _this._zoomStart.copy( _this._zoomEnd );

            } else {

                _this._zoomStart.y += ( _this._zoomEnd.y - _this._zoomStart.y ) * this.dynamicDampingFactor;

            }

        }

    };

    this.panCamera = (function(mouseChangeIn, bUpdate){

        var mouseChange = new THREE.Vector2(),
            objectUp = new THREE.Vector3(),
            pan = new THREE.Vector3();

        return function (mouseChangeIn, bUpdate) {

            if(mouseChangeIn !== undefined) {
              mouseChange = mouseChangeIn;

              if(icn3d !== undefined && icn3d.mouseChange !== undefined && (bUpdate === undefined || bUpdate === true)) icn3d.mouseChange.add(mouseChangeIn);
            }
            else {
              mouseChange.copy( _this._panEnd ).sub( _this._panStart );

              if(icn3d !== undefined && icn3d.mouseChange !== undefined && (bUpdate === undefined || bUpdate === true)) icn3d.mouseChange.add( _this._panEnd ).sub( _this._panStart );
            }

            if ( mouseChange.lengthSq() ) {

                mouseChange.multiplyScalar( _eye.length() * _this.panSpeed );

                pan.copy( _eye ).cross( _this.object.up ).setLength( mouseChange.x );
                pan.add( objectUp.copy( _this.object.up ).setLength( mouseChange.y ) );

                _this.object.position.add( pan );
                _this.target.add( pan );

                if ( _this.staticMoving ) {

                    _this._panStart.copy( _this._panEnd );

                } else {

                    _this._panStart.add( mouseChange.subVectors( _this._panEnd, _this._panStart ).multiplyScalar( _this.dynamicDampingFactor ) );

                }

            }
        }

    }());

    this.update = function (para) {

        _eye.subVectors( _this.object.position, _this.target );

        if ( !_this.noRotate ) {

            if(para !== undefined && para.quaternion !== undefined) {
              _this.rotateCamera(para.quaternion, para.update);
            }
            else {
              _this.rotateCamera();
            }

        }

        if ( !_this.noZoom ) {

            if(para !== undefined && para._zoomFactor !== undefined) {
              _this.zoomCamera(para._zoomFactor, para.update);
            }
            else {
              _this.zoomCamera();
            }

            _this.object.updateProjectionMatrix();

        }

        if ( !_this.noPan ) {

            if(para !== undefined && para.mouseChange !== undefined) {
              _this.panCamera(para.mouseChange, para.update);
            }
            else {
              _this.panCamera();
            }

        }

        _this.object.position.addVectors( _this.target, _eye );

        _this.object.lookAt( _this.target );

        if ( lastPosition.distanceToSquared( _this.object.position ) > EPS ) {

            _this.dispatchEvent( changeEvent );

            lastPosition.copy( _this.object.position );

        }

    };

    this.reset = function () {

        _this._state = STATE.NONE;
        _prevState = STATE.NONE;

        _this.target.copy( _this.target0 );
        _this.object.position.copy( _this.position0 );
        _this.object.up.copy( _this.up0 );

        _eye.subVectors( _this.object.position, _this.target );

        _this.object.left = _this.left0;
        _this.object.right = _this.right0;
        _this.object.top = _this.top0;
        _this.object.bottom = _this.bottom0;

        _this.object.lookAt( _this.target );

        _this.dispatchEvent( changeEvent );

        lastPosition.copy( _this.object.position );

    };

    // listeners

    function keydown( event ) {

        if ( _this.enabled === false || Object.keys(window).length < 2)  return;

        window.removeEventListener( 'keydown', keydown );

        _prevState = _this._state;

        if ( _this._state !== STATE.NONE ) {

            return;

        } else if ( event.keyCode === _this.keys[ STATE.ROTATE ] && !_this.noRotate ) {

            _this._state = STATE.ROTATE;

        } else if ( (event.keyCode === _this.keys[ STATE.ZOOM ]) && !_this.noZoom ) {

            _this._state = STATE.ZOOM;

        } else if ( (event.keyCode === _this.keys[ STATE.PAN ]) && !_this.noPan ) {

            _this._state = STATE.PAN;

        }

    }

    function keyup( event ) {

        if ( _this.enabled === false || Object.keys(window).length < 2)  return;

        _this._state = _prevState;

        window.addEventListener( 'keydown', keydown, false );

    }

    function mousedown( event ) {

        if ( _this.enabled === false || Object.keys(window).length < 2)  return;

        //event.preventDefault();
        event.stopPropagation();

        if ( _this._state === STATE.NONE ) {

            _this._state = event.button;

        }

        if ( _this._state === STATE.ROTATE && !_this.noRotate ) {

            _this._rotateStart.copy( getMouseProjectionOnBall( event.pageX, event.pageY ) );
            _this._rotateEnd.copy( _this._rotateStart );

        } else if ( _this._state === STATE.ZOOM && !_this.noZoom ) {

            _this._zoomStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );
            _this._zoomEnd.copy(_this._zoomStart);

        } else if ( _this._state === STATE.PAN && !_this.noPan ) {

            _this._panStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );
            _this._panEnd.copy(_this._panStart)

        }

        document.addEventListener( 'mousemove', mousemove, false );
        document.addEventListener( 'mouseup', mouseup, false );

        _this.dispatchEvent( startEvent );

    }

    function mousemove( event ) {

        if ( _this.enabled === false || Object.keys(window).length < 2)  return;

        //event.preventDefault();
        event.stopPropagation();

        if ( _this._state === STATE.ROTATE && !_this.noRotate ) {

            _this._rotateEnd.copy( getMouseProjectionOnBall( event.pageX, event.pageY ) );

        } else if ( _this._state === STATE.ZOOM && !_this.noZoom ) {

            _this._zoomEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );

        } else if ( _this._state === STATE.PAN && !_this.noPan ) {

            _this._panEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );

        }

    }

    function mouseup( event ) {

        if ( _this.enabled === false || Object.keys(window).length < 2)  return;

        //event.preventDefault();
        event.stopPropagation();

        _this._state = STATE.NONE;

        document.removeEventListener( 'mousemove', mousemove );
        document.removeEventListener( 'mouseup', mouseup );
        _this.dispatchEvent( endEvent );

    }

    function mousewheel( event ) {

        if ( _this.enabled === false || Object.keys(window).length < 2)  return;

        //event.preventDefault();
        event.stopPropagation();

        var delta = 0;

        if ( event.wheelDelta ) { // WebKit / Opera / Explorer 9

            delta = event.wheelDelta / 40;

        } else if ( event.detail ) { // Firefox

            delta = - event.detail / 3;

        }

        //_this._zoomStart.y += delta * 0.01;
        _this._zoomStart.y = delta * 0.01;
        _this.dispatchEvent( startEvent );
        _this.dispatchEvent( endEvent );

    }

    function touchstart( event ) {

        if ( _this.enabled === false || Object.keys(window).length < 2)  return;

        switch ( event.touches.length ) {

            case 1:
                _this._state = STATE.TOUCH_ROTATE;
                _this._rotateStart.copy( getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );
                _this._rotateEnd.copy( _this._rotateStart );
                break;

            case 2:
                _this._state = STATE.TOUCH_ZOOM_PAN;
                var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
                _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt( dx * dx + dy * dy );

                var x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;
                var y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;
                _this._panStart.copy( getMouseOnScreen( x, y ) );
                _this._panEnd.copy( _this._panStart );
                break;

            default:
                _this._state = STATE.NONE;

        }
        _this.dispatchEvent( startEvent );


    }

    function touchmove( event ) {

        if ( _this.enabled === false || Object.keys(window).length < 2)  return;

        //event.preventDefault();
        event.stopPropagation();

        switch ( event.touches.length ) {

            case 1:
                _this._rotateEnd.copy( getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );
                break;

            case 2:
                var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
                _touchZoomDistanceEnd = Math.sqrt( dx * dx + dy * dy );

                var x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;
                var y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;
                _this._panEnd.copy( getMouseOnScreen( x, y ) );
                break;

            default:
                _this._state = STATE.NONE;

        }

    }

    function touchend( event ) {

        if ( _this.enabled === false || Object.keys(window).length < 2)  return;

        switch ( event.touches.length ) {

            case 1:
                _this._rotateEnd.copy( getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );
                _this._rotateStart.copy( _this._rotateEnd );
                break;

            case 2:
                _touchZoomDistanceStart = _touchZoomDistanceEnd = 0;

                var x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;
                var y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;
                _this._panEnd.copy( getMouseOnScreen( x, y ) );
                _this._panStart.copy( _this._panEnd );
                break;

        }

        _this._state = STATE.NONE;
        _this.dispatchEvent( endEvent );

    }

    if(Object.keys(window).length >= 2 && this.domElement) {
        this.domElement.addEventListener( 'contextmn', function ( event ) {
            //event.preventDefault();
        }, false );

        this.domElement.addEventListener( 'mousedown', mousedown, false );

        this.domElement.addEventListener( 'mousewheel', mousewheel, false );
        this.domElement.addEventListener( 'DOMMouseScroll', mousewheel, false ); // firefox

        this.domElement.addEventListener( 'touchstart', touchstart, false );
        this.domElement.addEventListener( 'touchend', touchend, false );
        this.domElement.addEventListener( 'touchmove', touchmove, false );

        window.addEventListener( 'keydown', keydown, false );
        window.addEventListener( 'keyup', keyup, false );
    }

    this.handleResize();

    // force an update at start
    this.update();

};

THREE.OrthographicTrackballControls.prototype = Object.create( THREE.EventDispatcher.prototype );
THREE.OrthographicTrackballControls.prototype.constructor = THREE.OrthographicTrackballControls;

/**
 * @author alteredq / http://alteredqualia.com/
 * @authod mrdoob / http://mrdoob.com/
 * @authod arodic / http://aleksandarrodic.com/
 * modified by Jiyao Wang
 */

THREE.StereoEffect = function ( renderer ) {
    var _this = this;
    // API

    _this.separation = 3; // 1;

    // internals

    // _this._width, _this._height;

    _this._position = new THREE.Vector3();
    _this._quaternion = new THREE.Quaternion();
    _this._scale = new THREE.Vector3();

    _this._cameraL = new THREE.PerspectiveCamera();
    _this._cameraR = new THREE.PerspectiveCamera();

    // initialization

    renderer.autoClear = false;

    _this.setSize = function ( width, height ) {

        _this._width = width / 2;
        _this._height = height;

        renderer.setSize( width, height );

    };

    _this.render = function ( scene, camera ) {

        scene.updateMatrixWorld();

        if ( camera.parent === undefined ) camera.updateMatrixWorld();
    
        camera.matrixWorld.decompose( _this._position, _this._quaternion, _this._scale );

        // left
        _this._cameraL.copy(camera);
        _this._cameraL.aspect = 0.5 * camera.aspect;
        _this._cameraL.updateProjectionMatrix();
        
/*
        _this._cameraL.fov = camera.fov;
        _this._cameraL.aspect = 0.5 * camera.aspect;
        _this._cameraL.near = camera.near;
        _this._cameraL.far = camera.far;
        _this._cameraL.updateProjectionMatrix();

        _this._cameraL.position.copy( _this._position );
        // _this._cameraL.quaternion.copy( _this._quaternion );
*/
        _this._cameraL.translateX( - _this.separation );

        // right
        _this._cameraR.copy(camera);
        _this._cameraR.aspect = 0.5 * camera.aspect;
        _this._cameraR.updateProjectionMatrix();

/*
        _this._cameraR.fov = camera.fov;
        _this._cameraR.aspect = 0.5 * camera.aspect;
        _this._cameraR.near = camera.near;
        _this._cameraR.far = camera.far;
        // _this._cameraR.projectionMatrix = _this._cameraL.projectionMatrix;
        _this._cameraR.updateProjectionMatrix();

        _this._cameraR.position.copy( _this._position );
        // _this._cameraR.quaternion.copy( _this._quaternion );
*/

        _this._cameraR.translateX( _this.separation );

        //

        renderer.setViewport( 0, 0, _this._width * 2, _this._height );
        renderer.clear();

        renderer.setViewport( 0, 0, _this._width, _this._height );
        renderer.render( scene, _this._cameraL );

        renderer.setViewport( _this._width, 0, _this._width, _this._height );
        renderer.render( scene, _this._cameraR );

    };

};



// ; var __CIFTools = function () {
//   'use strict';
/*
 * Copyright (c) 2016 - now David Sehnal, licensed under MIT License, See LICENSE file for more info.
 */
var CIFTools;
(function (CIFTools) {
    CIFTools.VERSION = { number: "1.1.7", date: "Oct 30 2018" };
// })(CIFTools || (CIFTools = {}));
/*
 * Copyright (c) 2016 - now David Sehnal, licensed under MIT License, See LICENSE file for more info.
 */
// var CIFTools;
// (function (CIFTools) {
    var Utils;
    (function (Utils) {
        var ChunkedArray;
        (function (ChunkedArray) {
            function is(x) {
                return x.creator && x.chunkSize;
            }
            ChunkedArray.is = is;
            function add4(array, x, y, z, w) {
                if (array.currentIndex >= array.chunkSize) {
                    array.currentIndex = 0;
                    array.current = array.creator(array.chunkSize);
                    array.parts[array.parts.length] = array.current;
                }
                array.current[array.currentIndex++] = x;
                array.current[array.currentIndex++] = y;
                array.current[array.currentIndex++] = z;
                array.current[array.currentIndex++] = w;
                return array.elementCount++;
            }
            ChunkedArray.add4 = add4;
            function add3(array, x, y, z) {
                if (array.currentIndex >= array.chunkSize) {
                    array.currentIndex = 0;
                    array.current = array.creator(array.chunkSize);
                    array.parts[array.parts.length] = array.current;
                }
                array.current[array.currentIndex++] = x;
                array.current[array.currentIndex++] = y;
                array.current[array.currentIndex++] = z;
                return array.elementCount++;
            }
            ChunkedArray.add3 = add3;
            function add2(array, x, y) {
                if (array.currentIndex >= array.chunkSize) {
                    array.currentIndex = 0;
                    array.current = array.creator(array.chunkSize);
                    array.parts[array.parts.length] = array.current;
                }
                array.current[array.currentIndex++] = x;
                array.current[array.currentIndex++] = y;
                return array.elementCount++;
            }
            ChunkedArray.add2 = add2;
            function add(array, x) {
                if (array.currentIndex >= array.chunkSize) {
                    array.currentIndex = 0;
                    array.current = array.creator(array.chunkSize);
                    array.parts[array.parts.length] = array.current;
                }
                array.current[array.currentIndex++] = x;
                return array.elementCount++;
            }
            ChunkedArray.add = add;
            function compact(array) {
                var ret = array.creator(array.elementSize * array.elementCount), offset = (array.parts.length - 1) * array.chunkSize, offsetInner = 0, part;
                if (array.parts.length > 1) {
                    if (array.parts[0].buffer) {
                        for (var i = 0; i < array.parts.length - 1; i++) {
                            ret.set(array.parts[i], array.chunkSize * i);
                        }
                    }
                    else {
                        for (var i = 0; i < array.parts.length - 1; i++) {
                            offsetInner = array.chunkSize * i;
                            part = array.parts[i];
                            for (var j = 0; j < array.chunkSize; j++) {
                                ret[offsetInner + j] = part[j];
                            }
                        }
                    }
                }
                if (array.current.buffer && array.currentIndex >= array.chunkSize) {
                    ret.set(array.current, array.chunkSize * (array.parts.length - 1));
                }
                else {
                    for (var i = 0; i < array.currentIndex; i++) {
                        ret[offset + i] = array.current[i];
                    }
                }
                return ret;
            }
            ChunkedArray.compact = compact;
            function forVertex3D(chunkVertexCount) {
                if (chunkVertexCount === void 0) { chunkVertexCount = 262144; }
                return create(function (size) { return new Float32Array(size); }, chunkVertexCount, 3);
            }
            ChunkedArray.forVertex3D = forVertex3D;
            function forIndexBuffer(chunkIndexCount) {
                if (chunkIndexCount === void 0) { chunkIndexCount = 262144; }
                return create(function (size) { return new Uint32Array(size); }, chunkIndexCount, 3);
            }
            ChunkedArray.forIndexBuffer = forIndexBuffer;
            function forTokenIndices(chunkTokenCount) {
                if (chunkTokenCount === void 0) { chunkTokenCount = 131072; }
                return create(function (size) { return new Int32Array(size); }, chunkTokenCount, 2);
            }
            ChunkedArray.forTokenIndices = forTokenIndices;
            function forIndices(chunkTokenCount) {
                if (chunkTokenCount === void 0) { chunkTokenCount = 131072; }
                return create(function (size) { return new Int32Array(size); }, chunkTokenCount, 1);
            }
            ChunkedArray.forIndices = forIndices;
            function forInt32(chunkSize) {
                if (chunkSize === void 0) { chunkSize = 131072; }
                return create(function (size) { return new Int32Array(size); }, chunkSize, 1);
            }
            ChunkedArray.forInt32 = forInt32;
            function forFloat32(chunkSize) {
                if (chunkSize === void 0) { chunkSize = 131072; }
                return create(function (size) { return new Float32Array(size); }, chunkSize, 1);
            }
            ChunkedArray.forFloat32 = forFloat32;
            function forArray(chunkSize) {
                if (chunkSize === void 0) { chunkSize = 131072; }
                return create(function (size) { return []; }, chunkSize, 1);
            }
            ChunkedArray.forArray = forArray;
            function create(creator, chunkElementCount, elementSize) {
                chunkElementCount = chunkElementCount | 0;
                if (chunkElementCount <= 0)
                    chunkElementCount = 1;
                var chunkSize = chunkElementCount * elementSize;
                var current = creator(chunkSize);
                return {
                    elementSize: elementSize,
                    chunkSize: chunkSize,
                    creator: creator,
                    current: current,
                    parts: [current],
                    currentIndex: 0,
                    elementCount: 0
                };
            }
            ChunkedArray.create = create;
        })(ChunkedArray = Utils.ChunkedArray || (Utils.ChunkedArray = {}));
    })(Utils = CIFTools.Utils || (CIFTools.Utils = {}));
// })(CIFTools || (CIFTools = {}));
/*
 * Copyright (c) 2016 - now David Sehnal, licensed under MIT License, See LICENSE file for more info.
 */
/**
 * Efficient integer and float parsers.
 *
 * For the purposes of parsing numbers from the mmCIF data representations,
 * up to 4 times faster than JS parseInt/parseFloat.
 */
// var CIFTools;
// (function (CIFTools) {
//     var Utils;
    (function (Utils) {
        var FastNumberParsers;
        (function (FastNumberParsers) {
            "use strict";
            function parseIntSkipTrailingWhitespace(str, start, end) {
                while (start < end && str.charCodeAt(start) === 32)
                    start++;
                return parseInt(str, start, end);
            }
            FastNumberParsers.parseIntSkipTrailingWhitespace = parseIntSkipTrailingWhitespace;
            function parseInt(str, start, end) {
                var ret = 0, neg = 1;
                if (str.charCodeAt(start) === 45 /* - */) {
                    neg = -1;
                    start++;
                }
                for (; start < end; start++) {
                    var c = str.charCodeAt(start) - 48;
                    if (c > 9 || c < 0)
                        return (neg * ret) | 0;
                    else
                        ret = (10 * ret + c) | 0;
                }
                return neg * ret;
            }
            FastNumberParsers.parseInt = parseInt;
            function parseScientific(main, str, start, end) {
                // handle + in '1e+1' separately.
                if (str.charCodeAt(start) === 43 /* + */)
                    start++;
                return main * Math.pow(10.0, parseInt(str, start, end));
            }
            function parseFloatSkipTrailingWhitespace(str, start, end) {
                while (start < end && str.charCodeAt(start) === 32)
                    start++;
                return parseFloat(str, start, end);
            }
            FastNumberParsers.parseFloatSkipTrailingWhitespace = parseFloatSkipTrailingWhitespace;
            function parseFloat(str, start, end) {
                var neg = 1.0, ret = 0.0, point = 0.0, div = 1.0;
                if (str.charCodeAt(start) === 45) {
                    neg = -1.0;
                    ++start;
                }
                while (start < end) {
                    var c = str.charCodeAt(start) - 48;
                    if (c >= 0 && c < 10) {
                        ret = ret * 10 + c;
                        ++start;
                    }
                    else if (c === -2) { // .
                        ++start;
                        while (start < end) {
                            c = str.charCodeAt(start) - 48;
                            if (c >= 0 && c < 10) {
                                point = 10.0 * point + c;
                                div = 10.0 * div;
                                ++start;
                            }
                            else if (c === 53 || c === 21) { // 'e'/'E'
                                return parseScientific(neg * (ret + point / div), str, start + 1, end);
                            }
                            else {
                                return neg * (ret + point / div);
                            }
                        }
                        return neg * (ret + point / div);
                    }
                    else if (c === 53 || c === 21) { // 'e'/'E'
                        return parseScientific(neg * ret, str, start + 1, end);
                    }
                    else
                        break;
                }
                return neg * ret;
            }
            FastNumberParsers.parseFloat = parseFloat;
        })(FastNumberParsers = Utils.FastNumberParsers || (Utils.FastNumberParsers = {}));
    })(Utils = CIFTools.Utils || (CIFTools.Utils = {}));
// })(CIFTools || (CIFTools = {}));
/*
 * Copyright (c) 2016 - now David Sehnal, licensed under MIT License, See LICENSE file for more info.
 */
// var CIFTools;
// (function (CIFTools) {
//     var Utils;
    (function (Utils) {
        var __paddingSpaces = [];
        (function () {
            var s = '';
            for (var i = 0; i < 512; i++) {
                __paddingSpaces[i] = s;
                s = s + ' ';
            }
        })();
        var StringWriter;
        (function (StringWriter) {
            function create(chunkCapacity) {
                if (chunkCapacity === void 0) { chunkCapacity = 512; }
                return {
                    chunkData: [],
                    chunkOffset: 0,
                    chunkCapacity: chunkCapacity,
                    data: []
                };
            }
            StringWriter.create = create;
            function asString(writer) {
                if (!writer.data.length) {
                    if (writer.chunkData.length === writer.chunkOffset)
                        return writer.chunkData.join('');
                    return writer.chunkData.splice(0, writer.chunkOffset).join('');
                }
                if (writer.chunkOffset > 0) {
                    writer.data[writer.data.length] = writer.chunkData.splice(0, writer.chunkOffset).join('');
                }
                return writer.data.join('');
            }
            StringWriter.asString = asString;
            function writeTo(writer, stream) {
                finalize(writer);
                for (var _i = 0, _a = writer.data; _i < _a.length; _i++) {
                    var s = _a[_i];
                    stream.writeString(s);
                }
            }
            StringWriter.writeTo = writeTo;
            function finalize(writer) {
                if (writer.chunkOffset > 0) {
                    if (writer.chunkData.length === writer.chunkOffset)
                        writer.data[writer.data.length] = writer.chunkData.join('');
                    else
                        writer.data[writer.data.length] = writer.chunkData.splice(0, writer.chunkOffset).join('');
                    writer.chunkOffset = 0;
                }
            }
            function newline(writer) {
                write(writer, '\n');
            }
            StringWriter.newline = newline;
            function whitespace(writer, len) {
                write(writer, __paddingSpaces[len]);
            }
            StringWriter.whitespace = whitespace;
            function write(writer, val) {
                if (val === undefined || val === null) {
                    return;
                }
                if (writer.chunkOffset === writer.chunkCapacity) {
                    writer.data[writer.data.length] = writer.chunkData.join('');
                    writer.chunkOffset = 0;
                }
                writer.chunkData[writer.chunkOffset++] = val;
            }
            StringWriter.write = write;
            function writeSafe(writer, val) {
                if (writer.chunkOffset === writer.chunkCapacity) {
                    writer.data[writer.data.length] = writer.chunkData.join('');
                    writer.chunkOffset = 0;
                }
                writer.chunkData[writer.chunkOffset++] = val;
            }
            StringWriter.writeSafe = writeSafe;
            function writePadLeft(writer, val, totalWidth) {
                if (val === undefined || val === null) {
                    write(writer, __paddingSpaces[totalWidth]);
                }
                var padding = totalWidth - val.length;
                if (padding > 0)
                    write(writer, __paddingSpaces[padding]);
                write(writer, val);
            }
            StringWriter.writePadLeft = writePadLeft;
            function writePadRight(writer, val, totalWidth) {
                if (val === undefined || val === null) {
                    write(writer, __paddingSpaces[totalWidth]);
                }
                var padding = totalWidth - val.length;
                write(writer, val);
                if (padding > 0)
                    write(writer, __paddingSpaces[padding]);
            }
            StringWriter.writePadRight = writePadRight;
            function writeInteger(writer, val) {
                write(writer, '' + val);
            }
            StringWriter.writeInteger = writeInteger;
            function writeIntegerPadLeft(writer, val, totalWidth) {
                var s = '' + val;
                var padding = totalWidth - s.length;
                if (padding > 0)
                    write(writer, __paddingSpaces[padding]);
                write(writer, s);
            }
            StringWriter.writeIntegerPadLeft = writeIntegerPadLeft;
            function writeIntegerPadRight(writer, val, totalWidth) {
                var s = '' + val;
                var padding = totalWidth - s.length;
                write(writer, s);
                if (padding > 0)
                    write(writer, __paddingSpaces[padding]);
            }
            StringWriter.writeIntegerPadRight = writeIntegerPadRight;
            /**
             * @example writeFloat(123.2123, 100) -- 2 decim
             */
            function writeFloat(writer, val, precisionMultiplier) {
                write(writer, '' + Math.round(precisionMultiplier * val) / precisionMultiplier);
            }
            StringWriter.writeFloat = writeFloat;
            function writeFloatPadLeft(writer, val, precisionMultiplier, totalWidth) {
                var s = '' + Math.round(precisionMultiplier * val) / precisionMultiplier;
                var padding = totalWidth - s.length;
                if (padding > 0)
                    write(writer, __paddingSpaces[padding]);
                write(writer, s);
            }
            StringWriter.writeFloatPadLeft = writeFloatPadLeft;
            function writeFloatPadRight(writer, val, precisionMultiplier, totalWidth) {
                var s = '' + Math.round(precisionMultiplier * val) / precisionMultiplier;
                var padding = totalWidth - s.length;
                write(writer, s);
                if (padding > 0)
                    write(writer, __paddingSpaces[padding]);
            }
            StringWriter.writeFloatPadRight = writeFloatPadRight;
        })(StringWriter = Utils.StringWriter || (Utils.StringWriter = {}));
    })(Utils = CIFTools.Utils || (CIFTools.Utils = {}));
// })(CIFTools || (CIFTools = {}));
/*
 * Copyright (c) 2016 - now David Sehnal, licensed under MIT License, See LICENSE file for more info.
 */
// var CIFTools;
// (function (CIFTools) {
//     "use strict";
    /**
     * Represents a column that is not present.
     */
    var _UndefinedColumn = /** @class */ (function () {
        function _UndefinedColumn() {
            this.isDefined = false;
        }
        _UndefinedColumn.prototype.getString = function (row) { return null; };
        ;
        _UndefinedColumn.prototype.getInteger = function (row) { return 0; };
        _UndefinedColumn.prototype.getFloat = function (row) { return 0.0; };
        _UndefinedColumn.prototype.getValuePresence = function (row) { return 1 /* NotSpecified */; };
        _UndefinedColumn.prototype.areValuesEqual = function (rowA, rowB) { return true; };
        _UndefinedColumn.prototype.stringEquals = function (row, value) { return value === null; };
        return _UndefinedColumn;
    }());
    CIFTools.UndefinedColumn = new _UndefinedColumn();
    /**
     * Helper functions for categoies.
     */
    var Category;
    (function (Category) {
        /**
         * Extracts a matrix from a category from a specified rowIndex.
         *
         * _category.matrix[1][1] v11
         * ....
         * ....
         * _category.matrix[rows][cols] vRowsCols
         */
        function getMatrix(category, field, rows, cols, rowIndex) {
            var ret = [];
            for (var i = 1; i <= rows; i++) {
                var row = [];
                for (var j = 1; j <= cols; j++) {
                    row[j - 1] = category.getColumn(field + "[" + i + "][" + j + "]").getFloat(rowIndex);
                }
                ret[i - 1] = row;
            }
            return ret;
        }
        Category.getMatrix = getMatrix;
        /**
         * Extracts a vector from a category from a specified rowIndex.
         *
         * _category.matrix[1][1] v11
         * ....
         * ....
         * _category.matrix[rows][cols] vRowsCols
         */
        function getVector(category, field, rows, cols, rowIndex) {
            var ret = [];
            for (var i = 1; i <= rows; i++) {
                ret[i - 1] = category.getColumn(field + "[" + i + "]").getFloat(rowIndex);
            }
            return ret;
        }
        Category.getVector = getVector;
    })(Category = CIFTools.Category || (CIFTools.Category = {}));
// })(CIFTools || (CIFTools = {}));
/*
 * Copyright (c) 2016 - now David Sehnal, licensed under MIT License, See LICENSE file for more info.
 */
// var CIFTools;
// (function (CIFTools) {
//     "use strict";
    var ParserResult;
    (function (ParserResult) {
        function error(message, line) {
            if (line === void 0) { line = -1; }
            return new ParserError(message, line);
        }
        ParserResult.error = error;
        function success(result, warnings) {
            if (warnings === void 0) { warnings = []; }
            return new ParserSuccess(result, warnings);
        }
        ParserResult.success = success;
    })(ParserResult = CIFTools.ParserResult || (CIFTools.ParserResult = {}));
    var ParserError = /** @class */ (function () {
        function ParserError(message, line) {
            this.message = message;
            this.line = line;
            this.isError = true;
        }
        ParserError.prototype.toString = function () {
            if (this.line >= 0) {
                return "[Line " + this.line + "] " + this.message;
            }
            return this.message;
        };
        return ParserError;
    }());
    CIFTools.ParserError = ParserError;
    var ParserSuccess = /** @class */ (function () {
        function ParserSuccess(result, warnings) {
            this.result = result;
            this.warnings = warnings;
            this.isError = false;
        }
        return ParserSuccess;
    }());
    CIFTools.ParserSuccess = ParserSuccess;
// })(CIFTools || (CIFTools = {}));
/*
 * Copyright (c) 2016 - now David Sehnal, licensed under MIT License, See LICENSE file for more info.
 */
/*
 * Copyright (c) 2016 - now David Sehnal, licensed under MIT License, See LICENSE file for more info.
 */
/*
    On data representation of molecular files

    Consider an mmCIF file that stores a molecule with 100k atoms. For the sake of simplicity,
    lets ignore things like symmetry or assemblies, and assume, that the file only stores the
    _atom_site records. The atom site "table" in the standard mmCIF from PDB database currently
    has 26 columns.

    So the data looks something like this:

        loop_
        _atom_site.column1
        ....
        _atom_site.column26
        t1,1 .... t1,26
        t100000,1 .... t100000,26

    The straightforward way to represent this data in JavaScript is to have an array of objects
    with properties named "column1" ..., "column26":

        [{ column1: "t1,1", ..., column26: "t1,26" },
          ...,
         { column1: "t100000,1", ..., column26: "t100000,26" }]

    So in order to represent the atoms sites, we would need 100k objects and 2.6 million strings.
    Is this bad? well, sort of. It would not be so bad if this representation would be the only
    thing we need to keep in memory and/or the life time of the object was short. But usually
    we would need to keep the object around for the entire lifetime of the app. This alone
    adds a very non-significant overhead for the garbage collector (which increases the app's
    latency). What's worse is that we usually only need a fraction of this data, but this can
    vary application for application. For just 100k atoms, the overhead is not "that bad", but
    consider 1M atoms and suddenly we have a problem.

    The following data model shows an alternative way of storing molecular file s
    in memory that is very efficient, fast and introduces a very minimal overhead.

 */
// var CIFTools;
// (function (CIFTools) {
    var Text;
    (function (Text) {
        "use strict";
        var ShortStringPool;
        (function (ShortStringPool) {
            function create() { return Object.create(null); }
            ShortStringPool.create = create;
            function get(pool, str) {
                if (str.length > 6)
                    return str;
                var value = pool[str];
                if (value !== void 0)
                    return value;
                pool[str] = str;
                return str;
            }
            ShortStringPool.get = get;
        })(ShortStringPool || (ShortStringPool = {}));
        /**
         * Represents the input file.
         */
        var File = /** @class */ (function () {
            function File(data) {
                /**
                 * Data blocks inside the file. If no data block is present, a "default" one is created.
                 */
                this.dataBlocks = [];
                this.data = data;
            }
            File.prototype.toJSON = function () {
                return this.dataBlocks.map(function (b) { return b.toJSON(); });
            };
            return File;
        }());
        Text.File = File;
        /**
         * Represents a single data block.
         */
        var DataBlock = /** @class */ (function () {
            function DataBlock(data, header) {
                this.header = header;
                this.data = data;
                this.categoryList = [];
                this.additionalData = {};
                this.categoryMap = new Map();
            }
            Object.defineProperty(DataBlock.prototype, "categories", {
                /**
                 * Categories of the block.
                 * block.categories._atom_site / ['_atom_site']
                 */
                get: function () {
                    return this.categoryList;
                },
                enumerable: true,
                configurable: true
            });
            /**
             * Gets a category by its name.
             */
            DataBlock.prototype.getCategory = function (name) {
                return this.categoryMap.get(name);
            };
            /**
             * Adds a category.
             */
            DataBlock.prototype.addCategory = function (category) {
                this.categoryList[this.categoryList.length] = category;
                this.categoryMap.set(category.name, category);
            };
            DataBlock.prototype.toJSON = function () {
                return {
                    id: this.header,
                    categories: this.categoryList.map(function (c) { return c.toJSON(); }),
                    additionalData: this.additionalData
                };
            };
            return DataBlock;
        }());
        Text.DataBlock = DataBlock;
        /**
         * Represents a single CIF category.
         */
        var Category = /** @class */ (function () {
            function Category(data, name, startIndex, endIndex, columns, tokens, tokenCount) {
                this.name = name;
                this.tokens = tokens;
                this.data = data;
                this.startIndex = startIndex;
                this.endIndex = endIndex;
                this.columnCount = columns.length;
                this.rowCount = (tokenCount / columns.length) | 0;
                this.columnIndices = new Map();
                this.columnNameList = [];
                for (var i = 0; i < columns.length; i++) {
                    var colName = columns[i].substr(name.length + 1);
                    this.columnIndices.set(colName, i);
                    this.columnNameList.push(colName);
                }
            }
            Object.defineProperty(Category.prototype, "columnNames", {
                /**
                 * The array of columns.
                 */
                get: function () {
                    return this.columnNameList;
                },
                enumerable: true,
                configurable: true
            });
            /**
             * Get a column object that makes accessing data easier.
             * @returns undefined if the column isn't present, the Column object otherwise.
             */
            Category.prototype.getColumn = function (name) {
                var i = this.columnIndices.get(name);
                if (i !== void 0)
                    return new Column(this, this.data, name, i);
                return CIFTools.UndefinedColumn;
            };
            Category.prototype.toJSON = function () {
                var rows = [], data = this.data, tokens = this.tokens;
                var colNames = this.columnNameList;
                var strings = ShortStringPool.create();
                for (var i = 0; i < this.rowCount; i++) {
                    var item = {};
                    for (var j = 0; j < this.columnCount; j++) {
                        var tk = (i * this.columnCount + j) * 2;
                        item[colNames[j]] = ShortStringPool.get(strings, data.substring(tokens[tk], tokens[tk + 1]));
                    }
                    rows[i] = item;
                }
                return { name: this.name, columns: colNames, rows: rows };
            };
            return Category;
        }());
        Text.Category = Category;
        var fastParseInt = CIFTools.Utils.FastNumberParsers.parseInt;
        var fastParseFloat = CIFTools.Utils.FastNumberParsers.parseFloat;
        /**
         * Represents a single column of a CIF category.
         */
        var Column = /** @class */ (function () {
            function Column(category, data, name, index) {
                this.data = data;
                this.name = name;
                this.index = index;
                this.stringPool = ShortStringPool.create();
                this.isDefined = true;
                this.tokens = category.tokens;
                this.columnCount = category.columnCount;
            }
            /**
             * Returns the string value at given row.
             */
            Column.prototype.getString = function (row) {
                var i = (row * this.columnCount + this.index) * 2;
                var ret = ShortStringPool.get(this.stringPool, this.data.substring(this.tokens[i], this.tokens[i + 1]));
                if (ret === "." || ret === "?")
                    return null;
                return ret;
            };
            /**
             * Returns the integer value at given row.
             */
            Column.prototype.getInteger = function (row) {
                var i = (row * this.columnCount + this.index) * 2;
                return fastParseInt(this.data, this.tokens[i], this.tokens[i + 1]);
            };
            /**
             * Returns the float value at given row.
             */
            Column.prototype.getFloat = function (row) {
                var i = (row * this.columnCount + this.index) * 2;
                return fastParseFloat(this.data, this.tokens[i], this.tokens[i + 1]);
            };
            /**
             * Returns true if the token has the specified string value.
             */
            Column.prototype.stringEquals = function (row, value) {
                var aIndex = (row * this.columnCount + this.index) * 2, s = this.tokens[aIndex], len = value.length;
                if (len !== this.tokens[aIndex + 1] - s)
                    return false;
                for (var i = 0; i < len; i++) {
                    if (this.data.charCodeAt(i + s) !== value.charCodeAt(i))
                        return false;
                }
                return true;
            };
            /**
             * Determines if values at the given rows are equal.
             */
            Column.prototype.areValuesEqual = function (rowA, rowB) {
                var aIndex = (rowA * this.columnCount + this.index) * 2, bIndex = (rowB * this.columnCount + this.index) * 2;
                var aS = this.tokens[aIndex], bS = this.tokens[bIndex], len = this.tokens[aIndex + 1] - aS;
                if (len !== this.tokens[bIndex + 1] - bS)
                    return false;
                for (var i = 0; i < len; i++) {
                    if (this.data.charCodeAt(i + aS) !== this.data.charCodeAt(i + bS)) {
                        return false;
                    }
                }
                return true;
            };
            /**
             * Returns true if the value is not defined (. or ? token).
             */
            Column.prototype.getValuePresence = function (row) {
                var index = row * this.columnCount + this.index;
                var s = this.tokens[2 * index];
                if (this.tokens[2 * index + 1] - s !== 1)
                    return 0 /* Present */;
                var v = this.data.charCodeAt(s);
                if (v === 46 /* . */)
                    return 1 /* NotSpecified */;
                if (v === 63 /* ? */)
                    return 2 /* Unknown */;
                return 0 /* Present */;
            };
            return Column;
        }());
        Text.Column = Column;
    })(Text = CIFTools.Text || (CIFTools.Text = {}));
// })(CIFTools || (CIFTools = {}));
/*
 * Copyright (c) 2016 - now David Sehnal, licensed under MIT License, See LICENSE file for more info.
 */
// var CIFTools;
// (function (CIFTools) {
//     var Text;
    (function (Text) {
        "use strict";
        var TokenIndexBuilder;
        (function (TokenIndexBuilder) {
            function resize(builder) {
                // scale the size using golden ratio, because why not.
                var newBuffer = new Int32Array((1.61 * builder.tokens.length) | 0);
                newBuffer.set(builder.tokens);
                builder.tokens = newBuffer;
                builder.tokensLenMinus2 = (newBuffer.length - 2) | 0;
            }
            function addToken(builder, start, end) {
                if (builder.count >= builder.tokensLenMinus2) {
                    resize(builder);
                }
                builder.tokens[builder.count++] = start;
                builder.tokens[builder.count++] = end;
            }
            TokenIndexBuilder.addToken = addToken;
            function create(size) {
                return {
                    tokensLenMinus2: (size - 2) | 0,
                    count: 0,
                    tokens: new Int32Array(size)
                };
            }
            TokenIndexBuilder.create = create;
        })(TokenIndexBuilder || (TokenIndexBuilder = {}));
        /**
         * Eat everything until a whitespace/newline occurs.
         */
        function eatValue(state) {
            while (state.position < state.length) {
                switch (state.data.charCodeAt(state.position)) {
                    case 9: // \t
                    case 10: // \n
                    case 13: // \r
                    case 32: // ' '
                        state.currentTokenEnd = state.position;
                        return;
                    default:
                        ++state.position;
                        break;
                }
            }
            state.currentTokenEnd = state.position;
        }
        /**
         * Eats an escaped values. Handles the "degenerate" cases as well.
         *
         * "Degenerate" cases:
         * - 'xx'x' => xx'x
         * - 'xxxNEWLINE => 'xxx
         *
         */
        function eatEscaped(state, esc) {
            var next, c;
            ++state.position;
            while (state.position < state.length) {
                c = state.data.charCodeAt(state.position);
                if (c === esc) {
                    next = state.data.charCodeAt(state.position + 1);
                    switch (next) {
                        case 9: // \t
                        case 10: // \n
                        case 13: // \r
                        case 32: // ' '
                            // get rid of the quotes.
                            state.currentTokenStart++;
                            state.currentTokenEnd = state.position;
                            state.isEscaped = true;
                            ++state.position;
                            return;
                        default:
                            if (next === void 0) { // = "end of stream"
                                // get rid of the quotes.
                                state.currentTokenStart++;
                                state.currentTokenEnd = state.position;
                                state.isEscaped = true;
                                ++state.position;
                                return;
                            }
                            ++state.position;
                            break;
                    }
                }
                else {
                    // handle 'xxxNEWLINE => 'xxx
                    if (c === 10 || c === 13) {
                        state.currentTokenEnd = state.position;
                        return;
                    }
                    ++state.position;
                }
            }
            state.currentTokenEnd = state.position;
        }
        /**
         * Eats a multiline token of the form NL;....NL;
         */
        function eatMultiline(state) {
            var prev = 59, pos = state.position + 1, c;
            while (pos < state.length) {
                c = state.data.charCodeAt(pos);
                if (c === 59 && (prev === 10 || prev === 13)) { // ;, \n \r
                    state.position = pos + 1;
                    // get rid of the ;
                    state.currentTokenStart++;
                    // remove trailing newlines
                    pos--;
                    c = state.data.charCodeAt(pos);
                    while (c === 10 || c === 13) {
                        pos--;
                        c = state.data.charCodeAt(pos);
                    }
                    state.currentTokenEnd = pos + 1;
                    state.isEscaped = true;
                    return;
                }
                else {
                    // handle line numbers
                    if (c === 13) { // \r
                        state.currentLineNumber++;
                    }
                    else if (c === 10 && prev !== 13) { // \r\n
                        state.currentLineNumber++;
                    }
                    prev = c;
                    ++pos;
                }
            }
            state.position = pos;
            return prev;
        }
        /**
         * Skips until \n or \r occurs -- therefore the newlines get handled by the "skipWhitespace" function.
         */
        function skipCommentLine(state) {
            while (state.position < state.length) {
                var c = state.data.charCodeAt(state.position);
                if (c === 10 || c === 13) {
                    return;
                }
                ++state.position;
            }
        }
        /**
         * Skips all the whitespace - space, tab, newline, CR
         * Handles incrementing line count.
         */
        function skipWhitespace(state) {
            var prev = 10;
            while (state.position < state.length) {
                var c = state.data.charCodeAt(state.position);
                switch (c) {
                    case 9: // '\t'
                    case 32: // ' '
                        prev = c;
                        ++state.position;
                        break;
                    case 10: // \n
                        // handle \r\n
                        if (prev !== 13) {
                            ++state.currentLineNumber;
                        }
                        prev = c;
                        ++state.position;
                        break;
                    case 13: // \r
                        prev = c;
                        ++state.position;
                        ++state.currentLineNumber;
                        break;
                    default:
                        return prev;
                }
            }
            return prev;
        }
        function isData(state) {
            // here we already assume the 5th char is _ and that the length >= 5
            // d/D
            var c = state.data.charCodeAt(state.currentTokenStart);
            if (c !== 68 && c !== 100)
                return false;
            // a/A
            c = state.data.charCodeAt(state.currentTokenStart + 1);
            if (c !== 65 && c !== 97)
                return false;
            // t/t
            c = state.data.charCodeAt(state.currentTokenStart + 2);
            if (c !== 84 && c !== 116)
                return false;
            // a/A
            c = state.data.charCodeAt(state.currentTokenStart + 3);
            if (c !== 65 && c !== 97)
                return false;
            return true;
        }
        function isSave(state) {
            // here we already assume the 5th char is _ and that the length >= 5
            // s/S
            var c = state.data.charCodeAt(state.currentTokenStart);
            if (c !== 83 && c !== 115)
                return false;
            // a/A
            c = state.data.charCodeAt(state.currentTokenStart + 1);
            if (c !== 65 && c !== 97)
                return false;
            // v/V
            c = state.data.charCodeAt(state.currentTokenStart + 2);
            if (c !== 86 && c !== 118)
                return false;
            // e/E
            c = state.data.charCodeAt(state.currentTokenStart + 3);
            if (c !== 69 && c !== 101)
                return false;
            return true;
        }
        function isLoop(state) {
            // here we already assume the 5th char is _ and that the length >= 5
            if (state.currentTokenEnd - state.currentTokenStart !== 5)
                return false;
            // l/L
            var c = state.data.charCodeAt(state.currentTokenStart);
            if (c !== 76 && c !== 108)
                return false;
            // o/O
            c = state.data.charCodeAt(state.currentTokenStart + 1);
            if (c !== 79 && c !== 111)
                return false;
            // o/O
            c = state.data.charCodeAt(state.currentTokenStart + 2);
            if (c !== 79 && c !== 111)
                return false;
            // p/P
            c = state.data.charCodeAt(state.currentTokenStart + 3);
            if (c !== 80 && c !== 112)
                return false;
            return true;
        }
        /**
         * Checks if the current token shares the namespace with string at <start,end).
         */
        function isNamespace(state, start, end) {
            var i, nsLen = end - start, offset = state.currentTokenStart - start, tokenLen = state.currentTokenEnd - state.currentTokenStart;
            if (tokenLen < nsLen)
                return false;
            for (i = start; i < end; ++i) {
                if (state.data.charCodeAt(i) !== state.data.charCodeAt(i + offset))
                    return false;
            }
            if (nsLen === tokenLen)
                return true;
            if (state.data.charCodeAt(i + offset) === 46) { // .
                return true;
            }
            return false;
        }
        /**
         * Returns the index of '.' in the current token. If no '.' is present, returns currentTokenEnd.
         */
        function getNamespaceEnd(state) {
            var i;
            for (i = state.currentTokenStart; i < state.currentTokenEnd; ++i) {
                if (state.data.charCodeAt(i) === 46)
                    return i;
            }
            return i;
        }
        /**
         * Get the namespace string. endIndex is obtained by the getNamespaceEnd() function.
         */
        function getNamespace(state, endIndex) {
            return state.data.substring(state.currentTokenStart, endIndex);
        }
        /**
         * String representation of the current token.
         */
        function getTokenString(state) {
            return state.data.substring(state.currentTokenStart, state.currentTokenEnd);
        }
        /**
         * Move to the next token.
         */
        function moveNextInternal(state) {
            var prev = skipWhitespace(state);
            if (state.position >= state.length) {
                state.currentTokenType = 6 /* End */;
                return;
            }
            state.currentTokenStart = state.position;
            state.currentTokenEnd = state.position;
            state.isEscaped = false;
            var c = state.data.charCodeAt(state.position);
            switch (c) {
                case 35: // #, comment
                    skipCommentLine(state);
                    state.currentTokenType = 5 /* Comment */;
                    break;
                case 34: // ", escaped value
                case 39: // ', escaped value
                    eatEscaped(state, c);
                    state.currentTokenType = 3 /* Value */;
                    break;
                case 59: // ;, possible multiline value
                    // multiline value must start at the beginning of the line.
                    if (prev === 10 || prev === 13) { // /n or /r
                        eatMultiline(state);
                    }
                    else {
                        eatValue(state);
                    }
                    state.currentTokenType = 3 /* Value */;
                    break;
                default:
                    eatValue(state);
                    // escaped is always Value
                    if (state.isEscaped) {
                        state.currentTokenType = 3 /* Value */;
                        // _ always means column name
                    }
                    else if (state.data.charCodeAt(state.currentTokenStart) === 95) { // _
                        state.currentTokenType = 4 /* ColumnName */;
                        // 5th char needs to be _ for data_ or loop_
                    }
                    else if (state.currentTokenEnd - state.currentTokenStart >= 5 && state.data.charCodeAt(state.currentTokenStart + 4) === 95) {
                        if (isData(state))
                            state.currentTokenType = 0 /* Data */;
                        else if (isSave(state))
                            state.currentTokenType = 1 /* Save */;
                        else if (isLoop(state))
                            state.currentTokenType = 2 /* Loop */;
                        else
                            state.currentTokenType = 3 /* Value */;
                        // all other tests failed, we are at Value token.
                    }
                    else {
                        state.currentTokenType = 3 /* Value */;
                    }
                    break;
            }
        }
        /**
         * Moves to the next non-comment token.
         */
        function moveNext(state) {
            moveNextInternal(state);
            while (state.currentTokenType === 5 /* Comment */)
                moveNextInternal(state);
        }
        function createTokenizer(data) {
            return {
                data: data,
                length: data.length,
                position: 0,
                currentTokenStart: 0,
                currentTokenEnd: 0,
                currentTokenType: 6 /* End */,
                currentLineNumber: 1,
                isEscaped: false
            };
        }
        /**
         * Reads a category containing a single row.
         */
        function handleSingle(tokenizer, block) {
            var nsStart = tokenizer.currentTokenStart, nsEnd = getNamespaceEnd(tokenizer), name = getNamespace(tokenizer, nsEnd), column, columns = [], tokens = TokenIndexBuilder.create(512), tokenCount = 0, readingNames = true;
            while (readingNames) {
                if (tokenizer.currentTokenType !== 4 /* ColumnName */ || !isNamespace(tokenizer, nsStart, nsEnd)) {
                    readingNames = false;
                    break;
                }
                column = getTokenString(tokenizer);
                moveNext(tokenizer);
                if (tokenizer.currentTokenType !== 3 /* Value */) {
                    return {
                        hasError: true,
                        errorLine: tokenizer.currentLineNumber,
                        errorMessage: "Expected value."
                    };
                }
                columns[columns.length] = column;
                TokenIndexBuilder.addToken(tokens, tokenizer.currentTokenStart, tokenizer.currentTokenEnd);
                tokenCount++;
                moveNext(tokenizer);
            }
            block.addCategory(new Text.Category(block.data, name, nsStart, tokenizer.currentTokenStart, columns, tokens.tokens, tokenCount));
            return {
                hasError: false,
                errorLine: 0,
                errorMessage: ""
            };
        }
        /**
         * Reads a loop.
         */
        function handleLoop(tokenizer, block) {
            var start = tokenizer.currentTokenStart, loopLine = tokenizer.currentLineNumber;
            moveNext(tokenizer);
            var name = getNamespace(tokenizer, getNamespaceEnd(tokenizer)), columns = [], tokens = TokenIndexBuilder.create(name === "_atom_site" ? (block.data.length / 1.85) | 0 : 1024), tokenCount = 0;
            while (tokenizer.currentTokenType === 4 /* ColumnName */) {
                columns[columns.length] = getTokenString(tokenizer);
                moveNext(tokenizer);
            }
            while (tokenizer.currentTokenType === 3 /* Value */) {
                TokenIndexBuilder.addToken(tokens, tokenizer.currentTokenStart, tokenizer.currentTokenEnd);
                tokenCount++;
                moveNext(tokenizer);
            }
            if (tokenCount % columns.length !== 0) {
                return {
                    hasError: true,
                    errorLine: tokenizer.currentLineNumber,
                    errorMessage: "The number of values for loop starting at line " + loopLine + " is not a multiple of the number of columns."
                };
            }
            block.addCategory(new Text.Category(block.data, name, start, tokenizer.currentTokenStart, columns, tokens.tokens, tokenCount));
            return {
                hasError: false,
                errorLine: 0,
                errorMessage: ""
            };
        }
        /**
         * Creates an error result.
         */
        function error(line, message) {
            return CIFTools.ParserResult.error(message, line);
        }
        /**
         * Creates a data result.
         */
        function result(data) {
            return CIFTools.ParserResult.success(data);
        }
        /**
         * Parses an mmCIF file.
         *
         * @returns CifParserResult wrapper of the result.
         */
        function parseInternal(data) {
            var tokenizer = createTokenizer(data), cat, id, file = new Text.File(data), block = new Text.DataBlock(data, "default"), saveFrame = new Text.DataBlock(data, "empty"), inSaveFrame = false, blockSaveFrames;
            moveNext(tokenizer);
            while (tokenizer.currentTokenType !== 6 /* End */) {
                var token = tokenizer.currentTokenType;
                // Data block
                if (token === 0 /* Data */) {
                    if (inSaveFrame) {
                        return error(tokenizer.currentLineNumber, "Unexpected data block inside a save frame.");
                    }
                    if (block.categories.length > 0) {
                        file.dataBlocks.push(block);
                    }
                    block = new Text.DataBlock(data, data.substring(tokenizer.currentTokenStart + 5, tokenizer.currentTokenEnd));
                    moveNext(tokenizer);
                    // Save frame
                }
                else if (token === 1 /* Save */) {
                    id = data.substring(tokenizer.currentTokenStart + 5, tokenizer.currentTokenEnd);
                    if (id.length === 0) {
                        if (saveFrame.categories.length > 0) {
                            blockSaveFrames = block.additionalData["saveFrames"];
                            if (!blockSaveFrames) {
                                blockSaveFrames = [];
                                block.additionalData["saveFrames"] = blockSaveFrames;
                            }
                            blockSaveFrames[blockSaveFrames.length] = saveFrame;
                        }
                        inSaveFrame = false;
                    }
                    else {
                        if (inSaveFrame) {
                            return error(tokenizer.currentLineNumber, "Save frames cannot be nested.");
                        }
                        inSaveFrame = true;
                        saveFrame = new Text.DataBlock(data, id);
                    }
                    moveNext(tokenizer);
                    // Loop
                }
                else if (token === 2 /* Loop */) {
                    cat = handleLoop(tokenizer, inSaveFrame ? saveFrame : block);
                    if (cat.hasError) {
                        return error(cat.errorLine, cat.errorMessage);
                    }
                    // Single row
                }
                else if (token === 4 /* ColumnName */) {
                    cat = handleSingle(tokenizer, inSaveFrame ? saveFrame : block);
                    if (cat.hasError) {
                        return error(cat.errorLine, cat.errorMessage);
                    }
                    // Out of options
                }
                else {
                    return error(tokenizer.currentLineNumber, "Unexpected token. Expected data_, loop_, or data name.");
                }
            }
            // Check if the latest save frame was closed.
            if (inSaveFrame) {
                return error(tokenizer.currentLineNumber, "Unfinished save frame (`" + saveFrame.header + "`).");
            }
            if (block.categories.length > 0) {
                file.dataBlocks.push(block);
            }
            return result(file);
        }
        function parse(data) {
            return parseInternal(data);
        }
        Text.parse = parse;
    })(Text = CIFTools.Text || (CIFTools.Text = {}));
// })(CIFTools || (CIFTools = {}));
/*
 * Copyright (c) 2016 - now David Sehnal, licensed under MIT License, See LICENSE file for more info.
 */
// var CIFTools;
// (function (CIFTools) {
//     var Text;
    (function (Text) {
        "use strict";
        var StringWriter = CIFTools.Utils.StringWriter;
        var Writer = /** @class */ (function () {
            function Writer() {
                this.writer = StringWriter.create();
                this.encoded = false;
                this.dataBlockCreated = false;
            }
            Writer.prototype.startDataBlock = function (header) {
                this.dataBlockCreated = true;
                StringWriter.write(this.writer, "data_" + (header || '').replace(/[ \n\t]/g, '').toUpperCase() + "\n#\n");
            };
            Writer.prototype.writeCategory = function (category, contexts) {
                if (this.encoded) {
                    throw new Error('The writer contents have already been encoded, no more writing.');
                }
                if (!this.dataBlockCreated) {
                    throw new Error('No data block created.');
                }
                var src = !contexts || !contexts.length ? [category(void 0)] : contexts.map(function (c) { return category(c); });
                var data = src.filter(function (c) { return c && c.count > 0; });
                if (!data.length)
                    return;
                var count = data.reduce(function (a, c) { return a + (c.count === void 0 ? 1 : c.count); }, 0);
                if (!count)
                    return;
                else if (count === 1) {
                    writeCifSingleRecord(data[0], this.writer);
                }
                else {
                    writeCifLoop(data, this.writer);
                }
            };
            Writer.prototype.encode = function () {
                this.encoded = true;
            };
            Writer.prototype.flush = function (stream) {
                StringWriter.writeTo(this.writer, stream);
            };
            return Writer;
        }());
        Text.Writer = Writer;
        function isMultiline(value) {
            return !!value && value.indexOf('\n') >= 0;
        }
        function writeCifSingleRecord(category, writer) {
            var fields = category.desc.fields;
            var data = category.data;
            var width = fields.reduce(function (w, s) { return Math.max(w, s.name.length); }, 0) + category.desc.name.length + 5;
            for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {
                var f = fields_1[_i];
                StringWriter.writePadRight(writer, category.desc.name + "." + f.name, width);
                var presence = f.presence;
                var p = presence ? presence(data, 0) : 0 /* Present */;
                if (p !== 0 /* Present */) {
                    if (p === 1 /* NotSpecified */)
                        writeNotSpecified(writer);
                    else
                        writeUnknown(writer);
                }
                else {
                    var val = f.string(data, 0);
                    if (isMultiline(val)) {
                        writeMultiline(writer, val);
                        StringWriter.newline(writer);
                    }
                    else {
                        writeChecked(writer, val);
                    }
                }
                StringWriter.newline(writer);
            }
            StringWriter.write(writer, '#\n');
        }
        function writeCifLoop(categories, writer) {
            writeLine(writer, 'loop_');
            var first = categories[0];
            var fields = first.desc.fields;
            for (var _i = 0, fields_2 = fields; _i < fields_2.length; _i++) {
                var f = fields_2[_i];
                writeLine(writer, first.desc.name + "." + f.name);
            }
            for (var _a = 0, categories_1 = categories; _a < categories_1.length; _a++) {
                var category = categories_1[_a];
                var data = category.data;
                var count = category.count;
                for (var i = 0; i < count; i++) {
                    for (var _b = 0, fields_3 = fields; _b < fields_3.length; _b++) {
                        var f = fields_3[_b];
                        var presence = f.presence;
                        var p = presence ? presence(data, i) : 0 /* Present */;
                        if (p !== 0 /* Present */) {
                            if (p === 1 /* NotSpecified */)
                                writeNotSpecified(writer);
                            else
                                writeUnknown(writer);
                        }
                        else {
                            var val = f.string(data, i);
                            if (isMultiline(val)) {
                                writeMultiline(writer, val);
                                StringWriter.newline(writer);
                            }
                            else {
                                writeChecked(writer, val);
                            }
                        }
                    }
                    StringWriter.newline(writer);
                }
            }
            StringWriter.write(writer, '#\n');
        }
        function writeLine(writer, val) {
            StringWriter.write(writer, val);
            StringWriter.newline(writer);
        }
        function writeInteger(writer, val) {
            StringWriter.writeSafe(writer, '' + val + ' ');
        }
        /**
            * eg writeFloat(123.2123, 100) -- 2 decim
            */
        function writeFloat(writer, val, precisionMultiplier) {
            StringWriter.writeSafe(writer, '' + Math.round(precisionMultiplier * val) / precisionMultiplier + ' ');
        }
        /**
            * Writes '. '
            */
        function writeNotSpecified(writer) {
            StringWriter.writeSafe(writer, '. ');
        }
        /**
            * Writes '? '
            */
        function writeUnknown(writer) {
            StringWriter.writeSafe(writer, '? ');
        }
        function writeChecked(writer, val) {
            if (!val) {
                StringWriter.writeSafe(writer, '. ');
                return;
            }
            var escape = false, escapeCharStart = '\'', escapeCharEnd = '\' ';
            var hasWhitespace = false;
            var hasSingle = false;
            var hasDouble = false;
            for (var i = 0, _l = val.length - 1; i < _l; i++) {
                var c = val.charCodeAt(i);
                switch (c) {
                    case 9:
                        hasWhitespace = true;
                        break; // \t
                    case 10: // \n
                        StringWriter.writeSafe(writer, '\n;' + val);
                        StringWriter.writeSafe(writer, '\n; ');
                        return;
                    case 32:
                        hasWhitespace = true;
                        break; // ' '
                    case 34: // "
                        if (hasSingle) {
                            StringWriter.writeSafe(writer, '\n;' + val);
                            StringWriter.writeSafe(writer, '\n; ');
                            return;
                        }
                        hasDouble = true;
                        escape = true;
                        escapeCharStart = '\'';
                        escapeCharEnd = '\' ';
                        break;
                    case 39: // '
                        if (hasDouble) {
                            StringWriter.writeSafe(writer, '\n;' + val);
                            StringWriter.writeSafe(writer, '\n; ');
                            return;
                        }
                        escape = true;
                        hasSingle = true;
                        escapeCharStart = '"';
                        escapeCharEnd = '" ';
                        break;
                }
            }
            var fst = val.charCodeAt(0);
            if (!escape && (fst === 35 /* # */ || fst === 36 /* $ */ || fst === 59 /* ; */ || fst === 91 /* [ */ || fst === 93 /* ] */ || hasWhitespace)) {
                escapeCharStart = '\'';
                escapeCharEnd = '\' ';
                escape = true;
            }
            if (escape) {
                StringWriter.writeSafe(writer, escapeCharStart + val + escapeCharEnd);
            }
            else {
                StringWriter.write(writer, val);
                StringWriter.writeSafe(writer, ' ');
            }
        }
        function writeMultiline(writer, val) {
            StringWriter.writeSafe(writer, '\n;' + val);
            StringWriter.writeSafe(writer, '\n; ');
        }
        function writeToken(writer, data, start, end) {
            var escape = false, escapeCharStart = '\'', escapeCharEnd = '\' ';
            for (var i = start; i < end - 1; i++) {
                var c = data.charCodeAt(i);
                switch (c) {
                    case 10: // \n
                        StringWriter.writeSafe(writer, '\n;' + data.substring(start, end));
                        StringWriter.writeSafe(writer, '\n; ');
                        return;
                    case 34: // "
                        escape = true;
                        escapeCharStart = '\'';
                        escapeCharEnd = '\' ';
                        break;
                    case 39: // '
                        escape = true;
                        escapeCharStart = '"';
                        escapeCharEnd = '" ';
                        break;
                }
            }
            if (!escape && data.charCodeAt(start) === 59 /* ; */) {
                escapeCharStart = '\'';
                escapeCharEnd = '\' ';
                escape = true;
            }
            if (escape) {
                StringWriter.writeSafe(writer, escapeCharStart + data.substring(start, end));
                StringWriter.writeSafe(writer, escapeCharStart);
            }
            else {
                StringWriter.write(writer, data.substring(start, end));
                StringWriter.writeSafe(writer, ' ');
            }
        }
    })(Text = CIFTools.Text || (CIFTools.Text = {}));
// })(CIFTools || (CIFTools = {}));
/*
 * Copyright (c) 2016 - now David Sehnal, licensed under MIT License, See LICENSE file for more info.
 */
// var CIFTools;
// (function (CIFTools) {
    var Binary;
    (function (Binary) {
        var MessagePack;
        (function (MessagePack) {
            /*
             * Adapted from https://github.com/rcsb/mmtf-javascript
             * by Alexander Rose <alexander.rose@weirdbyte.de>, MIT License, Copyright (c) 2016
             */
            /**
             * decode all key-value pairs of a map into an object
             * @param  {Integer} length - number of key-value pairs
             * @return {Object} decoded map
             */
            function map(state, length) {
                var value = {};
                for (var i = 0; i < length; i++) {
                    var key = parse(state);
                    value[key] = parse(state);
                }
                return value;
            }
            /**
             * decode binary array
             * @param  {Integer} length - number of elements in the array
             * @return {Uint8Array} decoded array
             */
            function bin(state, length) {
                // This approach to binary parsing wastes a bit of memory to trade for speed compared to:
                //
                //   let value = buffer.subarray(offset, offset + length); //new Uint8Array(buffer.buffer, offset, length);
                // 
                // It turns out that using the view created by subarray probably uses DataView
                // in the background, which causes the element access to be several times slower
                // than creating the new byte array.
                var value = new Uint8Array(length);
                var o = state.offset;
                for (var i = 0; i < length; i++)
                    value[i] = state.buffer[i + o];
                state.offset += length;
                return value;
            }
            /**
             * decode string
             * @param  {Integer} length - number string characters
             * @return {String} decoded string
             */
            function str(state, length) {
                var value = MessagePack.utf8Read(state.buffer, state.offset, length);
                state.offset += length;
                return value;
            }
            /**
                 * decode array
                 * @param  {Integer} length - number of array elements
                 * @return {Array} decoded array
                 */
            function array(state, length) {
                var value = new Array(length);
                for (var i = 0; i < length; i++) {
                    value[i] = parse(state);
                }
                return value;
            }
            /**
             * recursively parse the MessagePack data
             * @return {Object|Array|String|Number|Boolean|null} decoded MessagePack data
             */
            function parse(state) {
                var type = state.buffer[state.offset];
                var value, length;
                // Positive FixInt
                if ((type & 0x80) === 0x00) {
                    state.offset++;
                    return type;
                }
                // FixMap
                if ((type & 0xf0) === 0x80) {
                    length = type & 0x0f;
                    state.offset++;
                    return map(state, length);
                }
                // FixArray
                if ((type & 0xf0) === 0x90) {
                    length = type & 0x0f;
                    state.offset++;
                    return array(state, length);
                }
                // FixStr
                if ((type & 0xe0) === 0xa0) {
                    length = type & 0x1f;
                    state.offset++;
                    return str(state, length);
                }
                // Negative FixInt
                if ((type & 0xe0) === 0xe0) {
                    value = state.dataView.getInt8(state.offset);
                    state.offset++;
                    return value;
                }
                switch (type) {
                    // nil
                    case 0xc0:
                        state.offset++;
                        return null;
                    // false
                    case 0xc2:
                        state.offset++;
                        return false;
                    // true
                    case 0xc3:
                        state.offset++;
                        return true;
                    // bin 8
                    case 0xc4:
                        length = state.dataView.getUint8(state.offset + 1);
                        state.offset += 2;
                        return bin(state, length);
                    // bin 16
                    case 0xc5:
                        length = state.dataView.getUint16(state.offset + 1);
                        state.offset += 3;
                        return bin(state, length);
                    // bin 32
                    case 0xc6:
                        length = state.dataView.getUint32(state.offset + 1);
                        state.offset += 5;
                        return bin(state, length);
                    // float 32
                    case 0xca:
                        value = state.dataView.getFloat32(state.offset + 1);
                        state.offset += 5;
                        return value;
                    // float 64
                    case 0xcb:
                        value = state.dataView.getFloat64(state.offset + 1);
                        state.offset += 9;
                        return value;
                    // uint8
                    case 0xcc:
                        value = state.buffer[state.offset + 1];
                        state.offset += 2;
                        return value;
                    // uint 16
                    case 0xcd:
                        value = state.dataView.getUint16(state.offset + 1);
                        state.offset += 3;
                        return value;
                    // uint 32
                    case 0xce:
                        value = state.dataView.getUint32(state.offset + 1);
                        state.offset += 5;
                        return value;
                    // int 8
                    case 0xd0:
                        value = state.dataView.getInt8(state.offset + 1);
                        state.offset += 2;
                        return value;
                    // int 16
                    case 0xd1:
                        value = state.dataView.getInt16(state.offset + 1);
                        state.offset += 3;
                        return value;
                    // int 32
                    case 0xd2:
                        value = state.dataView.getInt32(state.offset + 1);
                        state.offset += 5;
                        return value;
                    // str 8
                    case 0xd9:
                        length = state.dataView.getUint8(state.offset + 1);
                        state.offset += 2;
                        return str(state, length);
                    // str 16
                    case 0xda:
                        length = state.dataView.getUint16(state.offset + 1);
                        state.offset += 3;
                        return str(state, length);
                    // str 32
                    case 0xdb:
                        length = state.dataView.getUint32(state.offset + 1);
                        state.offset += 5;
                        return str(state, length);
                    // array 16
                    case 0xdc:
                        length = state.dataView.getUint16(state.offset + 1);
                        state.offset += 3;
                        return array(state, length);
                    // array 32
                    case 0xdd:
                        length = state.dataView.getUint32(state.offset + 1);
                        state.offset += 5;
                        return array(state, length);
                    // map 16:
                    case 0xde:
                        length = state.dataView.getUint16(state.offset + 1);
                        state.offset += 3;
                        return map(state, length);
                    // map 32
                    case 0xdf:
                        length = state.dataView.getUint32(state.offset + 1);
                        state.offset += 5;
                        return map(state, length);
                }
                throw new Error("Unknown type 0x" + type.toString(16));
            }
            function decode(buffer) {
                return parse({
                    buffer: buffer,
                    offset: 0,
                    dataView: new DataView(buffer.buffer)
                });
            }
            MessagePack.decode = decode;
        })(MessagePack = Binary.MessagePack || (Binary.MessagePack = {}));
    })(Binary = CIFTools.Binary || (CIFTools.Binary = {}));
// })(CIFTools || (CIFTools = {}));
/*
 * Copyright (c) 2016 - now David Sehnal, licensed under MIT License, See LICENSE file for more info.
 */
// var CIFTools;
// (function (CIFTools) {
//     var Binary;
    (function (Binary) {
        var MessagePack;
        (function (MessagePack) {
            /*
             * Adapted from https://github.com/rcsb/mmtf-javascript
             * by Alexander Rose <alexander.rose@weirdbyte.de>, MIT License, Copyright (c) 2016
             */
            function encode(value) {
                var buffer = new ArrayBuffer(encodedSize(value));
                var view = new DataView(buffer);
                var bytes = new Uint8Array(buffer);
                encodeInternal(value, view, bytes, 0);
                return bytes;
            }
            MessagePack.encode = encode;
            function encodedSize(value) {
                var type = typeof value;
                // Raw Bytes
                if (type === "string") {
                    var length_1 = MessagePack.utf8ByteCount(value);
                    if (length_1 < 0x20) {
                        return 1 + length_1;
                    }
                    if (length_1 < 0x100) {
                        return 2 + length_1;
                    }
                    if (length_1 < 0x10000) {
                        return 3 + length_1;
                    }
                    if (length_1 < 0x100000000) {
                        return 5 + length_1;
                    }
                }
                if (value instanceof Uint8Array) {
                    var length_2 = value.byteLength;
                    if (length_2 < 0x100) {
                        return 2 + length_2;
                    }
                    if (length_2 < 0x10000) {
                        return 3 + length_2;
                    }
                    if (length_2 < 0x100000000) {
                        return 5 + length_2;
                    }
                }
                if (type === "number") {
                    // Floating Point
                    // double
                    if (Math.floor(value) !== value)
                        return 9;
                    // Integers
                    if (value >= 0) {
                        // positive fixnum
                        if (value < 0x80)
                            return 1;
                        // uint 8
                        if (value < 0x100)
                            return 2;
                        // uint 16
                        if (value < 0x10000)
                            return 3;
                        // uint 32
                        if (value < 0x100000000)
                            return 5;
                        throw new Error("Number too big 0x" + value.toString(16));
                    }
                    // negative fixnum
                    if (value >= -0x20)
                        return 1;
                    // int 8
                    if (value >= -0x80)
                        return 2;
                    // int 16
                    if (value >= -0x8000)
                        return 3;
                    // int 32
                    if (value >= -0x80000000)
                        return 5;
                    throw new Error("Number too small -0x" + value.toString(16).substr(1));
                }
                // Boolean, null
                if (type === "boolean" || value === null || value === void 0)
                    return 1;
                // Container Types
                if (type === "object") {
                    var length_3, size = 0;
                    if (Array.isArray(value)) {
                        length_3 = value.length;
                        for (var i = 0; i < length_3; i++) {
                            size += encodedSize(value[i]);
                        }
                    }
                    else {
                        var keys = Object.keys(value);
                        length_3 = keys.length;
                        for (var i = 0; i < length_3; i++) {
                            var key = keys[i];
                            size += encodedSize(key) + encodedSize(value[key]);
                        }
                    }
                    if (length_3 < 0x10) {
                        return 1 + size;
                    }
                    if (length_3 < 0x10000) {
                        return 3 + size;
                    }
                    if (length_3 < 0x100000000) {
                        return 5 + size;
                    }
                    throw new Error("Array or object too long 0x" + length_3.toString(16));
                }
                throw new Error("Unknown type " + type);
            }
            function encodeInternal(value, view, bytes, offset) {
                var type = typeof value;
                // Strings Bytes
                if (type === "string") {
                    var length_4 = MessagePack.utf8ByteCount(value);
                    // fix str
                    if (length_4 < 0x20) {
                        view.setUint8(offset, length_4 | 0xa0);
                        MessagePack.utf8Write(bytes, offset + 1, value);
                        return 1 + length_4;
                    }
                    // str 8
                    if (length_4 < 0x100) {
                        view.setUint8(offset, 0xd9);
                        view.setUint8(offset + 1, length_4);
                        MessagePack.utf8Write(bytes, offset + 2, value);
                        return 2 + length_4;
                    }
                    // str 16
                    if (length_4 < 0x10000) {
                        view.setUint8(offset, 0xda);
                        view.setUint16(offset + 1, length_4);
                        MessagePack.utf8Write(bytes, offset + 3, value);
                        return 3 + length_4;
                    }
                    // str 32
                    if (length_4 < 0x100000000) {
                        view.setUint8(offset, 0xdb);
                        view.setUint32(offset + 1, length_4);
                        MessagePack.utf8Write(bytes, offset + 5, value);
                        return 5 + length_4;
                    }
                }
                if (value instanceof Uint8Array) {
                    var length_5 = value.byteLength;
                    var bytes_1 = new Uint8Array(view.buffer);
                    // bin 8
                    if (length_5 < 0x100) {
                        view.setUint8(offset, 0xc4);
                        view.setUint8(offset + 1, length_5);
                        bytes_1.set(value, offset + 2);
                        return 2 + length_5;
                    }
                    // bin 16
                    if (length_5 < 0x10000) {
                        view.setUint8(offset, 0xc5);
                        view.setUint16(offset + 1, length_5);
                        bytes_1.set(value, offset + 3);
                        return 3 + length_5;
                    }
                    // bin 32
                    if (length_5 < 0x100000000) {
                        view.setUint8(offset, 0xc6);
                        view.setUint32(offset + 1, length_5);
                        bytes_1.set(value, offset + 5);
                        return 5 + length_5;
                    }
                }
                if (type === "number") {
                    if (!isFinite(value)) {
                        throw new Error("Number not finite: " + value);
                    }
                    // Floating point
                    if (Math.floor(value) !== value) {
                        view.setUint8(offset, 0xcb);
                        view.setFloat64(offset + 1, value);
                        return 9;
                    }
                    // Integers
                    if (value >= 0) {
                        // positive fixnum
                        if (value < 0x80) {
                            view.setUint8(offset, value);
                            return 1;
                        }
                        // uint 8
                        if (value < 0x100) {
                            view.setUint8(offset, 0xcc);
                            view.setUint8(offset + 1, value);
                            return 2;
                        }
                        // uint 16
                        if (value < 0x10000) {
                            view.setUint8(offset, 0xcd);
                            view.setUint16(offset + 1, value);
                            return 3;
                        }
                        // uint 32
                        if (value < 0x100000000) {
                            view.setUint8(offset, 0xce);
                            view.setUint32(offset + 1, value);
                            return 5;
                        }
                        throw new Error("Number too big 0x" + value.toString(16));
                    }
                    // negative fixnum
                    if (value >= -0x20) {
                        view.setInt8(offset, value);
                        return 1;
                    }
                    // int 8
                    if (value >= -0x80) {
                        view.setUint8(offset, 0xd0);
                        view.setInt8(offset + 1, value);
                        return 2;
                    }
                    // int 16
                    if (value >= -0x8000) {
                        view.setUint8(offset, 0xd1);
                        view.setInt16(offset + 1, value);
                        return 3;
                    }
                    // int 32
                    if (value >= -0x80000000) {
                        view.setUint8(offset, 0xd2);
                        view.setInt32(offset + 1, value);
                        return 5;
                    }
                    throw new Error("Number too small -0x" + (-value).toString(16).substr(1));
                }
                // null
                if (value === null || value === undefined) {
                    view.setUint8(offset, 0xc0);
                    return 1;
                }
                // Boolean
                if (type === "boolean") {
                    view.setUint8(offset, value ? 0xc3 : 0xc2);
                    return 1;
                }
                // Container Types
                if (type === "object") {
                    var length_6, size = 0;
                    var isArray = Array.isArray(value);
                    var keys = void 0;
                    if (isArray) {
                        length_6 = value.length;
                    }
                    else {
                        keys = Object.keys(value);
                        length_6 = keys.length;
                    }
                    if (length_6 < 0x10) {
                        view.setUint8(offset, length_6 | (isArray ? 0x90 : 0x80));
                        size = 1;
                    }
                    else if (length_6 < 0x10000) {
                        view.setUint8(offset, isArray ? 0xdc : 0xde);
                        view.setUint16(offset + 1, length_6);
                        size = 3;
                    }
                    else if (length_6 < 0x100000000) {
                        view.setUint8(offset, isArray ? 0xdd : 0xdf);
                        view.setUint32(offset + 1, length_6);
                        size = 5;
                    }
                    if (isArray) {
                        for (var i = 0; i < length_6; i++) {
                            size += encodeInternal(value[i], view, bytes, offset + size);
                        }
                    }
                    else {
                        for (var _i = 0, _a = keys; _i < _a.length; _i++) {
                            var key = _a[_i];
                            size += encodeInternal(key, view, bytes, offset + size);
                            size += encodeInternal(value[key], view, bytes, offset + size);
                        }
                    }
                    return size;
                }
                throw new Error("Unknown type " + type);
            }
        })(MessagePack = Binary.MessagePack || (Binary.MessagePack = {}));
    })(Binary = CIFTools.Binary || (CIFTools.Binary = {}));
// })(CIFTools || (CIFTools = {}));
/*
 * Copyright (c) 2016 - now David Sehnal, licensed under MIT License, See LICENSE file for more info.
 */
// var CIFTools;
// (function (CIFTools) {
//     var Binary;
    (function (Binary) {
        var MessagePack;
        (function (MessagePack) {
            /*
             * Adapted from https://github.com/rcsb/mmtf-javascript
             * by Alexander Rose <alexander.rose@weirdbyte.de>, MIT License, Copyright (c) 2016
             */
            function utf8Write(data, offset, str) {
                var byteLength = data.byteLength;
                for (var i = 0, l = str.length; i < l; i++) {
                    var codePoint = str.charCodeAt(i);
                    // One byte of UTF-8
                    if (codePoint < 0x80) {
                        data[offset++] = codePoint >>> 0 & 0x7f | 0x00;
                        continue;
                    }
                    // Two bytes of UTF-8
                    if (codePoint < 0x800) {
                        data[offset++] = codePoint >>> 6 & 0x1f | 0xc0;
                        data[offset++] = codePoint >>> 0 & 0x3f | 0x80;
                        continue;
                    }
                    // Three bytes of UTF-8.
                    if (codePoint < 0x10000) {
                        data[offset++] = codePoint >>> 12 & 0x0f | 0xe0;
                        data[offset++] = codePoint >>> 6 & 0x3f | 0x80;
                        data[offset++] = codePoint >>> 0 & 0x3f | 0x80;
                        continue;
                    }
                    // Four bytes of UTF-8
                    if (codePoint < 0x110000) {
                        data[offset++] = codePoint >>> 18 & 0x07 | 0xf0;
                        data[offset++] = codePoint >>> 12 & 0x3f | 0x80;
                        data[offset++] = codePoint >>> 6 & 0x3f | 0x80;
                        data[offset++] = codePoint >>> 0 & 0x3f | 0x80;
                        continue;
                    }
                    throw new Error("bad codepoint " + codePoint);
                }
            }
            MessagePack.utf8Write = utf8Write;
            var __chars = function () {
                var data = [];
                for (var i = 0; i < 1024; i++)
                    data[i] = String.fromCharCode(i);
                return data;
            }();
            function throwError(err) {
                throw new Error(err);
            }
            function utf8Read(data, offset, length) {
                var chars = __chars;
                var str = void 0, chunk = [], chunkSize = 512, chunkOffset = 0;
                for (var i = offset, end = offset + length; i < end; i++) {
                    var byte = data[i];
                    // One byte character
                    if ((byte & 0x80) === 0x00) {
                        chunk[chunkOffset++] = chars[byte];
                    }
                    // Two byte character
                    else if ((byte & 0xe0) === 0xc0) {
                        chunk[chunkOffset++] = chars[((byte & 0x0f) << 6) | (data[++i] & 0x3f)];
                    }
                    // Three byte character
                    else if ((byte & 0xf0) === 0xe0) {
                        chunk[chunkOffset++] = String.fromCharCode(((byte & 0x0f) << 12) |
                            ((data[++i] & 0x3f) << 6) |
                            ((data[++i] & 0x3f) << 0));
                    }
                    // Four byte character
                    else if ((byte & 0xf8) === 0xf0) {
                        chunk[chunkOffset++] = String.fromCharCode(((byte & 0x07) << 18) |
                            ((data[++i] & 0x3f) << 12) |
                            ((data[++i] & 0x3f) << 6) |
                            ((data[++i] & 0x3f) << 0));
                    }
                    else
                        throwError("Invalid byte " + byte.toString(16));
                    if (chunkOffset === chunkSize) {
                        str = str || [];
                        str[str.length] = chunk.join('');
                        chunkOffset = 0;
                    }
                }
                if (!str)
                    return chunk.slice(0, chunkOffset).join('');
                if (chunkOffset > 0) {
                    str[str.length] = chunk.slice(0, chunkOffset).join('');
                }
                return str.join('');
            }
            MessagePack.utf8Read = utf8Read;
            function utf8ByteCount(str) {
                var count = 0;
                for (var i = 0, l = str.length; i < l; i++) {
                    var codePoint = str.charCodeAt(i);
                    if (codePoint < 0x80) {
                        count += 1;
                        continue;
                    }
                    if (codePoint < 0x800) {
                        count += 2;
                        continue;
                    }
                    if (codePoint < 0x10000) {
                        count += 3;
                        continue;
                    }
                    if (codePoint < 0x110000) {
                        count += 4;
                        continue;
                    }
                    throwError("bad codepoint " + codePoint);
                }
                return count;
            }
            MessagePack.utf8ByteCount = utf8ByteCount;
        })(MessagePack = Binary.MessagePack || (Binary.MessagePack = {}));
    })(Binary = CIFTools.Binary || (CIFTools.Binary = {}));
// })(CIFTools || (CIFTools = {}));
/*
 * Copyright (c) 2016 - now David Sehnal, licensed under MIT License, See LICENSE file for more info.
 */
// var CIFTools;
// (function (CIFTools) {
//     var Binary;
    (function (Binary) {
        "use strict";
        /**
         * Fixed point, delta, RLE, integer packing adopted from https://github.com/rcsb/mmtf-javascript/
         * by Alexander Rose <alexander.rose@weirdbyte.de>, MIT License, Copyright (c) 2016
         */
        function decode(data) {
            var current = data.data;
            for (var i = data.encoding.length - 1; i >= 0; i--) {
                current = Decoder.decodeStep(current, data.encoding[i]);
            }
            return current;
        }
        Binary.decode = decode;
        var Decoder;
        (function (Decoder) {
            function decodeStep(data, encoding) {
                switch (encoding.kind) {
                    case 'ByteArray': {
                        switch (encoding.type) {
                            case 4 /* Uint8 */: return data;
                            case 1 /* Int8 */: return int8(data);
                            case 2 /* Int16 */: return int16(data);
                            case 5 /* Uint16 */: return uint16(data);
                            case 3 /* Int32 */: return int32(data);
                            case 6 /* Uint32 */: return uint32(data);
                            case 32 /* Float32 */: return float32(data);
                            case 33 /* Float64 */: return float64(data);
                            default: throw new Error('Unsupported ByteArray type.');
                        }
                    }
                    case 'FixedPoint': return fixedPoint(data, encoding);
                    case 'IntervalQuantization': return intervalQuantization(data, encoding);
                    case 'RunLength': return runLength(data, encoding);
                    case 'Delta': return delta(data, encoding);
                    case 'IntegerPacking': return integerPacking(data, encoding);
                    case 'StringArray': return stringArray(data, encoding);
                }
            }
            Decoder.decodeStep = decodeStep;
            function getIntArray(type, size) {
                switch (type) {
                    case 1 /* Int8 */: return new Int8Array(size);
                    case 2 /* Int16 */: return new Int16Array(size);
                    case 3 /* Int32 */: return new Int32Array(size);
                    case 4 /* Uint8 */: return new Uint8Array(size);
                    case 5 /* Uint16 */: return new Uint16Array(size);
                    case 6 /* Uint32 */: return new Uint32Array(size);
                    default: throw new Error('Unsupported integer data type.');
                }
            }
            function getFloatArray(type, size) {
                switch (type) {
                    case 32 /* Float32 */: return new Float32Array(size);
                    case 33 /* Float64 */: return new Float64Array(size);
                    default: throw new Error('Unsupported floating data type.');
                }
            }
            /* http://stackoverflow.com/questions/7869752/javascript-typed-arrays-and-endianness */
            var isLittleEndian = (function () {
                var arrayBuffer = new ArrayBuffer(2);
                var uint8Array = new Uint8Array(arrayBuffer);
                var uint16array = new Uint16Array(arrayBuffer);
                uint8Array[0] = 0xAA;
                uint8Array[1] = 0xBB;
                if (uint16array[0] === 0xBBAA)
                    return true;
                return false;
            })();
            function int8(data) { return new Int8Array(data.buffer, data.byteOffset); }
            function flipByteOrder(data, bytes) {
                var buffer = new ArrayBuffer(data.length);
                var ret = new Uint8Array(buffer);
                for (var i = 0, n = data.length; i < n; i += bytes) {
                    for (var j = 0; j < bytes; j++) {
                        ret[i + bytes - j - 1] = data[i + j];
                    }
                }
                return buffer;
            }
            function view(data, byteSize, c) {
                if (isLittleEndian)
                    return new c(data.buffer);
                return new c(flipByteOrder(data, byteSize));
            }
            function int16(data) { return view(data, 2, Int16Array); }
            function uint16(data) { return view(data, 2, Uint16Array); }
            function int32(data) { return view(data, 4, Int32Array); }
            function uint32(data) { return view(data, 4, Uint32Array); }
            function float32(data) { return view(data, 4, Float32Array); }
            function float64(data) { return view(data, 8, Float64Array); }
            function fixedPoint(data, encoding) {
                var n = data.length;
                var output = getFloatArray(encoding.srcType, n);
                var f = 1 / encoding.factor;
                for (var i = 0; i < n; i++) {
                    output[i] = f * data[i];
                }
                return output;
            }
            function intervalQuantization(data, encoding) {
                var n = data.length;
                var output = getFloatArray(encoding.srcType, n);
                var delta = (encoding.max - encoding.min) / (encoding.numSteps - 1);
                var min = encoding.min;
                for (var i = 0; i < n; i++) {
                    output[i] = min + delta * data[i];
                }
                return output;
            }
            function runLength(data, encoding) {
                var output = getIntArray(encoding.srcType, encoding.srcSize);
                var dataOffset = 0;
                for (var i = 0, il = data.length; i < il; i += 2) {
                    var value = data[i]; // value to be repeated
                    var length_7 = data[i + 1]; // number of repeats
                    for (var j = 0; j < length_7; ++j) {
                        output[dataOffset++] = value;
                    }
                }
                return output;
            }
            function delta(data, encoding) {
                var n = data.length;
                var output = getIntArray(encoding.srcType, n);
                if (!n)
                    return output;
                output[0] = data[0] + (encoding.origin | 0);
                for (var i = 1; i < n; ++i) {
                    output[i] = data[i] + output[i - 1];
                }
                return output;
            }
            function integerPackingSigned(data, encoding) {
                var upperLimit = encoding.byteCount === 1 ? 0x7F : 0x7FFF;
                var lowerLimit = -upperLimit - 1;
                var n = data.length;
                var output = new Int32Array(encoding.srcSize);
                var i = 0;
                var j = 0;
                while (i < n) {
                    var value = 0, t = data[i];
                    while (t === upperLimit || t === lowerLimit) {
                        value += t;
                        i++;
                        t = data[i];
                    }
                    value += t;
                    output[j] = value;
                    i++;
                    j++;
                }
                return output;
            }
            function integerPackingUnsigned(data, encoding) {
                var upperLimit = encoding.byteCount === 1 ? 0xFF : 0xFFFF;
                var n = data.length;
                var output = new Int32Array(encoding.srcSize);
                var i = 0;
                var j = 0;
                while (i < n) {
                    var value = 0, t = data[i];
                    while (t === upperLimit) {
                        value += t;
                        i++;
                        t = data[i];
                    }
                    value += t;
                    output[j] = value;
                    i++;
                    j++;
                }
                return output;
            }
            function integerPacking(data, encoding) {
                return encoding.isUnsigned ? integerPackingUnsigned(data, encoding) : integerPackingSigned(data, encoding);
            }
            function stringArray(data, encoding) {
                var str = encoding.stringData;
                var offsets = decode({ encoding: encoding.offsetEncoding, data: encoding.offsets });
                var indices = decode({ encoding: encoding.dataEncoding, data: data });
                var cache = Object.create(null);
                var result = new Array(indices.length);
                var offset = 0;
                for (var _i = 0, indices_1 = indices; _i < indices_1.length; _i++) {
                    var i = indices_1[_i];
                    if (i < 0) {
                        result[offset++] = null;
                        continue;
                    }
                    var v = cache[i];
                    if (v === void 0) {
                        v = str.substring(offsets[i], offsets[i + 1]);
                        cache[i] = v;
                    }
                    result[offset++] = v;
                }
                return result;
            }
        })(Decoder || (Decoder = {}));
    })(Binary = CIFTools.Binary || (CIFTools.Binary = {}));
// })(CIFTools || (CIFTools = {}));
/*
 * Copyright (c) 2016 - now David Sehnal, licensed under MIT License, See LICENSE file for more info.
 */
// var CIFTools;
// (function (CIFTools) {
//     var Binary;
    (function (Binary) {
        "use strict";
        var File = /** @class */ (function () {
            function File(data) {
                this.dataBlocks = data.dataBlocks.map(function (b) { return new DataBlock(b); });
            }
            File.prototype.toJSON = function () {
                return this.dataBlocks.map(function (b) { return b.toJSON(); });
            };
            return File;
        }());
        Binary.File = File;
        var DataBlock = /** @class */ (function () {
            function DataBlock(data) {
                this.additionalData = {};
                this.header = data.header;
                this.categoryList = data.categories.map(function (c) { return new Category(c); });
                this.categoryMap = new Map();
                for (var _i = 0, _a = this.categoryList; _i < _a.length; _i++) {
                    var c = _a[_i];
                    this.categoryMap.set(c.name, c);
                }
            }
            Object.defineProperty(DataBlock.prototype, "categories", {
                get: function () { return this.categoryList; },
                enumerable: true,
                configurable: true
            });
            DataBlock.prototype.getCategory = function (name) { return this.categoryMap.get(name); };
            DataBlock.prototype.toJSON = function () {
                return {
                    id: this.header,
                    categories: this.categoryList.map(function (c) { return c.toJSON(); }),
                    additionalData: this.additionalData
                };
            };
            return DataBlock;
        }());
        Binary.DataBlock = DataBlock;
        var Category = /** @class */ (function () {
            function Category(data) {
                this.name = data.name;
                this.columnCount = data.columns.length;
                this.rowCount = data.rowCount;
                this.columnNameList = [];
                this.encodedColumns = new Map();
                for (var _i = 0, _a = data.columns; _i < _a.length; _i++) {
                    var c = _a[_i];
                    this.encodedColumns.set(c.name, c);
                    this.columnNameList.push(c.name);
                }
            }
            Object.defineProperty(Category.prototype, "columnNames", {
                get: function () { return this.columnNameList; },
                enumerable: true,
                configurable: true
            });
            Category.prototype.getColumn = function (name) {
                var w = this.encodedColumns.get(name);
                if (w)
                    return wrapColumn(w);
                return CIFTools.UndefinedColumn;
            };
            Category.prototype.toJSON = function () {
                var _this = this;
                var rows = [];
                var columns = this.columnNameList.map(function (name) { return ({ name: name, column: _this.getColumn(name) }); });
                for (var i = 0; i < this.rowCount; i++) {
                    var item = {};
                    for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
                        var c = columns_1[_i];
                        var d = c.column.getValuePresence(i);
                        if (d === 0 /* Present */)
                            item[c.name] = c.column.getString(i);
                        else if (d === 1 /* NotSpecified */)
                            item[c.name] = '.';
                        else
                            item[c.name] = '?';
                    }
                    rows[i] = item;
                }
                return { name: this.name, columns: this.columnNames, rows: rows };
            };
            return Category;
        }());
        Binary.Category = Category;
        function wrapColumn(column) {
            if (!column.data.data)
                return CIFTools.UndefinedColumn;
            var data = Binary.decode(column.data);
            var mask = void 0;
            if (column.mask)
                mask = Binary.decode(column.mask);
            if (data.buffer && data.byteLength && data.BYTES_PER_ELEMENT) {
                return mask ? new MaskedNumericColumn(data, mask) : new NumericColumn(data);
            }
            return mask ? new MaskedStringColumn(data, mask) : new StringColumn(data);
        }
        var fastParseInt = CIFTools.Utils.FastNumberParsers.parseInt;
        var fastParseFloat = CIFTools.Utils.FastNumberParsers.parseFloat;
        var NumericColumn = /** @class */ (function () {
            function NumericColumn(data) {
                this.data = data;
                this.isDefined = true;
            }
            NumericColumn.prototype.getString = function (row) { return "" + this.data[row]; };
            NumericColumn.prototype.getInteger = function (row) { return this.data[row] | 0; };
            NumericColumn.prototype.getFloat = function (row) { return 1.0 * this.data[row]; };
            NumericColumn.prototype.stringEquals = function (row, value) { return this.data[row] === fastParseFloat(value, 0, value.length); };
            NumericColumn.prototype.areValuesEqual = function (rowA, rowB) { return this.data[rowA] === this.data[rowB]; };
            NumericColumn.prototype.getValuePresence = function (row) { return 0 /* Present */; };
            return NumericColumn;
        }());
        var MaskedNumericColumn = /** @class */ (function () {
            function MaskedNumericColumn(data, mask) {
                this.data = data;
                this.mask = mask;
                this.isDefined = true;
            }
            MaskedNumericColumn.prototype.getString = function (row) { return this.mask[row] === 0 /* Present */ ? "" + this.data[row] : null; };
            MaskedNumericColumn.prototype.getInteger = function (row) { return this.mask[row] === 0 /* Present */ ? this.data[row] : 0; };
            MaskedNumericColumn.prototype.getFloat = function (row) { return this.mask[row] === 0 /* Present */ ? this.data[row] : 0; };
            MaskedNumericColumn.prototype.stringEquals = function (row, value) { return this.mask[row] === 0 /* Present */ ? this.data[row] === fastParseFloat(value, 0, value.length) : value === null || value === void 0; };
            MaskedNumericColumn.prototype.areValuesEqual = function (rowA, rowB) { return this.data[rowA] === this.data[rowB]; };
            MaskedNumericColumn.prototype.getValuePresence = function (row) { return this.mask[row]; };
            return MaskedNumericColumn;
        }());
        var StringColumn = /** @class */ (function () {
            function StringColumn(data) {
                this.data = data;
                this.isDefined = true;
            }
            StringColumn.prototype.getString = function (row) { return this.data[row]; };
            StringColumn.prototype.getInteger = function (row) { var v = this.data[row]; return fastParseInt(v, 0, v.length); };
            StringColumn.prototype.getFloat = function (row) { var v = this.data[row]; return fastParseFloat(v, 0, v.length); };
            StringColumn.prototype.stringEquals = function (row, value) { return this.data[row] === value; };
            StringColumn.prototype.areValuesEqual = function (rowA, rowB) { return this.data[rowA] === this.data[rowB]; };
            StringColumn.prototype.getValuePresence = function (row) { return 0 /* Present */; };
            return StringColumn;
        }());
        var MaskedStringColumn = /** @class */ (function () {
            function MaskedStringColumn(data, mask) {
                this.data = data;
                this.mask = mask;
                this.isDefined = true;
            }
            MaskedStringColumn.prototype.getString = function (row) { return this.mask[row] === 0 /* Present */ ? this.data[row] : null; };
            MaskedStringColumn.prototype.getInteger = function (row) { if (this.mask[row] !== 0 /* Present */)
                return 0; var v = this.data[row]; return fastParseInt(v || '', 0, (v || '').length); };
            MaskedStringColumn.prototype.getFloat = function (row) { if (this.mask[row] !== 0 /* Present */)
                return 0; var v = this.data[row]; return fastParseFloat(v || '', 0, (v || '').length); };
            MaskedStringColumn.prototype.stringEquals = function (row, value) { return this.data[row] === value; };
            MaskedStringColumn.prototype.areValuesEqual = function (rowA, rowB) { return this.data[rowA] === this.data[rowB]; };
            MaskedStringColumn.prototype.getValuePresence = function (row) { return this.mask[row]; };
            return MaskedStringColumn;
        }());
    })(Binary = CIFTools.Binary || (CIFTools.Binary = {}));
// })(CIFTools || (CIFTools = {}));
/*
 * Copyright (c) 2016 - now David Sehnal, licensed under MIT License, See LICENSE file for more info.
 */
// var CIFTools;
// (function (CIFTools) {
//     var Binary;
    (function (Binary) {
        "use strict";
        /**
         * Fixed point, delta, RLE, integer packing adopted from https://github.com/rcsb/mmtf-javascript/
         * by Alexander Rose <alexander.rose@weirdbyte.de>, MIT License, Copyright (c) 2016
         */
        var Encoder = /** @class */ (function () {
            function Encoder(providers) {
                this.providers = providers;
            }
            Encoder.prototype.and = function (f) {
                return new Encoder(this.providers.concat([f]));
            };
            Encoder.prototype.encode = function (data) {
                var encoding = [];
                for (var _i = 0, _a = this.providers; _i < _a.length; _i++) {
                    var p = _a[_i];
                    var t = p(data);
                    if (!t.encodings.length) {
                        throw new Error('Encodings must be non-empty.');
                    }
                    data = t.data;
                    for (var _b = 0, _c = t.encodings; _b < _c.length; _b++) {
                        var e = _c[_b];
                        encoding.push(e);
                    }
                }
                if (!(data instanceof Uint8Array)) {
                    throw new Error('The encoding must result in a Uint8Array. Fix your encoding chain.');
                }
                return {
                    encoding: encoding,
                    data: data
                };
            };
            return Encoder;
        }());
        Binary.Encoder = Encoder;
        (function (Encoder) {
            var _a, _b;
            function by(f) {
                return new Encoder([f]);
            }
            Encoder.by = by;
            function uint8(data) {
                return {
                    encodings: [{ kind: 'ByteArray', type: 4 /* Uint8 */ }],
                    data: data
                };
            }
            function int8(data) {
                return {
                    encodings: [{ kind: 'ByteArray', type: 1 /* Int8 */ }],
                    data: new Uint8Array(data.buffer, data.byteOffset)
                };
            }
            var writers = (_a = {},
                _a[2 /* Int16 */] = function (v, i, a) { v.setInt16(2 * i, a, true); },
                _a[5 /* Uint16 */] = function (v, i, a) { v.setUint16(2 * i, a, true); },
                _a[3 /* Int32 */] = function (v, i, a) { v.setInt32(4 * i, a, true); },
                _a[6 /* Uint32 */] = function (v, i, a) { v.setUint32(4 * i, a, true); },
                _a[32 /* Float32 */] = function (v, i, a) { v.setFloat32(4 * i, a, true); },
                _a[33 /* Float64 */] = function (v, i, a) { v.setFloat64(8 * i, a, true); },
                _a);
            var byteSizes = (_b = {},
                _b[2 /* Int16 */] = 2,
                _b[5 /* Uint16 */] = 2,
                _b[3 /* Int32 */] = 4,
                _b[6 /* Uint32 */] = 4,
                _b[32 /* Float32 */] = 4,
                _b[33 /* Float64 */] = 8,
                _b);
            function byteArray(data) {
                var type = Binary.Encoding.getDataType(data);
                if (type === 1 /* Int8 */)
                    return int8(data);
                else if (type === 4 /* Uint8 */)
                    return uint8(data);
                var result = new Uint8Array(data.length * byteSizes[type]);
                var w = writers[type];
                var view = new DataView(result.buffer);
                for (var i = 0, n = data.length; i < n; i++) {
                    w(view, i, data[i]);
                }
                return {
                    encodings: [{ kind: 'ByteArray', type: type }],
                    data: result
                };
            }
            Encoder.byteArray = byteArray;
            function _fixedPoint(data, factor) {
                var srcType = Binary.Encoding.getDataType(data);
                var result = new Int32Array(data.length);
                for (var i = 0, n = data.length; i < n; i++) {
                    result[i] = Math.round(data[i] * factor);
                }
                return {
                    encodings: [{ kind: 'FixedPoint', factor: factor, srcType: srcType }],
                    data: result
                };
            }
            function fixedPoint(factor) { return function (data) { return _fixedPoint(data, factor); }; }
            Encoder.fixedPoint = fixedPoint;
            function _intervalQuantizaiton(data, min, max, numSteps, arrayType) {
                var srcType = Binary.Encoding.getDataType(data);
                if (!data.length) {
                    return {
                        encodings: [{ kind: 'IntervalQuantization', min: min, max: max, numSteps: numSteps, srcType: srcType }],
                        data: new Int32Array(0)
                    };
                }
                if (max < min) {
                    var t = min;
                    min = max;
                    max = t;
                }
                var delta = (max - min) / (numSteps - 1);
                var output = new arrayType(data.length);
                for (var i = 0, n = data.length; i < n; i++) {
                    var v = data[i];
                    if (v <= min)
                        output[i] = 0;
                    else if (v >= max)
                        output[i] = numSteps;
                    else
                        output[i] = (Math.round((v - min) / delta)) | 0;
                }
                return {
                    encodings: [{ kind: 'IntervalQuantization', min: min, max: max, numSteps: numSteps, srcType: srcType }],
                    data: output
                };
            }
            function intervalQuantizaiton(min, max, numSteps, arrayType) {
                if (arrayType === void 0) { arrayType = Int32Array; }
                return function (data) { return _intervalQuantizaiton(data, min, max, numSteps, arrayType); };
            }
            Encoder.intervalQuantizaiton = intervalQuantizaiton;
            function runLength(data) {
                var srcType = Binary.Encoding.getDataType(data);
                if (srcType === void 0) {
                    data = new Int32Array(data);
                    srcType = 3 /* Int32 */;
                }
                if (!data.length) {
                    return {
                        encodings: [{ kind: 'RunLength', srcType: srcType, srcSize: 0 }],
                        data: new Int32Array(0)
                    };
                }
                // calculate output size
                var fullLength = 2;
                for (var i = 1, il = data.length; i < il; i++) {
                    if (data[i - 1] !== data[i]) {
                        fullLength += 2;
                    }
                }
                var output = new Int32Array(fullLength);
                var offset = 0;
                var runLength = 1;
                for (var i = 1, il = data.length; i < il; i++) {
                    if (data[i - 1] !== data[i]) {
                        output[offset] = data[i - 1];
                        output[offset + 1] = runLength;
                        runLength = 1;
                        offset += 2;
                    }
                    else {
                        ++runLength;
                    }
                }
                output[offset] = data[data.length - 1];
                output[offset + 1] = runLength;
                return {
                    encodings: [{ kind: 'RunLength', srcType: srcType, srcSize: data.length }],
                    data: output
                };
            }
            Encoder.runLength = runLength;
            function delta(data) {
                if (!Binary.Encoding.isSignedIntegerDataType(data)) {
                    throw new Error('Only signed integer types can be encoded using delta encoding.');
                }
                var srcType = Binary.Encoding.getDataType(data);
                if (srcType === void 0) {
                    data = new Int32Array(data);
                    srcType = 3 /* Int32 */;
                }
                if (!data.length) {
                    return {
                        encodings: [{ kind: 'Delta', origin: 0, srcType: srcType }],
                        data: new data.constructor(0)
                    };
                }
                var output = new data.constructor(data.length);
                var origin = data[0];
                output[0] = data[0];
                for (var i = 1, n = data.length; i < n; i++) {
                    output[i] = data[i] - data[i - 1];
                }
                output[0] = 0;
                return {
                    encodings: [{ kind: 'Delta', origin: origin, srcType: srcType }],
                    data: output
                };
            }
            Encoder.delta = delta;
            function isSigned(data) {
                for (var i = 0, n = data.length; i < n; i++) {
                    if (data[i] < 0)
                        return true;
                }
                return false;
            }
            function packingSize(data, upperLimit) {
                var lowerLimit = -upperLimit - 1;
                var size = 0;
                for (var i = 0, n = data.length; i < n; i++) {
                    var value = data[i];
                    if (value === 0) {
                        size += 1;
                    }
                    else if (value > 0) {
                        size += Math.ceil(value / upperLimit);
                        if (value % upperLimit === 0)
                            size += 1;
                    }
                    else {
                        size += Math.ceil(value / lowerLimit);
                        if (value % lowerLimit === 0)
                            size += 1;
                    }
                }
                return size;
            }
            function determinePacking(data) {
                var signed = isSigned(data);
                var size8 = signed ? packingSize(data, 0x7F) : packingSize(data, 0xFF);
                var size16 = signed ? packingSize(data, 0x7FFF) : packingSize(data, 0xFFFF);
                if (data.length * 4 < size16 * 2) {
                    // 4 byte packing is the most effective
                    return {
                        isSigned: signed,
                        size: data.length,
                        bytesPerElement: 4
                    };
                }
                else if (size16 * 2 < size8) {
                    // 2 byte packing is the most effective
                    return {
                        isSigned: signed,
                        size: size16,
                        bytesPerElement: 2
                    };
                }
                else {
                    // 1 byte packing is the most effective
                    return {
                        isSigned: signed,
                        size: size8,
                        bytesPerElement: 1
                    };
                }
                ;
            }
            function _integerPacking(data, packing) {
                var upperLimit = packing.isSigned
                    ? (packing.bytesPerElement === 1 ? 0x7F : 0x7FFF)
                    : (packing.bytesPerElement === 1 ? 0xFF : 0xFFFF);
                var lowerLimit = -upperLimit - 1;
                var n = data.length;
                var packed = packing.isSigned
                    ? packing.bytesPerElement === 1 ? new Int8Array(packing.size) : new Int16Array(packing.size)
                    : packing.bytesPerElement === 1 ? new Uint8Array(packing.size) : new Uint16Array(packing.size);
                var j = 0;
                for (var i = 0; i < n; i++) {
                    var value = data[i];
                    if (value >= 0) {
                        while (value >= upperLimit) {
                            packed[j] = upperLimit;
                            ++j;
                            value -= upperLimit;
                        }
                    }
                    else {
                        while (value <= lowerLimit) {
                            packed[j] = lowerLimit;
                            ++j;
                            value -= lowerLimit;
                        }
                    }
                    packed[j] = value;
                    ++j;
                }
                var result = byteArray(packed);
                return {
                    encodings: [{
                            kind: 'IntegerPacking',
                            byteCount: packing.bytesPerElement,
                            isUnsigned: !packing.isSigned,
                            srcSize: n
                        },
                        result.encodings[0]
                    ],
                    data: result.data
                };
            }
            /**
             * Packs Int32 array. The packing level is determined automatically to either 1-, 2-, or 4-byte words.
             */
            function integerPacking(data) {
                if (!(data instanceof Int32Array)) {
                    throw new Error('Integer packing can only be applied to Int32 data.');
                }
                var packing = determinePacking(data);
                if (packing.bytesPerElement === 4) {
                    // no packing done, Int32 encoding will be used
                    return byteArray(data);
                }
                return _integerPacking(data, packing);
            }
            Encoder.integerPacking = integerPacking;
            function stringArray(data) {
                var map = Object.create(null);
                var strings = [];
                var accLength = 0;
                var offsets = CIFTools.Utils.ChunkedArray.create(function (s) { return new Int32Array(s); }, 1024, 1);
                var output = new Int32Array(data.length);
                CIFTools.Utils.ChunkedArray.add(offsets, 0);
                var i = 0;
                for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
                    var s = data_1[_i];
                    // handle null strings.
                    if (s === null || s === void 0) {
                        output[i++] = -1;
                        continue;
                    }
                    var index = map[s];
                    if (index === void 0) {
                        // increment the length
                        accLength += s.length;
                        // store the string and index                   
                        index = strings.length;
                        strings[index] = s;
                        map[s] = index;
                        // write the offset
                        CIFTools.Utils.ChunkedArray.add(offsets, accLength);
                    }
                    output[i++] = index;
                }
                var encOffsets = Encoder.by(delta).and(integerPacking).encode(CIFTools.Utils.ChunkedArray.compact(offsets));
                var encOutput = Encoder.by(delta).and(runLength).and(integerPacking).encode(output);
                return {
                    encodings: [{ kind: 'StringArray', dataEncoding: encOutput.encoding, stringData: strings.join(''), offsetEncoding: encOffsets.encoding, offsets: encOffsets.data }],
                    data: encOutput.data
                };
            }
            Encoder.stringArray = stringArray;
        })(Encoder = Binary.Encoder || (Binary.Encoder = {}));
    })(Binary = CIFTools.Binary || (CIFTools.Binary = {}));
// })(CIFTools || (CIFTools = {}));
/*
 * Copyright (c) 2016 - now David Sehnal, licensed under MIT License, See LICENSE file for more info.
 */
// var CIFTools;
// (function (CIFTools) {
//     var Binary;
    (function (Binary) {
        "use strict";
        Binary.VERSION = '0.3.0';
        var Encoding;
        (function (Encoding) {
            function getDataType(data) {
                var srcType;
                if (data instanceof Int8Array)
                    srcType = 1 /* Int8 */;
                else if (data instanceof Int16Array)
                    srcType = 2 /* Int16 */;
                else if (data instanceof Int32Array)
                    srcType = 3 /* Int32 */;
                else if (data instanceof Uint8Array)
                    srcType = 4 /* Uint8 */;
                else if (data instanceof Uint16Array)
                    srcType = 5 /* Uint16 */;
                else if (data instanceof Uint32Array)
                    srcType = 6 /* Uint32 */;
                else if (data instanceof Float32Array)
                    srcType = 32 /* Float32 */;
                else if (data instanceof Float64Array)
                    srcType = 33 /* Float64 */;
                else
                    throw new Error('Unsupported integer data type.');
                return srcType;
            }
            Encoding.getDataType = getDataType;
            function isSignedIntegerDataType(data) {
                return data instanceof Int8Array || data instanceof Int16Array || data instanceof Int32Array;
            }
            Encoding.isSignedIntegerDataType = isSignedIntegerDataType;
        })(Encoding = Binary.Encoding || (Binary.Encoding = {}));
    })(Binary = CIFTools.Binary || (CIFTools.Binary = {}));
// })(CIFTools || (CIFTools = {}));
/*
 * Copyright (c) 2016 - now David Sehnal, licensed under MIT License, See LICENSE file for more info.
 */
// var CIFTools;
// (function (CIFTools) {
//     var Binary;
    (function (Binary) {
        "use strict";
        function checkVersions(min, current) {
            for (var i = 0; i < 2; i++) {
                if (min[i] > current[i])
                    return false;
            }
            return true;
        }
        function parse(data) {
            var minVersion = [0, 3];
            try {
                var array = new Uint8Array(data);
                var unpacked = Binary.MessagePack.decode(array);
                if (!checkVersions(minVersion, unpacked.version.match(/(\d)\.(\d)\.\d/).slice(1))) {
                    return CIFTools.ParserResult.error("Unsupported format version. Current " + unpacked.version + ", required " + minVersion.join('.') + ".");
                }
                var file = new Binary.File(unpacked);
                return CIFTools.ParserResult.success(file);
            }
            catch (e) {
                return CIFTools.ParserResult.error('' + e);
            }
        }
        Binary.parse = parse;
    })(Binary = CIFTools.Binary || (CIFTools.Binary = {}));
// })(CIFTools || (CIFTools = {}));
/*
 * Copyright (c) 2016 - now David Sehnal, licensed under MIT License, See LICENSE file for more info.
 */
// var CIFTools;
// (function (CIFTools) {
//     var Binary;
    (function (Binary) {
        "use strict";
        function encodeField(field, data, totalCount) {
            var array, isNative = false;
            if (field.typedArray) {
                array = new field.typedArray(totalCount);
            }
            else {
                isNative = true;
                array = new Array(totalCount);
            }
            var mask = new Uint8Array(totalCount);
            var presence = field.presence;
            var getter = field.number ? field.number : field.string;
            var allPresent = true;
            var offset = 0;
            for (var _i = 0, data_2 = data; _i < data_2.length; _i++) {
                var _d = data_2[_i];
                var d = _d.data;
                for (var i = 0, _b = _d.count; i < _b; i++) {
                    var p = presence ? presence(d, i) : 0 /* Present */;
                    if (p !== 0 /* Present */) {
                        mask[offset] = p;
                        if (isNative)
                            array[offset] = null;
                        allPresent = false;
                    }
                    else {
                        mask[offset] = 0 /* Present */;
                        array[offset] = getter(d, i);
                    }
                    offset++;
                }
            }
            var encoder = field.encoder ? field.encoder : Binary.Encoder.by(Binary.Encoder.stringArray);
            var encoded = encoder.encode(array);
            var maskData = void 0;
            if (!allPresent) {
                var maskRLE = Binary.Encoder.by(Binary.Encoder.runLength).and(Binary.Encoder.byteArray).encode(mask);
                if (maskRLE.data.length < mask.length) {
                    maskData = maskRLE;
                }
                else {
                    maskData = Binary.Encoder.by(Binary.Encoder.byteArray).encode(mask);
                }
            }
            return {
                name: field.name,
                data: encoded,
                mask: maskData
            };
        }
        var Writer = /** @class */ (function () {
            function Writer(encoder) {
                this.dataBlocks = [];
                this.data = {
                    encoder: encoder,
                    version: Binary.VERSION,
                    dataBlocks: this.dataBlocks
                };
            }
            Writer.prototype.startDataBlock = function (header) {
                this.dataBlocks.push({
                    header: (header || '').replace(/[ \n\t]/g, '').toUpperCase(),
                    categories: []
                });
            };
            Writer.prototype.writeCategory = function (category, contexts) {
                if (!this.data) {
                    throw new Error('The writer contents have already been encoded, no more writing.');
                }
                if (!this.dataBlocks.length) {
                    throw new Error('No data block created.');
                }
                var src = !contexts || !contexts.length ? [category(void 0)] : contexts.map(function (c) { return category(c); });
                var categories = src.filter(function (c) { return c && c.count > 0; });
                if (!categories.length)
                    return;
                var count = categories.reduce(function (a, c) { return a + c.count; }, 0);
                if (!count)
                    return;
                var first = categories[0];
                var cat = { name: first.desc.name, columns: [], rowCount: count };
                var data = categories.map(function (c) { return ({ data: c.data, count: c.count }); });
                for (var _i = 0, _a = first.desc.fields; _i < _a.length; _i++) {
                    var f = _a[_i];
                    cat.columns.push(encodeField(f, data, count));
                }
                this.dataBlocks[this.dataBlocks.length - 1].categories.push(cat);
            };
            Writer.prototype.encode = function () {
                this.encodedData = Binary.MessagePack.encode(this.data);
                this.data = null;
                this.dataBlocks = null;
            };
            Writer.prototype.flush = function (stream) {
                stream.writeBinary(this.encodedData);
            };
            return Writer;
        }());
        Binary.Writer = Writer;
    })(Binary = CIFTools.Binary || (CIFTools.Binary = {}));
 })(CIFTools || (CIFTools = {}));
//   return CIFTools;
// }
// if (typeof module === 'object' && typeof module.exports === 'object') {
//   module.exports = __CIFTools();
// } else if (typeof define === 'function' && define.amd) {
//   define(['require'], function(require) { return __CIFTools(); })
// } else {
//   var __target = !!window ? window : this;
//   __target.CIFTools = __CIFTools();
// }


/*
 * ==========================================================
 *  COLOR PICKER PLUGIN 1.3.9
 * ==========================================================
 * Author: Taufik Nurrohman <https://github.com/tovic>
 * License: MIT
 * ----------------------------------------------------------
 */

(function(win, doc, NS) {

    var instance = '__instance__',
        first = 'firstChild',
        delay = setTimeout;

    function is_set(x) {
        return typeof x !== "undefined";
    }

    function is_string(x) {
        return typeof x === "string";
    }

    function is_object(x) {
        return typeof x === "object";
    }

    function object_length(x) {
        return Object.keys(x).length;
    }

    function edge(a, b, c) {
        if (a < b) return b;
        if (a > c) return c;
        return a;
    }

    function num(i, j) {
        return parseInt(i, j || 10);
    }

    function round(i) {
        return Math.round(i);
    }

    // [h, s, v] ... 0 <= h, s, v <= 1
    function HSV2RGB(a) {
        var h = +a[0],
            s = +a[1],
            v = +a[2],
            r, g, b, i, f, p, q, t;
        i = Math.floor(h * 6);
        f = h * 6 - i;
        p = v * (1 - s);
        q = v * (1 - f * s);
        t = v * (1 - (1 - f) * s);
        i = i || 0;
        q = q || 0;
        t = t || 0;
        switch (i % 6) {
            case 0:
                r = v, g = t, b = p;
                break;
            case 1:
                r = q, g = v, b = p;
                break;
            case 2:
                r = p, g = v, b = t;
                break;
            case 3:
                r = p, g = q, b = v;
                break;
            case 4:
                r = t, g = p, b = v;
                break;
            case 5:
                r = v, g = p, b = q;
                break;
        }
        return [round(r * 255), round(g * 255), round(b * 255)];
    }

    function HSV2HEX(a) {
        return RGB2HEX(HSV2RGB(a));
    }

    // [r, g, b] ... 0 <= r, g, b <= 255
    function RGB2HSV(a) {
        var r = +a[0],
            g = +a[1],
            b = +a[2],
            max = Math.max(r, g, b),
            min = Math.min(r, g, b),
            d = max - min,
            h, s = (max === 0 ? 0 : d / max),
            v = max / 255;
        switch (max) {
            case min:
                h = 0;
                break;
            case r:
                h = (g - b) + d * (g < b ? 6 : 0);
                h /= 6 * d;
                break;
            case g:
                h = (b - r) + d * 2;
                h /= 6 * d;
                break;
            case b:
                h = (r - g) + d * 4;
                h /= 6 * d;
                break;
        }
        return [h, s, v];
    }

    function RGB2HEX(a) {
        var s = +a[2] | (+a[1] << 8) | (+a[0] << 16);
        s = '000000' + s.toString(16);
        return s.slice(-6);
    }

    // rrggbb or rgb
    function HEX2HSV(s) {
        return RGB2HSV(HEX2RGB(s));
    }

    function HEX2RGB(s) {
        if (s.length === 3) {
            s = s.replace(/./g, '$&$&');
        }
        return [num(s[0] + s[1], 16), num(s[2] + s[3], 16), num(s[4] + s[5], 16)];
    }

    // convert range from `0` to `360` and `0` to `100` in color into range from `0` to `1`
    function _2HSV_pri(a) {
        return [+a[0] / 360, +a[1] / 100, +a[2] / 100];
    }

    // convert range from `0` to `1` into `0` to `360` and `0` to `100` in color
    function _2HSV_pub(a) {
        return [round(+a[0] * 360), round(+a[1] * 100), round(+a[2] * 100)];
    }

    // convert range from `0` to `255` in color into range from `0` to `1`
    function _2RGB_pri(a) {
        return [+a[0] / 255, +a[1] / 255, +a[2] / 255];
    }

    // *
    function parse(x) {
        if (is_object(x)) return x;
        var rgb = /\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i.exec(x),
            hsv = /\s*hsv\s*\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)\s*$/i.exec(x),
            hex = x[0] === '#' && x.match(/^#([\da-f]{3}|[\da-f]{6})$/i);
        if (hex) {
            return HEX2HSV(x.slice(1));
        } else if (hsv) {
            return _2HSV_pri([+hsv[1], +hsv[2], +hsv[3]]);
        } else if (rgb) {
            return RGB2HSV([+rgb[1], +rgb[2], +rgb[3]]);
        }
        return [0, 1, 1]; // default is red
    }

    (function($) {

        // plugin version
        $.version = '1.3.9';

        // collect all instance(s)
        $[instance] = {};

        // plug to all instance(s)
        $.each = function(fn, t) {
            return delay(function() {
                var ins = $[instance], i;
                for (i in ins) {
                    fn(ins[i], i, ins);
                }
            }, t === 0 ? 0 : (t || 1)), $;
        };

        // static method(s)
        $.parse = parse;
        $._HSV2RGB = HSV2RGB;
        $._HSV2HEX = HSV2HEX;
        $._RGB2HSV = RGB2HSV;
        $._HEX2HSV = HEX2HSV;
        $._HEX2RGB = function(a) {
            return _2RGB_pri(HEX2RGB(a));
        };
        $.HSV2RGB = function(a) {
            return HSV2RGB(_2HSV_pri(a));
        };
        $.HSV2HEX = function(a) {
            return HSV2HEX(_2HSV_pri(a));
        };
        $.RGB2HSV = function(a) {
            return _2HSV_pub(RGB2HSV(a));
        };
        $.RGB2HEX = RGB2HEX;
        $.HEX2HSV = function(s) {
            return _2HSV_pub(HEX2HSV(s));
        };
        $.HEX2RGB = HEX2RGB;

    })(win[NS] = function(target, events, parent) {

        var b = doc.body,
            h = doc.documentElement,
            $ = this,
            $$ = win[NS],
            _ = false,
            hooks = {},
            picker = doc.createElement('div'),
            on_down = "touchstart mousedown",
            on_move = "touchmove mousemove",
            on_up = "touchend mouseup",
            on_resize = "orientationchange resize";

        // return a new instance if `CP` was called without the `new` operator
        if (!($ instanceof $$)) {
            return new $$(target, events);
        }

        // store color picker instance to `CP.__instance__`
        $$[instance][target.id || target.name || object_length($$[instance])] = $;

        // trigger color picker panel on click by default
        if (!is_set(events) || events === true) {
            events = on_down;
        }

        // add event
        function on(ev, el, fn) {
            ev = ev.split(/\s+/);
            for (var i = 0, ien = ev.length; i < ien; ++i) {
                el.addEventListener(ev[i], fn, false);
            }
        }

        // remove event
        function off(ev, el, fn) {
            ev = ev.split(/\s+/);
            for (var i = 0, ien = ev.length; i < ien; ++i) {
                el.removeEventListener(ev[i], fn);
            }
        }

        // get mouse/finger coordinate
        function point(el, e) {
            var T = 'touches',
                X = 'clientX',
                Y = 'clientY',
                x = !!e[T] ? e[T][0][X] : e[X],
                y = !!e[T] ? e[T][0][Y] : e[Y],
                o = offset(el);
            return {
                x: x - o.l,
                y: y - o.t
            };
        }

        // get position
        function offset(el) {
            var left, top, rect;
            if (el === win) {
                left = win.pageXOffset || h.scrollLeft;
                top = win.pageYOffset || h.scrollTop;
            } else {
                rect = el.getBoundingClientRect();
                left = rect.left;
                top = rect.top;
            }
            return {
                l: left,
                t: top
            };
        }

        // get closest parent
        function closest(a, b) {
            while ((a = a.parentElement) && a !== b);
            return a;
        }

        // prevent default
        function prevent(e) {
            if (e) e.preventDefault();
        }

        // get dimension
        function size(el) {
            return el === win ? {
                w: win.innerWidth,
                h: win.innerHeight
            } : {
                w: el.offsetWidth,
                h: el.offsetHeight
            };
        }

        // get color data
        function get_data(a) {
            return _ || (is_set(a) ? a : false);
        }

        // set color data
        function set_data(a) {
            _ = a;
        }

        // add hook
        function add(ev, fn, id) {
            if (!is_set(ev)) return hooks;
            if (!is_set(fn)) return hooks[ev];
            if (!is_set(hooks[ev])) hooks[ev] = {};
            if (!is_set(id)) id = object_length(hooks[ev]);
            return hooks[ev][id] = fn, $;
        }

        // remove hook
        function remove(ev, id) {
            if (!is_set(ev)) return hooks = {}, $;
            if (!is_set(id)) return hooks[ev] = {}, $;
            return delete hooks[ev][id], $;
        }

        // trigger hook
        function trigger(ev, a, id) {
            if (!is_set(hooks[ev])) return $;
            if (!is_set(id)) {
                for (var i in hooks[ev]) {
                    hooks[ev][i].apply($, a);
                }
            } else {
                if (is_set(hooks[ev][id])) {
                    hooks[ev][id].apply($, a);
                }
            }
            return $;
        }

        // initialize data ...
        set_data($$.parse(target.getAttribute('data-color') || target.value || [0, 1, 1]));

        // generate color picker pane ...
        picker.className = 'color-picker';
        picker.innerHTML = '<div class="color-picker-control"><span class="color-picker-h"><i></i></span><span class="color-picker-sv"><i></i></span></div>';
        var c = picker[first].children,
            HSV = get_data([0, 1, 1]), // default is red
            H = c[0],
            SV = c[1],
            H_point = H[first],
            SV_point = SV[first],
            start_H = 0,
            start_SV = 0,
            drag_H = 0,
            drag_SV = 0,
            left = 0,
            top = 0,
            P_W = 0,
            P_H = 0,
            v = HSV2HEX(HSV),
            set;

        // on update ...
        function trigger_(k, x) {
            if (!k || k === "h") {
                trigger("change:h", x);
            }
            if (!k || k === "sv") {
                trigger("change:sv", x);
            }
            trigger("change", x);
        }

        // is visible?
        function visible() {
            return picker.parentNode;
        }

        // create
        function create(first, bucket) {
            if (!first) {
                (parent || bucket || b).appendChild(picker), $.visible = true;
            }
            P_W = size(picker).w;
            P_H = size(picker).h;
            var SV_size = size(SV),
                SV_point_size = size(SV_point),
                H_H = size(H).h,
                SV_W = SV_size.w,
                SV_H = SV_size.h,
                H_point_H = size(H_point).h,
                SV_point_W = SV_point_size.w,
                SV_point_H = SV_point_size.h;
            if (first) {
                picker.style.left = picker.style.top = '-9999px';
                function click(e) {
                    var t = e.target,
                        is_target = t === target || closest(t, target) === target;
                    if (is_target) {
                        create();
                    } else {
                        $.exit();
                    }
                    trigger(is_target ? "enter" : "exit", [$]);
                }
                if (events !== false) {
                    on(events, target, click);
                }
                $.create = function() {
                    return create(1), trigger("create", [$]), $;
                };
                $.destroy = function() {
                    if (events !== false) {
                        off(events, target, click);
                    }
                    $.exit(), set_data(false);
                    return trigger("destroy", [$]), $;
                };
            } else {
                fit();
            }
            set = function() {
                HSV = get_data(HSV), color();
                H_point.style.top = (H_H - (H_point_H / 2) - (H_H * +HSV[0])) + 'px';
                SV_point.style.right = (SV_W - (SV_point_W / 2) - (SV_W * +HSV[1])) + 'px';
                SV_point.style.top = (SV_H - (SV_point_H / 2) - (SV_H * +HSV[2])) + 'px';
            };
            $.exit = function(e) {
                if (visible()) {
                    visible().removeChild(picker);
                    $.visible = false;
                }
                off(on_down, H, down_H);
                off(on_down, SV, down_SV);
                off(on_move, doc, move);
                off(on_up, doc, stop);
                off(on_resize, win, fit);
                return $;
            };
            function color(e) {
                var a = HSV2RGB(HSV),
                    b = HSV2RGB([HSV[0], 1, 1]);
                SV.style.backgroundColor = 'rgb(' + b.join(',') + ')';
                set_data(HSV);
                prevent(e);
            };
            set();
            function do_H(e) {
                var y = edge(point(H, e).y, 0, H_H);
                HSV[0] = (H_H - y) / H_H;
                H_point.style.top = (y - (H_point_H / 2)) + 'px';
                color(e);
            }
            function do_SV(e) {
                var o = point(SV, e),
                    x = edge(o.x, 0, SV_W),
                    y = edge(o.y, 0, SV_H);
                HSV[1] = 1 - ((SV_W - x) / SV_W);
                HSV[2] = (SV_H - y) / SV_H;
                SV_point.style.right = (SV_W - x - (SV_point_W / 2)) + 'px';
                SV_point.style.top = (y - (SV_point_H / 2)) + 'px';
                color(e);
            }
            function move(e) {
                if (drag_H) {
                    do_H(e), v = HSV2HEX(HSV);
                    if (!start_H) {
                        trigger("drag:h", [v, $]);
                        trigger("drag", [v, $]);
                        trigger_("h", [v, $]);
                    }
                }
                if (drag_SV) {
                    do_SV(e), v = HSV2HEX(HSV);
                    if (!start_SV) {
                        trigger("drag:sv", [v, $]);
                        trigger("drag", [v, $]);
                        trigger_("sv", [v, $]);
                    }
                }
                start_H = 0,
                start_SV = 0;
            }
            function stop(e) {
                var t = e.target,
                    k = drag_H ? "h" : "sv",
                    a = [HSV2HEX(HSV), $],
                    is_target = t === target || closest(t, target) === target,
                    is_picker = t === picker || closest(t, picker) === picker;
                if (!is_target && !is_picker) {
                    // click outside the target or picker element to exit
                    if (visible() && events !== false) $.exit(), trigger("exit", [$]), trigger_(0, a);
                } else {
                    if (is_picker) {
                        trigger("stop:" + k, a);
                        trigger("stop", a);
                        trigger_(k, a);
                    }
                }
                drag_H = 0,
                drag_SV = 0;
            }
            function down_H(e) {
                start_H = 1,
                drag_H = 1,
                move(e), prevent(e);
                trigger("start:h", [v, $]);
                trigger("start", [v, $]);
                trigger_("h", [v, $]);
            }
            function down_SV(e) {
                start_SV = 1,
                drag_SV = 1,
                move(e), prevent(e);
                trigger("start:sv", [v, $]);
                trigger("start", [v, $]);
                trigger_("sv", [v, $]);
            }
            if (!first) {
                on(on_down, H, down_H);
                on(on_down, SV, down_SV);
                on(on_move, doc, move);
                on(on_up, doc, stop);
                on(on_resize, win, fit);
            }
        } create(1);

        delay(function() {
            var a = [HSV2HEX(HSV), $];
            trigger("create", a);
            trigger_(0, a);
        }, 0);

        // fit to window
        $.fit = function(o) {
            var w = size(win),
                y = size(h),
                screen_w = w.w - y.w, // vertical scroll bar
                screen_h = w.h - h.clientHeight, // horizontal scroll bar
                ww = offset(win),
                to = offset(target);
            left = to.l + ww.l;
            top = to.t + ww.t + size(target).h; // drop!
            if (is_object(o)) {
                is_set(o[0]) && (left = o[0]);
                is_set(o[1]) && (top = o[1]);
            } else {
                var min_x = ww.l,
                    min_y = ww.t,
                    max_x = ww.l + w.w - P_W - screen_w,
                    max_y = ww.t + w.h - P_H - screen_h;
                left = edge(left, min_x, max_x) >> 0;
                top = edge(top, min_y, max_y) >> 0;
            }
            picker.style.left = left + 'px';
            picker.style.top = top + 'px';
            return trigger("fit", [$]), $;
        };

        // for event listener ID
        function fit() {
            return $.fit();
        }

        // set hidden color picker data
        $.set = function(a) {
            if (!is_set(a)) return get_data();
            if (is_string(a)) {
                a = $$.parse(a);
            }
            return set_data(a), set(), $;
        };

        // alias for `$.set()`
        $.get = function(a) {
            return get_data(a);
        };

        // register to global ...
        $.target = target;
        $.picker = picker;
        $.visible = false;
        $.on = add;
        $.off = remove;
        $.fire = trigger;
        $.hooks = hooks;
        $.enter = function(bucket) {
            return create(0, bucket);
        };

        // return the global object
        return $;

    });

})(window, document, 'CP');

/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 1.3.8
 * 2018-03-22 14:03:47
 *
 * By Eli Grey, https://eligrey.com
 * License: MIT
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/* @source http://purl.eligrey.com/github/FileSaver.js/blob/master/src/FileSaver.js */

//var saveAs = saveAs || (function(view) {
var saveAs = (function(view) {
    "use strict";
    // IE <10 is explicitly unsupported
    if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
        return;
    }
    var doc = view.document
          // only get URL when necessary in case Blob.js hasn't overridden it yet
        , get_URL = function() {
            return view.URL || view.webkitURL || view;
        }
        , save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
        , can_use_save_link = "download" in save_link
        , click = function(node) {
            var event = new MouseEvent("click");
            node.dispatchEvent(event);
        }
        , is_safari = /constructor/i.test(view.HTMLElement) || view.safari
        , is_chrome_ios =/CriOS\/[\d]+/.test(navigator.userAgent)
        , setImmediate = view.setImmediate || view.setTimeout
        , throw_outside = function(ex) {
            setImmediate(function() {
                throw ex;
            }, 0);
        }
        , force_saveable_type = "application/octet-stream"
        // the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
        , arbitrary_revoke_timeout = 1000 * 40 // in ms
        , revoke = function(file) {
            var revoker = function() {
                if (typeof file === "string") { // file is an object URL
                    get_URL().revokeObjectURL(file);
                } else { // file is a File
                    file.remove();
                }
            };
            setTimeout(revoker, arbitrary_revoke_timeout);
        }
        , dispatch = function(filesaver, event_types, event) {
            event_types = [].concat(event_types);
            var i = event_types.length;
            while (i--) {
                var listener = filesaver["on" + event_types[i]];
                if (typeof listener === "function") {
                    try {
                        listener.call(filesaver, event || filesaver);
                    } catch (ex) {
                        throw_outside(ex);
                    }
                }
            }
        }
        , auto_bom = function(blob) {
            // prepend BOM for UTF-8 XML and text/* types (including HTML)
            // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
            //if (blob && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
            if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
                return new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});
            }
            return blob;
        }
        , FileSaver = function(blob, name, no_auto_bom) {
            if (!no_auto_bom) {
                blob = auto_bom(blob);
            }
            // First try a.download, then web filesystem, then object URLs
            var
                  filesaver = this
                , type = (blob) ? blob.type : undefined
                , force = type === force_saveable_type
                , object_url
                , dispatch_all = function() {
                    dispatch(filesaver, "writestart progress write writeend".split(" "));
                }
                // on any filesys errors revert to saving with object URLs
                , fs_error = function() {
                    if ((is_chrome_ios || (force && is_safari)) && view.FileReader) {
                        // Safari doesn't allow downloading of blob urls
                        var reader = new FileReader();
                        reader.onloadend = function() {
                            var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
                            var urlTarget = '_blank';
                            var popup = view.open(url, urlTarget);
                            if(!popup) view.location.href = url;
                            url=undefined; // release reference before dispatching
                            filesaver.readyState = filesaver.DONE;
                            dispatch_all();
                        };
                        reader.readAsDataURL(blob);
                        filesaver.readyState = filesaver.INIT;
                        return;
                    }
                    // don't create more object URLs than needed
                    if (!object_url) object_url = get_URL().createObjectURL(blob);
                    if (force) {
                        view.location.href = object_url;
                    } else {
                        var opened = view.open(object_url, "_blank");
                        if (!opened) {
                            // Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
                            view.location.href = object_url;
                        }
                    }
                    filesaver.readyState = filesaver.DONE;
                    dispatch_all();
                    revoke(object_url);
                }
            ;
            filesaver.readyState = filesaver.INIT;

            if (can_use_save_link) {
                if (!object_url) object_url = get_URL().createObjectURL(blob);
                setImmediate(function() {
                    save_link.href = object_url;
                    save_link.download = name;
                    click(save_link);
                    dispatch_all();
                    revoke(object_url);
                    filesaver.readyState = filesaver.DONE;
                }, 0);
                return;
            }

            fs_error();
        }
        , FS_proto = FileSaver.prototype
        , saveAs = function(blob, name, no_auto_bom) {
            return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
        }
    ;

    // IE 10+ (native saveAs)
    if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
        return function(blob, name, no_auto_bom) {
            name = name || blob.name || "download";

            if (!no_auto_bom) {
                blob = auto_bom(blob);
            }
            return navigator.msSaveOrOpenBlob(blob, name);
        };
    }

    // todo: detect chrome extensions & packaged apps
    //save_link.target = "_blank";

    FS_proto.abort = function(){};
    FS_proto.readyState = FS_proto.INIT = 0;
    FS_proto.WRITING = 1;
    FS_proto.DONE = 2;

    FS_proto.error =
    FS_proto.onwritestart =
    FS_proto.onprogress =
    FS_proto.onwrite =
    FS_proto.onabort =
    FS_proto.onerror =
    FS_proto.onwriteend =
        null;

    return saveAs;
}(
       typeof self !== "undefined" && self
    || typeof window !== "undefined" && window
    || this
));

/*
 * JavaScript Canvas to Blob
 * https://github.com/blueimp/JavaScript-Canvas-to-Blob
 *
 * Copyright 2012, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on stackoverflow user Stoive's code snippet:
 * http://stackoverflow.com/q/4998908
 */

/* global atob, Blob, define */

;(function (window) {
  'use strict';

  var CanvasPrototype =
    window.HTMLCanvasElement && window.HTMLCanvasElement.prototype
  var hasBlobConstructor =
    window.Blob &&
    (function () {
      try {
        return Boolean(new Blob())
      } catch (e) {
        return false
      }
    })()
  var hasArrayBufferViewSupport =
    hasBlobConstructor &&
    window.Uint8Array &&
    (function () {
      try {
        return new Blob([new Uint8Array(100)]).size === 100
      } catch (e) {
        return false
      }
    })()
  var BlobBuilder =
    window.BlobBuilder ||
    window.WebKitBlobBuilder ||
    window.MozBlobBuilder ||
    window.MSBlobBuilder
  var dataURIPattern = /^data:((.*?)(;charset=.*?)?)(;base64)?,/
  var dataURLtoBlob =
    (hasBlobConstructor || BlobBuilder) &&
    window.atob &&
    window.ArrayBuffer &&
    window.Uint8Array &&
    function (dataURI) {
      var matches,
        mediaType,
        isBase64,
        dataString,
        byteString,
        arrayBuffer,
        intArray,
        i,
        bb
      // Parse the dataURI components as per RFC 2397
      matches = dataURI.match(dataURIPattern)
      if (!matches) {
        throw new Error('invalid data URI')
      }
      // Default to text/plain;charset=US-ASCII
      mediaType = matches[2]
        ? matches[1]
        : 'text/plain' + (matches[3] || ';charset=US-ASCII')
      isBase64 = !!matches[4]
      dataString = dataURI.slice(matches[0].length)
      if (isBase64) {
        // Convert base64 to raw binary data held in a string:
        byteString = atob(dataString)
      } else {
        // Convert base64/URLEncoded data component to raw binary:
        byteString = decodeURIComponent(dataString)
      }
      // Write the bytes of the string to an ArrayBuffer:
      arrayBuffer = new ArrayBuffer(byteString.length)
      intArray = new Uint8Array(arrayBuffer)
      for (i = 0; i < byteString.length; i += 1) {
        intArray[i] = byteString.charCodeAt(i)
      }
      // Write the ArrayBuffer (or ArrayBufferView) to a blob:
      if (hasBlobConstructor) {
        return new Blob([hasArrayBufferViewSupport ? intArray : arrayBuffer], {
          type: mediaType
        })
      }
      bb = new BlobBuilder()
      bb.append(arrayBuffer)
      return bb.getBlob(mediaType)
    }
  if (window.HTMLCanvasElement && !CanvasPrototype.toBlob) {
    if (CanvasPrototype.mozGetAsFile) {
      CanvasPrototype.toBlob = function (callback, type, quality) {
        var self = this
        setTimeout(function () {
          if (quality && CanvasPrototype.toDataURL && dataURLtoBlob) {
            callback(dataURLtoBlob(self.toDataURL(type, quality)))
          } else {
            callback(self.mozGetAsFile('blob', type))
          }
        })
      }
    } else if (CanvasPrototype.toDataURL && dataURLtoBlob) {
      CanvasPrototype.toBlob = function (callback, type, quality) {
        var self = this
        setTimeout(function () {
          callback(dataURLtoBlob(self.toDataURL(type, quality)))
        })
      }
    }
  }
  if (typeof define === 'function' && define.amd) {
    define(function () {
      return dataURLtoBlob
    })
  } else if (typeof module === 'object' && module.exports) {
    module.exports = dataURLtoBlob
  } else {
    window.dataURLtoBlob = dataURLtoBlob
  }
})(window)

var icn3d = (function (exports) {
    'use strict';

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    //import * as $ from 'jquery';

    class HashUtilsCls {
        constructor(icn3dui) {
            this.icn3dui = icn3dui;
        }

        //Clone the "fromHash" and return the cloned hash.
        cloneHash(from) { this.icn3dui;
          let to = {};

          if(from === undefined) from = {};

          for(let i in from) {
            to[i] = from[i];
          }

          return to;
        }

        //Get the intersection of two hashes "atoms1" and "atoms2". The returned hash has atom index as key and 1 as value.
        intHash(atoms1, atoms2) { this.icn3dui;
            let results = {};

            if(atoms1 === undefined) atoms1 = {};
            if(atoms2 === undefined) atoms2 = {};

            if(Object.keys(atoms1).length < Object.keys(atoms2).length) {
                for (let i in atoms1) {
                    if (atoms2 !== undefined && atoms2[i]) {
                        results[i] = atoms1[i];
                    }
                }
            }
            else {
                for (let i in atoms2) {
                    if (atoms1 !== undefined && atoms1[i]) {
                        results[i] = atoms2[i];
                    }
                }
            }

            return results;
        }

        // get atoms in allAtoms, but not in "atoms"
        //Get atoms in "includeAtoms", but not in "excludeAtoms". The returned hash has atom index as key and 1 as value.
        exclHash(includeAtomsInput, excludeAtoms) { let me = this.icn3dui;
            if(includeAtomsInput === undefined) includeAtomsInput = {};
            if(excludeAtoms === undefined) excludeAtoms = {};

            let includeAtoms = me.hashUtilsCls.cloneHash(includeAtomsInput);

            for (let i in includeAtoms) {
                if (excludeAtoms !== undefined && excludeAtoms[i]) {
                    delete includeAtoms[i];
                }
            }

            return includeAtoms;
        }

        //Get the union of two hashes "atoms1" and "atoms2". The returned hash has atom index as key and 1 as value.
        unionHash(atoms1, atoms2) { let me = this.icn3dui;
            // much slower
            //return me.hashUtilsCls.unionHashNotInPlace(atoms1, atoms2);

            // much faster
            return me.hashUtilsCls.unionHashInPlace(atoms1, atoms2);
        }

        unionHashInPlace(atoms1, atoms2) { this.icn3dui;
            if(atoms1 === undefined) atoms1 = {};
            if(atoms2 === undefined) atoms2 = {};

            $.extend(atoms1, atoms2);

            return atoms1;
        }

        unionHashNotInPlace(atoms1, atoms2) { this.icn3dui;
            let results = $.extend({}, atoms1, atoms2);

            return results;
        }

        //Get the intersection of two hashes "atoms1" and "atoms2". The returned hash has atom index as key and atom object as value.
        intHash2Atoms(atoms1, atoms2, allAtoms) { let me = this.icn3dui;
            return me.hashUtilsCls.hash2Atoms(me.hashUtilsCls.intHash(atoms1, atoms2), allAtoms);
        }

        // get atoms in allAtoms, but not in "atoms"
        //Get atoms in "includeAtoms", but not in "excludeAtoms". The returned hash has atom index as key and atom object as value.
        exclHash2Atoms(includeAtoms, excludeAtoms, allAtoms) { let me = this.icn3dui;
            return me.hashUtilsCls.hash2Atoms(me.hashUtilsCls.exclHash(includeAtoms, excludeAtoms), allAtoms);
        }

        //Get the union of two hashes "atoms1" and "atoms2". The returned hash has atom index as key and atom object as value.
        unionHash2Atoms(atoms1, atoms2, allAtoms) { let me = this.icn3dui;
            return me.hashUtilsCls.hash2Atoms(me.hashUtilsCls.unionHash(atoms1, atoms2), allAtoms);
        }

        //The input "hash" has atom index as key and 1 as value. The returned hash has atom index as key and atom object as value.
        hash2Atoms(hash, allAtoms) { this.icn3dui;
            let atoms = {};
            for(let i in hash) {
              atoms[i] = allAtoms[i];
            }

            return atoms;
        }

        hashvalue2array(hash) { this.icn3dui;
            //return $.map(hash, function(v) { return v; });

            let array = [];
            for(let i in hash) {
                array.push(hash[i]);
            }

            return array;
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */



    // import {ParasCls} from './parasCls.js';

    class UtilsCls {
        constructor(icn3dui) {
            this.icn3dui = icn3dui;
        }

        //Determine whether the current browser is Internet Explorer.
        isIE() { this.icn3dui;
            //http://stackoverflow.com/questions/19999388/check-if-user-is-using-ie-with-jquery
            let ua = window.navigator.userAgent;
            let msie = ua.indexOf("MSIE ");

            if (msie > 0 || !!window.navigator.userAgent.match(/Trident.*rv\:11\./))      // If Internet Explorer
                return true;
            else                 // If another browser, return 0
                return false;
        }

        //Determine whether it is a mobile device.
        isMobile() { this.icn3dui;
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(window.navigator.userAgent);
        }

        //Determine whether it is a Mac.
        isMac() { this.icn3dui;
            return /Mac/i.test(window.navigator.userAgent);
        }

        isAndroid() { this.icn3dui;
          return /android/i.test(window.navigator.userAgent.toLowerCase());
        }

        isChrome() { this.icn3dui;
          return navigator.userAgent.includes("Chrome") && navigator.vendor.includes("Google Inc");
        }

        //Determine whether Session Storage is supported in your browser. Session Storage is not supported in Safari.
        isSessionStorageSupported() { this.icn3dui;
            return window.sessionStorage;
        }

        isLocalStorageSupported() { this.icn3dui;
          return window.localStorage;
        }

        // http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
        hexToRgb(hex, a) { this.icn3dui;
             let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
             return result ? {
                 r: parseInt(result[1], 16),
                 g: parseInt(result[2], 16),
                 b: parseInt(result[3], 16),
                 a: a
             } : null;
        }

        //isCalphaPhosOnly(atomlist, atomname1, atomname2) {
        isCalphaPhosOnly(atomlist) { this.icn3dui;
              let bCalphaPhosOnly = false;

              let index = 0, testLength = 100; //30
              //var bOtherAtoms = false;
              let nOtherAtoms = 0;
              for(let i in atomlist) {
                if(index < testLength) {
                  let atomName = atomlist[i].name;   
                  if(!atomName) continue;
                  atomName = atomName.trim();

                  if(atomName !== "CA" && atomName !== "P" && atomName !== "O3'" && atomName !== "O3*") {
                    //bOtherAtoms = true;
                    //break;
                    ++nOtherAtoms;
                  }
                }
                else {
                  break;
                }

                ++index;
              }

              //if(!bOtherAtoms) {
              if(nOtherAtoms < 0.5 * index) {
                bCalphaPhosOnly = true;
              }

              return bCalphaPhosOnly;
        }

        // from iview (http://istar.cse.cuhk.edu.hk/iview/)
        //Determine whether atom1 and atom2 have covalent bond.
        hasCovalentBond(atom0, atom1) { let me = this.icn3dui;
            let r = me.parasCls.covalentRadii[atom0.elem.toUpperCase()] + me.parasCls.covalentRadii[atom1.elem.toUpperCase()];

            //return atom0.coord.distanceToSquared(atom1.coord) < 1.3 * r * r;
            let dx = atom0.coord.x - atom1.coord.x;
            let dy = atom0.coord.y - atom1.coord.y;
            let dz = atom0.coord.z - atom1.coord.z;
            let distSq = dx*dx + dy*dy + dz*dz;

            // r(N) = 0.71, r(H) = 0.31, N-H in residues are about 1.5
            // factor = (1.5 / 1.02) * (1.5 / 1.02) = 2.16
            let factor = ((atom0.elem == 'N' && atom1.elem.substr(0,1) == 'H') || (atom1.elem == 'N' && atom0.elem.substr(0,1) == 'H')) ? 2.2 : 1.3;

            return distSq < factor * r * r;
        }

        //Convert a three-letter residue name to a one-letter residue abbreviation, e.g., 'LYS' to 'K', or ' A' to 'A' for nucleotides.
        residueName2Abbr(residueName) { this.icn3dui;
          let pos = residueName.indexOf(' ');
          if(pos > 0) {
              residueName = residueName.substr(0, pos);
          }

          switch(residueName) {
            case '  A':
              return 'A';
            case '  C':
              return 'C';
            case '  G':
              return 'G';
            case '  T':
              return 'T';
            case '  U':
              return 'U';
            case '  I':
              return 'I';
            case ' DA':
              return 'A';
            case ' DC':
              return 'C';
            case ' DG':
              return 'G';
            case ' DT':
              return 'T';
            case ' DU':
              return 'U';
            case ' DI':
              return 'I';
            case 'DA':
              return 'A';
            case 'DC':
              return 'C';
            case 'DG':
              return 'G';
            case 'DT':
              return 'T';
            case 'DU':
              return 'U';
            case 'DI':
              return 'I';
            case 'ALA':
              return 'A';
            case 'ARG':
              return 'R';
            case 'ASN':
              return 'N';
            case 'ASP':
              return 'D';
            case 'CYS':
              return 'C';
            case 'GLU':
              return 'E';
            case 'GLN':
              return 'Q';
            case 'GLY':
              return 'G';
            case 'HIS':
              return 'H';
            case 'ILE':
              return 'I';
            case 'LEU':
              return 'L';
            case 'LYS':
              return 'K';
            case 'MET':
              return 'M';
            case 'PHE':
              return 'F';
            case 'PRO':
              return 'P';
            case 'SER':
              return 'S';
            case 'THR':
              return 'T';
            case 'TRP':
              return 'W';
            case 'TYR':
              return 'Y';
            case 'VAL':
              return 'V';
            case 'SEC':
              return 'U';
        //        case 'PYL':
        //          return 'O';
        //          break;

            case 'HOH':
              return 'O';
            case 'WAT':
              return 'O';

            default:
              return residueName.trim();
          }
        }

        residueAbbr2Name(residueAbbr) { this.icn3dui;
          residueAbbr = residueAbbr.toUpperCase();

          if(residueAbbr.length > 1) {
              return residueAbbr;
          }

          switch(residueAbbr) {
            case 'A':
              return 'ALA';
            case 'R':
              return 'ARG';
            case 'N':
              return 'ASN';
            case 'D':
              return 'ASP';
            case 'C':
              return 'CYS';
            case 'E':
              return 'GLU';
            case 'Q':
              return 'GLN';
            case 'G':
              return 'GLY';
            case 'H':
              return 'HIS';
            case 'I':
              return 'ILE';
            case 'L':
              return 'LEU';
            case 'K':
              return 'LYS';
            case 'M':
              return 'MET';
            case 'F':
              return 'PHE';
            case 'P':
              return 'PRO';
            case 'S':
              return 'SER';
            case 'T':
              return 'THR';
            case 'W':
              return 'TRP';
            case 'Y':
              return 'TYR';
            case 'V':
              return 'VAL';
            case 'O':
              return 'HOH';

            default:
              return residueAbbr.trim();
          }
        }

        getJSONFromArray(inArray) { this.icn3dui;
            let jsonStr = '';
            for(let i = 0, il= inArray.length; i < il; ++i) {
                jsonStr += JSON.stringify(inArray[i]);
                if(i != il - 1) jsonStr += ', ';
            }
            return jsonStr;
        }

        checkFileAPI() { this.icn3dui;
             if(!window.File || !window.FileReader || !window.FileList || !window.Blob) {
                alert('The File APIs are not fully supported in this browser.');
             }
        }

        getIdArray(resid) { this.icn3dui;
            //var idArray = resid.split('_');
            let idArray = [];

            if(resid) {
                let pos1 = resid.indexOf('_');
                let pos2 = resid.lastIndexOf('_');
                idArray.push(resid.substr(0, pos1));
                idArray.push(resid.substr(pos1 + 1, pos2 - pos1 - 1));
                idArray.push(resid.substr(pos2 + 1));
            }

            return idArray;
        }

        compResid(a, b, type) { let me = this.icn3dui;
          let aArray = a.split(',');
          let bArray = b.split(',');
          let aIdArray, bIdArray;
          if(type == 'save1') {
            aIdArray = me.utilsCls.getIdArray(aArray[0]); //aArray[0].split('_');
            bIdArray = me.utilsCls.getIdArray(bArray[0]); //bArray[0].split('_');
          }
          else if(type == 'save2') {
            aIdArray = me.utilsCls.getIdArray(aArray[1]); //aArray[1].split('_');
            bIdArray = me.utilsCls.getIdArray(bArray[1]); //bArray[1].split('_');
          }
          let aChainid = aIdArray[0] + '_' + aIdArray[1];
          let bChainid = bIdArray[0] + '_' + bIdArray[1];
          let aResi = parseInt(aIdArray[2]);
          let bResi = parseInt(bIdArray[2]);
          if(aChainid > bChainid){
            return 1;
          }
          else if(aChainid < bChainid){
            return -1;
          }
          else if(aChainid == bChainid){
            return (aResi > bResi) ? 1 :(aResi < bResi) ? -1 : 0;
          }
        }

        toggle(id1, id2, id3, id4) { this.icn3dui;
          let itemArray = [id1, id2];
          for(let i in itemArray) {
              let item = itemArray[i];
              $("#" + item).toggleClass('ui-icon-plus');
              $("#" + item).toggleClass('ui-icon-minus');
          }

          itemArray = [id1, id2, id3, id4];
          for(let i in itemArray) {
              let item = itemArray[i];
              $("#" + item).toggleClass('icn3d-shown');
              $("#" + item).toggleClass('icn3d-hidden');
          }
        }

        setViewerWidthHeight(me, bRealSize) { //let me = this.icn3dui;
            if(me.bNode) {
                me.htmlCls.WIDTH = 400;
                me.htmlCls.HEIGHT = 400;
                return;
            }

            me.htmlCls.WIDTH = $( window ).width() - me.htmlCls.LESSWIDTH;
            me.htmlCls.HEIGHT = $( window ).height() - me.htmlCls.EXTRAHEIGHT - me.htmlCls.LESSHEIGHT;

            // width from css
            let viewer_width, viewer_height;

            if(!bRealSize && me.oriWidth !== undefined && me.cfg.width.toString().indexOf('%') === -1) {
                viewer_width = me.oriWidth;
                viewer_height = me.oriHeight;
            }
            else {
                // css width and height with the unit "px"
                viewer_width = $( "#" + me.pre + "viewer" ).css('width');
                viewer_height = $( "#" + me.pre + "viewer" ).css('height');

                viewer_width = (viewer_width) ? viewer_width.replace(/px/g, '') : me.htmlCls.WIDTH;
                viewer_height = (viewer_height) ? viewer_height.replace(/px/g, '') : me.htmlCls.HEIGHT;

                if(!bRealSize) {
                    // width and height from input parameter
                    if(me.cfg.width.toString().indexOf('%') !== -1) {
                      viewer_width = $( window ).width() * me.cfg.width.substr(0, me.cfg.width.toString().indexOf('%')) / 100.0 - me.htmlCls.LESSWIDTH;
                    }
                    else if(me.cfg.width) {
                      viewer_width = parseInt(me.cfg.width);
                    }

                    if(me.cfg.height.toString().indexOf('%') !== -1) {
                      viewer_height = $( window ).height() * me.cfg.height.substr(0, me.cfg.height.toString().indexOf('%')) / 100.0 - me.htmlCls.EXTRAHEIGHT - me.htmlCls.LESSHEIGHT;
                    }
                    else if(me.cfg.height) {
                      viewer_height = parseInt(me.cfg.height);
                    }
                }
            }

            if(viewer_width && me.htmlCls.WIDTH > viewer_width) me.htmlCls.WIDTH = viewer_width;
            if(viewer_height && me.htmlCls.HEIGHT > viewer_height) me.htmlCls.HEIGHT = viewer_height;
        }

        sumArray(numArray) {
          let sum = 0;

          for(let i = 0, il = numArray.length; i < il; ++i) {
            sum += numArray[i];
          }

          return sum;
        }

        getMemDesc() {
          return "<div style='width:150px'><span style='color:red'>Red</span> and <span style='color:blue'>blue</span> membranes indicate <span style='color:red'>extracellular</span> and <span style='color:blue'>intracellular</span> membranes, respectively.<br><br></div>";
        }

        getStructures(atoms) { let me = this.icn3dui;
          let idHash = {};
          for(let i in atoms) {
              let structureid = me.icn3d.atoms[i].structure;
              idHash[structureid] = 1;
          }

          return idHash;
        }

        getHlStructures(atoms) { let me = this.icn3dui;
          if(!atoms) atoms = me.icn3d.hAtoms;

          return this.getStructures(atoms);
        }

        getDisplayedStructures(atoms) { let me = this.icn3dui;
          if(!atoms) atoms = me.icn3d.dAtoms;

          return this.getStructures(atoms);
        }

        getDateDigitStr() { this.icn3dui;
          let date = new Date();
          let monthStr =(date.getMonth() + 1).toString();
          if(date.getMonth() + 1 < 10) monthStr = '0' + monthStr;

          let dateStr = date.getDate().toString();
          if(date.getDate() < 10) dateStr = '0' + dateStr;

          return date.getFullYear().toString() + monthStr + dateStr;
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */



    class ParasCls {
        constructor(icn3dui) {
            this.icn3dui = icn3dui;

            // https://pubs.acs.org/doi/pdf/10.1021/acs.jproteome.8b00473
            this.glycanHash = {
                'GLC': {'c': '1E90FF', 's': 'sphere'},
                'BGC': {'c': '1E90FF', 's': 'sphere'},

                'NAG': {'c': '1E90FF', 's': 'cube'},
                'NDG': {'c': '1E90FF', 's': 'cube'},
                'GCS': {'c': '1E90FF', 's': 'cube'},
                'PA1': {'c': '1E90FF', 's': 'cube'},

                'GCU': {'c': '1E90FF', 's': 'cone'},
                'BDP': {'c': '1E90FF', 's': 'cone'},
                'G6D': {'c': '1E90FF', 's': 'cone'},

                'DDA': {'c': '1E90FF', 's': 'cylinder'},
                'B6D': {'c': '1E90FF', 's': 'cylinder'},
                'XXM': {'c': '1E90FF', 's': 'cylinder'},


                'MAN': {'c': '00FF00', 's': 'sphere'},
                'BMA': {'c': '00FF00', 's': 'sphere'},

                'BM3': {'c': '00FF00', 's': 'cube'},
                '95Z': {'c': '00FF00', 's': 'cube'},

                'MAV': {'c': '00FF00', 's': 'cone'},
                'BEM': {'c': '00FF00', 's': 'cone'},
                'RAM': {'c': '00FF00', 's': 'cone'},
                'RM4': {'c': '00FF00', 's': 'cone'},

                'TYV': {'c': '00FF00', 's': 'cylinder'},
                'ARA': {'c': '00FF00', 's': 'cylinder'},
                'ARB': {'c': '00FF00', 's': 'cylinder'},
                'KDN': {'c': '00FF00', 's': 'cylinder'},
                'KDM': {'c': '00FF00', 's': 'cylinder'},
                '6PZ': {'c': '00FF00', 's': 'cylinder'},
                'GMH': {'c': '00FF00', 's': 'cylinder'},
                'BDF': {'c': '00FF00', 's': 'cylinder'},


                'GAL': {'c': 'FFFF00', 's': 'sphere'},
                'GLA': {'c': 'FFFF00', 's': 'sphere'},

                'NGA': {'c': 'FFFF00', 's': 'cube'},
                'A2G': {'c': 'FFFF00', 's': 'cube'},
                'X6X': {'c': 'FFFF00', 's': 'cube'},
                '1GN': {'c': 'FFFF00', 's': 'cube'},

                'ADA': {'c': 'FFFF00', 's': 'cone'},
                'GTR': {'c': 'FFFF00', 's': 'cone'},

                'LDY': {'c': 'FFFF00', 's': 'cylinder'},
                'KDO': {'c': 'FFFF00', 's': 'cylinder'},
                'T6T': {'c': 'FFFF00', 's': 'cylinder'},


                'GUP': {'c': 'A52A2A', 's': 'sphere'},
                'GL0': {'c': 'A52A2A', 's': 'sphere'},

                'LGU': {'c': 'A52A2A', 's': 'cone'},

                'ABE': {'c': 'A52A2A', 's': 'cylinder'},
                'XYS': {'c': 'A52A2A', 's': 'cylinder'},
                'XYP': {'c': 'A52A2A', 's': 'cylinder'},
                'SOE': {'c': 'A52A2A', 's': 'cylinder'},


                'PZU': {'c': 'FF69B4', 's': 'cylinder'},
                'RIP': {'c': 'FF69B4', 's': 'cylinder'},
                '0MK': {'c': 'FF69B4', 's': 'cylinder'},


                'ALL': {'c': '8A2BE2', 's': 'sphere'},
                'AFD': {'c': '8A2BE2', 's': 'sphere'},

                'NAA': {'c': '8A2BE2', 's': 'cube'},

                'SIA': {'c': '8A2BE2', 's': 'cylinder'},
                'SIB': {'c': '8A2BE2', 's': 'cylinder'},
                'AMU': {'c': '8A2BE2', 's': 'cylinder'},


                'X0X': {'c': '1E90FF', 's': 'cone'},
                'X1X': {'c': '1E90FF', 's': 'cone'},

                'NGC': {'c': '1E90FF', 's': 'cylinder'},
                'NGE': {'c': '1E90FF', 's': 'cylinder'},


                '4N2': {'c': 'A0522D', 's': 'sphere'},

                'HSQ': {'c': 'A0522D', 's': 'cube'},

                'IDR': {'c': 'A0522D', 's': 'cone'},

                'MUR': {'c': 'A0522D', 's': 'cylinder'},


                'FUC': {'c': 'FF0000', 's': 'cone'},
                'FUL': {'c': 'FF0000', 's': 'cone'}
            };

            // added nucleotides and ions
            this.nucleotidesArray = ['  G', '  A', '  T', '  C', '  U', ' DG', ' DA', ' DT', ' DC', ' DU',
                'G', 'A', 'T', 'C', 'U', 'DG', 'DA', 'DT', 'DC', 'DU'];

            this.ionsArray = ['  K', ' NA', ' MG', ' AL', ' CA', ' TI', ' MN', ' FE', ' NI', ' CU', ' ZN', ' AG', ' BA',
                '  F', ' CL', ' BR', '  I', 'K', 'NA', 'MG', 'AL', 'CA', 'TI', 'MN', 'FE', 'NI', 'CU', 'ZN', 'AG', 'BA',
                'F', 'CL', 'BR', 'I'];

            this.cationsTrimArray = ['K', 'NA', 'MG', 'AL', 'CA', 'TI', 'MN', 'FE', 'NI', 'CU', 'ZN', 'AG', 'BA'];
            this.anionsTrimArray = ['F', 'CL', 'BR', 'I'];

            this.ionCharges = {K: 1, NA: 1, MG: 2, AL: 3, CA: 2, TI: 3, MN: 2, FE: 3, NI: 2, CU: 2, ZN: 2, AG: 1, BA: 2};

            this.vdwRadii = { // Hu, S.Z.; Zhou, Z.H.; Tsai, K.R. Acta Phys.-Chim. Sin., 2003, 19:1073.
                 H: 1.08,           HE: 1.34,           LI: 1.75,           BE: 2.05,            B: 1.47,
                 C: 1.49,            N: 1.41,            O: 1.40,            F: 1.39,           NE: 1.68,
                 NA: 1.84,          MG: 2.05,           AL: 2.11,           SI: 2.07,            P: 1.92,
                 S: 1.82,           CL: 1.83,           AR: 1.93,            K: 2.05,           CA: 2.21,
                 SC: 2.16,          TI: 1.87,            V: 1.79,           CR: 1.89,           MN: 1.97,
                 FE: 1.94,          CO: 1.92,           NI: 1.84,           CU: 1.86,           ZN: 2.10,
                 GA: 2.08,          GE: 2.15,           AS: 2.06,           SE: 1.93,           BR: 1.98,
                 KR: 2.12,          RB: 2.16,           SR: 2.24,            Y: 2.19,           ZR: 1.86,
                 NB: 2.07,          MO: 2.09,           TC: 2.09,           RU: 2.07,           RH: 1.95,
                 PD: 2.02,          AG: 2.03,           CD: 2.30,           IN: 2.36,           SN: 2.33,
                 SB: 2.25,          TE: 2.23,            I: 2.23,           XE: 2.21,           CS: 2.22,
                 BA: 2.51,          LA: 2.40,           CE: 2.35,           PR: 2.39,           ND: 2.29,
                 PM: 2.36,          SM: 2.29,           EU: 2.33,           GD: 2.37,           TB: 2.21,
                 DY: 2.29,          HO: 2.16,           ER: 2.35,           TM: 2.27,           YB: 2.42,
                 LU: 2.21,          HF: 2.12,           TA: 2.17,            W: 2.10,           RE: 2.17,
                 OS: 2.16,          IR: 2.02,           PT: 2.09,           AU: 2.17,           HG: 2.09,
                 TL: 2.35,          PB: 2.32,           BI: 2.43,           PO: 2.29,           AT: 2.36,
                 RN: 2.43,          FR: 2.56,           RA: 2.43,           AC: 2.60,           TH: 2.37,
                 PA: 2.43,           U: 2.40,           NP: 2.21,           PU: 2.56,           AM: 2.56,
                 CM: 2.56,          BK: 2.56,           CF: 2.56,           ES: 2.56,           FM: 2.56
            };

            this.covalentRadii = { // http://en.wikipedia.org/wiki/Covalent_radius
                 H: 0.31,           HE: 0.28,           LI: 1.28,           BE: 0.96,            B: 0.84,
                 C: 0.76,            N: 0.71,            O: 0.66,            F: 0.57,           NE: 0.58,
                 NA: 1.66,          MG: 1.41,           AL: 1.21,           SI: 1.11,            P: 1.07,
                 S: 1.05,           CL: 1.02,           AR: 1.06,            K: 2.03,           CA: 1.76,
                 SC: 1.70,          TI: 1.60,            V: 1.53,           CR: 1.39,           MN: 1.39,
                 FE: 1.32,          CO: 1.26,           NI: 1.24,           CU: 1.32,           ZN: 1.22,
                 GA: 1.22,          GE: 1.20,           AS: 1.19,           SE: 1.20,           BR: 1.20,
                 KR: 1.16,          RB: 2.20,           SR: 1.95,            Y: 1.90,           ZR: 1.75,
                 NB: 1.64,          MO: 1.54,           TC: 1.47,           RU: 1.46,           RH: 1.42,
                 PD: 1.39,          AG: 1.45,           CD: 1.44,           IN: 1.42,           SN: 1.39,
                 SB: 1.39,          TE: 1.38,            I: 1.39,           XE: 1.40,           CS: 2.44,
                 BA: 2.15,          LA: 2.07,           CE: 2.04,           PR: 2.03,           ND: 2.01,
                 PM: 1.99,          SM: 1.98,           EU: 1.98,           GD: 1.96,           TB: 1.94,
                 DY: 1.92,          HO: 1.92,           ER: 1.89,           TM: 1.90,           YB: 1.87,
                 LU: 1.87,          HF: 1.75,           TA: 1.70,            W: 1.62,           RE: 1.51,
                 OS: 1.44,          IR: 1.41,           PT: 1.36,           AU: 1.36,           HG: 1.32,
                 TL: 1.45,          PB: 1.46,           BI: 1.48,           PO: 1.40,           AT: 1.50,
                 RN: 1.50,          FR: 2.60,           RA: 2.21,           AC: 2.15,           TH: 2.06,
                 PA: 2.00,           U: 1.96,           NP: 1.90,           PU: 1.87,           AM: 1.80,
                 CM: 1.69
            };

        /*
            this.surfaces = {
                1: undefined,
                2: undefined,
                3: undefined,
                4: undefined
            };
        */

            //'C': this.thr(0xC8C8C8),
            this.atomColors = {
                'H': this.thr(0xFFFFFF),       'He': this.thr(0xFFC0CB),      'HE': this.thr(0xFFC0CB),
                'Li': this.thr(0xB22222),      'LI': this.thr(0xB22222),      'B': this.thr(0x00FF00),
                'C': this.thr(0xAAAAAA),       'N': this.thr(0x0000FF),       'O': this.thr(0xF00000),
                'F': this.thr(0xDAA520),       'Na': this.thr(0x0000FF),      'NA': this.thr(0x0000FF),
                'Mg': this.thr(0x228B22),      'MG': this.thr(0x228B22),      'Al': this.thr(0x808090),
                'AL': this.thr(0x808090),      'Si': this.thr(0xDAA520),      'SI': this.thr(0xDAA520),
                'P': this.thr(0xFFA500),       'S': this.thr(0xFFC832),       'Cl': this.thr(0x00FF00),
                'CL': this.thr(0x00FF00),      'Ca': this.thr(0x808090),      'CA': this.thr(0x808090),
                'Ti': this.thr(0x808090),      'TI': this.thr(0x808090),      'Cr': this.thr(0x808090),
                'CR': this.thr(0x808090),      'Mn': this.thr(0x808090),      'MN': this.thr(0x808090),
                'Fe': this.thr(0xFFA500),      'FE': this.thr(0xFFA500),      'Ni': this.thr(0xA52A2A),
                'NI': this.thr(0xA52A2A),      'Cu': this.thr(0xA52A2A),      'CU': this.thr(0xA52A2A),
                'Zn': this.thr(0xA52A2A),      'ZN': this.thr(0xA52A2A),      'Br': this.thr(0xA52A2A),
                'BR': this.thr(0xA52A2A),      'Ag': this.thr(0x808090),      'AG': this.thr(0x808090),
                'I': this.thr(0xA020F0),       'Ba': this.thr(0xFFA500),      'BA': this.thr(0xFFA500),
                'Au': this.thr(0xDAA520),      'AU': this.thr(0xDAA520)
            };

            this.atomnames = {
                'H': 'Hydrogen',        'HE': 'Helium',         'LI': 'Lithium',        'B': 'Boron',           
                'C': 'Carbon',          'N': 'Nitrogen',        'O': 'Oxygen',          'F': 'Fluorine',       
                'NA': 'Sodium',         'MG': 'Magnesium',      'AL': 'Aluminum',       'SI': 'Silicon',      
                'P': 'Phosphorus',      'S': 'Sulfur',          'CL': 'Chlorine',       'CA': 'Calcium',      
                'TI': 'Titanium',       'CR': 'Chromium',       'MN': 'Manganese',      'FE': 'Iron',      
                'NI': 'Nickel',         'CU': 'Copper',         'ZN': 'Zinc',           'BR': 'Bromine',
                'AG': 'Silver',         'I': 'Iodine',          'BA': 'Barium',         'AU': 'Gold'
            };

            this.defaultAtomColor = this.thr(0xCCCCCC);

            this.stdChainColors = [
                // first 6 colors from MMDB
                this.thr(0xFF00FF),            this.thr(0x0000FF),            this.thr(0x996633),
                this.thr(0x00FF99),            this.thr(0xFF9900),            this.thr(0xFF6666),
                this.thr(0x32CD32),            this.thr(0x1E90FF),            this.thr(0xFA8072),
                this.thr(0xFFA500),            this.thr(0x00CED1),            this.thr(0xFF69B4),
                this.thr(0x00FF00),            this.thr(0x0000FF),            this.thr(0xFF0000),
                this.thr(0xFFFF00),            this.thr(0x00FFFF),            this.thr(0xFF00FF),
                this.thr(0x3CB371),            this.thr(0x4682B4),            this.thr(0xCD5C5C),
                this.thr(0xFFE4B5),            this.thr(0xAFEEEE),            this.thr(0xEE82EE),
                this.thr(0x006400),            this.thr(0x00008B),            this.thr(0x8B0000),
                this.thr(0xCD853F),            this.thr(0x008B8B),            this.thr(0x9400D3)
            ];

            this.backgroundColors = {
                'black': this.thr(0x000000),
                 'grey': this.thr(0xCCCCCC),
                'white': this.thr(0xFFFFFF),
                'transparent': this.thr(0xFFFFFF) //this.thr(0x000000)
            };

            this.residueColors = {
                ALA: this.thr(0xC8C8C8),       ARG: this.thr(0x145AFF),       ASN: this.thr(0x00DCDC),
                ASP: this.thr(0xE60A0A),       CYS: this.thr(0xE6E600),       GLN: this.thr(0x00DCDC),
                GLU: this.thr(0xE60A0A),       GLY: this.thr(0xEBEBEB),       HIS: this.thr(0x8282D2),
                ILE: this.thr(0x0F820F),       LEU: this.thr(0x0F820F),       LYS: this.thr(0x145AFF),
                MET: this.thr(0xE6E600),       PHE: this.thr(0x3232AA),       PRO: this.thr(0xDC9682),
                SER: this.thr(0xFA9600),       THR: this.thr(0xFA9600),       TRP: this.thr(0xB45AB4),
                TYR: this.thr(0x3232AA),       VAL: this.thr(0x0F820F),       ASX: this.thr(0xFF69B4),
                GLX: this.thr(0xFF69B4),         'G': this.thr(0x008000),       'A': this.thr(0x6080FF),
                'T': this.thr(0xFF8000),         'C': this.thr(0xFF0000),       'U': this.thr(0xFF8000),
                'DG': this.thr(0x008000),       'DA': this.thr(0x6080FF),      'DT': this.thr(0xFF8000),
                'DC': this.thr(0xFF0000),       'DU': this.thr(0xFF8000)
            };

            // calculated in iCn3D, the value could fluctuate 10-20 in different proteins
            this.residueArea = {
                ALA: 247,       ARG: 366,       ASN: 290,       ASP: 285,       CYS: 271,
                GLN: 336,       GLU: 325,       GLY: 217,       HIS: 340,       ILE: 324,
                LEU: 328,       LYS: 373,       MET: 346,       PHE: 366,       PRO: 285,
                SER: 265,       THR: 288,       TRP: 414,       TYR: 387,       VAL: 293,
                ASX: 290,       GLX: 336,         'G': 520,       'A': 507,       'T': 515,
                'C': 467,         'U': 482,      'DG': 520,      'DA': 507,      'DT': 515,
                'DC': 467,       'DU': 482
            };

            this.defaultResidueColor = this.thr(0xBEA06E);

            this.chargeColors = {
                // charged residues
                '  G': this.thr(0xFF0000),     '  A': this.thr(0xFF0000),     '  T': this.thr(0xFF0000),
                '  C': this.thr(0xFF0000),     '  U': this.thr(0xFF0000),     ' DG': this.thr(0xFF0000),
                ' DA': this.thr(0xFF0000),     ' DT': this.thr(0xFF0000),     ' DC': this.thr(0xFF0000),
                ' DU': this.thr(0xFF0000),       'G': this.thr(0xFF0000),       'A': this.thr(0xFF0000),
                'T': this.thr(0xFF0000),         'C': this.thr(0xFF0000),       'U': this.thr(0xFF0000),
                'DG': this.thr(0xFF0000),       'DA': this.thr(0xFF0000),      'DT': this.thr(0xFF0000),
                'DC': this.thr(0xFF0000),       'DU': this.thr(0xFF0000),     'ARG': this.thr(0x0000FF),
                'LYS': this.thr(0x0000FF),     'ASP': this.thr(0xFF0000),     'GLU': this.thr(0xFF0000),
                'HIS': this.thr(0x8080FF),     'GLY': this.thr(0x888888),     'PRO': this.thr(0x888888),
                'ALA': this.thr(0x888888),     'VAL': this.thr(0x888888),     'LEU': this.thr(0x888888),
                'ILE': this.thr(0x888888),     'PHE': this.thr(0x888888),     'SER': this.thr(0x888888),
                'THR': this.thr(0x888888),     'ASN': this.thr(0x888888),     'GLN': this.thr(0x888888),
                'TYR': this.thr(0x888888),     'MET': this.thr(0x888888),     'CYS': this.thr(0x888888),
                'TRP': this.thr(0x888888)
            };

            this.hydrophobicColors = {
                // charged residues
                '  G': this.thr(0xFF0000),     '  A': this.thr(0xFF0000),     '  T': this.thr(0xFF0000),
                '  C': this.thr(0xFF0000),     '  U': this.thr(0xFF0000),     ' DG': this.thr(0xFF0000),
                ' DA': this.thr(0xFF0000),     ' DT': this.thr(0xFF0000),     ' DC': this.thr(0xFF0000),
                ' DU': this.thr(0xFF0000),       'G': this.thr(0xFF0000),       'A': this.thr(0xFF0000),
                'T': this.thr(0xFF0000),         'C': this.thr(0xFF0000),       'U': this.thr(0xFF0000),
                'DG': this.thr(0xFF0000),       'DA': this.thr(0xFF0000),      'DT': this.thr(0xFF0000),
                'DC': this.thr(0xFF0000),       'DU': this.thr(0xFF0000),     'ARG': this.thr(0x0000FF),
                'LYS': this.thr(0x0000FF),     'ASP': this.thr(0xFF0000),     'GLU': this.thr(0xFF0000),
                'HIS': this.thr(0x8080FF),

                //this.thr().setHSL(1/3.0, 1, 0.5 + 0.5 * ( + 0.81)/(1.14 + 0.81)),
                // hydrophobic
                // https://en.m.wikipedia.org/wiki/Hydrophobicity_scales#Wimley%E2%80%93White_whole_residue_hydrophobicity_scales
                'TRP': this.thr().setHSL(1/3.0, 1, 0.5 + 0.5 * (-2.09 + 2.09) / (0 + 2.09)),
                'PHE': this.thr().setHSL(1/3.0, 1, 0.5 + 0.5 * (-1.71 + 2.09) / (0 + 2.09)),
                'LEU': this.thr().setHSL(1/3.0, 1, 0.5 + 0.5 * (-1.25 + 2.09) / (0 + 2.09)),
                'ILE': this.thr().setHSL(1/3.0, 1, 0.5 + 0.5 * (-1.12 + 2.09) / (0 + 2.09)),
                'TYR': this.thr().setHSL(1/3.0, 1, 0.5 + 0.5 * (-0.71 + 2.09) / (0 + 2.09)),
                'MET': this.thr().setHSL(1/3.0, 1, 0.5 + 0.5 * (-0.67 + 2.09) / (0 + 2.09)),
                'VAL': this.thr().setHSL(1/3.0, 1, 0.5 + 0.5 * (-0.46 + 2.09) / (0 + 2.09)),
                'CYS': this.thr().setHSL(1/3.0, 1, 0.5 + 0.5 * (-0.02 + 2.09) / (0 + 2.09)),

                // polar
                'PRO': this.thr().setHSL(1/6.0, 1, 0.5 + 0.5 * (-0.14 + 1.15) / (0 + 1.15)),
                'THR': this.thr().setHSL(1/6.0, 1, 0.5 + 0.5 * (-0.25 + 1.15) / (0 + 1.15)),
                'SER': this.thr().setHSL(1/6.0, 1, 0.5 + 0.5 * (-0.46 + 1.15) / (0 + 1.15)),
                'ALA': this.thr().setHSL(1/6.0, 1, 0.5 + 0.5 * (-0.50 + 1.15) / (0 + 1.15)),
                'GLN': this.thr().setHSL(1/6.0, 1, 0.5 + 0.5 * (-0.77 + 1.15) / (0 + 1.15)),
                'ASN': this.thr().setHSL(1/6.0, 1, 0.5 + 0.5 * (-0.85 + 1.15) / (0 + 1.15)),
                'GLY': this.thr().setHSL(1/6.0, 1, 0.5 + 0.5 * (-1.15 + 1.15) / (0 + 1.15))
            };

            this.normalizedHPColors = {
                // charged residues
                '  G': this.thr(0xFFFFFF),     '  A': this.thr(0xFFFFFF),     '  T': this.thr(0xFFFFFF),
                '  C': this.thr(0xFFFFFF),     '  U': this.thr(0xFFFFFF),     ' DG': this.thr(0xFFFFFF),
                ' DA': this.thr(0xFFFFFF),     ' DT': this.thr(0xFFFFFF),     ' DC': this.thr(0xFFFFFF),
                ' DU': this.thr(0xFFFFFF),       'G': this.thr(0xFFFFFF),       'A': this.thr(0xFFFFFF),
                'T': this.thr(0xFFFFFF),         'C': this.thr(0xFFFFFF),       'U': this.thr(0xFFFFFF),
                'DG': this.thr(0xFFFFFF),       'DA': this.thr(0xFFFFFF),      'DT': this.thr(0xFFFFFF),
                'DC': this.thr(0xFFFFFF),       'DU': this.thr(0xFFFFFF),     'ARG': this.thr(0xFFFFFF),
                'LYS': this.thr(0xFFFFFF),     'ASP': this.thr(0xFFFFFF),     'GLU': this.thr(0xFFFFFF),
                'HIS': this.thr(0xFFFFFF),

                //this.thr().setHSL(1/3.0, 1, 0.5 + 0.5 * ( + 0.81)/(1.14 + 0.81)),
                // hydrophobic
                // https://en.m.wikipedia.org/wiki/Hydrophobicity_scales#Wimley%E2%80%93White_whole_residue_hydrophobicity_scales
                // 1.15 ~ -2.09: white ~ green
                'TRP': this.thr().setHSL(1/3.0, 1, 0.5 + 0.5 * (-2.09 + 2.09) / 3.24),
                'PHE': this.thr().setHSL(1/3.0, 1, 0.5 + 0.5 * (-1.71 + 2.09) / 3.24),
                'LEU': this.thr().setHSL(1/3.0, 1, 0.5 + 0.5 * (-1.25 + 2.09) / 3.24),
                'ILE': this.thr().setHSL(1/3.0, 1, 0.5 + 0.5 * (-1.12 + 2.09) / 3.24),
                'TYR': this.thr().setHSL(1/3.0, 1, 0.5 + 0.5 * (-0.71 + 2.09) / 3.24),
                'MET': this.thr().setHSL(1/3.0, 1, 0.5 + 0.5 * (-0.67 + 2.09) / 3.24),
                'VAL': this.thr().setHSL(1/3.0, 1, 0.5 + 0.5 * (-0.46 + 2.09) / 3.24),
                'CYS': this.thr().setHSL(1/3.0, 1, 0.5 + 0.5 * (-0.02 + 2.09) / 3.24),

                // polar
                'PRO': this.thr().setHSL(1/3.0, 1, 0.5 + 0.5 * (0.14 + 2.09) / 3.24),
                'THR': this.thr().setHSL(1/3.0, 1, 0.5 + 0.5 * (0.25 + 2.09) / 3.24),
                'SER': this.thr().setHSL(1/3.0, 1, 0.5 + 0.5 * (0.46 + 2.09) / 3.24),
                'ALA': this.thr().setHSL(1/3.0, 1, 0.5 + 0.5 * (0.50 + 2.09) / 3.24),
                'GLN': this.thr().setHSL(1/3.0, 1, 0.5 + 0.5 * (0.77 + 2.09) / 3.24),
                'ASN': this.thr().setHSL(1/3.0, 1, 0.5 + 0.5 * (0.85 + 2.09) / 3.24),
                'GLY': this.thr().setHSL(1/3.0, 1, 0.5 + 0.5 * (1.15 + 2.09) / 3.24)
            };

            this.hydrophobicValues = {
                // charged residues, larger than max polar (1.15)
                '  G': 3,     '  A': 3,     '  T': 3,
                '  C': 3,     '  U': 3,     ' DG': 3,
                ' DA': 3,     ' DT': 3,     ' DC': 3,
                ' DU': 3,       'G': 3,       'A': 3,
                'T': 3,         'C': 3,       'U': 3,
                'DG': 3,       'DA': 3,      'DT': 3,
                'DC': 3,       'DU': 3,     'ARG': 1.5,
                'LYS': 1.5,     'ASP': 3,     'GLU': 3,
                'HIS': 2,

                // hydrophobic
                // https://en.m.wikipedia.org/wiki/Hydrophobicity_scales#Wimley%E2%80%93White_whole_residue_hydrophobicity_scales
                // 1.15 ~ -2.09: white ~ green
                'TRP': -2.09,
                'PHE': -1.71,
                'LEU': -1.25,
                'ILE': -1.12,
                'TYR': -0.71,
                'MET': -0.67,
                'VAL': -0.46,
                'CYS': -0.02,

                // polar
                'PRO': 0.14,
                'THR': 0.25,
                'SER': 0.46,
                'ALA': 0.50,
                'GLN': 0.77,
                'ASN': 0.85,
                'GLY': 1.15
            };

            this.residueAbbrev = {
                ALA: "A (Ala)",       ARG: "R (Arg)",       ASN: "N (Asn)",
                ASP: "D (Asp)",       CYS: "C (Cys)",       GLN: "Q (Gln)",
                GLU: "E (Glu)",       GLY: "G (Gly)",       HIS: "H (His)",
                ILE: "I (Ile)",       LEU: "L (Leu)",       LYS: "K (Lys)",
                MET: "M (Met)",       PHE: "F (Phe)",       PRO: "P (Pro)",
                SER: "S (Ser)",       THR: "T (Thr)",       TRP: "W (Trp)",
                TYR: "Y (Tyr)",       VAL: "V (Val)",       
                //ASX: "B (Asx)",       GLX: "Z (Glx)",   
                ASX: "X (Asx)",       GLX: "X (Glx)",       
                'G': "Guanine",       'A': "Adenine",
                'T': "Thymine",         'C': "Cytosine",       'U': "Uracil",
                'DG': "deoxy-Guanine",       'DA': "deoxy-Adenine",      'DT': "deoxy-Thymine",
                'DC': "deoxy-Cytosine",       'DU': 'deoxy-Uracil'
            };

            this.ssColors = {
                helix: this.thr(0xFF0000),
                sheet: this.thr(0x008000),
                 coil: this.thr(0x6080FF) //this.thr(0xEEEEEE) //this.thr(0x6080FF)
            };

            this.ssColors2 = {
                helix: this.thr(0xFF0000),
                sheet: this.thr(0xFFC800),
                 coil: this.thr(0x6080FF) //this.thr(0xEEEEEE) //this.thr(0x6080FF)
            };

            this.resn2restype = {
                "ALA": 1, "ARG": 4, "ASN": 7, "ASP": 10, "CYS": 13, "GLN": 16, "GLU": 19, "GLY": 22, "HIS": 25, "ILE": 28, "LEU": 31, "LYS": 34, "MET": 37, "PHE": 40, "PRO": 43, "SER": 46, "THR": 49, "TRP": 52, "TYR": 55, "VAL": 58
            };

            this.nuclMainArray = ["C1'", "C1*", "C2'", "C2*", "C3'", "C3*", "C4'", "C4*", "C5'", "C5*", "O3'", "O3*", "O4'", "O4*", "O5'", "O5*", "P", "OP1", "O1P", "OP2", "O2P"];

            // https://www.ncbi.nlm.nih.gov/Class/FieldGuide/BLOSUM62.txt, range from -4 to 11
            this.b62ResArray = ['A', 'R', 'N', 'D', 'C', 'Q', 'E', 'G', 'H', 'I', 'L', 'K', 'M', 'F',
                'P', 'S', 'T', 'W', 'Y', 'V', 'B', 'Z', 'X', '*']; // length: 24
            this.b62Matrix = [
                [4, -1, -2, -2, 0, -1, -1, 0, -2, -1, -1, -1, -1, -2, -1, 1, 0, -3, -2, 0, -2, -1, 0, -4],
                [-1, 5, 0, -2, -3, 1, 0, -2, 0, -3, -2, 2, -1, -3, -2, -1, -1, -3, -2, -3, -1, 0, -1, -4],
                [-2, 0, 6, 1, -3, 0, 0, 0, 1, -3, -3, 0, -2, -3, -2, 1, 0, -4, -2, -3, 3, 0, -1, -4],
                [-2, -2, 1, 6, -3, 0, 2, -1, -1, -3, -4, -1, -3, -3, -1, 0, -1, -4, -3, -3, 4, 1, -1, -4],
                [0, -3, -3, -3, 9, -3, -4, -3, -3, -1, -1, -3, -1, -2, -3, -1, -1, -2, -2, -1, -3, -3, -2, -4],
                [-1, 1, 0, 0, -3, 5, 2, -2, 0, -3, -2, 1, 0, -3, -1, 0, -1, -2, -1, -2, 0, 3, -1, -4],
                [-1, 0, 0, 2, -4, 2, 5, -2, 0, -3, -3, 1, -2, -3, -1, 0, -1, -3, -2, -2, 1, 4, -1, -4],
                [0, -2, 0, -1, -3, -2, -2, 6, -2, -4, -4, -2, -3, -3, -2, 0, -2, -2, -3, -3, -1, -2, -1, -4],
                [-2, 0, 1, -1, -3, 0, 0, -2, 8, -3, -3, -1, -2, -1, -2, -1, -2, -2, 2, -3, 0, 0, -1, -4],
                [-1, -3, -3, -3, -1, -3, -3, -4, -3, 4, 2, -3, 1, 0, -3, -2, -1, -3, -1, 3, -3, -3, -1, -4],
                [-1, -2, -3, -4, -1, -2, -3, -4, -3, 2, 4, -2, 2, 0, -3, -2, -1, -2, -1, 1, -4, -3, -1, -4],
                [-1, 2, 0, -1, -3, 1, 1, -2, -1, -3, -2, 5, -1, -3, -1, 0, -1, -3, -2, -2, 0, 1, -1, -4],
                [-1, -1, -2, -3, -1, 0, -2, -3, -2, 1, 2, -1, 5, 0, -2, -1, -1, -1, -1, 1, -3, -1, -1, -4],
                [-2, -3, -3, -3, -2, -3, -3, -3, -1, 0, 0, -3, 0, 6, -4, -2, -2, 1, 3, -1, -3, -3, -1, -4],
                [-1, -2, -2, -1, -3, -1, -1, -2, -2, -3, -3, -1, -2, -4, 7, -1, -1, -4, -3, -2, -2, -1, -2, -4],
                [1, -1, 1, 0, -1, 0, 0, 0, -1, -2, -2, 0, -1, -2, -1, 4, 1, -3, -2, -2, 0, 0, 0, -4],
                [0, -1, 0, -1, -1, -1, -1, -2, -2, -1, -1, -1, -1, -2, -1, 1, 5, -2, -2, 0, -1, -1, 0, -4],
                [-3, -3, -4, -4, -2, -2, -3, -2, -2, -3, -2, -3, -1, 1, -4, -3, -2, 11, 2, -3, -4, -3, -2, -4],
                [-2, -2, -2, -3, -2, -1, -2, -3, 2, -1, -1, -2, -1, 3, -3, -2, -2, 2, 7, -1, -3, -2, -1, -4],
                [0, -3, -3, -3, -1, -2, -2, -3, -3, 3, 1, -2, 1, -1, -2, -2, 0, -3, -1, 4, -3, -2, -1, -4],
                [-2, -1, 3, 4, -3, 0, 1, -1, 0, -3, -4, 0, -3, -3, -2, 0, -1, -4, -3, -3, 4, 1, -1, -4],
                [-1, 0, 0, 1, -3, 3, 4, -2, 0, -3, -3, 1, -1, -3, -1, 0, -1, -3, -2, -2, 1, 4, -1, -4],
                [0, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, 0, 0, -2, -1, -1, -1, -1, -1, -4],
                [-4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, 1],
            ];
        }

        thr(color) { this.icn3dui;
            if(color == '#0') color = '#000';
            return new THREE.Color(color);
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class MyEventCls {
        constructor(icn3dui) {
            this.icn3dui = icn3dui;
        }

        onId(id, eventName, myFunction) { this.icn3dui;
            if(Object.keys(window).length < 2) return;

            if(id.substr(0, 1) == '#') id = id.substr(1);
            if(document.getElementById(id)) {
                let eventArray = eventName.split(' ');
                eventArray.forEach(event => {
                    document.getElementById(id).addEventListener(event, myFunction);
                });
            }
        }

        onIds(idArray, eventName, myFunction) { let me = this.icn3dui;
            let bArray = Array.isArray(idArray);
            if(bArray) {
                idArray.forEach(id => {
                    me.myEventCls.onId(id, eventName, myFunction);
                });
            }
            else {
                me.myEventCls.onId(idArray, eventName, myFunction);
            }
        }

        // CSS selector such as class
    /*
        onSel(selector, eventName, myFunction) { let me = this.icn3dui;
            let elemArray = document.querySelectorAll(selector); // non-live
            elemArray.forEach(elem => {
                let eventArray = eventName.split(' ');
                eventArray.forEach(event => {
                    elem.addEventListener(event, myFunction);
                });
            });
        }

        onSelClass(selector, eventName, myFunction) { let me = this.icn3dui;
            selector = selector.replace(/\./gi, '');
            let classArray = selector.split(',');
            classArray.forEach(item => {
                let elemArray = document.getElementsByClassName(item.trim()); // live
                if(Array.isArray(elemArray)) {
                    elemArray.forEach(elem => {
                        let eventArray = eventName.split(' ');
                        eventArray.forEach(event => {
                            elem.addEventListener(event, myFunction);
                        });
                    });
                }
            });
        }
    */
    }

    // from Thomas Madej at NCBI
    /* A routine to return the superposition rmsd for 'n' pairs of corresponding
     * points.  It also returns the translation vectors and rotation matrix.
     *
     * Based on the appendix in the paper:
     *
     *  A.D. McLachlan, "Gene Duplications in the Structural Evolution of
     *  Chymotrypsin", J. Mol. Biol. 128 (1979) 49-79.
     */



    class RmsdSuprCls {
        constructor(icn3dui) {
            this.icn3dui = icn3dui;
        }

        getRmsdSuprCls(co1, co2, n) { let me = this.icn3dui;
        //    let TINY0 = 1.0e-10;
            let supr;
            let rot = new Array(9);

            let i, k, flag;
            //double cp[3], cq[3];
            let cp = new THREE.Vector3(), cq = new THREE.Vector3();

            let da, ra, rb, d1, d2, d3, e, s, v;
            //double ap[MAX_RES][3], bp[MAX_RES][3], mat[9];
            let ap = [], bp = [];
        //    let mat = new Array(9);

            //double h1[3], h2[3], h3[3], k1[3], k2[3], k3[3];
            let h1 = new Array(3), h2 = new Array(3), h3 = new Array(3), k1 = new Array(3), k2 = new Array(3), k3 = new Array(3);

            supr = 0.0;

            if (n <= 1) return {'rot': undefined, 'trans1': undefined, 'trans2': undefined, 'rmsd': 999};

            // read in and reformat the coordinates
            // calculate the centroids
            let finalCnt = n;
            for (i = 0; i < n; i++) {
                if(co1[i] === undefined || co2[i] === undefined) {
                    --finalCnt;
                    continue;
                }
                ap.push(co1[i].clone());
                bp.push(co2[i].clone());

                cp.add(co1[i]);
                cq.add(co2[i]);
            }

            n = finalCnt;
            if (n <= 1) return {'rot': undefined, 'trans1': undefined, 'trans2': undefined, 'rmsd': 999};

            cp.multiplyScalar(1.0 / n);
            cq.multiplyScalar(1.0 / n);

            // save the translation vectors
            let xc1 = cp;
            let xc2 = cq;

            // translate coordinates
            for (i = 0; i < n; i++) {
                ap[i].sub(cp);
                bp[i].sub(cq);
            }

            // radii of gyration
            for (i = 0, ra = rb = 0.0; i < n; i++) {
                ra += ap[i].x*ap[i].x + ap[i].y*ap[i].y + ap[i].z*ap[i].z;
                rb += bp[i].x*bp[i].x + bp[i].y*bp[i].y + bp[i].z*bp[i].z;
            }

            ra /= n;
            rb /= n;

            let u = new Array(9); //var u00, u01, u02, u10, u11, u12, u20, u21, u22;

            // correlation matrix U
            for (i = 0; i < 9; ++i) {
                u[i] = 0;
            }

            for (i = 0; i < n; i++) {
                u[0] += ap[i].x*bp[i].x;
                u[1] += ap[i].x*bp[i].y;
                u[2] += ap[i].x*bp[i].z;
                u[3] += ap[i].y*bp[i].x;
                u[4] += ap[i].y*bp[i].y;
                u[5] += ap[i].y*bp[i].z;
                u[6] += ap[i].z*bp[i].x;
                u[7] += ap[i].z*bp[i].y;
                u[8] += ap[i].z*bp[i].z;
            }

            for (i = 0; i < 9; ++i) {
                u[i] /= n;
            }

            let eigenRet = me.rmsdSuprCls.getEigenVectors(u);
            k = eigenRet.k;
            h1 = eigenRet.h1;
            h2 = eigenRet.h2;
            h3 = eigenRet.h3;

            k1 = eigenRet.k1;
            k2 = eigenRet.k2;
            k3 = eigenRet.k3;

            d1 = eigenRet.d1;
            d2 = eigenRet.d2;
            d3 = eigenRet.d3;

            flag = eigenRet.flag;

            s = eigenRet.s;

            if (k != 1) {
                supr = 100.0;
                rot[0] = 1.0; rot[1] = 0.0; rot[2] = 0.0;
                rot[3] = 0.0; rot[4] = 1.0; rot[5] = 0.0;
                rot[6] = 0.0; rot[7] = 0.0; rot[8] = 1.0;
                return {'rot': rot, 'trans1': xc1, 'trans2': xc2, 'rmsd': supr};
            }

            if (flag == 1) {
                // compute the k-vectors via the h-vectors
                k1[0] = u[0]*h1[0] + u[3]*h1[1] + u[6]*h1[2];
                k1[1] = u[1]*h1[0] + u[4]*h1[1] + u[7]*h1[2];
                k1[2] = u[2]*h1[0] + u[5]*h1[1] + u[8]*h1[2];
                da = Math.sqrt(d1);
                k1[0] /= da;
                k1[1] /= da;
                k1[2] /= da;
                k2[0] = u[0]*h2[0] + u[3]*h2[1] + u[6]*h2[2];
                k2[1] = u[1]*h2[0] + u[4]*h2[1] + u[7]*h2[2];
                k2[2] = u[2]*h2[0] + u[5]*h2[1] + u[8]*h2[2];
                da = Math.sqrt(d2);
                k2[0] /= da;
                k2[1] /= da;
                k2[2] /= da;
                k3[0] = u[0]*h3[0] + u[3]*h3[1] + u[6]*h3[2];
                k3[1] = u[1]*h3[0] + u[4]*h3[1] + u[7]*h3[2];
                k3[2] = u[2]*h3[0] + u[5]*h3[1] + u[8]*h3[2];
                da = Math.sqrt(d3);
                k3[0] /= da;
                k3[1] /= da;
                k3[2] /= da;
            }
            else if (flag == 2) {
                // compute the h-vectors via the k-vectors
                h1[0] = u[0]*k1[0] + u[1]*k1[1] + u[2]*k1[2];
                h1[1] = u[3]*k1[0] + u[4]*k1[1] + u[5]*k1[2];
                h1[2] = u[6]*k1[0] + u[7]*k1[1] + u[8]*k1[2];
                da = Math.sqrt(d1);
                h1[0] /= da;
                h1[1] /= da;
                h1[2] /= da;
                h2[0] = u[0]*k2[0] + u[1]*k2[1] + u[2]*k2[2];
                h2[1] = u[3]*k2[0] + u[4]*k2[1] + u[5]*k2[2];
                h2[2] = u[6]*k2[0] + u[7]*k2[1] + u[8]*k2[2];
                da = Math.sqrt(d2);
                h2[0] /= da;
                h2[1] /= da;
                h2[2] /= da;
                h3[0] = u[0]*k3[0] + u[1]*k3[1] + u[2]*k3[2];
                h3[1] = u[3]*k3[0] + u[4]*k3[1] + u[5]*k3[2];
                h3[2] = u[6]*k3[0] + u[7]*k3[1] + u[8]*k3[2];
                da = Math.sqrt(d3);
                h3[0] /= da;
                h3[1] /= da;
                h3[2] /= da;
            }

            if (s > 0.0) {
                rot[0] = (k1[0]*h1[0] + k2[0]*h2[0] + k3[0]*h3[0]);
                rot[1] = (k1[0]*h1[1] + k2[0]*h2[1] + k3[0]*h3[1]);
                rot[2] = (k1[0]*h1[2] + k2[0]*h2[2] + k3[0]*h3[2]);
                rot[3] = (k1[1]*h1[0] + k2[1]*h2[0] + k3[1]*h3[0]);
                rot[4] = (k1[1]*h1[1] + k2[1]*h2[1] + k3[1]*h3[1]);
                rot[5] = (k1[1]*h1[2] + k2[1]*h2[2] + k3[1]*h3[2]);
                rot[6] = (k1[2]*h1[0] + k2[2]*h2[0] + k3[2]*h3[0]);
                rot[7] = (k1[2]*h1[1] + k2[2]*h2[1] + k3[2]*h3[1]);
                rot[8] = (k1[2]*h1[2] + k2[2]*h2[2] + k3[2]*h3[2]);
            }
            else {
                rot[0] = (k1[0]*h1[0] + k2[0]*h2[0] - k3[0]*h3[0]);
                rot[1] = (k1[0]*h1[1] + k2[0]*h2[1] - k3[0]*h3[1]);
                rot[2] = (k1[0]*h1[2] + k2[0]*h2[2] - k3[0]*h3[2]);
                rot[3] = (k1[1]*h1[0] + k2[1]*h2[0] - k3[1]*h3[0]);
                rot[4] = (k1[1]*h1[1] + k2[1]*h2[1] - k3[1]*h3[1]);
                rot[5] = (k1[1]*h1[2] + k2[1]*h2[2] - k3[1]*h3[2]);
                rot[6] = (k1[2]*h1[0] + k2[2]*h2[0] - k3[2]*h3[0]);
                rot[7] = (k1[2]*h1[1] + k2[2]*h2[1] - k3[2]*h3[1]);
                rot[8] = (k1[2]*h1[2] + k2[2]*h2[2] - k3[2]*h3[2]);
            }

            // optimal rotation correction via eigenvalues
            d1 = Math.sqrt(d1);
            d2 = Math.sqrt(d2);
            d3 = Math.sqrt(d3);
            v = d1 + d2 + s*d3;
            e = ra + rb - 2.0*v;

            if (e > 0.0) {
                supr = Math.sqrt(e);
            }
            else {
                supr = undefined;
            }

            return {'rot': rot, 'trans1': xc1, 'trans2': xc2, 'rmsd': supr};

        }; // end rmsd_supr


        eigen_values(a0) { this.icn3dui;
            let v00, v01, v02, v10, v11, v12, v20, v21, v22;
            let a, b, c, p, q, t, u, v, d1, d2, d3;

            // initialization
            v00 = a0[0]; v01 = a0[1]; v02 = a0[2];
            v10 = a0[3]; v11 = a0[4]; v12 = a0[5];
            v20 = a0[6]; v21 = a0[7]; v22 = a0[8];

            // coefficients of the characteristic polynomial for V
            // det(xI - V) = x^3 + a*x^2 + b*x + c
            a = -(v00 + v11 + v22);
            b = v00*v11 + (v00 + v11)*v22 - v12*v21 - v01*v10 - v02*v20;
            c = -v00*v11*v22 + v00*v12*v21 + v01*v10*v22 - v01*v12*v20 - v02*v10*v21
                + v02*v11*v20;

            // transformed polynomial: x = y - a/3, poly(y) = y^3 + p*y + q
            p = -a*a/3.0 + b;
            q = a*a*a/13.5 - a*b/3.0 + c;

            // solutions y = u + v
            t = 0.25*q*q + p*p*p/27.0;

            if (t < 0.0) {
                let r, theta;

                // things are a bit more complicated
                r = Math.sqrt(0.25*q*q - t);
                theta = Math.acos(-0.5*q/r);
                d1 = 2.0*Math.cbrt(r)*Math.cos(theta/3.0);
            }
            else {
                u = Math.cbrt(-0.5*q + Math.sqrt(t));
                v = Math.cbrt(-0.5*q - Math.sqrt(t));
                d1 = u + v;
            }

            // return to the original characteristic polynomial
            d1 -= a/3.0;
            a += d1;
            c /= -d1;

            // solve the quadratic x^2 + a*x + c = 0
            d2 = 0.5*(-a + Math.sqrt(a*a - 4.0*c));
            d3 = 0.5*(-a - Math.sqrt(a*a - 4.0*c));

            // order the eigenvalues: d1 >= d2 >= d3
            if (d2 < d3) {
                t = d3;
                d3 = d2;
                d2 = d3;
            }

            if (d1 < d2) {
                t = d2;
                d2 = d1;
                d1 = t;
            }

            if (d2 < d3) {
                t = d3;
                d3 = d2;
                d2 = d3;
            }

            return {'d1': d1, 'd2': d2, 'd3': d3};
        }; // end eigen_values

        // Return the basis for the null space of the input matrix.
        null_basis(a0, v1, v2, v3, epsi) { this.icn3dui;
            let k, k0, spec;
            let a11, a12, a13, a21, a22, a23, a31, a32, a33;
            let b22, b23, b32, b33;
            let t, mx0;

            // initialization
            a11 = a0[0]; a12 = a0[1]; a13 = a0[2];
            a21 = a0[3]; a22 = a0[4]; a23 = a0[5];
            a31 = a0[6]; a32 = a0[7]; a33 = a0[8];

            // scale the matrix, so find the max entry
            mx0 = Math.abs(a11);
            if (Math.abs(a12) > mx0) mx0 = Math.abs(a12);
            if (Math.abs(a13) > mx0) mx0 = Math.abs(a13);
            if (Math.abs(a21) > mx0) mx0 = Math.abs(a21);
            if (Math.abs(a22) > mx0) mx0 = Math.abs(a22);
            if (Math.abs(a23) > mx0) mx0 = Math.abs(a23);
            if (Math.abs(a31) > mx0) mx0 = Math.abs(a31);
            if (Math.abs(a32) > mx0) mx0 = Math.abs(a32);
            if (Math.abs(a33) > mx0) mx0 = Math.abs(a33);

            if (mx0 < 1.0e-10) {
                // interpret this as the matrix of all 0's
                k0 = 3;
                return {'k': k0, 'v1': v1, 'v2': v2, 'v3': v3};
            }

            spec = 0;
            a11 /= mx0; a12 /= mx0; a13 /= mx0;
            a21 /= mx0; a22 /= mx0; a23 /= mx0;
            a31 /= mx0; a32 /= mx0; a33 /= mx0;

            if ((Math.abs(a11) < epsi) && (Math.abs(a21) < epsi) && (Math.abs(a31) < epsi)) {
                // let x1 is independent
                k = 1;
                v1[0] = 1.0; v1[1] = 0.0; v1[2] = 0.0;

                if ((Math.abs(a12) < epsi) && (Math.abs(a22) < epsi) && (Math.abs(a32) < epsi)) {
                    // let x2 is independent
                    k = 2;
                    v2[0] = 0.0; v2[1] = 1.0; v2[2] = 0.0;

                    if ((Math.abs(a13) < epsi) && (Math.abs(a23) < epsi) && (Math.abs(a33) < epsi)) {
                        // let x3 is independent
                        k = 3;
                        v3[0] = 0.0; v3[1] = 0.0; v3[2] = 1.0;
                    }

                    // else, we must have x3 = 0.0, so we're done
                }
                else {
                    // reorder so that a12 is maximized
                    mx0 = Math.abs(a12);

                    if (Math.abs(a22) > mx0) {
                        // swap rows 1 and 2
                        t = a11; a11 = a21; a21 = t;
                        t = a12; a12 = a22; a22 = t;
                        t = a13; a13 = a23; a23 = t;
                        mx0 = Math.abs(a12);
                    }

                    if (Math.abs(a32) > mx0) {
                        // swap rows 1 and 3
                        t = a11; a11 = a31; a31 = t;
                        t = a12; a12 = a32; a32 = t;
                        t = a13; a13 = a33; a33 = t;
                    }

                    // let x2 is dependent, x2 = -a13/a12*x3
                    b32 = a23 - a22*a13/a12;
                    b33 = a33 - a32*a13/a12;

                    if ((Math.abs(b32) < epsi) && (Math.abs(b33) < epsi)) {
                        //* let x3 is independent
                        k = 2;
                        v2[0] = 0.0; v2[1] = -a13/a12; v2[2] = 1.0;
                        spec = 1;
                    }

                    // else, we must have x3 = x2 = 0.0, so we're done
                }
            }
            else {
                // reorder so that a11 is maximized
                mx0 = Math.abs(a11);

                if (Math.abs(a12) > mx0) {
                    // swap rows 1 and 2
                    t = a11; a11 = a21; a21 = t;
                    t = a12; a12 = a22; a22 = t;
                    t = a13; a13 = a23; a23 = t;
                    mx0 = Math.abs(a11);
                }

                if (Math.abs(a13) > mx0) {
                    // swap rows 1 and 3
                    t = a11; a11 = a31; a31 = t;
                    t = a12; a12 = a32; a32 = t;
                    t = a13; a13 = a33; a33 = t;
                }

                // let x1 is dependent, x1 = -a12/a11*x2 - a13/a11*x3
                b22 = a22 - a21*a12/a11;
                b23 = a23 - a21*a13/a11;
                b32 = a32 - a31*a12/a11;
                b33 = a33 - a31*a13/a11;

                if ((Math.abs(b22) < epsi) && (Math.abs(b32) < epsi)) {
                    // let x2 is independent
                    k = 1;
                    v1[0] = -a12/a11; v1[1] = 1.0; v1[2] = 0.0;

                    if ((Math.abs(b23) < epsi) && (Math.abs(b33) < epsi)) {
                        // let x3 is independent
                        k = 2;
                        v2[0] = -a13/a11; v2[1] = 0.0; v2[2] = 1.0;
                        spec = 2;
                    }

                    // else, we must have x3 = 0.0, so we're done
                }
                else {
                    // reorder so that b22 is maximized
                    if (Math.abs(b22) < Math.abs(b32)) {
                        t = b22; b22 = b32; b32 = t;
                        t = b23; b23 = b33; b33 = t;
                    }

                    // let x2 is dependent, x2 = -b23/b22*x3
                    if (Math.abs(b33 - b23*b32/b22) < epsi) {
                        // let x3 is independent
                        k = 1;
                        v1[0] = (a12/a11)*(b23/b22) - a13/a11;
                        v1[1] = -b23/b22; v1[2] = 1.0;
                        spec = 3;
                    }
                    else {
                        // the null space contains only the zero vector
                        k0 = 0;
                        v1[0] = 0.0; v1[1] = 0.0; v1[2] = 0.0;
                        //return;
                        return {'k': k0, 'v1': v1, 'v2': v2, 'v3': v3};
                    }
                }
            }

            k0 = k;

            if (spec > 0) {
                // special cases, basis should be orthogonalized
                if (spec == 1) {
                    // 2nd vector must be normalized
                    a11 = v2[0]; a12 = v2[1]; a13 = v2[2];
                    t = Math.sqrt(a11*a11 + a12*a12 + a13*a13);
                    v2[0] = a11/t; v2[1] = a12/t; v2[2] = a13/t;
                }
                else if (spec == 2) {
                    // 1st, 2nd vectors must be orthogonalized
                    a11 = v1[0]; a12 = v1[1]; a13 = v1[2];
                    a21 = v2[0]; a22 = v2[1]; a23 = v2[2];
                    t = a11*a21 + a12*a22 + a13*a23;

                    if (Math.abs(t) >= epsi) {
                        v2[0] = a11 + t*a21;
                        v2[1] = a12 + t*a22;
                        v2[2] = a13 + t*a23;
                        a21 = v2[0]; a22 = v2[1]; a23 = v2[2];
                    }

                    // normalize the vectors
                    t = Math.sqrt(a11*a11 + a12*a12 + a13*a13);
                    v1[0] = a11/t; v1[1] = a12/t; v1[2] = a13/t;
                    t = Math.sqrt(a21*a21 + a22*a22 + a23*a23);
                    v2[0] = a21/t; v2[1] = a22/t; v2[2] = a23/t;
                }
                else {
                    // 1st vector must be normalized
                    a11 = v1[0]; a12 = v1[1]; a13 = v1[2];
                    t = Math.sqrt(a11*a11 + a12*a12 + a13*a13);
                    v1[0] = a11/t; v1[1] = a12/t; v1[2] = a13/t;
                }
            }

            return {'k': k0, 'v1': v1, 'v2': v2, 'v3': v3};
        }; // end null_basis


        getEigenForSelection(coord, n) { let me = this.icn3dui;
            let i;
            let cp = new THREE.Vector3();
            let ap = [];

            // read in and reformat the coordinates
            // calculate the centroids
            for (i = 0; i < n; i++) {
                ap.push(coord[i]);

                cp.add(coord[i]);
            }

            cp.multiplyScalar(1.0 / n);

            // translate coordinates
            for (i = 0; i < n; i++) {
                ap[i].sub(cp);
            }

            let u = new Array(9); //var u00, u01, u02, u10, u11, u12, u20, u21, u22;

            for (i = 0; i < 9; ++i) {
                u[i] = 0;
            }

            // http://individual.utoronto.ca/rav/Web/FR/cov.htm
            // https://builtin.com/data-science/step-step-explanation-principal-component-analysis
            for (i = 0; i < n; i++) {
                u[0] += ap[i].x*ap[i].x;
                u[1] += ap[i].x*ap[i].y;
                u[2] += ap[i].x*ap[i].z;
                u[3] += ap[i].y*ap[i].x;
                u[4] += ap[i].y*ap[i].y;
                u[5] += ap[i].y*ap[i].z;
                u[6] += ap[i].z*ap[i].x;
                u[7] += ap[i].z*ap[i].y;
                u[8] += ap[i].z*ap[i].z;
            }

            for (i = 0; i < 9; ++i) {
                u[i] /= n;
            }

            return me.rmsdSuprCls.getEigenVectors(u);
        };

        getEigenVectors(u, bJustPc1) { let me = this.icn3dui;
        //    let TINY0 = 1.0e-10;
            let TINY0 = 1.0e-8;
            let k, flag;
            let mat = new Array(9);

            let h1 = new Array(3), h2 = new Array(3), h3 = new Array(3), k1 = new Array(3), k2 = new Array(3), k3 = new Array(3);

            let dU, d1, d2, d3, s;

            // determinant of U
            dU = u[0]*(u[4]*u[8] - u[5]*u[7]);
            dU -= u[1]*(u[3]*u[8] - u[5]*u[6]);
            dU += u[2]*(u[3]*u[7] - u[4]*u[6]);
            s = (dU < 0.0) ? -1.0 : 1.0;

            let v1 = new Array(3), v2 = new Array(3);
            for(let i = 0; i < 3; ++i) {
                v1[i] = new THREE.Vector3();
                v2[i] = new THREE.Vector3();
            }

            // compute V = UU' (it is symmetric)
            v1[0].x = u[0]*u[0] + u[1]*u[1] + u[2]*u[2];
            v1[0].y = u[0]*u[3] + u[1]*u[4] + u[2]*u[5];
            v1[0].z = u[0]*u[6] + u[1]*u[7] + u[2]*u[8];
            v1[1].x = v1[0].y;
            v1[1].y = u[3]*u[3] + u[4]*u[4] + u[5]*u[5];
            v1[1].z = u[3]*u[6] + u[4]*u[7] + u[5]*u[8];
            v1[2].x = v1[0].z;
            v1[2].y = v1[1].z;
            v1[2].z = u[6]*u[6] + u[7]*u[7] + u[8]*u[8];

            // also compute V = U'U, as it may be needed
            v2[0].x = u[0]*u[0] + u[3]*u[3] + u[6]*u[6];
            v2[0].y = u[0]*u[1] + u[3]*u[4] + u[6]*u[7];
            v2[0].z = u[0]*u[2] + u[3]*u[5] + u[6]*u[8];
            v2[1].x = v2[0].y;
            v2[1].y = u[1]*u[1] + u[4]*u[4] + u[7]*u[7];
            v2[1].z = u[1]*u[2] + u[4]*u[5] + u[7]*u[8];
            v2[2].x = v2[0].z;
            v2[2].y = v2[1].z;
            v2[2].z = u[2]*u[2] + u[5]*u[5] + u[8]*u[8];

            // compute the eigenvalues
            mat[0] = v1[0].x; mat[1] = v1[0].y; mat[2] = v1[0].z;
            mat[3] = v1[1].x; mat[4] = v1[1].y; mat[5] = v1[1].z;
            mat[6] = v1[2].x; mat[7] = v1[2].y; mat[8] = v1[2].z;

            let eigen = me.rmsdSuprCls.eigen_values(mat);

            d1 = eigen.d1;
            d2 = eigen.d2;
            d3 = eigen.d3;

            // now we need the eigenvectors
            flag = 1;
            mat[0] -= d1;
            mat[4] -= d1;
            mat[8] -= d1;
            let basis = me.rmsdSuprCls.null_basis(mat, h1, h2, h3, TINY0);
            k = basis.k;
            h1 = basis.v1;
            h2 = basis.v2;
            h3 = basis.v3;

            if(bJustPc1) return {"k": k, "h1": h1, "h2": h2, "h3": h3, "k1": k1, "k2": k2, "k3": k3, "d1": d1, "d2": d2, "d3": d3, "flag": flag, "s": s};

            if (k == 1) {
                mat[0] += d1 - d2;
                mat[4] += d1 - d2;
                mat[8] += d1 - d2;
                basis = me.rmsdSuprCls.null_basis(mat, h2, h3, h1, TINY0);
                k = basis.k;
                h2 = basis.v1;
                h3 = basis.v2;
                h1 = basis.v3;

                if (k == 1) {
                    mat[0] += d2 - d3;
                    mat[4] += d2 - d3;
                    mat[8] += d2 - d3;
                    basis = me.rmsdSuprCls.null_basis(mat, h3, h1, h2, TINY0);
                    k = basis.k;
                    h3 = basis.v1;
                    h1 = basis.v2;
                    h2 = basis.v3;
                }
            }

            if (k != 1) {
                // retry the computation, but using V = U'U
                mat[0] = v2[0].x; mat[1] = v2[0].y; mat[2] = v2[0].z;
                mat[3] = v2[1].x; mat[4] = v2[1].y; mat[5] = v2[1].z;
                mat[6] = v2[2].x; mat[7] = v2[2].y; mat[8] = v2[2].z;

                // now we need the eigenvectors
                flag = 2;
                mat[0] -= d1;
                mat[4] -= d1;
                mat[8] -= d1;
                basis = me.rmsdSuprCls.null_basis(mat, k1, k2, k3, TINY0);
                k = basis.k;
                k1 = basis.v1;
                k2 = basis.v2;
                k3 = basis.v3;

                if (k == 1) {
                    mat[0] += d1 - d2;
                    mat[4] += d1 - d2;
                    mat[8] += d1 - d2;
                    basis = me.rmsdSuprCls.null_basis(mat, k2, k3, k1, TINY0);
                    k = basis.k;
                    k2 = basis.v1;
                    k3 = basis.v2;
                    k1 = basis.v3;

                    if (k == 1) {
                        mat[0] += d2 - d3;
                        mat[4] += d2 - d3;
                        mat[8] += d2 - d3;
                        basis = me.rmsdSuprCls.null_basis(mat, k3, k1, k2, TINY0);
                        k = basis.k;
                        k3 = basis.v1;
                        k1 = basis.v2;
                        k2 = basis.v3;
                    }
                }
            }

            return {"k": k, "h1": h1, "h2": h2, "h3": h3, "k1": k1, "k2": k2, "k3": k3, "d1": d1, "d2": d2, "d3": d3, "flag": flag, "s": s};
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */



    class SubdivideCls {
        constructor(icn3dui) {
            this.icn3dui = icn3dui;
        }

        // cubic splines for four points: http://thalestriangles.blogspot.com/2014/02/a-bit-of-ex-spline-ation.html
        // https://math.stackexchange.com/questions/577641/how-to-calculate-interpolating-splines-in-3d-space
        subdivide(_pnts, _clrs, DIV, bShowArray, bHighlight, prevone, nexttwo, bExtendLastRes) { let me = this.icn3dui;

            let ret = [];
            let pos = [];
            let color = [];

            let pnts = new Array(); // Smoothing test

            let prevoneLen = (prevone !== undefined) ? prevone.length : 0;
            let nexttwoLenOri = (nexttwo !== undefined) ? nexttwo.length : 0;

            let maxDist = 6.0;

            if(prevoneLen > 0
                && Math.abs(prevone[0].x - _pnts[0].x) <= maxDist
                && Math.abs(prevone[0].y - _pnts[0].y) <= maxDist
                && Math.abs(prevone[0].z - _pnts[0].z) <= maxDist
                ) {
              pnts.push(prevone[0]);
              prevoneLen = 1;
            }
            else {
              prevoneLen = 0;
            }

            pnts.push(_pnts[0]);
            for (let i = 1, lim = _pnts.length - 1; i < lim; ++i) {
                let p0 = _pnts[i], p1 = _pnts[i + 1];
                pnts.push(p0.smoothen ? p0.clone().add(p1).multiplyScalar(0.5) : p0);
            }
            pnts.push(_pnts[_pnts.length - 1]);

            let nexttwoLen = 0;
            if(nexttwoLenOri > 0
                && Math.abs(nexttwo[0].x - _pnts[_pnts.length - 1].x) <= maxDist
                && Math.abs(nexttwo[0].y - _pnts[_pnts.length - 1].y) <= maxDist
                && Math.abs(nexttwo[0].z - _pnts[_pnts.length - 1].z) <= maxDist
                ) {
              pnts.push(nexttwo[0]);
              ++nexttwoLen;
            }

            if(nexttwoLenOri > 1
                && Math.abs(nexttwo[0].x - nexttwo[1].x) <= maxDist
                && Math.abs(nexttwo[0].y - nexttwo[1].y) <= maxDist
                && Math.abs(nexttwo[0].z - nexttwo[1].z) <= maxDist
                ) {
              pnts.push(nexttwo[1]);
              ++nexttwoLen;
            }

            let savedPoints = [];
            let savedPos = [];
            let savedColor = [];

            //var nexttwoLen = nexttwoLenOri;
            if(bExtendLastRes) {
                nexttwoLen = (nexttwoLenOri > 0) ? nexttwoLenOri - 1 : 0;
            }

            let alpha = 1, newI;

            for (let i = -1, size = pnts.length, DIVINV = 1 / DIV; i <= size - 3; ++i) {
                newI = i - prevoneLen;
                let p0 = pnts[i === -1 ? 0 : i];
                let p1 = pnts[i + 1];
                let p2 = pnts[i + 2];
                let p3 = pnts[i === size - 3 ? size - 1 : i + 3];

                let t0 = 0;
                let t1 = me.subdivideCls.getKnot(alpha, t0, p0, p1);
                let t2 = me.subdivideCls.getKnot(alpha, t1, p1, p2);
                let t3 = me.subdivideCls.getKnot(alpha, t2, p2, p3);

                if(t1 - t0 < 1e-4) t1 = t0 + 1;
                if(t2 - t1 < 1e-4) t2 = t1 + 1;
                if(t3 - t2 < 1e-4) t3 = t2 + 1;

                //if(i > -1 && bHighlight && bShowArray !== undefined && bShowArray[i + 1]) {
                if(i > -1 && (bShowArray === undefined || bShowArray[newI + 1]) ) {
                    // get from previous i for the first half of residue
                    if(i >= -1 + prevoneLen && i <= size - 3 - nexttwoLen + 1) {
                        ret = ret.concat(savedPoints);
                        pos = pos.concat(savedPos);
                        color = color.concat(savedColor);
                    }
                }

                savedPoints = [];
                savedPos = [];
                savedColor = [];

                let step = (t2 - t1) * DIVINV;
                for (let j = 0; j < DIV; ++j) {
                    let t = t1 + step * j;
                    let x = me.subdivideCls.getValueFromKnot(t, t0, t1, t2, t3, p0.x, p1.x, p2.x, p3.x);
                    let y = me.subdivideCls.getValueFromKnot(t, t0, t1, t2, t3, p0.y, p1.y, p2.y, p3.y);
                    let z = me.subdivideCls.getValueFromKnot(t, t0, t1, t2, t3, p0.z, p1.z, p2.z, p3.z);

                    if(!bShowArray) {
                        if(i >= -1 + prevoneLen && i <= size - 3 - nexttwoLen) {
                            ret.push(new THREE.Vector3(x, y, z));
                            pos.push(newI + 1);
                            color.push(_clrs[newI+1]);
                        }
                    }
                    else {
                        if(i >= -1 + prevoneLen && i <= size - 3 - nexttwoLen) {
                            if(bShowArray[newI + 1]) {
                                if(j <= parseInt((DIV) / 2) ) {
                                    ret.push(new THREE.Vector3(x, y, z));
                                    pos.push(bShowArray[newI + 1]);
                                    color.push(_clrs[newI+1]);
                                }
                            }
                        }

                        if(i >= -1 + prevoneLen && i <= size - 3 - nexttwoLen + 1) {
                            if(bShowArray[newI + 2]) {
                                if(j > parseInt((DIV) / 2) ) {
                                    savedPoints.push(new THREE.Vector3(x, y, z));
                                    savedPos.push(bShowArray[newI + 2]);
                                    savedColor.push(_clrs[newI+2]);
                                }
                            }
                        }
                    } // end else

                } // end for (let j = 0;
            } // end for (let i = -1;

            if(!bShowArray || bShowArray[newI + 1]) {
                //if(bHighlight) {
                ret = ret.concat(savedPoints);
                pos = pos.concat(savedPos);
                color = color.concat(savedColor);
                //}

                ret.push(pnts[pnts.length - 1 - nexttwoLen]);
                pos.push(pnts.length - 1 - nexttwoLen);
                color.push(_clrs[pnts.length - 1 - nexttwoLen]);
            }

            savedPoints = [];
            savedPos = [];
            savedColor = [];
            pnts = [];

            let pnts_positions = [];

            pnts_positions.push(ret);
            pnts_positions.push(pos);
            pnts_positions.push(color);

            return pnts_positions;
        };


        getKnot(alpha, ti, Pi, Pj) { this.icn3dui;
            //var alpha = 1;

            //return Math.pow(Pi.distanceTo(Pj), alpha) + ti;
            return Pi.distanceTo(Pj) + ti;
        }

        getValueFromKnot(t, t0, t1, t2, t3, y0, y1, y2, y3) { this.icn3dui;
            let inf = 9999;

            // m(i) = ( t(i+1) - t(i) == 0 ) ? 0 : ( y(i+1) - y(i) ) / ( t(i+1) - t(i) )
            let m0 = (y1 - y0) / (t1 - t0);
            let m1 = (y2 - y1) / (t2 - t1);
            let m2 = (y3 - y2) / (t3 - t2);

            // L(i) = m(i) * (t - t(i)) + y(i)
            //var L0 = m0 * (t - t0) + y0;
            let L1 = m1 * (t - t1) + y1;
            //var L2 = m2 * (t - t2) + y2;

            let denom = (t1 + t2) * (t1 + t2) - 4*(t0*t1 + t2*t3 - t0*t3);
            let d1, d2;

            if(denom == 0) {
                d1 = inf;
                d2 = inf;
            }
            else {
                d1 = 6 * (3*m1*t1 + 2*m0*t3 + m2*t1 - 2*m0*t1 - 2*m1*t3 - m1*t2 - m2*t1) / denom;
                d2 = 6 * (3*m1*t2 + 2*m2*t0 + m0*t1 - 2*m1*t0 - 2*m2*t2 - m0*t2 - m1*t1) / denom;
            }

            // a(i) = ( 2*d(i) + d(i+1) ) / 6 / (t(i) - t(i+1))
            // b(i) = ( 2*d(i+1) + d(i) ) / 6 / (t(i+1) - t(i))
            //var a0 = ( 2*d0 + d1 ) / 6 / (t0 - t1);
            let a1 = ( 2*d1 + d2 ) / 6 / (t1 - t2);
            //var a2 = ( 2*d2 + d3 ) / 6 / (t2 - t3);

            //var b0 = ( 2*d1 + d0 ) / 6 / (t1 - t0);
            let b1 = ( 2*d2 + d1 ) / 6 / (t2 - t1);
            //var b2 = ( 2*d3 + d2 ) / 6 / (t3 - t2);

            // C(i) = a(i)*(t - t(i))*(t - t(i+1))*(t - t(i+1)) + b(i)*(t - t(i))*(t - t(i))*(t - t(i+1))
            //var C0 = a0*(t - t0)*(t - t1)*(t - t1) + b0*(t - t0)*(t - t0)*(t - t1);
            let C1 = a1*(t - t1)*(t - t2)*(t - t2) + b1*(t - t1)*(t - t1)*(t - t2);
            //var C2 = a2*(t - t2)*(t - t3)*(t - t3) + b2*(t - t2)*(t - t2)*(t - t3);

            let F1 = L1 + C1;

            return F1;
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class ConvertTypeCls {
        constructor(icn3dui) {
            this.icn3dui = icn3dui;
        }

        passFloat32( array, output ){ let me = this.icn3dui;
            let n = array.length;
            if( !output ) output = new Uint8Array( 4 * n );
            let dv = me.convertTypeCls.getDataView( output );
            for( let i = 0; i < n; ++i ){
                dv.setFloat32( 4 * i, array[ i ], true); // litteEndian = true
            }        return me.convertTypeCls.getUint8View( output );
        }

        passInt8( array, output ){ let me = this.icn3dui;
            let n = array.length;
            if( !output ) output = new Uint8Array( 1 * n );
            let dv = me.convertTypeCls.getDataView( output );
            for( let i = 0; i < n; ++i ){
                dv.setInt8( 1 * i, array[ i ], true); // litteEndian = true
            }        return me.convertTypeCls.getUint8View( output );
        }

        passInt16( array, output ){ let me = this.icn3dui;
            let n = array.length;
            if( !output ) output = new Uint8Array( 2 * n );
            let dv = me.convertTypeCls.getDataView( output );
            for( let i = 0; i < n; ++i ){
                dv.setInt16( 2 * i, array[ i ], true); // litteEndian = true
            }        return me.convertTypeCls.getUint8View( output );
        }

        passInt32( array, output ){ let me = this.icn3dui;
            let n = array.length;
            if( !output ) output = new Uint8Array( 4 * n );
            let dv = me.convertTypeCls.getDataView( output );
            for( let i = 0; i < n; ++i ){
                dv.setInt32( 4 * i, array[ i ], true); // litteEndian = true
            }        return me.convertTypeCls.getUint8View( output );
        }

        getUint8View( typedArray ){ let me = this.icn3dui;
            return me.convertTypeCls.getView( Uint8Array, typedArray );
        }

        getDataView( typedArray ){ let me = this.icn3dui;
            return me.convertTypeCls.getView( DataView, typedArray );
        }

        getView( ctor, typedArray, elemSize ){ this.icn3dui;
            return typedArray ? new ctor(
                typedArray.buffer,
                typedArray.byteOffset,
                typedArray.byteLength / ( elemSize || 1 )
            ) : undefined;
        }

        getBlobFromBufferAndText(arrayBuffer, text) { let me = this.icn3dui;
            let strArray = new Uint8Array(arrayBuffer);

            let strArray2 = new Uint8Array(text.length);
            for(let i = 0; i < text.length; ++i) {
               strArray2[i] = me.convertTypeCls.passInt8([text.charCodeAt(i)])[0];
            }

            let blobArray = []; // hold blobs

            //blobArray.push(new Blob([strArray0],{ type: "application/octet-stream"}));
            blobArray.push(new Blob([strArray],{ type: "application/octet-stream"}));
            blobArray.push(new Blob([strArray2],{ type: "application/octet-stream"}));

            //var blob = new Blob(blobArray,{ type: "application/octet-stream"});
            let blob = new Blob(blobArray,{ type: "image/png"});

            return blob;
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class ClickMenu {
        constructor(icn3dui) {
            this.icn3dui = icn3dui;
        }

        setAlphaFoldLegend() { let me = this.icn3dui; me.icn3d;
            let legendHtml;
            legendHtml = '<div>';
            legendHtml += '<span class="icn3d-square" style="background-color: rgb(0, 83, 204);">&nbsp;</span> <span>Very high (pLDDT &gt; 90)</span><br>';
            legendHtml += '<span class="icn3d-square" style="background-color: rgb(101, 203, 243);">&nbsp;</span> <span>Confident (90 &gt; pLDDT &gt; 70)</span><br>';
            legendHtml += '<span class="icn3d-square" style="background-color: rgb(255, 209, 19);">&nbsp;</span> <span>Low (70 &gt; pLDDT &gt; 50)</span><br>';
            legendHtml += '<span class="icn3d-square" style="background-color: rgb(255, 125, 69);">&nbsp;</span> <span>Very low (pLDDT &lt; 50)</span><br>';
            legendHtml += '</div>';

            return legendHtml;
        }

        setLegendHtml(bAf) { let me = this.icn3dui, ic = me.icn3d;
            let legendHtml = "<br>";
            if(bAf) {
                legendHtml += this.setAlphaFoldLegend();
            }
            else {
                let startColorStr = (ic.startColor == 'red') ? '#F00' : (ic.startColor == 'green') ? '#0F0' : '#00F';
                let midColorStr = (ic.midColor == 'white') ? '#FFF' : '#000';
                let endColorStr = (ic.endColor == 'red') ? '#F00' : (ic.endColor == 'green') ? '#0F0' : '#00F';
                let rangeStr = startColorStr + ' 0%, ' + midColorStr + ' 50%, ' + endColorStr + ' 100%';

                legendHtml += "<div style='height: 20px; background: linear-gradient(to right, " + rangeStr + ");'></div><table width='100%' border='0' cellspacing='0' cellpadding='0'><tr><td width='33%'>" + ic.startValue + "</td><td width='33%' align='center'>" + ic.midValue + "</td><td width='33%' align='right'>" + ic.endValue + "</td></tr></table>";
            }

            return legendHtml;
        }

        SetChainsAdvancedMenu() { let me = this.icn3dui, ic = me.icn3d;
            if(ic.bSetChainsAdvancedMenu === undefined || !ic.bSetChainsAdvancedMenu) {
                let prevHAtoms = me.hashUtilsCls.cloneHash(ic.hAtoms);
                ic.definedSetsCls.setPredefinedInMenu();
                ic.bSetChainsAdvancedMenu = true;
                ic.hAtoms = me.hashUtilsCls.cloneHash(prevHAtoms);
            }
        }

        setSetsMenus(id, bOneset) { let me = this.icn3dui, ic = me.icn3d;
            this.SetChainsAdvancedMenu();

            let id1 = id;
            let id2 = id + '2';

            let definedAtomsHtml = ic.definedSetsCls.setAtomMenu(['protein']);
            if($("#" + me.pre + id1).length) {
                $("#" + me.pre + id1).html("  <option value='selected'>selected</option>" + definedAtomsHtml);
            }
            if(!bOneset && $("#" + me.pre + id2).length) {
                $("#" + me.pre + id2).html("  <option value='selected' selected>selected</option>" + definedAtomsHtml);
            }

            $("#" + me.pre + id1).resizable();
            if(!bOneset) $("#" + me.pre + id2).resizable();
        }

        applyShownMenus(bNoSave) { let me = this.icn3dui; me.icn3d;
            let idArray = [];

            for(let id in me.htmlCls.allMenus) {
                if(me.htmlCls.shownMenus.hasOwnProperty(id)) {
                    $("#" + me.pre + id).parent().show();
                }
                else {            
                    $("#" + me.pre + id).parent().hide();     
                    idArray.push(id);         
                }
            }   

            if(Object.keys(me.htmlCls.shownMenus).length == Object.keys(me.htmlCls.allMenus).length) {
                $(".icn3d-menusep").show();
            }
            else {
                $(".icn3d-menusep").hide();
            }

            // save to localStorage
            if(localStorage && !bNoSave) localStorage.setItem('hiddenmenus', JSON.stringify(idArray));
        }

        getHiddenMenusFromCache() { let me = this.icn3dui; me.icn3d;
          me.htmlCls.shownMenus = {};

          let mode = me.htmlCls.setHtmlCls.getCookie('menumode');

          let idArrayStr = (localStorage) ? localStorage.getItem('hiddenmenus') : '';
          
          if(idArrayStr && idArrayStr != '[]') {
             me.htmlCls.shownMenus = {};

             let idArray = JSON.parse(idArrayStr);

             for(let menu in me.htmlCls.allMenus) {
                if(idArray.indexOf(menu) == -1) {
                   me.htmlCls.shownMenus[menu] = 1;
                }
             }
          }
          else {
             if(mode == 'all') {
                me.htmlCls.shownMenus = me.hashUtilsCls.cloneHash(me.htmlCls.allMenus);
             }
             else if(!mode || mode == 'simple') {
                me.htmlCls.shownMenus = me.hashUtilsCls.cloneHash(me.htmlCls.simpleMenus);
             }
             else {
                me.htmlCls.shownMenus = me.hashUtilsCls.cloneHash(me.htmlCls.simpleMenus);
             }
          }
        }
        
        displayShownMenus() { let me = this.icn3dui; me.icn3d;
            let html = "<form name='" + me.pre + "selmenu'>";
            html += "<table><tr><th>File</th><th>Select</th><th>View</th><th>Style</th><th>Color</th><th>Analysis</th><th>Help</th></tr>";
            html += "<tr>";
            for(let id in me.htmlCls.allMenusSel) {
                // skip all unicolor: too many
                if(id.substr(0, 6) == 'uniclr' 
                    || id.substr(0, 11) == 'mn5_opacity'
                    || id.substr(0, 14) == 'mn6_labelscale'
                    || id.substr(0, 4) == 'faq_'
                    || id.substr(0, 4) == 'dev_') {
                        continue;
                }

                if(id == 'mn1_searchgrooup') {
                    html += "<td valign='top'>";
                }
                else if(id == 'mn2_definedsets') {
                    html += "</td><td valign='top'>";
                }
                else if(id == 'mn2_show_selected') {
                    html += "</td><td valign='top'>";
                }
                else if(id == 'mn3_proteinwrap' || (me.cfg.cid && id == 'mn3_ligwrap')) {
                    html += "</td><td valign='top'>";
                }
                else if(id == 'mn4_clrwrap') {
                    html += "</td><td valign='top'>";
                }
                else if(id == 'mn6_selectannotations') {
                    html += "</td><td valign='top'>";
                }
                else if(id == 'abouticn3d') {
                    html += "</td><td valign='top'>";
                }

                let checkStr = (me.htmlCls.shownMenus.hasOwnProperty(id)) ? "checked" : "";

                let selType = me.htmlCls.allMenusSel[id];
                let styleStr = (selType == 3) ? " style='margin-left:30px'" : ((selType == 2) ? " style='margin-left:15px'" : "");

                html += "<span style='white-space:nowrap'><input type='checkbox' name='" + id + "' value='" + id + "'" + checkStr + styleStr + ">" + me.htmlCls.allMenus[id] + "</span><br>";
            }  
            html += "</td></tr></table></form>";

            $("#" + me.pre + "menulist").html(html);
        }

        async setIgTemplate(template) { let me = this.icn3dui, ic = me.icn3d;
          ic.bRunRefnumAgain = true;

          // reset for the selection
          let residueArray = ic.resid2specCls.atoms2residues(Object.keys(ic.hAtoms));
          for(let i = 0, il = residueArray.length; i < il; ++i) {
             let resid = residueArray[i];

             if(ic.resid2refnum) delete ic.resid2refnum[resid];
             // if(ic.resid2refnum_ori) delete ic.resid2refnum_ori[resid];
             if(ic.resid2domainid) delete ic.resid2domainid[resid];
          }

          let bSelection = true;
          // await ic.refnumCls.showIgRefNum(template);
          if(!ic.bAnnoShown) await ic.showAnnoCls.showAnnotations();
          await ic.annotationCls.setAnnoTabIg(bSelection, template);

          ic.bRunRefnumAgain = false;
        }

        setClashedResidues() { let me = this.icn3dui, ic = me.icn3d;
          // check contacts between all chains
          let chainidArray = Object.keys(ic.chains);
          let radius = 4, bSphereCalc = false, bInteraction = true;
          for(let i = 0, il = chainidArray.length; i < il; ++i) {
             let chainid1 = chainidArray[i];
             for(let j = i + 1, jl = chainidArray.length; j < jl; ++j) {
                let chainid2 = chainidArray[j];
                ic.showInterCls.pickCustomSphere_base(radius, ic.chains[chainid1], ic.chains[chainid2], bSphereCalc, bInteraction);
             }
          }

          // use domains to determine which one to hide
          let bNotShowDomain = true;
          ic.annoDomainCls.showDomainAll(bNotShowDomain);
        }

        clickMenu1() { let me = this.icn3dui; me.icn3d;
            if(me.bNode) return;

            let thisClass = this;
        //mn 1
        //    clkMn1_mmtfid: function() {
            me.myEventCls.onIds("#" + me.pre + "mn1_vastplus", "click", function(e) { me.icn3d; //e.preventDefault();
                me.htmlCls.dialogCls.openDlg('dl_vastplus', 'Please input PDB ID for VAST+');
             });

            me.myEventCls.onIds("#" + me.pre + "mn1_vast", "click", function(e) { me.icn3d; //e.preventDefault();
                me.htmlCls.dialogCls.openDlg('dl_vast', 'Please input chain or PDB file for VAST');
             });

            me.myEventCls.onIds("#" + me.pre + "mn1_foldseek", "click", function(e) { me.icn3d; //e.preventDefault();
                me.htmlCls.dialogCls.openDlg('dl_foldseek', 'Submit your selection to Foldseek');
             });

            me.myEventCls.onIds("#" + me.pre + "mn1_mmtfid", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_mmtfid', 'Please input BCIF/MMTF ID');
            });

        //    clkMn1_pdbid: function() {
            me.myEventCls.onIds("#" + me.pre + "mn1_pdbid", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_pdbid', 'Please input PDB ID');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_afid", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_afid', 'Please input AlphaFold UniProt ID');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_refseqid", "click", function(e) { me.icn3d; //e.preventDefault();
                me.htmlCls.dialogCls.openDlg('dl_refseqid', 'Please input NCBI Protein Accession');
             });

            me.myEventCls.onIds("#" + me.pre + "mn1_opmid", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_opmid', 'Please input OPM PDB ID');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_align", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_align', 'Align two PDB structures');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_alignaf", "click", function(e) { me.icn3d; //e.preventDefault();
                me.htmlCls.dialogCls.openDlg('dl_alignaf', 'Align two AlphaFold structures');
             });

            me.myEventCls.onIds("#" + me.pre + "mn1_chainalign", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_chainalign', 'Align multiple chains by structure alignment');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_chainalign2", "click", function(e) { me.icn3d; //e.preventDefault();
                me.htmlCls.dialogCls.openDlg('dl_chainalign2', 'Align multiple chains by sequence alignment');
             });

            me.myEventCls.onIds("#" + me.pre + "mn1_chainalign3", "click", function(e) { me.icn3d; //e.preventDefault();
                me.htmlCls.dialogCls.openDlg('dl_chainalign3', 'Align multiple chains residue by residue');
             });

            me.myEventCls.onIds("#" + me.pre + "mn1_mutation", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_mutation', 'Show the mutations in 3D');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_pdbfile", "click", function(e) { me.icn3d; //e.preventDefault();
               //me = me.setIcn3dui($(this).attr('id'));
               me.htmlCls.dialogCls.openDlg('dl_pdbfile', 'Please input PDB File');
            });
            me.myEventCls.onIds(["#" + me.pre + "mn1_pdbfile_app", "#" + me.pre + "tool_pdbfile"], "click", function(e) { me.icn3d; //e.preventDefault();
               //me = me.setIcn3dui($(this).attr('id'));
               me.htmlCls.dialogCls.openDlg('dl_pdbfile_app', 'Please append PDB Files');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_mol2file", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_mol2file', 'Please input Mol2 File');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_sdffile", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_sdffile', 'Please input SDF File');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_xyzfile", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_xyzfile', 'Please input XYZ File');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_afmapfile", "click", function(e) { me.icn3d; //e.preventDefault();
                me.htmlCls.dialogCls.openDlg('dl_afmapfile', 'Please input AlphaFold PAE File');
             });

            me.myEventCls.onIds("#" + me.pre + "mn1_urlfile", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_urlfile', 'Load data by URL');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_clustalwfile", "click", function(e) { me.icn3d; //e.preventDefault();
                me.htmlCls.dialogCls.openDlg('dl_clustalwfile', 'Please input CLUSTALW MSA File');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_fastafile", "click", function(e) { me.icn3d; //e.preventDefault();
                me.htmlCls.dialogCls.openDlg('dl_fastafile', 'Please input FASTA MSA File');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_fixedversion", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_fixedversion', 'Open Share Link URL in the archived version of iCn3D');
            });
            me.myEventCls.onIds("#" + me.pre + "reload_fixedversion", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               let url = $("#" + me.pre + "sharelinkurl").val();
               thisClass.setLogCmd("open " + url, false);
               localStorage.setItem('fixedversion', '1');
               let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
               window.open(url, urlTarget);
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_mmciffile", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_mmciffile', 'Please append mmCIF File');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_mmcifid", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_mmcifid', 'Please input mmCIF ID');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_mmdbid", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_mmdbid', 'Please input MMDB or PDB ID');
            });

            me.myEventCls.onIds(["#" + me.pre + "mn1_mmdbafid", , "#" + me.pre + "tool_mmdbafid"], "click", function(e) { me.icn3d; //e.preventDefault();
                me.htmlCls.dialogCls.openDlg('dl_mmdbafid', 'Please input PDB/MMDB/AlphaFold UniProt IDs');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_blast_rep_id", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_blast_rep_id', 'Align sequence to structure');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_esmfold", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_esmfold', 'Sequence to structure prediction with ESMFold');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_proteinname", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_proteinname', 'Please input protein or gene name');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_cid", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_cid', 'Please input PubChem Compound');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_smiles", "click", function(e) { me.icn3d; //e.preventDefault();
             me.htmlCls.dialogCls.openDlg('dl_smiles', 'Please input a chemical SMILES');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_pngimage", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_pngimage', 'Please append PNG images');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_state", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_state', 'Please input the state file');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_selection", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_selection', 'Please input the selection file');
            });
           
            me.myEventCls.onIds("#" + me.pre + "mn1_collection", "click", function (e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg("dl_selectCollections", "Select Collections");
            });
           
            me.myEventCls.onIds("#" + me.pre + "mn1_dsn6", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_dsn6', 'Please input the map file to display electron density map');
            });


            me.myEventCls.onIds(["#" + me.pre + "mn1_delphi", "#" + me.pre + "mn1_delphi2", "#" + me.pre + "tool_delphi"], "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.loadPhiFrom = 'delphi';
               $("#" + me.pre + "dl_delphi_tabs").tabs();
               me.htmlCls.dialogCls.openDlg('dl_delphi', 'Please set parameters to display DelPhi potential map');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_phi", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.loadPhiFrom = 'phi';
               $("#" + me.pre + "dl_phi_tabs").tabs();
               $("#" + me.pre + "phitab1_tabs").tabs();
               $("#" + me.pre + "phitab2_tabs").tabs();
               me.htmlCls.dialogCls.openDlg('dl_phi', 'Please input local phi or cube file to display DelPhi potential map');
            });
            me.myEventCls.onIds("#" + me.pre + "mn1_phiurl", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.loadPhiFrom = 'phiurl';
               $("#" + me.pre + "dl_phiurl_tabs").tabs();
               $("#" + me.pre + "phiurltab1_tabs").tabs();
               $("#" + me.pre + "phiurltab2_tabs").tabs();
               me.htmlCls.dialogCls.openDlg('dl_phiurl', 'Please input URL phi or cube file to display DelPhi potential map');
            });


            me.myEventCls.onIds("#" + me.pre + "mn1_dsn6url", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_dsn6url', 'Please input the map file to display electron density map');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_exportState", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               thisClass.setLogCmd("export state file", false);
               let file_pref = Object.keys(ic.structures).join(',');

               ic.saveFileCls.saveFile(file_pref + '_statefile.txt', 'command');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_exportVideo", "click", function(e) { me.icn3d; //e.preventDefault();
             thisClass.setLogCmd("export video", false);
             me.htmlCls.dialogCls.openDlg('dl_video', 'Save canvas changes in a video');
            });


            me.myEventCls.onIds("#" + me.pre + "mn1_exportPdbRes", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.setHtmlCls.exportPdb();

               thisClass.setLogCmd("export pdb", true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_exportSecondary", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.setHtmlCls.exportSecondary();

               thisClass.setLogCmd("export secondary structure", true);
            });

            me.myEventCls.onIds(["#" + me.pre + "delphipdb", "#" + me.pre + "phipdb"], "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               let pdbStr = ic.saveFileCls.getSelectedResiduePDB();

               thisClass.setLogCmd("export PDB of selected residues", false);
               //let file_pref = Object.keys(ic.structures).join(',');
               let file_pref = Object.keys(ic.structures).join(',');
               ic.saveFileCls.saveFile(file_pref + '_icn3d_residues.pdb', 'text', [pdbStr]);
            });

            me.myEventCls.onIds(["#" + me.pre + "delphipqr", "#" + me.pre + "phipqr", "#" + me.pre + "phiurlpqr"], "click", async function(e) { me.icn3d; //e.preventDefault();
               await me.htmlCls.setHtmlCls.exportPqr();
               thisClass.setLogCmd("export pqr", true);
            });

          //   me.myEventCls.onIds("#" + me.pre + "delphipqbh", "click", async function(e) { let ic = me.icn3d; //e.preventDefault();
          //       let bPdb = true;
          //       await me.htmlCls.setHtmlCls.exportPqr(bPdb);
          //       thisClass.setLogCmd("export pdbh", false);
          //    });

            me.myEventCls.onIds("#" + me.pre + "profixpdb", "click", async function(e) { let ic = me.icn3d; //e.preventDefault();
             let bHydrogen = false;
             await ic.scapCls.exportPdbProfix(bHydrogen);
             thisClass.setLogCmd("export pdb missing atoms", true);
            });

            me.myEventCls.onIds("#" + me.pre + "profixpdbh", "click", async function(e) { let ic = me.icn3d; //e.preventDefault();
            let bHydrogen = true;
            await ic.scapCls.exportPdbProfix(bHydrogen);
            thisClass.setLogCmd("export pdb hydrogen", true);
           });

           me.myEventCls.onIds("#" + me.pre + "mn1_exportIgstrand", "click", async function(e) { let ic = me.icn3d; //e.preventDefault();
           ic.refnumCls.exportRefnum('igstrand');
           thisClass.setLogCmd("export refnum igstrand", true);
          });

          me.myEventCls.onIds("#" + me.pre + "mn1_exportKabat", "click", async function(e) { let ic = me.icn3d; //e.preventDefault();
          ic.refnumCls.exportRefnum('kabat');
             thisClass.setLogCmd("export refnum kabat", true);
          });

          me.myEventCls.onIds("#" + me.pre + "mn1_exportImgt", "click", async function(e) { let ic = me.icn3d; //e.preventDefault();
          ic.refnumCls.exportRefnum('imgt');
          thisClass.setLogCmd("export refnum imgt", true);
          });

            me.myEventCls.onIds("#" + me.pre + "mn1_exportStl", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               thisClass.setLogCmd("export stl file", false);
               //ic.threeDPrintCls.hideStabilizer();
               ic.export3DCls.exportStlFile('');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_exportVrml", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               thisClass.setLogCmd("export vrml file", false);
               //ic.threeDPrintCls.hideStabilizer();
               ic.export3DCls.exportVrmlFile('');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_exportStlStab", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               thisClass.setLogCmd("export stl stabilizer file", false);
               //ic.bRender = false;
               ic.threeDPrintCls.hideStabilizer();
               ic.threeDPrintCls.resetAfter3Dprint();
               ic.threeDPrintCls.addStabilizer();
               ic.export3DCls.exportStlFile('_stab');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_exportVrmlStab", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               thisClass.setLogCmd("export vrml stabilizer file", false);
               //ic.bRender = false;
               ic.threeDPrintCls.hideStabilizer();
               ic.threeDPrintCls.resetAfter3Dprint();
               ic.threeDPrintCls.addStabilizer();
               ic.export3DCls.exportVrmlFile('_stab');
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_exportInteraction", "click", async function(e) { let ic = me.icn3d; //e.preventDefault();
               thisClass.setLogCmd("export interactions", false);
               if(me.cfg.mmdbid !== undefined) await ic.viewInterPairsCls.retrieveInteractionData();
               ic.viewInterPairsCls.exportInteractions();
            });

            me.myEventCls.onIds(["#" + me.pre + "mn1_exportCanvas", "#" + me.pre + "saveimage"], "click", async function(e) { let ic = me.icn3d; //e.preventDefault();
               // do not record the export command
               //thisClass.setLogCmd("export canvas", true);
               thisClass.setLogCmd("export canvas", false);
               //var file_pref =(ic.inputid) ? ic.inputid : "custom";
               //ic.saveFileCls.saveFile(file_pref + '_image_icn3d_loadable.png', 'png');
               let bPngHtml = true;
               await ic.shareLinkCls.shareLink(bPngHtml);
            });
            me.myEventCls.onIds("#" + me.pre + "mn1_exportCanvas1", "click", async function(e) { let ic = me.icn3d; //e.preventDefault();
               thisClass.setLogCmd("export canvas 1", true);
               ic.scaleFactor = 1;
               await ic.shareLinkCls.shareLink(true, true);
            });
            me.myEventCls.onIds("#" + me.pre + "mn1_exportCanvas2", "click", async function(e) { let ic = me.icn3d; //e.preventDefault();
               thisClass.setLogCmd("export canvas 2", true);
               ic.scaleFactor = 2;
               await ic.shareLinkCls.shareLink(true, true);
            });
            me.myEventCls.onIds("#" + me.pre + "mn1_exportCanvas4", "click", async function(e) { let ic = me.icn3d; //e.preventDefault();
               thisClass.setLogCmd("export canvas 4", true);
               ic.scaleFactor = 4;
               await ic.shareLinkCls.shareLink(true, true);
            });
            me.myEventCls.onIds("#" + me.pre + "mn1_exportCanvas8", "click", async function(e) { let ic = me.icn3d; //e.preventDefault();
               thisClass.setLogCmd("export canvas 8", true);
               ic.scaleFactor = 8;
               await ic.shareLinkCls.shareLink(true, true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_exportCounts", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               thisClass.setLogCmd("export counts", false);
               let text = '<html><body><div style="text-align:center"><br><b>Total Count for atoms with coordinates</b>:<br/><table align=center border=1 cellpadding=10 cellspacing=0><tr><th>Structure Count</th><th>Chain Count</th><th>Residue Count</th><th>Atom Count</th></tr>';
               text += '<tr><td>' + Object.keys(ic.structures).length + '</td><td>' + Object.keys(ic.chains).length + '</td><td>' + Object.keys(ic.residues).length + '</td><td>' + Object.keys(ic.atoms).length + '</td></tr>';
               text += '</table><br/>';
               text += '<b>Counts by Chain for atoms with coordinates</b>:<br/><table align=center border=1 cellpadding=10 cellspacing=0><tr><th>Structure</th><th>Chain</th><th>Residue Count</th><th>Atom Count</th></tr>';
               let chainArray = Object.keys(ic.chains);

               for(let i = 0, il = chainArray.length; i < il; ++i) {
                   let chainid = chainArray[i];
                   //if(!chainid) continue;

                   let pos = chainid.indexOf('_');
                   let structure = chainid.substr(0, pos);
                   let chain = chainid.substr(pos + 1);
                   let residueHash = {};
                   let atoms = ic.chains[chainid];
                   for(let j in atoms) {
                       residueHash[ic.atoms[j].resi] = 1;
                   }
                   text += '<tr><td>' + structure + '</td><td>' + chain + '</td><td>' + Object.keys(residueHash).length + '</td><td>' + Object.keys(ic.chains[chainid]).length + '</td></tr>';
               }
               text += '</table><br/></div></body></html>';
               let file_pref = Object.keys(ic.structures).join(',');
               ic.saveFileCls.saveFile(file_pref + '_counts.html', 'html', text);
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_exportSelections", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               thisClass.setLogCmd("export all selections", false);
              
               thisClass.SetChainsAdvancedMenu();

               let text = ic.saveFileCls.exportCustomAtoms();
               let file_pref = Object.keys(ic.structures).join(',');
               ic.saveFileCls.saveFile(file_pref + '_selections.txt', 'text', [text]);
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_exportSelDetails", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               thisClass.setLogCmd("export all selections with details", false);
              
               thisClass.SetChainsAdvancedMenu();

               let bDetails = true;
               let text = ic.saveFileCls.exportCustomAtoms(bDetails);
               let file_pref = Object.keys(ic.structures).join(',');
               ic.saveFileCls.saveFile(file_pref + '_sel_details.txt', 'text', [text]);
            });

            me.myEventCls.onIds(["#" + me.pre + "mn1_sharelink", "#" + me.pre + "tool_sharelink"], "click", async function(e) { let ic = me.icn3d; //e.preventDefault();
                await ic.shareLinkCls.shareLink();
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_replayon", "click", async function(e) { let ic = me.icn3d; //e.preventDefault();
              await ic.resizeCanvasCls.replayon();
              thisClass.setLogCmd("replay on", true);
            });
            me.myEventCls.onIds("#" + me.pre + "mn1_replayoff", "click", async function(e) { let ic = me.icn3d; //e.preventDefault();
                await ic.resizeCanvasCls.replayoff();
                thisClass.setLogCmd("replay off", true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_menuall", "click", function(e) { me.icn3d; //e.preventDefault();
                me.htmlCls.shownMenus = me.hashUtilsCls.cloneHash(me.htmlCls.allMenus);

                thisClass.applyShownMenus();    
              });

            me.myEventCls.onIds("#" + me.pre + "mn1_menusimple", "click", function(e) { me.icn3d; //e.preventDefault();
                me.htmlCls.shownMenus = me.hashUtilsCls.cloneHash(me.htmlCls.simpleMenus);

                thisClass.applyShownMenus();
              });

            me.myEventCls.onIds("#" + me.pre + "mn1_menupref", "click", function(e) { me.icn3d; //e.preventDefault();
                me.htmlCls.dialogCls.openDlg('dl_menupref', 'Select Menus');

                thisClass.getHiddenMenusFromCache();

                thisClass.displayShownMenus();
             });

             me.myEventCls.onIds(["#" + me.pre + "apply_menupref", "#" + me.pre + "apply_menupref2"], "click", function(e) { me.icn3d; //e.preventDefault();
                var checkboxes = document.querySelectorAll('form[name="' + me.pre + 'selmenu"] input:checked');
                me.htmlCls.shownMenus = {};
                for (var checkbox of checkboxes) {
                    me.htmlCls.shownMenus[checkbox.value] = 1;
                }

                me.htmlCls.setHtmlCls.setCookie('menumode', 'custom');

                thisClass.applyShownMenus();
             });

             me.myEventCls.onIds(["#" + me.pre + "reset_menupref", "#" + me.pre + "reset_menupref2"], "click", function(e) { me.icn3d; //e.preventDefault();
                me.htmlCls.shownMenus = me.hashUtilsCls.cloneHash(me.htmlCls.simpleMenus);
                me.htmlCls.setHtmlCls.setCookie('menumode', 'simple');

                thisClass.applyShownMenus();
                thisClass.displayShownMenus();
             });

             me.myEventCls.onIds(["#" + me.pre + "reset_menupref_all", "#" + me.pre + "reset_menupref_all2"], "click", function(e) { me.icn3d; //e.preventDefault();
                me.htmlCls.shownMenus = me.hashUtilsCls.cloneHash(me.htmlCls.allMenus);
                me.htmlCls.setHtmlCls.setCookie('menumode', 'all');

                thisClass.applyShownMenus();
                thisClass.displayShownMenus();
             });

             me.myEventCls.onIds(["#" + me.pre + "savepref", "#" + me.pre + "savepref2"], "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                let menuStr = '[';

                //var checkboxes = document.querySelectorAll('form[name="' + me.pre + 'selmenu"] input:checked');
                var checkboxes = document.querySelectorAll('form[name="' + me.pre + 'selmenu"] input:not(:checked)');
                let cnt = 0;
                for (var checkbox of checkboxes) {
                    if(cnt > 0) menuStr += ', ';
                    menuStr += '"' + checkbox.value + '"';
                    ++cnt;
                }
                
                menuStr += ']';
        
                ic.saveFileCls.saveFile('icn3d_menus_pref.txt', 'text', [menuStr]);
             });

             me.myEventCls.onIds("#" + me.pre + "reload_menupreffile", "click", function(e) { me.icn3d; 
                e.preventDefault();

                if(!me.cfg.notebook) dialog.dialog( "close" );
                let file = $("#" + me.pre + "menupreffile")[0].files[0];
                if(!file) {
                  alert("Please select a file before clicking 'Load'");
                }
                else {
                  me.htmlCls.setHtmlCls.fileSupport();
                  let reader = new FileReader();
                  reader.onload = function(e) {
                    let dataStr = e.target.result; // or = reader.result;
                    let idArray = JSON.parse(dataStr);

                    me.htmlCls.shownMenus = {};
                    // for(let i = 0, il = idArray.length; i < il; ++i) {
                    //     me.htmlCls.shownMenus[idArray[i]] = 1;
                    // }
                    for(let menu in me.htmlCls.allMenus) {
                        if(idArray.indexOf(menu) == -1) {
                            me.htmlCls.shownMenus[menu] = 1;
                        }
                    }

                    thisClass.applyShownMenus();
                    thisClass.displayShownMenus();

                    me.htmlCls.setHtmlCls.setCookie('menumode', 'custom');
                  };
                  reader.readAsText(file);
                }
             });

            me.myEventCls.onIds(["#" + me.pre + "mn1_menuloadpref", "#" + me.pre + "loadpref", "#" + me.pre + "loadpref2"], "click", function(e) { me.icn3d; //e.preventDefault();
                me.htmlCls.dialogCls.openDlg('dl_menuloadpref', 'Please input the menu preference file');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_link_structure", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               let url = ic.saveFileCls.getLinkToStructureSummary(true);
               let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
               window.open(url, urlTarget);
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_alphafold", "click", function(e) { me.icn3d; //e.preventDefault();
               let url = 'https://github.com/sokrypton/ColabFold';
               window.open(url, '_blank');
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_link_bind", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               let url = "https://www.ncbi.nlm.nih.gov/pccompound?LinkName=pccompound_structure&from_uid=" + ic.inputid;
               thisClass.setLogCmd("link to 3D protein structures bound to CID " + ic.inputid + ": " + url, false);
               let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
               window.open(url, urlTarget);
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_link_vast", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
             let url;  
             if(ic.inputid === undefined) {
                   url = "https://www.ncbi.nlm.nih.gov/pccompound?term=" + ic.molTitle;
                   thisClass.setLogCmd("link to compounds " + ic.molTitle + ": " + url, false);
               }
               else {
                   if(me.cfg.cid !== undefined) {
                           url = "https://www.ncbi.nlm.nih.gov/pccompound?LinkName=pccompound_pccompound_3d&from_uid=" + ic.inputid;
                           thisClass.setLogCmd("link to compounds with structure similar to CID " + ic.inputid + ": " + url, false);
                   }
                   else {
                       let idArray = ic.inputid.split('_');
                       
                       if(idArray.length === 1) {
                           url = me.htmlCls.baseUrl + "vastplus/vastplus.cgi?uid=" + ic.inputid;
                           thisClass.setLogCmd("link to structures similar to " + ic.inputid + ": " + url, false);
                       }
                       else if(idArray.length === 2) {
                           url = me.htmlCls.baseUrl + "vastplus/vastplus.cgi?uid=" + idArray[0];
                           thisClass.setLogCmd("link to structures similar to " + idArray[0] + ": " + url, false);
                       }
                   }
               }

               let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
               window.open(url, urlTarget);
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_link_pubmed", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               let url;
               if(ic.inputid === undefined) {
                   url = "https://www.ncbi.nlm.nih.gov/pubmed/?term=" + ic.molTitle;
                   thisClass.setLogCmd("link to literature about " + ic.molTitle + ": " + url, false);
                   let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                   window.open(url, urlTarget);
               }
               else if(ic.pmid) {
                   let idArray = ic.pmid.toString().split('_');
                   if(idArray.length === 1) {
                       url = "https://www.ncbi.nlm.nih.gov/pubmed/" + ic.pmid;
                       thisClass.setLogCmd("link to PubMed ID " + ic.pmid + ": " + url, false);
                   }
                   else if(idArray.length === 2) {
                       url = "https://www.ncbi.nlm.nih.gov/pubmed/?term=" + idArray[0] + " OR " + idArray[1];
                       thisClass.setLogCmd("link to PubMed IDs " + idArray[0] + ", " + idArray[1] + ": " + url, false);
                   }
                   let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                   window.open(url, urlTarget);
               }
               else if(isNaN(ic.inputid)) {
                   let idArray = ic.inputid.toString().split('_');
                   if(idArray.length === 1) {
                       url = "https://www.ncbi.nlm.nih.gov/pubmed/?term=" + ic.inputid;
                       thisClass.setLogCmd("link to literature about PDB " + ic.inputid + ": " + url, false);
                   }
                   else if(idArray.length === 2) {
                       url = "https://www.ncbi.nlm.nih.gov/pubmed/?term=" + idArray[0] + " OR " + idArray[1];
                       thisClass.setLogCmd("link to literature about PDB " + idArray[0] + " OR " + idArray[1] + ": " + url, false);
                   }
                   let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                   window.open(url, urlTarget);
               }
               else {
                   if(me.cfg.cid !== undefined) {
                       alert("No literature information is available for this compound in the SDF file.");
                   }
                   else {
                       alert("No literature information is available for this structure.");
                   }
               }
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_link_protein", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
              //ic.saveFileCls.setEntrezLinks('protein');
              let structArray = Object.keys(ic.structures);
              let chainArray = Object.keys(ic.chains);
              let text = '';
              for(let i = 0, il = chainArray.length; i < il; ++i) {
                  let firstAtom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.chains[chainArray[i]]);
                  if(ic.proteins.hasOwnProperty(firstAtom.serial) && chainArray[i].length == 6) {
                      text += chainArray[i] + '[accession] OR ';
                  }
              }
              if(text.length > 0) text = text.substr(0, text.length - 4);
              let url = "https://www.ncbi.nlm.nih.gov/protein/?term=" + text;
              thisClass.setLogCmd("link to Entrez protein about PDB " + structArray + ": " + url, false);
              let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
              window.open(url, urlTarget);
            });

        }

        clickMenu2() { let me = this.icn3dui; me.icn3d;
            if(me.bNode) return;

            let thisClass = this;

            me.myEventCls.onIds(["#" + me.pre + "mn6_selectannotations", "#" + me.pre + "tool_selectannotations"], "click", async function(e) { let ic = me.icn3d; //e.preventDefault();
               await ic.showAnnoCls.showAnnotations();
               thisClass.setLogCmd("view annotations", true);
               //thisClass.setLogCmd("window annotations", true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_selectall", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               thisClass.setLogCmd("select all", true);
               ic.selectionCls.selectAll();
               ic.hlUpdateCls.removeHlAll();
               ic.drawCls.draw();
            });
            me.myEventCls.onIds("#" + me.pre + "clearall", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               thisClass.setLogCmd("clear all", true);
               ic.bSelectResidue = false;
               ic.selectionCls.selectAll();
               ic.hlUpdateCls.removeHlAll();
               ic.drawCls.draw();
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_selectdisplayed", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               thisClass.setLogCmd("select displayed set", true);
               //ic.hAtoms = me.hashUtilsCls.cloneHash(ic.dAtoms);
               ic.hAtoms = me.hashUtilsCls.cloneHash(ic.viewSelectionAtoms);
               ic.hlUpdateCls.updateHlAll();
               //ic.drawCls.draw();
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_clashedYes", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                ic.bHideClashed = false;
                ic.annoDomainCls.showHideClashedResidues();

                ic.drawCls.draw();
                thisClass.setLogCmd('clashed residues show', true);
            });
            me.myEventCls.onIds("#" + me.pre + "mn2_clashedNo", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                ic.bHideClashed = true;

                thisClass.setClashedResidues();
                ic.annoDomainCls.showHideClashedResidues();

                ic.drawCls.draw();
                thisClass.setLogCmd('clashed residues hide', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_fullstru", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               thisClass.setLogCmd("show all", true);
               ic.selectionCls.showAll();
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_selectcomplement", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               if(Object.keys(ic.hAtoms).length < Object.keys(ic.atoms).length) {
                   thisClass.setLogCmd("select complement", true);
                   ic.resid2specCls.selectComplement();
               }
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_selectmainchains", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               thisClass.setLogCmd("select main chains", true);
               ic.selectionCls.selectMainChains();
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_selectsidechains", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               thisClass.setLogCmd("select side chains", true);
               ic.selectionCls.selectSideChains();
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_selectmainsidechains", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               thisClass.setLogCmd("select main side chains", true);
               ic.selectionCls.selectMainSideChains();
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_propPos", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               thisClass.setLogCmd("select prop positive", true);
               ic.resid2specCls.selectProperty('positive');
            });
            me.myEventCls.onIds("#" + me.pre + "mn2_propNeg", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               thisClass.setLogCmd("select prop negative", true);
               ic.resid2specCls.selectProperty('negative');
            });
            me.myEventCls.onIds("#" + me.pre + "mn2_propHydro", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               thisClass.setLogCmd("select prop hydrophobic", true);
               ic.resid2specCls.selectProperty('hydrophobic');
            });
            me.myEventCls.onIds("#" + me.pre + "mn2_propPolar", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               thisClass.setLogCmd("select prop polar", true);
               ic.resid2specCls.selectProperty('polar');
            });
            me.myEventCls.onIds("#" + me.pre + "mn2_propBfactor", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_propbybfactor', 'Select residue based on B-factor/pLDDT');
            });
            me.myEventCls.onIds("#" + me.pre + "mn2_propSolAcc", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_propbypercentout', 'Select residue based on the percentage of solvent accessilbe surface area');
            });
            me.myEventCls.onIds("#" + me.pre + "applypropbybfactor", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               let from = $("#" + me.pre + "minbfactor").val();
               let to = $("#" + me.pre + "maxbfactor").val();
               thisClass.setLogCmd("select prop b factor | " + from + '_' + to, true);
               ic.resid2specCls.selectProperty('b factor', from, to);
            });
            me.myEventCls.onIds("#" + me.pre + "applypropbypercentout", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               let from = $("#" + me.pre + "minpercentout").val();
               let to = $("#" + me.pre + "maxpercentout").val();
               thisClass.setLogCmd("select prop percent out | " + from + '_' + to, true);
               ic.resid2specCls.selectProperty('percent out', from, to);
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_alignment", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_alignment', 'Select residues in aligned sequences');
               thisClass.setLogCmd("window aligned sequences", true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_window_table", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_allinteraction', 'Show interactions');
               thisClass.setLogCmd("window interaction table", true);
            });
            me.myEventCls.onIds("#" + me.pre + "mn1_window_linegraph", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_linegraph', 'Show interactions between two lines of residue nodes');
               thisClass.setLogCmd("window interaction graph", true);
            });
            me.myEventCls.onIds("#" + me.pre + "mn1_window_scatterplot", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_scatterplot', 'Show interactions as map');
               thisClass.setLogCmd("window interaction scatterplot", true);
            });
            me.myEventCls.onIds("#" + me.pre + "mn1_window_graph", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_graph', 'Force-directed graph');
               thisClass.setLogCmd("window force-directed graph", true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_yournote", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_yournote', 'Your note about the current display');
            });

            me.myEventCls.onIds("#" + me.pre + "applyyournote", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.yournote = $("#" + me.pre + "yournote").val();
               if(me.cfg.shownote) document.title = ic.yournote;
               if(!me.cfg.notebook) dialog.dialog( "close" );
               thisClass.setLogCmd('your note | ' + ic.yournote, true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_command", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_advanced2', 'Select by specification');
            });

            me.myEventCls.onIds(["#" + me.pre + "mn2_definedsets", "#" + me.pre + "definedsets", "#" + me.pre + "definedsets2", "#" + me.pre + "tool_definedsets"], "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.definedSetsCls.showSets();
               thisClass.setLogCmd('defined sets', true);
               //thisClass.setLogCmd('window defined sets', true);
            });
            $(document).on("click", "#" + me.pre + "setOr", function(e) { let ic = me.icn3d;
                e.stopImmediatePropagation();
                ic.setOperation = 'or';
            });
            $(document).on("click", "#" + me.pre + "setAnd", function(e) { let ic = me.icn3d;
                e.stopImmediatePropagation();
                ic.setOperation = 'and';
            });
            $(document).on("click", "#" + me.pre + "setNot", function(e) { let ic = me.icn3d;
                e.stopImmediatePropagation();
                ic.setOperation = 'not';
            });


            me.myEventCls.onIds("#" + me.pre + "mn2_pkNo", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.pk = 0;
               ic.opts['pk'] = 'no';
               thisClass.setLogCmd('set pk off', true);
               ic.drawCls.draw();
               ic.hlObjectsCls.removeHlObjects();
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_pkYes", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.pk = 1;
               ic.opts['pk'] = 'atom';
               thisClass.setLogCmd('set pk atom', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_pkResidue", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.pk = 2;
               ic.opts['pk'] = 'residue';
               thisClass.setLogCmd('set pk residue', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_pkStrand", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.pk = 3;
               ic.opts['pk'] = 'strand';
               thisClass.setLogCmd('set pk strand', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_pkDomain", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.pk = 4;
               ic.opts['pk'] = 'domain';
               thisClass.setLogCmd('set pk domain', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_pkChain", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.pk = 5;
               ic.opts['pk'] = 'chain';
               thisClass.setLogCmd('set pk chain', true);
            });

            me.myEventCls.onIds("#" + me.pre + "adjustmem", "click", function(e) { me.icn3d; //e.preventDefault();
                me.htmlCls.dialogCls.openDlg('dl_adjustmem', 'Adjust the Z-axis positions of the membrane');
            });

            me.myEventCls.onIds("#" + me.pre + "togglemem", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.selectionCls.toggleMembrane();
               thisClass.setLogCmd('toggle membrane', true);
            });

            me.myEventCls.onIds("#" + me.pre + "selectplane", "click", function(e) { me.icn3d; //e.preventDefault();
                me.htmlCls.dialogCls.openDlg('dl_selectplane', 'Select a region between two planes');
            });

            me.myEventCls.onIds(["#" + me.pre + "mn2_aroundsphere", "#" + me.pre + "tool_aroundsphere"], "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                thisClass.SetChainsAdvancedMenu();

                let definedAtomsHtml = ic.definedSetsCls.setAtomMenu(['protein']);
                if($("#" + me.pre + "atomsCustomSphere").length) {
                    $("#" + me.pre + "atomsCustomSphere").html("  <option value='non-selected' selected>non-selected</option><option value='selected'>selected</option>" + definedAtomsHtml);
                }
                if($("#" + me.pre + "atomsCustomSphere2").length) {
                    $("#" + me.pre + "atomsCustomSphere2").html("  <option value='selected' selected>selected</option>" + definedAtomsHtml);
                }
                me.htmlCls.dialogCls.openDlg('dl_aroundsphere', 'Select a sphere around a set of residues');
                ic.bSphereCalc = false;
                //thisClass.setLogCmd('set calculate sphere false', true);
                $("#" + me.pre + "atomsCustomSphere").resizable();
                $("#" + me.pre + "atomsCustomSphere2").resizable();
            });

            me.myEventCls.onIds(["#" + me.pre + "mn2_select_chain", "#" + me.pre + "definedSets"], "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_select_chain', 'Select Structure/Chain/Custom Selection');
            });

        }

        clickMenu3() { let me = this.icn3dui; me.icn3d;
            if(me.bNode) return;

            let thisClass = this;
        // mn 3
            me.myEventCls.onIds(["#" + me.pre + "mn3_proteinsRibbon","#" + me.pre + "tool_proteinsRibbon"], "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('proteins', 'ribbon');
               thisClass.setLogCmd('style proteins ribbon', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_proteinsStrand", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('proteins', 'strand');
               thisClass.setLogCmd('style proteins strand', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_proteinsCylinder", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('proteins', 'cylinder and plate');
               thisClass.setLogCmd('style proteins cylinder and plate', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_proteinsSchematic", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('proteins', 'schematic');
               thisClass.setLogCmd('style proteins schematic', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_proteinsCalpha", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('proteins', 'c alpha trace');
               thisClass.setLogCmd('style proteins c alpha trace', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_proteinsBackbone", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('proteins', 'backbone');
               thisClass.setLogCmd('style proteins backbone', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_proteinsBfactor", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('proteins', 'b factor tube');
               thisClass.setLogCmd('style proteins b factor tube', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_proteinsLines", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('proteins', 'lines');
               thisClass.setLogCmd('style proteins lines', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_proteinsStick", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('proteins', 'stick');
               thisClass.setLogCmd('style proteins stick', true);
            });

            me.myEventCls.onIds(["#" + me.pre + "mn3_proteinsBallstick", "#" + me.pre + "tool_proteinsBallstick"], "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('proteins', 'ball and stick');
               thisClass.setLogCmd('style proteins ball and stick', true);
            });

            me.myEventCls.onIds(["#" + me.pre + "mn3_proteinsSphere", "#" + me.pre + "tool_proteinsSphere"], "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('proteins', 'sphere');
               thisClass.setLogCmd('style proteins sphere', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_proteinsNo", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('proteins', 'nothing');
               thisClass.setLogCmd('style proteins nothing', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_sidecLines", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('sidec', 'lines2');
               thisClass.setLogCmd('style sidec lines2', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_sidecStick", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('sidec', 'stick2');
               thisClass.setLogCmd('style sidec stick2', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_sidecBallstick", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('sidec', 'ball and stick2');
               thisClass.setLogCmd('style sidec ball and stick2', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_sidecSphere", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('sidec', 'sphere2');
               thisClass.setLogCmd('style sidec sphere2', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_sidecNo", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('sidec', 'nothing');
               thisClass.setLogCmd('style sidec nothing', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_ntbaseLines", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                ic.setOptionCls.setStyle('ntbase', 'lines2');
                thisClass.setLogCmd('style ntbase lines2', true);
             });
     
             me.myEventCls.onIds("#" + me.pre + "mn3_ntbaseStick", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                ic.setOptionCls.setStyle('ntbase', 'stick2');
                thisClass.setLogCmd('style ntbase stick2', true);
             });
     
             me.myEventCls.onIds("#" + me.pre + "mn3_ntbaseBallstick", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                ic.setOptionCls.setStyle('ntbase', 'ball and stick2');
                thisClass.setLogCmd('style ntbase ball and stick2', true);
             });
     
             me.myEventCls.onIds("#" + me.pre + "mn3_ntbaseSphere", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                ic.setOptionCls.setStyle('ntbase', 'sphere2');
                thisClass.setLogCmd('style ntbase sphere2', true);
             });
     
             me.myEventCls.onIds("#" + me.pre + "mn3_ntbaseNo", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                ic.setOptionCls.setStyle('ntbase', 'nothing');
                thisClass.setLogCmd('style ntbase nothing', true);
             });

            me.myEventCls.onIds("#" + me.pre + "mn3_nuclCartoon", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('nucleotides', 'nucleotide cartoon');
               thisClass.setLogCmd('style nucleotides nucleotide cartoon', true);
           });

            me.myEventCls.onIds("#" + me.pre + "mn3_nuclBackbone", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('nucleotides', 'backbone');
               thisClass.setLogCmd('style nucleotides backbone', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_nuclSchematic", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('nucleotides', 'schematic');
               thisClass.setLogCmd('style nucleotides schematic', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_nuclPhos", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('nucleotides', 'o3 trace');
               thisClass.setLogCmd('style nucleotides o3 trace', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_nuclLines", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('nucleotides', 'lines');
               thisClass.setLogCmd('style nucleotides lines', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_nuclStick", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('nucleotides', 'stick');
               thisClass.setLogCmd('style nucleotides stick', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_nuclBallstick", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('nucleotides', 'ball and stick');
               thisClass.setLogCmd('style nucleotides ball and stick', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_nuclSphere", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('nucleotides', 'sphere');
               thisClass.setLogCmd('style nucleotides sphere', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_nuclNo", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('nucleotides', 'nothing');
               thisClass.setLogCmd('style nucleotides nothing', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_ligLines", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('chemicals', 'lines');
               thisClass.setLogCmd('style chemicals lines', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_ligStick", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('chemicals', 'stick');
               thisClass.setLogCmd('style chemicals stick', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_ligBallstick", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('chemicals', 'ball and stick');
               thisClass.setLogCmd('style chemicals ball and stick', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_ligSchematic", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('chemicals', 'schematic');
               thisClass.setLogCmd('style chemicals schematic', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_ligSphere", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('chemicals', 'sphere');
               thisClass.setLogCmd('style chemicals sphere', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_ligNo", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('chemicals', 'nothing');
               thisClass.setLogCmd('style chemicals nothing', true);
            });


            me.myEventCls.onIds("#" + me.pre + "mn3_glycansCartYes", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.bGlycansCartoon = true;
               ic.drawCls.draw();
               thisClass.setLogCmd('glycans cartoon yes', true);
            });
            me.myEventCls.onIds("#" + me.pre + "mn3_glycansCartNo", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.bGlycansCartoon = false;
               ic.drawCls.draw();
               thisClass.setLogCmd('glycans cartoon no', true);
            });


            me.myEventCls.onIds("#" + me.pre + "mn3_hydrogensYes", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.showInterCls.showHydrogens();
               ic.drawCls.draw();
               thisClass.setLogCmd('hydrogens', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_hydrogensNo", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.showInterCls.hideHydrogens();
               ic.drawCls.draw();
               thisClass.setLogCmd('set hydrogens off', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_ionsSphere", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('ions', 'sphere');
               thisClass.setLogCmd('style ions sphere', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_ionsDot", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('ions', 'dot');
               thisClass.setLogCmd('style ions dot', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_ionsNo", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('ions', 'nothing');
               thisClass.setLogCmd('style ions nothing', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_waterSphere", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('water', 'sphere');
               thisClass.setLogCmd('style water sphere', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_waterDot", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('water', 'dot');
               thisClass.setLogCmd('style water dot', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_waterNo", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setStyle('water', 'nothing');
               thisClass.setLogCmd('style water nothing', true);
            });

        }

        clickMenu4() { let me = this.icn3dui; me.icn3d;
            if(me.bNode) return;

            let thisClass = this;
        // mn 4
            me.myEventCls.onIds("#" + me.pre + "mn4_clrSpectrum", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setOption('color', 'spectrum');
               thisClass.setLogCmd('color spectrum', true);
            });
            me.myEventCls.onIds("#" + me.pre + "mn4_clrSpectrumChain", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setOption('color', 'spectrum for chains');
               thisClass.setLogCmd('color spectrum for chains', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn4_clrSpectrumAcrossSets", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                 thisClass.SetChainsAdvancedMenu();
                 let definedAtomsHtml = ic.definedSetsCls.setAtomMenu(['protein']);
                 if($("#" + me.pre + "atomsCustomColorSpectrumAcross").length) {
                     $("#" + me.pre + "atomsCustomColorSpectrumAcross").html(definedAtomsHtml);
                 }

                 if(ic.bRender) me.htmlCls.dialogCls.openDlg('dl_colorspectrumacrosssets', 'Please select sets to apply spectrum color for sets');
                 $("#" + me.pre + "atomsCustomColorSpectrumAcross").resizable();
             });

             me.myEventCls.onIds("#" + me.pre + "mn4_clrSpectrumSets", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                 thisClass.SetChainsAdvancedMenu();
                 let definedAtomsHtml = ic.definedSetsCls.setAtomMenu(['protein']);
                 if($("#" + me.pre + "atomsCustomColorSpectrum").length) {
                     $("#" + me.pre + "atomsCustomColorSpectrum").html(definedAtomsHtml);
                 }

                 if(ic.bRender) me.htmlCls.dialogCls.openDlg('dl_colorspectrumbysets', 'Please select sets to apply spectrum color for residues');
                 $("#" + me.pre + "atomsCustomColorSpectrum").resizable();
             });

             me.myEventCls.onIds("#" + me.pre + "mn4_clrRainbowAcrossSets", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                 thisClass.SetChainsAdvancedMenu();
                 let definedAtomsHtml = ic.definedSetsCls.setAtomMenu(['protein']);
                 if($("#" + me.pre + "atomsCustomColorRainbowAcross").length) {
                     $("#" + me.pre + "atomsCustomColorRainbowAcross").html(definedAtomsHtml);
                 }

                 if(ic.bRender) me.htmlCls.dialogCls.openDlg('dl_colorrainbowacrosssets', 'Please select sets to apply rainbow color for sets');
                 $("#" + me.pre + "atomsCustomColorRainbowAcross").resizable();
             });

             me.myEventCls.onIds("#" + me.pre + "mn4_clrRainbowSets", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                 thisClass.SetChainsAdvancedMenu();
                 let definedAtomsHtml = ic.definedSetsCls.setAtomMenu(['protein']);
                 if($("#" + me.pre + "atomsCustomColorRainbow").length) {
                     $("#" + me.pre + "atomsCustomColorRainbow").html(definedAtomsHtml);
                 }

                 if(ic.bRender) me.htmlCls.dialogCls.openDlg('dl_colorrainbowbysets', 'Please select sets to apply rainbow color for residues');
                 $("#" + me.pre + "atomsCustomColorRainbow").resizable();
             });

            me.myEventCls.onIds("#" + me.pre + "mn4_clrRainbow", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setOption('color', 'rainbow');

               thisClass.setLogCmd('color rainbow', true);
            });
            me.myEventCls.onIds(["#" + me.pre + "mn4_clrRainbowChain", "#" + me.pre + "tool_clrRainbowChain"], "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setOption('color', 'rainbow for chains');
               thisClass.setLogCmd('color rainbow for chains', true);
            });

            me.myEventCls.onIds(["#" + me.pre + "mn4_clrChain", "#" + me.pre + "tool_clrChain"], "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setOption('color', 'chain');
               thisClass.setLogCmd('color chain', true);
            });
            me.myEventCls.onIds("#" + me.pre + "mn4_clrStructure", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                ic.setOptionCls.setOption('color', 'structure');
                thisClass.setLogCmd('color structure', true);
             });

            me.myEventCls.onIds("#" + me.pre + "mn4_clrdomain", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setOption('color', 'domain');
               thisClass.setLogCmd('color domain', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn4_clrsets", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setOption('color', 'defined sets');
               thisClass.setLogCmd('color defined sets', true);
            });


            me.myEventCls.onIds(["#" + me.pre + "mn4_clrSSGreen", "#" + me.pre + "tool_clrSSGreen"], "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.sheetcolor = 'green';
               ic.setOptionCls.setOption('color', 'secondary structure green');
               thisClass.setLogCmd('color secondary structure green', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn4_clrSSYellow", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.sheetcolor = 'yellow';
               ic.setOptionCls.setOption('color', 'secondary structure yellow');
               thisClass.setLogCmd('color secondary structure yellow', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn4_clrSSSpectrum", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setOption('color', 'secondary structure spectrum');
               thisClass.setLogCmd('color secondary structure spectrum', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn4_clrResidue", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                //ic.legendClick = 2;
                ic.setOptionCls.setOption('color', 'residue');
                thisClass.setLogCmd('color residue', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn4_clrResidueCustom", "click", function(e) { me.icn3d; //e.preventDefault();
                //ic.legendClick = 2;
                me.htmlCls.dialogCls.openDlg('dl_rescolorfile', 'Please input the file on residue colors');
            });

            me.myEventCls.onIds("#" + me.pre + "reload_rescolorfile", "click", function(e) { let ic = me.icn3d; 
               e.preventDefault();

               if(!me.cfg.notebook) dialog.dialog( "close" );
               let file = $("#" + me.pre + "rescolorfile")[0].files[0];
               if(!file) {
                 alert("Please select a file before clicking 'Load'");
               }
               else {
                 me.htmlCls.setHtmlCls.fileSupport();
                 let reader = new FileReader();
                 reader.onload = function(e) {
                   let dataStrTmp = e.target.result; // or = reader.result;
                   let dataStr = dataStrTmp.replace(/#/g, "");
                   ic.customResidueColors = JSON.parse(dataStr);
                   for(let res in ic.customResidueColors) {
                       ic.customResidueColors[res.toUpperCase()] = me.parasCls.thr("#" + ic.customResidueColors[res]);
                   }
                   ic.setOptionCls.setOption('color', 'residue custom');
                   thisClass.setLogCmd('color residue custom | ' + dataStr, true);
                 };
                 reader.readAsText(file);
               }
            });

            me.myEventCls.onIds("#" + me.pre + "reload_customcolorfile", "click", function(e) { let ic = me.icn3d; 
               e.preventDefault();

               if(!me.cfg.notebook) dialog.dialog( "close" );
               ic.startColor = $("#" + me.pre + "startColor").val();
               ic.midColor = $("#" + me.pre + "midColor").val();
               ic.endColor = $("#" + me.pre + "endColor").val();

               let legendHtml = thisClass.setLegendHtml();
               //$("#" + me.pre + "legend").html(legendHtml).show();
               $("#" + me.pre + "dl_legend_html").html(legendHtml);
               me.htmlCls.dialogCls.openDlg('dl_legend', 'Color range');

               ic.addTrackCls.setCustomFile('color', ic.startColor, ic.midColor, ic.endColor);
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_customref", "click", function(e) { me.icn3d; //e.preventDefault();
     
                me.htmlCls.dialogCls.openDlg('dl_customref', 'Set custom reference numbers');
             });

            me.myEventCls.onIds("#" + me.pre + "reload_customreffile", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
     
                if(!me.cfg.notebook) dialog.dialog( "close" );
                
                let file = $("#" + ic.pre + "cstreffile")[0].files[0];
                if(!file) {
                    alert("Please select a file before clicking 'Apply'");
                }
                else {
                    me.utilsCls.checkFileAPI();
                    let reader = new FileReader();
                    reader.onload = async function(e) {
                        let dataStr = e.target.result; // or = reader.result;
                        await ic.refnumCls.parseCustomRefFile(dataStr);

                        dataStr = dataStr.replace(/\r/g, '').replace(/\n/g, '\\n');

                        thisClass.setLogCmd('custom refnum | ' + dataStr, true);
                    };
                    reader.readAsText(file);
                }
            }); 

            me.myEventCls.onIds("#" + me.pre + "remove_legend", "click", function(e) { me.icn3d; 
               e.preventDefault();

               $("#" + me.pre + "legend").hide();

               thisClass.setLogCmd('remove legend', true);
            });
            me.myEventCls.onIds("#" + me.pre + "reload_customtubefile", "click", function(e) { let ic = me.icn3d; 
               e.preventDefault();

               if(!me.cfg.notebook) dialog.dialog( "close" );
               ic.addTrackCls.setCustomFile('tube');
            });

            me.myEventCls.onIds("#" + me.pre + "mn4_clrCharge", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                //ic.legendClick = 3;
                ic.setOptionCls.setOption('color', 'charge');
                thisClass.setLogCmd('color charge', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn4_clrHydrophobic", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                //ic.legendClick = 4; 
                ic.setOptionCls.setOption('color', 'hydrophobic');
                thisClass.setLogCmd('color hydrophobic', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn4_clrNormalizedHP", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                //ic.legendClick = 4;
                ic.setOptionCls.setOption('color', 'normalized hydrophobic');
                thisClass.setLogCmd('color normalized hydrophobic', true);
            });


            me.myEventCls.onIds(["#" + me.pre + "mn4_clrAtom", "#" + me.pre + "tool_clrAtom"], "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                //ic.legendClick = 1;
                ic.setOptionCls.setOption('color', 'atom');
                thisClass.setLogCmd('color atom', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn4_clrBfactor", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                //ic.legendClick = 5;
                ic.setOptionCls.setOption('color', 'b factor');
                thisClass.setLogCmd('color b factor', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn4_clrConfidence", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                //ic.legendClick = 6;
                ic.setOptionCls.setOption('color', 'confidence');
                thisClass.setLogCmd('color confidence', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn4_clrIgstrand", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                //ic.legendClick = 6;
                ic.setOptionCls.setOption('color', 'ig strand');
                thisClass.setLogCmd('color ig strand', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn4_clrIgproto", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                //ic.legendClick = 6;
                ic.setOptionCls.setOption('color', 'ig protodomain');
                thisClass.setLogCmd('color ig protodomain', true);
            });


            me.myEventCls.onIds("#" + me.pre + "mn4_clrArea", "click", function(e) { me.icn3d; //e.preventDefault();
                me.htmlCls.dialogCls.openDlg('dl_colorbyarea', "Color based on residue's solvent accessibility");
            });
            me.myEventCls.onIds("#" + me.pre + "applycolorbyarea", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                ic.midpercent = $("#" + me.pre + 'midpercent').val();
                ic.setOptionCls.setOption('color', 'area');
                thisClass.setLogCmd('color area | ' + ic.midpercent, true);

            });

            me.myEventCls.onIds("#" + me.pre + "mn4_clrBfactorNorm", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setOption('color', 'b factor percentile');
               thisClass.setLogCmd('color b factor percentile', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn4_clrIdentity", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setOption('color', 'identity');
               thisClass.setLogCmd('color identity', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn4_clrConserved", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setOption('color', 'conservation');
               thisClass.setLogCmd('color conservation', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn4_clrCustom", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_clr', 'Color picker');
            });

            $(document).on("click", ".icn3d-color-rad-text", function(e) { let ic = me.icn3d; 
              e.stopImmediatePropagation();
              //e.preventDefault();
              let color = $(this).attr('color');
              ic.setOptionCls.setOption("color", color);

              thisClass.setLogCmd("color " + color, true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn4_clrSave", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.saveColor();
               thisClass.setLogCmd('save color', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn4_clrApplySave", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.applySavedColor();
               thisClass.setLogCmd('apply saved color', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_styleSave", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.saveStyle();
               thisClass.setLogCmd('save style', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_styleApplySave", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.applySavedStyle();
               thisClass.setLogCmd('apply saved style', true);
            });

        }

        clickMenu5() { let me = this.icn3dui; me.icn3d;
            if(me.bNode) return;

            let thisClass = this;
        // mn 5
            me.myEventCls.onIds("#" + me.pre + "mn5_neighborsYes", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.bConsiderNeighbors = true;
               ic.applyMapCls.removeLastSurface();
               ic.applyMapCls.applySurfaceOptions();
               if(ic.bRender) ic.drawCls.render();
               thisClass.setLogCmd('set surface neighbors on', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn5_neighborsNo", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.bConsiderNeighbors = false;
               ic.applyMapCls.removeLastSurface();
               ic.applyMapCls.applySurfaceOptions();
               if(ic.bRender) ic.drawCls.render();
               thisClass.setLogCmd('set surface neighbors off', true);
            });

            me.myEventCls.onIds(["#" + me.pre + "mn5_surfaceVDW", "#" + me.pre + "tool_surfaceVDW"], "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.bConsiderNeighbors = false;
               ic.setOptionCls.setOption('surface', 'Van der Waals surface');
               thisClass.setLogCmd('set surface Van der Waals surface', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn5_surfaceSAS", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.bConsiderNeighbors = false;
               ic.setOptionCls.setOption('surface', 'solvent accessible surface');
               thisClass.setLogCmd('set surface solvent accessible surface', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn5_surfaceMolecular", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.bConsiderNeighbors = false;
               ic.setOptionCls.setOption('surface', 'molecular surface');
               thisClass.setLogCmd('set surface molecular surface', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn5_surfaceVDWContext", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.bConsiderNeighbors = true;
               ic.setOptionCls.setOption('surface', 'Van der Waals surface with context');
               thisClass.setLogCmd('set surface Van der Waals surface with context', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn5_surfaceSASContext", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.bConsiderNeighbors = true;
               ic.setOptionCls.setOption('surface', 'solvent accessible surface with context');
               thisClass.setLogCmd('set surface solvent accessible surface with context', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn5_surfaceMolecularContext", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.bConsiderNeighbors = true;
               ic.setOptionCls.setOption('surface', 'molecular surface with context');
               thisClass.setLogCmd('set surface molecular surface with context', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn5_surfaceNo", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setOption('surface', 'nothing');
               thisClass.setLogCmd('set surface nothing', true);
            });

            $(document).on("click", "." + me.pre + "mn5_opacity", function(e) { let ic = me.icn3d; //e.preventDefault();
                ic.transparentRenderOrder = false;

                let value = $(this).attr('v');
               ic.setOptionCls.setOption('opacity', value);
               thisClass.setLogCmd('set surface opacity ' + value, true);
            });

            $(document).on("click", "." + me.pre + "mn5_opacityslow", function(e) { let ic = me.icn3d; //e.preventDefault();
                ic.transparentRenderOrder = true;

                let value = $(this).attr('v');
                ic.setOptionCls.setOption('opacity', value);
                thisClass.setLogCmd('set surface2 opacity ' + value, true);
             });

            me.myEventCls.onIds("#" + me.pre + "mn5_wireframeYes", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setOption('wireframe', 'yes');
               thisClass.setLogCmd('set surface wireframe on', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn5_wireframeNo", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setOption('wireframe', 'no');
               thisClass.setLogCmd('set surface wireframe off', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn5_elecmap2fofc", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_elecmap2fofc', '2Fo-Fc Electron Density Map');
            });

            me.myEventCls.onIds("#" + me.pre + "mn5_elecmapfofc", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_elecmapfofc', 'Fo-Fc Electron Density Map');
            });

            me.myEventCls.onIds(["#" + me.pre + "mn5_elecmapNo", "#" + me.pre + "elecmapNo2", "#" + me.pre + "elecmapNo3", "#" + me.pre + "elecmapNo4", "#" + me.pre + "elecmapNo5"], "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setOption('map', 'nothing');
               thisClass.setLogCmd('setoption map nothing', true);
            });

            me.myEventCls.onIds(["#" + me.pre + "delphimapNo", "#" + me.pre + "phimapNo", "#" + me.pre + "phiurlmapNo", "#" + me.pre + "mn1_phimapNo"], "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setOption('phimap', 'nothing');
               thisClass.setLogCmd('setoption phimap nothing', true);
            });

            me.myEventCls.onIds(["#" + me.pre + "delphimapNo2", "#" + me.pre + "phimapNo2", "#" + me.pre + "phiurlmapNo2"], "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               //ic.setOptionCls.setOption('surface', 'nothing');
               //thisClass.setLogCmd('set surface nothing', true);
               ic.setOptionCls.setOption('phisurface', 'nothing');
               thisClass.setLogCmd('setoption phisurface nothing', true);
            });

            me.myEventCls.onIds("#" + me.pre + "applymap2fofc", "click", async function(e) { let ic = me.icn3d; 
               e.preventDefault();

               //if(!me.cfg.notebook) dialog.dialog( "close" );
               let sigma2fofc = parseFloat($("#" + me.pre + "sigma2fofc" ).val());
               let type = '2fofc';
               //await ic.dsn6ParserCls.dsn6Parser(ic.inputid, type, sigma2fofc);
               await ic.densityCifParserCls.densityCifParser(ic.inputid, type, sigma2fofc);

               //ic.setOptionCls.setOption('map', '2fofc');
               thisClass.setLogCmd('set map 2fofc sigma ' + sigma2fofc, true);
            });

            me.myEventCls.onIds("#" + me.pre + "applymapfofc", "click", async function(e) { let ic = me.icn3d; 
               e.preventDefault();

               //if(!me.cfg.notebook) dialog.dialog( "close" );
               let sigmafofc = parseFloat($("#" + me.pre + "sigmafofc" ).val());
               let type = 'fofc';
               //await ic.dsn6ParserCls.dsn6Parser(ic.inputid, type, sigmafofc);
               await ic.densityCifParserCls.densityCifParser(ic.inputid, type, sigma2fofc);
               //ic.setOptionCls.setOption('map', 'fofc');
               thisClass.setLogCmd('set map fofc sigma ' + sigmafofc, true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn5_mapwireframeYes", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               //ic.dsn6ParserCls.dsn6Parser(ic.inputid);
               ic.setOptionCls.setOption('mapwireframe', 'yes');
               thisClass.setLogCmd('set map wireframe on', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn5_mapwireframeNo", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setOption('mapwireframe', 'no');
               thisClass.setLogCmd('set map wireframe off', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn5_emmap", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_emmap', 'EM Density Map');
            });

            me.myEventCls.onIds(["#" + me.pre + "mn5_emmapNo", "#" + me.pre + "emmapNo2"], "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setOption('emmap', 'nothing');
               thisClass.setLogCmd('setoption emmap nothing', true);
            });

            me.myEventCls.onIds("#" + me.pre + "applyemmap", "click", async function(e) { let ic = me.icn3d; 
               e.preventDefault();

               //if(!me.cfg.notebook) dialog.dialog( "close" );
               let empercentage = parseFloat($("#" + me.pre + "empercentage" ).val());
               let type = 'em';
               //ic.emd = 'emd-3906';

               await ic.densityCifParserCls.densityCifParser(ic.inputid, type, empercentage, ic.emd);
               thisClass.setLogCmd('set emmap percentage ' + empercentage, true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn5_emmapwireframeYes", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               //ic.dsn6ParserCls.dsn6Parser(ic.inputid);
               ic.setOptionCls.setOption('emmapwireframe', 'yes');
               thisClass.setLogCmd('set emmap wireframe on', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn5_emmapwireframeNo", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setOption('emmapwireframe', 'no');
               thisClass.setLogCmd('set emmap wireframe off', true);
            });

        }

        clickMenu6() { let me = this.icn3dui, ic = me.icn3d;
            if(me.bNode) return;

            let thisClass = this;
        // mn 6
            me.myEventCls.onIds("#" + me.pre + "mn6_assemblyYes", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.bAssembly = true;
               thisClass.setLogCmd('set assembly on', true);
               ic.drawCls.draw();
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_assemblyNo", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.bAssembly = false;
               thisClass.setLogCmd('set assembly off', true);
               ic.drawCls.draw();
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_igrefYes", "click", async function(e) { let ic = me.icn3d; //e.preventDefault();
                ic.bRunRefnumAgain = true;

                thisClass.setLogCmd('ig refnum on', true);
                // await ic.refnumCls.showIgRefNum();
                // thisClass.setLogCmd('set annotation ig', true);
                if(!ic.bAnnoShown) await ic.showAnnoCls.showAnnotations();

                let bSelection = true;
                await ic.annotationCls.setAnnoTabIg(bSelection);

                // if(ic.bShowRefnum) {
                //    ic.opts.color = 'ig strand';
                //    ic.setColorCls.setColorByOptions(ic.opts, ic.atoms);
       
                //    ic.selectionCls.selectAll_base();
                //    ic.hlUpdateCls.updateHlAll();
                //    ic.drawCls.draw();
                // }

                ic.bRunRefnumAgain = false;
             });

            me.myEventCls.onIds("#" + me.pre + "mn6_igrefTpl", "click", async function(e) { me.icn3d; //e.preventDefault();
                me.htmlCls.dialogCls.openDlg('dl_igrefTpl', 'Choose an Ig template');
             });

            me.myEventCls.onIds("#" + me.pre + "mn6_igrefTpl_apply", "click", async function(e) { me.icn3d; //e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );

                let template = $("#" + me.pre + "refTpl").val();

                await thisClass.setIgTemplate(template);

                thisClass.setLogCmd('ig template ' + template, true);
             });

             me.myEventCls.onIds("#" + me.pre + "mn6_alignrefTpl", "click", async function(e) { me.icn3d; //e.preventDefault();
                me.htmlCls.dialogCls.openDlg('dl_alignrefTpl', 'Align with an Ig template');
             });

             me.myEventCls.onIds("#" + me.pre + "mn6_alignrefTpl_apply", "click", async function(e) { let ic = me.icn3d; //e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
       
                let template = $("#" + me.pre + "refTpl2").val();

                let selAtoms = me.hashUtilsCls.cloneHash(ic.hAtoms);

                // load the template
                let url = me.htmlCls.baseUrl + "icn3d/refpdb/" + template + ".pdb";
                await ic.pdbParserCls.downloadUrl(url, 'pdb', undefined, template);
                thisClass.setLogCmd('load url ' + url + ' | type pdb', true);
       
                let structure = template.replace(/_/g, '').substr(0,4);

                let chainid = ic.structures[structure][0];

                ic.hAtoms = me.hashUtilsCls.unionHash(selAtoms, ic.chains[chainid]);

                // align the template with the selection
                me.cfg.aligntool = 'tmalign';
                await ic.realignParserCls.realignOnStructAlign();
                thisClass.setLogCmd('realign on tmalign', true);   
             });

             me.myEventCls.onIds("#" + me.pre + "mn6_igrefNo", "click", async function(e) { let ic = me.icn3d; //e.preventDefault();
                thisClass.setLogCmd('ig refnum off', true);
                await ic.refnumCls.hideIgRefNum();

                // ic.selectionCls.selectAll_base();
                // ic.hlUpdateCls.updateHlAll();
                
                // ic.drawCls.draw();
             });

            me.myEventCls.onIds("#" + me.pre + "mn6_addlabelAtoms", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.residueLabelsCls.addAtomLabels(ic.hAtoms);
               ic.selectionCls.saveSelectionIfSelected();
               thisClass.setLogCmd('add atom labels', true);
               ic.drawCls.draw();
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_addlabelElements", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.residueLabelsCls.addAtomLabels(ic.hAtoms, true);
               ic.selectionCls.saveSelectionIfSelected();
               thisClass.setLogCmd('add element labels', true);
               ic.drawCls.draw();
            });


            me.myEventCls.onIds("#" + me.pre + "mn6_addlabelResidues", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.residueLabelsCls.addResidueLabels(ic.hAtoms);
               ic.selectionCls.saveSelectionIfSelected();
               thisClass.setLogCmd('add residue labels', true);
               ic.drawCls.draw();
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_addlabelResnum", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.residueLabelsCls.addResidueLabels(ic.hAtoms, undefined, undefined, true);
               ic.selectionCls.saveSelectionIfSelected();
               thisClass.setLogCmd('add residue number labels', true);
               ic.drawCls.draw();
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_addlabelRefnum", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
             ic.residueLabelsCls.addResidueLabels(ic.hAtoms, undefined, undefined, undefined, true);
             ic.selectionCls.saveSelectionIfSelected();
             thisClass.setLogCmd('add reference number labels', true);
             ic.drawCls.draw();
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_addlabelIg", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
             ic.residueLabelsCls.addIgLabels(ic.hAtoms);
             ic.selectionCls.saveSelectionIfSelected();
             thisClass.setLogCmd('add ig labels', true);
             ic.drawCls.draw();
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_addlabelChains", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.analysisCls.addChainLabels(ic.hAtoms);
               ic.selectionCls.saveSelectionIfSelected();
               thisClass.setLogCmd('add chain labels', true);
               ic.drawCls.draw();
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_addlabelTermini", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.analysisCls.addTerminiLabels(ic.hAtoms);
               ic.selectionCls.saveSelectionIfSelected();
               thisClass.setLogCmd('add terminal labels', true);
               ic.drawCls.draw();
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_addlabelYes", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_addlabel', 'Add custom labels by selection');
               ic.pk = 1;
               ic.opts['pk'] = 'atom';
               ic.pickpair = true;
               ic.pAtomNum = 0;
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_addlabelSelection", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_addlabelselection', 'Add custom labels by the selected');
            });

             me.myEventCls.onIds("#" + me.pre + "mn6_labelColor", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_labelColor', 'Change color for all labels');
            });

            me.myEventCls.onIds(["#" + me.pre + "mn2_saveselection","#" + me.pre + "tool_saveselection"], "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_saveselection', 'Save the selected');
            });

            me.myEventCls.onIds(["#" + me.pre + "mn6_addlabelNo", "#" + me.pre + "removeLabels"], "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.labelcolor = undefined;
                ic.pickpair = false;
               //ic.labels['residue'] = [];
               //ic.labels['custom'] = [];
               let select = "set labels off";
               thisClass.setLogCmd(select, true);
               for(let name in ic.labels) {
                   //if(name === 'residue' || name === 'custom') {
                       ic.labels[name] = [];
                   //}
               }
               ic.drawCls.draw();
            });

            $(document).on("click", "." + me.pre + "mn6_labelscale", function(e) { let ic = me.icn3d; //e.preventDefault();
               let value = $(this).attr('v');
               ic.labelScale = value;
               ic.drawCls.draw();
               thisClass.setLogCmd('set label scale ' + value, true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_distanceYes", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_distance', 'Measure the distance of atoms');
               ic.pk = 1;
               ic.opts['pk'] = 'atom';
               ic.pickpair = true;
               ic.pAtomNum = 0;
               ic.bMeasureDistance = true;
            });


            me.myEventCls.onIds("#" + me.pre + "mn6_distTwoSets", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                me.htmlCls.dialogCls.openDlg('dl_disttwosets', 'Measure the distance between two sets');

                thisClass.setSetsMenus('atomsCustomDist');

               ic.bMeasureDistance = true;
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_distManySets", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                me.htmlCls.dialogCls.openDlg('dl_distmanysets', 'Measure the pairwise distances among many sets');

                thisClass.setSetsMenus('atomsCustomDistTable');

               ic.bMeasureDistance = true;
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_angleManySets", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
             me.htmlCls.dialogCls.openDlg('dl_anglemanysets', 'Measure the pairwise angles among many sets');

             thisClass.setSetsMenus('atomsCustomAngleTable');

            ic.bMeasureAngle = true;
           });

            me.myEventCls.onIds("#" + me.pre + "mn6_distanceNo", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.pickpair = false;
               let select = "set lines off";
               thisClass.setLogCmd(select, true);
               ic.labels['distance'] = [];
               ic.lines['distance'] = [];
               ic.distPnts = [];
               ic.pk = 2;
               ic.drawCls.draw();
            });

            me.myEventCls.onIds("#" + me.pre + "mn5_cartoonshape", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                me.htmlCls.dialogCls.openDlg('dl_cartoonshape', 'Draw cartoon for a set');

                let bOneset = true;
                thisClass.setSetsMenus('cartoonshape', bOneset);

               ic.bCartoonshape = true;
            });

            me.myEventCls.onIds("#" + me.pre + "mn5_linebtwsets", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                me.htmlCls.dialogCls.openDlg('dl_linebtwsets', 'Draw a line between two sets');

                thisClass.setSetsMenus('linebtwsets');

               ic.bLinebtwsets = true;
            });


            me.myEventCls.onIds(["#" + me.pre + "mn2_selectedcenter", "#" + me.pre + "zoomin_selection", "#" + me.pre + "tool_selectedcenter"], "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               //thisClass.setLogCmd('zoom selection', true);
               ic.transformCls.zoominSelection();
               ic.drawCls.draw();
               thisClass.setLogCmd('zoom selection', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_center", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               //thisClass.setLogCmd('center selection', true);
               ic.applyCenterCls.centerSelection();
               ic.drawCls.draw();
               thisClass.setLogCmd('center selection', true);
            });

            me.myEventCls.onIds(["#" + me.pre + "mn6_resetOrientation", "#" + me.pre + "resetOrientation", "#" + me.pre + "tool_resetOrientation"], "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               //thisClass.setLogCmd('reset orientation', true);
               ic.transformCls.resetOrientation();
               //ic.setColorCls.applyOriginalColor();
               ic.drawCls.draw();
               thisClass.setLogCmd('reset orientation', true);
            });

            me.myEventCls.onIds(["#" + me.pre + "mn6_chemicalbindingshow", "#" + me.pre + "chemicalbindingshow"], "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setOption('chemicalbinding', 'show');
               thisClass.setLogCmd('set chemicalbinding show', true);
            });

            me.myEventCls.onIds(["#" + me.pre + "mn6_chemicalbindinghide", "#" + me.pre + "chemicalbindinghide"], "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setOption('chemicalbinding', 'hide');
               thisClass.setLogCmd('set chemicalbinding hide', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_sidebyside", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               if(ic.bInputfile) {
                    alert("Side-by-Side does NOT work when the input is from a local file.");
                    return;
               }
               let url = ic.shareLinkCls.shareLinkUrl(undefined);
               //if(url.indexOf('http') !== 0) {
               //    alert("The url is more than 4000 characters and may not work.");
               //}
               //else {
                   // url = url.replace("icn3d/full.html?", "icn3d/full2.html?");

                   url = url.replace(/icn3d\/full[_\d\.]*\.html\?/, "icn3d/full2.html?");

                   url = url.replace("icn3d/?", "icn3d/full2.html?");

                   url += '&closepopup=1';
                   let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                   window.open(url, urlTarget);
                   // thisClass.setLogCmd('side by side | ' + url, true);
                   thisClass.setLogCmd('side by side | ' + url, false);
               //}
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_stereoYes", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                ic.opts['effect'] = 'stereo';
                ic.drawCls.draw();
                thisClass.setLogCmd('stereo on', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_stereoNo", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                ic.opts['effect'] = 'none';
                ic.drawCls.draw();
                thisClass.setLogCmd('stereo off', true);
            });

            $(document).on("click", "#" + me.pre + "mn2_translate", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_translate', 'Translate the X,Y,Z coordinates of the structure');
            });

            $(document).on("click", "#" + me.pre + "mn6_angleTwoSets", function(e) { me.icn3d; //e.preventDefault();
             me.htmlCls.dialogCls.openDlg('dl_angle', 'Measure the angle between two vectors');
            });

            $(document).on("click", "#" + me.pre + "mn2_matrix", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_matrix', 'Apply matrix to the X,Y,Z coordinates of the structure');
            });

            $(document).on("click", "." + me.pre + "mn6_rotate", function(e) { let ic = me.icn3d; //e.preventDefault();
               let value = $(this).attr('v').toLowerCase();
               let direction = value.split(' ')[1];

               thisClass.setLogCmd(value, true);
               ic.bStopRotate = false;
               ic.transformCls.rotateCount = 0;
               ic.transformCls.rotateCountMax = 6000;
               ic.ROT_DIR = direction;
               ic.resizeCanvasCls.rotStruc(direction);
            });

            $(document).on("click", "." + me.pre + "mn6_rotate90", function(e) { let ic = me.icn3d; //e.preventDefault();
              let value = $(this).attr('v').toLowerCase();
              let direction = value.split(' ')[1];

              thisClass.setLogCmd(value, true);
              let axis;
              if(direction == 'x') {
                  axis = new THREE.Vector3(1,0,0);
              }
              else if(direction == 'y') {
                  axis = new THREE.Vector3(0,1,0);
              }
              else if(direction == 'z') {
                  axis = new THREE.Vector3(0,0,1);
              }
              let angle = 0.5 * Math.PI;
              ic.transformCls.setRotation(axis, angle);
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_cameraPers", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setOption('camera', 'perspective');
               thisClass.setLogCmd('set camera perspective', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_cameraOrth", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setOption('camera', 'orthographic');
               thisClass.setLogCmd('set camera orthographic', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_bkgdBlack", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setStyleCls.setBackground('black');
            });

            me.myEventCls.onIds("#" + me.pre + "tool_bkgd", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                if(ic.opts['background'] == 'black') {
                    ic.setStyleCls.setBackground('white');
                }
                else {
                    ic.setStyleCls.setBackground('black');
                }
             });

            me.myEventCls.onIds("#" + me.pre + "mn6_bkgdGrey", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setStyleCls.setBackground('grey');
            });

            me.myEventCls.onIds(["#" + me.pre + "mn6_bkgdWhite", "#" + me.pre + "tool_bkgdWhite"], "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setStyleCls.setBackground('white');
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_bkgdTransparent", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setStyleCls.setBackground('transparent');
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_showfogYes", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               //ic.setOptionCls.setOption('fog', 'yes');
               ic.opts['fog'] = 'yes';
               ic.fogCls.setFog(true);
               ic.drawCls.draw();
               thisClass.setLogCmd('set fog on', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_showfogNo", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               //ic.setOptionCls.setOption('fog', 'no');
               ic.opts['fog'] = 'no';
               ic.fogCls.setFog(true);
               ic.drawCls.draw();
               thisClass.setLogCmd('set fog off', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_showslabYes", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setOption('slab', 'yes');
               thisClass.setLogCmd('set slab on', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_showslabNo", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setOption('slab', 'no');
               thisClass.setLogCmd('set slab off', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_showaxisYes", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.setOptionCls.setOption('axis', 'yes');
               thisClass.setLogCmd('set axis on', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_showaxisSel", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.pc1 = true;

               ic.axesCls.setPc1Axes();
               thisClass.setLogCmd('set pc1 axis', true);
            });


            me.myEventCls.onIds("#" + me.pre + "mn6_showaxisNo", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.pc1 = false;
               ic.axes = [];

               ic.setOptionCls.setOption('axis', 'no');

               thisClass.setLogCmd('set axis off', true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_symmetry", "click", async function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.bAxisOnly = false;
               await ic.symdCls.retrieveSymmetry(Object.keys(ic.structures)[0]);
               //me.htmlCls.dialogCls.openDlg('dl_symmetry', 'Symmetry');
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_symd", "click", async function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.bAxisOnly = false;
               await ic.symdCls.retrieveSymd();
               ic.bSymd = true;

               thisClass.setLogCmd('symd symmetry', true);
            });
            me.myEventCls.onIds("#" + me.pre + "mn6_clear_sym", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.symdArray = [];
               ic.drawCls.draw();
               thisClass.setLogCmd('clear symd symmetry', true);
            });
            me.myEventCls.onIds("#" + me.pre + "mn6_axes_only", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.bAxisOnly = true;
               ic.drawCls.draw();
               thisClass.setLogCmd('show axis', true);
            });


            me.myEventCls.onIds("#" + me.pre + "mn6_area", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                ic.analysisCls.calculateArea();
                thisClass.setLogCmd('area', true);
            });

            me.myEventCls.onIds("#" + me.pre + "applysymmetry", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.bAxisOnly = false;

               let title = $("#" + me.pre + "selectSymmetry" ).val();

               ic.symmetrytitle =(title === 'none') ? undefined : title;
               //if(title !== 'none') ic.applySymmetry(title);
               ic.drawCls.draw();
               thisClass.setLogCmd('symmetry ' + title, true);
            });
            me.myEventCls.onIds("#" + me.pre + "clearsymmetry", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               let title = 'none';
               ic.symmetrytitle = undefined;
               ic.drawCls.draw();
               thisClass.setLogCmd('symmetry ' + title, true);
            });

            me.myEventCls.onIds(["#" + me.pre + "mn6_hbondsYes", "#" + me.pre + "hbondsYes"], "click", function(e) { let ic = me.icn3d; //e.preventDefault();
                thisClass.SetChainsAdvancedMenu();

                let definedAtomsHtml = ic.definedSetsCls.setAtomMenu(['protein']);
                if($("#" + me.pre + "atomsCustomHbond").length) {
                    $("#" + me.pre + "atomsCustomHbond").html("  <option value='non-selected' selected>non-selected</option><option value='selected'>selected</option>" + definedAtomsHtml);
                }
                if($("#" + me.pre + "atomsCustomHbond2").length) {
                    $("#" + me.pre + "atomsCustomHbond2").html("  <option value='selected' selected>selected</option>" + definedAtomsHtml);
                }
               me.htmlCls.dialogCls.openDlg('dl_hbonds', 'Hydrogen bonds/interactions between two sets of atoms');
               ic.bHbondCalc = false;
               //thisClass.setLogCmd('set calculate hbond false', true);
               $("#" + me.pre + "atomsCustomHbond").resizable();
               $("#" + me.pre + "atomsCustomHbond2").resizable();
            });

            me.myEventCls.onIds(["#" + me.pre + "mn6_contactmap"], "click", function(e) { me.icn3d; //e.preventDefault();
                me.htmlCls.dialogCls.openDlg('dl_contact', 'Set contact map');
            });

            me.myEventCls.onIds(["#" + me.pre + "mn6_DSSP"], "click", async function(e) { let ic = me.icn3d; //e.preventDefault();
             thisClass.setLogCmd('set dssp sse', true);
             await ic.pdbParserCls.applyCommandDssp();
             ic.bResetAnno = true;

             if(ic.bAnnoShown) {
                 await ic.showAnnoCls.showAnnotations();
     
                 ic.annotationCls.resetAnnoTabAll();
             }
            });


            me.myEventCls.onIds("#" + me.pre + "mn6_hbondsNo", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.showInterCls.hideHbondsContacts();
               ic.drawCls.draw();
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_stabilizerYes", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               let select = "stabilizer";
               ic.threeDPrintCls.addStabilizer();
               ic.threeDPrintCls.prepareFor3Dprint();
               //ic.drawCls.draw();
               thisClass.setLogCmd(select, true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_stabilizerNo", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               let select = "set stabilizer off";
               thisClass.setLogCmd(select, true);
               ic.threeDPrintCls.hideStabilizer();
               ic.drawCls.draw();
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_stabilizerOne", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_stabilizer', 'Add One Stabilizer');
               ic.pk = 1;
               ic.opts['pk'] = 'atom';
               ic.pickpair = true;
               ic.pAtomNum = 0;
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_stabilizerRmOne", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_stabilizer_rm', 'Remove One Stabilizer');
               ic.pk = 1;
               ic.opts['pk'] = 'atom';
               ic.pickpair = true;
               ic.pAtomNum = 0;
            });

            me.myEventCls.onIds("#" + me.pre + "mn1_thicknessSet", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_thickness', 'Set Thickness for 3D Printing');
            });

            me.myEventCls.onIds("#" + me.pre + "mn3_setThickness", "click", function(e) { me.icn3d; //e.preventDefault();
               me.htmlCls.dialogCls.openDlg('dl_thickness2', 'Style Preferences');
            });


            me.myEventCls.onIds("#" + me.pre + "mn6_ssbondsYes", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               let select = "disulfide bonds";
               thisClass.setLogCmd(select, true);
               ic.showInterCls.showSsbonds();
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_ssbondsExport", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.viewInterPairsCls.exportSsbondPairs();
               thisClass.setLogCmd("export disulfide bond pairs", false);
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_ssbondsNo", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.opts["ssbonds"] = "no";
               let select = "set disulfide bonds off";
               thisClass.setLogCmd(select, true);
               ic.lines['ssbond'] = [];
               ic.setOptionCls.setStyle('sidec', 'nothing');
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_clbondsYes", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               let select = "cross linkage";
               thisClass.setLogCmd(select, true);
               //ic.bShowCrossResidueBond = true;
               //ic.setOptionCls.setStyle('proteins', 'lines')
               ic.showInterCls.showClbonds();
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_clbondsExport", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.viewInterPairsCls.exportClbondPairs();
               thisClass.setLogCmd("export cross linkage pairs", false);
            });

            me.myEventCls.onIds("#" + me.pre + "mn6_clbondsNo", "click", function(e) { let ic = me.icn3d; //e.preventDefault();
               ic.opts["clbonds"] = "no";
               let select = "set cross linkage off";
               thisClass.setLogCmd(select, true);
               //ic.bShowCrossResidueBond = false;
               //ic.setOptionCls.setStyle('proteins', 'ribbon')
               ic.lines['clbond'] = [];
               ic.setOptionCls.setStyle('sidec', 'nothing');
            });


            $("#" + me.pre + "newvs2").on('submit', function() {
                // fill the pdbstr
                let bVastSearch = true;
                let pdbstr = ic.saveFileCls.getAtomPDB(ic.hAtoms, undefined, undefined, undefined, undefined, undefined, undefined, bVastSearch);
                $("#" + me.pre + "pdbstr").val(pdbstr);
                return true;
            });

            $("#" + me.pre + "fssubmit").on('click', function() {
                let pdbstr = ic.saveFileCls.getAtomPDB(ic.hAtoms);
                let url = 'https://search.foldseek.com/api/ticket';


                let template = "<!doctype html>\n<head>\n<title>Loading Foldseek</title>\n<style>\n  body {\n    background-color: #121212;\n    color: #fff;\n    font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\n    height: 100vh;\n    display: flex;\n    flex-direction: column;\n    flex-wrap: wrap;\n    justify-content: center;\n    align-items: center;\n  }\n  .loader {\n    display: block;\n    width: 80px;\n    height: 80px;\n  }\n  .loader:after {\n    content: \" \";\n    display: block;\n    width: 64px;\n    height: 64px;\n    margin: 8px;\n    border-radius: 50%;\n    border: 6px solid #fff;\n    border-color: #fff transparent #fff transparent;\n    animation: loader 1.2s linear infinite;\n  }\n  @keyframes loader {\n    0% {\n      transform: rotate(0deg);\n    }\n    100% {\n      transform: rotate(360deg);\n    }\n  }\n</style>\n</head>\n<body>\n<div>Foldseek is loading...</div><div class=\"loader\"></div>\n</body>";

                let urlTarget = '_blank';
                let w = window.open('', urlTarget);
                w.document.body.innerHTML = template;

                $.ajax({
                    url: url,
                    type: 'POST',
                    data: { 
                        q : pdbstr,
                        database: ["afdb50", "afdb-swissprot", "gmgcl_id", "pdb100", "afdb-proteome", "mgnify_esm30"],
                        mode: "3diaa"
                    },
                    dataType: 'text',
                    success: function(data) {
                        w.location = 'https://search.foldseek.com/queue/' + JSON.parse(data).id;
                    },
                    error : function(xhr, textStatus, errorThrown ) {
                      console.log("Error in submitting data to Foldseek...");
                    }
                });
            });

            me.myEventCls.onIds("#" + me.pre + "jn_copy", "click", function(e) { me.icn3d; //e.preventDefault();
                let text = $("#" + me.pre + "jn_commands").val();
                navigator.clipboard.writeText(text);
            });
        } 

        //Show the input command in log. If "bSetCommand" is true, the command will be saved in the state file as well.
        setLogCmd(str, bSetCommand, bAddLogs) {var me = this.icn3dui, ic = me.icn3d;
          if(str.trim() === '') return false;
          let pos = str.indexOf('|||');
          if(pos !== -1) str = str.substr(0, pos);
          let transformation = {};

          if(!ic.quaternion) {
             // reset parameters
             ic._zoomFactor = 1.0;
             ic.mouseChange = new THREE.Vector2(0,0);
             ic.quaternion = new THREE.Quaternion(0,0,0,1);
          }

          transformation.factor = ic._zoomFactor;
          transformation.mouseChange = ic.mouseChange;
          transformation.quaternion = {};
          transformation.quaternion._x = parseFloat(ic.quaternion._x).toPrecision(5);
          transformation.quaternion._y = parseFloat(ic.quaternion._y).toPrecision(5);
          transformation.quaternion._z = parseFloat(ic.quaternion._z).toPrecision(5);
          transformation.quaternion._w = parseFloat(ic.quaternion._w).toPrecision(5);
          if(bSetCommand) {
              // save the command only when it's not a history command, i.e., not in the process of going back and forth
              if(ic.bAddCommands) {
                  // If a new command was called, remove the forward commands and push to the command array
                  if(ic.STATENUMBER < ic.commands.length) {
                      let oldCommand = ic.commands[ic.STATENUMBER - 1];
                      let pos = oldCommand.indexOf('|||');
                      if(pos != -1 && str !== oldCommand.substr(0, pos)) {
                        ic.commands = ic.commands.slice(0, ic.STATENUMBER);
                        ic.commands.push(str + '|||' + ic.transformCls.getTransformationStr(transformation));
                        ic.optsHistory.push(me.hashUtilsCls.cloneHash(ic.opts));
                        ic.optsHistory[ic.optsHistory.length - 1].hlatomcount = Object.keys(ic.hAtoms).length;
                        if(me.utilsCls.isSessionStorageSupported()) ic.setStyleCls.saveCommandsToSession();
                        ic.STATENUMBER = ic.commands.length;
                      }
                  }
                  else {
                    ic.commands.push(str + '|||' + ic.transformCls.getTransformationStr(transformation));
                    ic.optsHistory.push(me.hashUtilsCls.cloneHash(ic.opts));
                    if(ic.hAtoms !== undefined) ic.optsHistory[ic.optsHistory.length - 1].hlatomcount = Object.keys(ic.hAtoms).length;
                    if(me.utilsCls.isSessionStorageSupported()) ic.setStyleCls.saveCommandsToSession();
                    ic.STATENUMBER = ic.commands.length;
                  }
              }
          }
          if((ic.bAddLogs || bAddLogs) && me.cfg.showcommand) {
              let finalStr = (bSetCommand) ? str : '[comment] ' + str;
              ic.logs.push(finalStr);
              // move cursor to the end, and scroll to the end
              $("#" + me.pre + "logtext").val("> " + ic.logs.join("\n> ") + "\n> ");
              if($("#" + me.pre + "logtext")[0]) {
                $("#" + me.pre + "logtext").scrollTop($("#" + me.pre + "logtext")[0].scrollHeight);
              }
          }
          ic.setStyleCls.adjustIcon();
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class SetMenu {
        constructor(icn3dui) {
            this.icn3dui = icn3dui;
            //this.sh = this.icn3dui.htmlCls.setHtmlCls;
        }

        // simplify the calls of the following functions from setHtmlCls
        getLink(id, text, bSimpleMenu, selType) { let me = this.icn3dui;
            return me.htmlCls.setHtmlCls.getLink(id, text, bSimpleMenu, selType);
        }

        getMenuText(id, text, classname, bSimpleMenu, selType) { let me = this.icn3dui;
            return me.htmlCls.setHtmlCls.getMenuText(id, text, classname, bSimpleMenu, selType);
        }

        getMenuUrl(id, url, text, bSimpleMenu, selType) { let me = this.icn3dui;
            return me.htmlCls.setHtmlCls.getMenuUrl(id, url, text, bSimpleMenu, selType);
        }

        getMenuSep() { let me = this.icn3dui;
            return me.htmlCls.setHtmlCls.getMenuSep();
        }

        getLinkWrapper(id, text, wrapper, bSimpleMenu, selType, bHide) { let me = this.icn3dui; me.icn3d;
            return me.htmlCls.setHtmlCls.getLinkWrapper(id, text, wrapper, bSimpleMenu, selType, bHide);
        }

        getLinkWrapper2(id, text, wrapper, bSimpleMenu, selType) { let me = this.icn3dui; me.icn3d;
            return me.htmlCls.setHtmlCls.getLinkWrapper2(id, text, wrapper, bSimpleMenu, selType);
        }

        getRadio(radioid, id, text, bChecked, bSimpleMenu, selType) { let me = this.icn3dui;
            return me.htmlCls.setHtmlCls.getRadio(radioid, id, text, bChecked, bSimpleMenu, selType);
        }

        getRadClr(radioid, id, text, color, bChecked, bSimpleMenu, selType) { let me = this.icn3dui;
            return me.htmlCls.setHtmlCls.getRadioColor(radioid, id, text, color, bChecked, bSimpleMenu, selType);
        }

        resetMenu(mode) { let me = this.icn3dui;
            if(!mode || mode == 'simple') {
                me.htmlCls.shownMenus = me.hashUtilsCls.cloneHash(me.htmlCls.simpleMenus);

                me.htmlCls.clickMenuCls.applyShownMenus(); 
            }
            else if(mode == 'all') {
                me.htmlCls.shownMenus = me.hashUtilsCls.cloneHash(me.htmlCls.allMenus);

                me.htmlCls.clickMenuCls.applyShownMenus(); 
            }
            else if(mode == 'custom') {
                me.htmlCls.dialogCls.openDlg('dl_menupref', 'Select Menus');

                me.htmlCls.clickMenuCls.getHiddenMenusFromCache();

                me.htmlCls.clickMenuCls.displayShownMenus();
            }
        }

        setMenuMode(bMobile) { let me = this.icn3dui;
            let spaceCss = (bMobile) ? "; padding-left:6px; background-color:#eee" : "; margin:3px; background-color:white";
            let spaceCss2 = (bMobile) ? "; font-size:14px!important" : ""; 

            let mode = me.htmlCls.setHtmlCls.getCookie('menumode');

            let html = '<div class="icn3d-text" style="color:#f8b84e; font-weight:bold' + spaceCss + '">';
            html += '<select name="menumode" id="' + me.pre + 'menumode" class="icn3d-text" style="color:#f8b84e; font-weight:bold; border:0px' + spaceCss2 + '">';
            html += (mode == 'simple' || !mode) ? '<option value="simple" selected>Simple</option>' : '<option value="simple">Simple</option>';
            html += (mode == 'all') ? '<option value="all" selected>All</option>' : '<option value="all">All</option>';
            html += (mode == 'custom') ? '<option value="custom" selected>Custom</option>' : '<option value="custom">Custom</option>';
            html += '</select>';

            if(bMobile) {
                html += '<br><span style="font-size:12px">&nbsp;Menus</span>';
            }
            else {
                html += '&nbsp;Menus';
            }

            html += '</div>';

            return html;
        }

        //Set the HTML code for the menus shown at the top of the viewer.
        setTopMenusHtml(id, str1, str2) { let me = this.icn3dui;
            if(me.bNode) return '';

            let titleColor =(me.htmlCls.opts['background'] == 'black') ? me.htmlCls.GREYD : 'black';

            let html = "";

            html += "<div style='position:relative;'>";

            html += me.htmlCls.divStr + "popup' class='icn3d-text icn3d-popup'></div>";

            html += this.setReplayHtml();

            html += "<!--https://forum.jquery.com/topic/looking-for-a-jquery-horizontal-menu-bar-->";
            html += me.htmlCls.divStr + "mnlist' style='position:absolute; z-index:999; float:left; display:table-row; margin-top: -2px;'>";
            html += "<table border='0' cellpadding='0' cellspacing='0' width='100'><tr>";

            let tdStr = '<td valign="top">';

            html += tdStr + this.setMenuMode() + '</td>';

            html += tdStr + this.setMenu1() + '</td>';

            html += tdStr + this.setMenu2() + '</td>';

            html += tdStr + this.setMenu2b() + '</td>';
            html += tdStr + this.setMenu3() + '</td>';
            html += tdStr + this.setMenu4() + '</td>';

            html += tdStr + this.setMenu5() + '</td>';
            html += tdStr + this.setMenu6() + '</td>';

            // reset the menus at the end of the menus
            let mode = me.htmlCls.setHtmlCls.getCookie('menumode');
            this.resetMenu(mode);

            // me.htmlCls.shownMenus = me.hashUtilsCls.cloneHash(me.htmlCls.simpleMenus); 

            html += tdStr + "<div style='position:relative; margin-left:6px;'>" + str1;
            html += "<div class='icn3d-commandTitle' style='min-width:40px; margin-top: 3px; white-space: nowrap;'>" + str2;

            html += tdStr + '<div class="icn3d-commandTitle" style="white-space:nowrap; margin-top:10px; border-left:solid 1px #888888"><span id="' + me.pre +  'selection_expand" class="icn3d-expand icn3d-link" style="display:block;" title="Expand">' + me.htmlCls.space2 + 'Toolbar <span class="ui-icon ui-icon-plus" style="width:15px"></span>' + me.htmlCls.space2 + '</span><span id="' + me.pre +  'selection_shrink" class="icn3d-shrink icn3d-link" style="display:none;" title="Shrink">' + me.htmlCls.space2 + 'Toolbar <span class="ui-icon ui-icon-minus" style="width:15px"></span>' + me.htmlCls.space2 + '</span></div></td>';

            html += tdStr + '<div class="icn3d-commandTitle" style="white-space:nowrap; margin-top:8px; border-left:solid 1px #888888">' + me.htmlCls.space2 + '<input type="text" id="' + me.pre + 'search_seq" size="10" placeholder="one-letter seq."> <button style="white-space:nowrap;" id="' + me.pre + 'search_seq_button">Search</button> <a style="text-decoration: none;" href="' + me.htmlCls.baseUrl + 'icn3d/icn3d.html#selectb" target="_blank" title="Specification tips">?</a></div></td>';

            html += "</tr>";
            html += "</table>";
            html += "</div>";

            html += this.setTools();

            // show title at the top left corner
            html += me.htmlCls.divStr + "title' class='icn3d-commandTitle' style='font-size:1.2em; font-weight:normal; position:absolute; z-index:1; float:left; display:table-row; margin: 85px 0px 0px 5px; color:" + titleColor + "; width:" + me.htmlCls.WIDTH + "px'></div>";

            html += me.htmlCls.divStr + "viewer' style='position:relative; width:100%; height:100%; background-color: " + me.htmlCls.GREYD + ";'>";

            // deprecated, use the dialog dl_legend instead
            //html += me.htmlCls.divStr + "legend' class='icn3d-text icn3d-legend'></div>";

            html += me.htmlCls.divStr + "mnLogSection'>";
            html += "<div style='height: " + me.htmlCls.MENU_HEIGHT + "px;'></div>";
        //        html += "<div style='height: " + me.htmlCls.MENU_HEIGHT + "px;'></div>";

            html += " </div>";

            if(me.cfg.mmtfid === undefined) {
                //var tmpStr =(ic.realHeight < 300) ? 'top:100px; font-size: 1.2em;' : 'top:180px; font-size: 1.8em;';
                let tmpStr = 'top:180px; font-size: 1.8em;';
                html += me.htmlCls.divStr + "wait' style='position:absolute; left:50px; " + tmpStr + " color: #444444;'>Loading data...</div>";
            }
            html += "<canvas id='" + me.pre + "canvas' style='width:100%; height: 100%; background-color: #FFF;'>Your browser does not support WebGL.</canvas>";

            // separate for the log box
            if(me.cfg.showcommand === undefined || me.cfg.showcommand) {
                html += this.setLogWindow();
            }

            html += "</div>";

            html += "</div>";

            html += me.htmlCls.setDialogCls.setDialogs();

            html += me.htmlCls.setDialogCls.setCustomDialogs();

            $( "#" + id).html(html);

            // mn display
            $("accordion").accordion({ collapsible: true, active: false, heightStyle: "content"});
            $("accordion div").removeClass("ui-accordion-content ui-corner-all ui-corner-bottom ui-widget-content");

            $(".icn3d-mn-item").menu({position: { my: "left top", at: "right top" }});
            $(".icn3d-mn-item").hover(function(){},function(){$("accordion").accordion( "option", "active", "none");});

            $("#" + me.pre + "accordion1").hover( function(){ $("#" + me.pre + "accordion1 div").css("display", "block"); }, function(){ $("#" + me.pre + "accordion1 div").css("display", "none"); } );
            $("#" + me.pre + "accordion2").hover( function(){ $("#" + me.pre + "accordion2 div").css("display", "block"); }, function(){ $("#" + me.pre + "accordion2 div").css("display", "none"); } );
            $("#" + me.pre + "accordion2b").hover( function(){ $("#" + me.pre + "accordion2b div").css("display", "block"); }, function(){ $("#" + me.pre + "accordion2b div").css("display", "none"); } );
            $("#" + me.pre + "accordion3").hover( function(){ $("#" + me.pre + "accordion3 div").css("display", "block"); }, function(){ $("#" + me.pre + "accordion3 div").css("display", "none"); } );
            $("#" + me.pre + "accordion4").hover( function(){ $("#" + me.pre + "accordion4 div").css("display", "block"); }, function(){ $("#" + me.pre + "accordion4 div").css("display", "none"); } );
            $("#" + me.pre + "accordion5").hover( function(){ $("#" + me.pre + "accordion5 div").css("display", "block"); }, function(){ $("#" + me.pre + "accordion5 div").css("display", "none"); } );
            $("#" + me.pre + "accordion6").hover( function(){ $("#" + me.pre + "accordion6 div").css("display", "block"); }, function(){ $("#" + me.pre + "accordion6 div").css("display", "none"); } );
        }

        setTopMenusHtmlMobile(id, str1, str2) { let me = this.icn3dui;
            if(me.bNode) return '';

            let titleColor =(me.htmlCls.opts['background'] == 'black') ? me.htmlCls.GREYD : 'black';

            let html = "";

            html += "<div style='position:relative;'>";

            html += me.htmlCls.divStr + "popup' class='icn3d-text icn3d-popup'></div>";

            html += this.setReplayHtml();

            if(!me.utilsCls.isMobile()) {
                let marginLeft = me.htmlCls.WIDTH - 40 + 5;

                html += me.htmlCls.buttonStr + "fullscreen' style='position:absolute; z-index:1999; display:block; padding:0px; margin: 12px 0px 0px " + marginLeft + "px; width:30px; height:34px; border-radius:4px; border:none; background-color:#f6f6f6;' title='Full screen'>";
                html += "<svg fill='#1c94c4' viewBox='0 0 24 24' width='24' height='24'>";
                html += "<path d='M0 0h24v24H0z' fill='none'></path>";
                html += "<path d='M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z'></path>";
                html += "</svg>";
                html += "</button>";
            }

            html += "<!--https://forum.jquery.com/topic/looking-for-a-jquery-horizontal-menu-bar-->";
            html += me.htmlCls.divStr + "mnlist' style='position:absolute; z-index:999; float:left; display:block; margin: 5px 0px 0px 5px;'>";

            //html += "<div class='icn3d-menu'>";
            html += "<div>";

            html += "<accordion id='" + me.pre + "accordion0' class='icn3d-accordion'>";
            if(me.cfg.notebook) {
                html += "<h3 style='width:20px; height:24px; position:relative; padding: 0'><span style='position:absolute; left:3px; top:4px;'>&#9776;</span></h3>";
            }
            else {
                html += "<h3 style='width:30px; height:34px; position:relative; padding: 0; margin-top:7px!important; background-color:#f6f6f6;'><span style='position:absolute; left:7px; top:8px;'>&#9776;</span></h3>";
            }
            html += "<div>";

            html += '<li>' + this.setMenuMode(true);

            let liStr = "<li><span class='icn3d-menu-color'";

            html += "<ul class='icn3d-mn-item'>";
            html += liStr + ">File</span>";
            html += this.setMenu1_base();
            html += liStr + ">Select</span>";
            html += this.setMenu2_base();
            html += liStr + ">View</span>";
            html += this.setMenu2b_base();
            html += liStr + " id='" + me.pre + "style'>Style</span>";
            html += this.setMenu3_base();
            html += liStr + " id='" + me.pre + "color'>Color</span>";
            html += this.setMenu4_base();
            html += liStr + ">Analysis</span>";
            html += this.setMenu5_base();
            html += liStr + ">Help</span>";
            html += this.setMenu6_base();

            // reset the menus at the end of the menus
            let mode = me.htmlCls.setHtmlCls.getCookie('menumode');
            this.resetMenu(mode);

            // me.htmlCls.shownMenus = me.hashUtilsCls.cloneHash(me.htmlCls.simpleMenus); 

            html += "<li><div style='position:relative; margin-top:-6px;'>" + str1;
            html += "<div class='icn3d-commandTitle' style='margin-top: 3px; white-space: nowrap;'>" + str2;

            //if(me.cfg.align !== undefined) {
                html += "<li><span id='" + me.pre + "alternate2' class='icn3d-menu-color' title='Alternate the structures'>Alternate</span>";
            //}

            html += "</ul>";

            html += "</div>";
            html += "</accordion>";
            html += "</div>";

            html += "</div>";

            //html += me.htmlCls.setMenuCls.setTools();

            // show title at the top left corner
            html += me.htmlCls.divStr + "title' class='icn3d-commandTitle' style='font-size:1.2em; font-weight:normal; position:absolute; z-index:1; float:left; display:block; margin: 12px 0px 0px 40px; color:" + titleColor + "; width:" +(me.htmlCls.WIDTH - 40).toString() + "px'></div>";
            html += me.htmlCls.divStr + "viewer' style='position:relative; width:100%; height:100%; background-color: " + me.htmlCls.GREYD + ";'>";
            // don't show legend in mobile
            //html += me.htmlCls.divStr + "legend' class='icn3d-text icn3d-legend'></div>";
            html += me.htmlCls.divStr + "mnLogSection'>";
            html += "<div style='height: " + me.htmlCls.MENU_HEIGHT + "px;'></div>";
            html += "</div>";

            if(me.cfg.mmtfid === undefined) {
                //var tmpStr =(ic.realHeight < 300) ? 'top:100px; font-size: 1.2em;' : 'top:180px; font-size: 1.8em;';
                let tmpStr = 'top:180px; font-size: 1.8em;';
                html += me.htmlCls.divStr + "wait' style='position:absolute; left:50px; " + tmpStr + " color: #444444;'>Loading data...</div>";
            }
            html += "<canvas id='" + me.pre + "canvas' style='width:100%; height: 100%; background-color: #FFF;'>Your browser does not support WebGL.</canvas>";

            // separate for the log box
            if(me.cfg.showcommand === undefined || me.cfg.showcommand) {
                html += this.setLogWindow();
            }

            html += "</div>";

            html += "</div>";

            html += me.htmlCls.setDialogCls.setDialogs();

            html += me.htmlCls.setDialogCls.setCustomDialogs();

            $( "#" + id).html(html);

            // mn display
            $("accordion").accordion({ collapsible: true, active: false, heightStyle: "content"});
            $("accordion div").removeClass("ui-accordion-content ui-corner-all ui-corner-bottom ui-widget-content");

            $(".icn3d-mn-item").menu({position: { my: "left top", at: "right top" }});
            $(".icn3d-mn-item").hover(function(){},function(){$("accordion").accordion( "option", "active", "none");});

            $("#" + me.pre + "accordion0").hover( function(){ $("#" + me.pre + "accordion0 div").css("display", "block"); }, function(){ $("#" + me.pre + "accordion0 div").css("display", "none"); } );
        }

        setReplayHtml(id) { let me = this.icn3dui;
            if(me.bNode) return '';

            let html = '';

            html += me.htmlCls.divStr + "replay' style='display:none; position:absolute; z-index:9999; top:" + parseInt(me.htmlCls.HEIGHT - 100).toString() + "px; left:20px;'>";
            html += "<div title='Click to replay one step'><svg style='cursor:pointer;' fill='#f8b84e' viewBox='0 0 60 60' width='40' height='40'>";
            html += '<circle style="fill:#f8b84e;" cx="29" cy="29" r="29"/>';
            html += '<g>';
            html += '<polygon style="fill:#FFFFFF;" points="44,29 22,44 22,29.273 22,14"/>';
            html += '<path style="fill:#FFFFFF;" d="M22,45c-0.16,0-0.321-0.038-0.467-0.116C21.205,44.711,21,44.371,21,44V14c0-0.371,0.205-0.711,0.533-0.884c0.328-0.174,0.724-0.15,1.031,0.058l22,15C44.836,28.36,45,28.669,45,29s-0.164,0.64-0.437,0.826l-22,15C22.394,44.941,22.197,45,22,45z M23,15.893v26.215L42.225,29L23,15.893z"/>';
            html += '</g>';
            html += "</svg></div>";
            html += me.htmlCls.divStr + "replay_menu' style='background-color:#DDDDDD; padding:3px; font-weight:bold;'></div>";
            html += me.htmlCls.divStr + "replay_cmd' style='background-color:#DDDDDD; padding:3px; max-width:250px'></div>";
            html += "</div>";

            return html;
        }

        //Set the HTML code for the tools section. It includes several buttons, and is the second line at the top of the viewer.
        setTools() { let me = this.icn3dui;
            if(me.bNode) return '';

            let html = "";

            html += me.htmlCls.divStr + "selection' style='display:none;'><div style='position:absolute; z-index:555; float:left; display:table-row; margin: 32px 0px 0px 0px;'>";
            //html += "<table style='margin-top: 3px; width:100px;'>";
            html += "<table style='margin: 3px 0px 0px 76px; width:770px; background-color:#EEE;'>";

            html += this.setTools_base();

            // add custom buttons here
            // ...

            html += "</table>";
            html += "</div></div>";

            return html;
        }

        setButton(buttonStyle, id, title, text, color) { let me = this.icn3dui;
            if(me.bNode) return '';

            color =(color !== undefined) ? 'color:' + color : '';
            let bkgdColor = me.utilsCls.isMobile() ? ' background-color:#DDDDDD;' : '';
            return "<div style='margin:3px 0px 0px 10px;'><button style='-webkit-appearance:" + buttonStyle + "; height:36px;" + bkgdColor + "' id='" + me.pre + id + "'><span style='white-space:nowrap;" + color + "' class='icn3d-commandTitle' title='" + title + "'>" + text + "</span></button></div>";
        }

        setIcon(iconType, id, title, iconStyle, url, bText, bHighlight) { let me = this.icn3dui;
            if(me.bNode) return '';

            let color = (bHighlight) ? 'color:#f8b84e; ' : 'color:#1c94c4; ';
            let bkgdColor = ' background-color:#EEE; ';
            let cssCursor = (iconType == 'text') ? '' : 'cursor:pointer;';

            //let iconHtml = '<i id="' + me.pre + id + '" class="fa fa-' + iconStyle + '" title="' + title + '" style="font-size:20px; ' + color + bkgdColor + cssCursor + cssBorder + '"></i>';
            let iconHtml;
            if(bText) {
                iconHtml = '<div id="' + me.pre + id + '" title="' + title + '" style="font-family: Arial, Helvetica, sans-serif; font-size:16px; width:16px; height:16px;' + color + bkgdColor + cssCursor + '">' + iconStyle + '</div>';
            }
            else {
                iconHtml = '<i id="' + me.pre + id + '" class="las la-' + iconStyle + '" title="' + title + '" style="width:16px; height:16px;' + color + bkgdColor + cssCursor + '"></i>';
            }

            if(iconType == 'link') {
                return '<a href="' + url + '" target="_blank">' + iconHtml + '</a>';
            }
            else {
                return iconHtml;
            }
        }

        setTools_base() { let me = this.icn3dui;
            if(me.bNode) return '';

            // second row
            let html = "<tr valign='center'>";

            let iconType = 'regular';
            let tdStr = "<td valign='top' align='center'>";
            let tdStrBorder = "<td valign='top' align='center' style='border-left: solid 1px #888888'>";

            // line-awesome: https://icons8.com/line-awesome
            // File menu
            html += tdStr + this.setIcon(iconType, 'tool_mmdbafid', 'Input PDB/MMDB/AlphaFold IDs', 'id', undefined, true) + "</td>";
            html += tdStr + this.setIcon(iconType, 'tool_pdbfile', 'Input PDB Files (appendable)', 'file-alt') + "</td>";
            html += tdStr + this.setIcon(iconType, 'tool_sharelink', 'Get Share Link', 'link') + "</td>";
            html += tdStr + this.setIcon(iconType, 'saveimage', 'Save iCn3D PNG Image', 'camera') + "</td>";

            // Select menu
            html += tdStrBorder + this.setIcon(iconType, 'tool_definedsets', 'Defined Sets', 'object-group') + "</td>";
            html += tdStr + this.setIcon(iconType, 'tool_aroundsphere', 'Select by Distance', 'dot-circle') + "</td>";
            html += tdStr + this.setIcon(iconType, 'tool_saveselection', 'Save Selection as a Set', 'save') + "</td>";
            html += tdStr + this.setIcon(iconType, 'toggleHighlight', 'Toggle Highlight', 'highlighter') + "</td>";

            // View menu
            html += tdStrBorder + this.setIcon(iconType, 'show_selected', 'View Selection', 'eye') + "</td>";
            html += tdStr + this.setIcon(iconType, 'tool_selectedcenter', 'Zoom in Selection', 'search-plus') + "</td>";
            html += tdStr + this.setIcon(iconType, 'alternate', "Alternate the Structures by keying the letter 'a'", 'a', undefined, true, true) + "</td>";
            html += tdStr + this.setIcon(iconType, 'tool_resetOrientation', 'Reset Orientation', 'undo-alt') + "</td>";

            // Style menu
            html += tdStrBorder + this.setIcon(iconType, 'tool_proteinsRibbon', 'Style Ribbon for proteins', 'dna') + "</td>";
            html += tdStr + this.setIcon(iconType, 'tool_proteinsSphere', 'Style Sphere for proteins', 'volleyball-ball') + "</td>";
            html += tdStr + this.setIcon(iconType, 'tool_surfaceVDW', 'Show Van der Waals Surface', 'cloud') + "</td>";
            html += tdStr + this.setIcon(iconType, 'tool_bkgd', 'Toggle Background Color', 'adjust') + "</td>";

            // Color menu
            html += tdStrBorder + this.setIcon(iconType, 'tool_clrRainbowChain', 'Color Rainbow for Chains', 'rainbow') + "</td>"; 
            html += tdStr + this.setIcon(iconType, 'tool_clrSSGreen', 'Color by Secondary Structures', 'ring') + "</td>";
            html += tdStr + this.setIcon(iconType, 'tool_clrChain', 'Color by Chains', 'layer-group') + "</td>";
            html += tdStr + this.setIcon(iconType, 'tool_clrAtom', 'Color by Atoms', 'atom') + "</td>";

            // Analysis menu
            html += tdStrBorder + this.setIcon(iconType, 'tool_selectannotations', 'Sequences & Annotations', 'grip-lines') + "</td>";
            html += tdStr + this.setIcon(iconType, 'hbondsYes', 'Interactions', 'users') + "</td>";
            html += tdStr + this.setIcon(iconType, 'tool_delphi', 'DelPhi Potentials', 'cloud-meatball') + "</td>";
            html += tdStr + this.setIcon(iconType, 'removeLabels', 'Remove Labels', 'remove-format') + "</td>";

            // Help menu
            html += tdStrBorder + this.setIcon('link', 'tool-gallery', 'Gallery', 'image', 'https://www.ncbi.nlm.nih.gov/Structure/icn3d/icn3d.html#gallery') + "</td>";
            html += tdStr + this.setIcon('link', 'tool-video', 'Videos', 'file-video', 'https://www.ncbi.nlm.nih.gov/Structure/icn3d/icn3d.html#videos') + "</td>";
            html += tdStr + this.setIcon('link', 'tool-github', 'iCn3D GitHub', 'code', 'https://github.com/ncbi/icn3d') + "</td>";
            html += tdStr + this.setIcon('link', 'tool-hints', 'Transform Hints', 'info-circle', 'https://www.ncbi.nlm.nih.gov/Structure/icn3d/icn3d.html#useicn3d') + "</td>";

            html += "</tr>";

            return html;
        }

        setTheme(color) { let me = this.icn3dui;
            if(me.bNode) return '';

            let borderColor, bkgdColor, bkgdImg, iconImg, activeTabColor;

            me.htmlCls.themecolor = color;

            if(color == 'orange') {
                borderColor = '#e78f08';
                bkgdColor = '#f6a828';
                bkgdImg = 'ui-bg_gloss-wave_35_f6a828_500x100.png';
                iconImg = 'ui-icons_ef8c08_256x240.png';
                activeTabColor = '#eb8f00';
            }
            else if(color == 'black') {
                borderColor = '#333333';
                bkgdColor = '#333333';
                bkgdImg = 'ui-bg_gloss-wave_25_333333_500x100.png';
                iconImg = 'ui-icons_222222_256x240.png';
                activeTabColor = '#222222';
            }
            else if(color == 'blue') {
                borderColor = '#4297d7';
                bkgdColor = '#5c9ccc';
                bkgdImg = 'ui-bg_gloss-wave_55_5c9ccc_500x100.png';
                iconImg = 'ui-icons_228ef1_256x240.png';
                activeTabColor = '#444';
            }

            $('.ui-widget-header').css({
                'border': '1px solid ' + borderColor,
                'background': bkgdColor + ' url("https://www.ncbi.nlm.nih.gov/Structure/icn3d/lib/images/' + bkgdImg + '") 50% 50% repeat-x',
                'color':'#fff',
                'font-weight':'bold'
            });

            $('.ui-button .ui-icon').css({
                'background-image': 'url(https://www.ncbi.nlm.nih.gov/Structure/icn3d/lib/images/' + iconImg + ')'
            });

            $('.ui-state-active a, .ui-state-active a:link, .ui-state-active a:visited').css({
                'color': activeTabColor,
                'text-decoration': 'none'
            });
        }

        //Set the textarea for the log output.
        setLogWindow(bUpdate, bCmdWindowInput) { let me = this.icn3dui;
            if(me.bNode) return '';

            let bCmdWindow, html = "";

            // check command window 
            let value = me.htmlCls.setHtmlCls.getCookie('cmdwindow');
            if(value != '') {
                bCmdWindow = (bCmdWindowInput !== undefined) ? bCmdWindowInput : parseInt(value);
                if(bCmdWindow == 1) { // default 0
                    me.htmlCls.LOG_HEIGHT = 180; //65;
                    me.htmlCls.CMD_HEIGHT = 0.8*me.htmlCls.LOG_HEIGHT;

                    if(!bUpdate) html += me.htmlCls.divStr + "cmdlog' style='float:left; margin-top: 5px; width: 100%;'>";
                    html += "<textarea id='" + me.pre + "logtext' rows='2' style='width: 100%; height: " + me.htmlCls.CMD_HEIGHT + "px;  margin: auto; padding: 5px; box-sizing: border-box; border: 4px inset orange; background-color: " + me.htmlCls.GREYD + ";'></textarea>";
                }
                else {
                    me.htmlCls.LOG_HEIGHT = 65;
                    me.htmlCls.CMD_HEIGHT = 0.8*me.htmlCls.LOG_HEIGHT;

                    if(!bUpdate) html += me.htmlCls.divStr + "cmdlog' style='float:left; margin-top: 5px; width: 100%;'>";
                    html += "<textarea id='" + me.pre + "logtext' rows='2' style='width: 100%; height: " + me.htmlCls.CMD_HEIGHT + "px; padding: 0px; border: 0px; background-color: " + me.htmlCls.GREYD + ";'></textarea>";                 
                }
            }
            else {
                bCmdWindow = 0;

                me.htmlCls.LOG_HEIGHT = 65;
                me.htmlCls.CMD_HEIGHT = 0.8*me.htmlCls.LOG_HEIGHT;

                if(!bUpdate) html += me.htmlCls.divStr + "cmdlog' style='float:left; margin-top: 5px; width: 100%;'>";
                html += "<textarea id='" + me.pre + "logtext' rows='2' style='width: 100%; height: " + me.htmlCls.CMD_HEIGHT + "px; padding: 0px; border: 0px; background-color: " + me.htmlCls.GREYD + ";'></textarea>";
            }
            
            if(!bUpdate) html += "</div>";

            if(bUpdate) {
                me.htmlCls.clickMenuCls.setLogCmd('set cmdwindow ' + bCmdWindow, true);
                $("#" + me.pre + "cmdlog").html(html);
            }

            return html;
        }

        //Set the menu "File" at the top of the viewer.
        setMenu1() { let me = this.icn3dui;
            if(me.bNode) return '';

            let html = "";

            html += "<div class='icn3d-menu'>";

            html += "<accordion id='" + me.pre + "accordion1' class='icn3d-accordion'>";
            html += "<h3>File</h3>";
            html += "<div>";

            html += this.setMenu1_base();

            html += "</div>";
            html += "</accordion>";
            html += "</div>";

            return html;
        }

        setMenu1_base() { let me = this.icn3dui;
            if(me.bNode) return '';

            let html = "";

            html += "<ul class='icn3d-mn-item'>";
            
            html += this.getMenuText('mn1_searchgrooup', 'Search Structure ' + me.htmlCls.wifiStr, undefined, 1, 1);
            html += "<ul>";
            html += this.getMenuUrl('mn1_searchstru', 'https://www.ncbi.nlm.nih.gov/structure', 'PDB Structures ' + me.htmlCls.wifiStr, 1, 2);
            html += this.getLink('mn1_proteinname', 'AlphaFold Structures ' + me.htmlCls.wifiStr, 1, 2);
            html += this.getMenuUrl('mn1_afdatabase', 'https://alphafold.ebi.ac.uk', 'AlphaFold UniProt Database ' + me.htmlCls.wifiStr, undefined, 2);
            html += "</ul>";
            html += "</li>";

            html += this.getMenuText('mn1_searchsimilar', 'Search Similar' + me.htmlCls.wifiStr, undefined, undefined, 1);
            html += "<ul>";
            html += this.getLink('mn1_vastplus', 'NCBI VAST+ (PDB Complex)' + me.htmlCls.wifiStr, undefined, 2);
            html += this.getLink('mn1_vast', 'NCBI VAST (PDB Chain)' + me.htmlCls.wifiStr, undefined, 2);
            html += this.getLink('mn1_foldseek', 'Foldseek (PDB & AlphaFold)' + me.htmlCls.wifiStr, undefined, 2);
            html += "</ul>";
            html += "</li>";

            html += this.getMenuText('mn1_retrievebyid', 'Retrieve by ID', undefined, 1, 1); 
            html += "<ul>";
            
            html += this.getLink('mn1_mmdbafid', 'PDB/MMDB/AlphaFold IDs' + me.htmlCls.wifiStr, 1, 2);
            html += this.getLink('mn1_mmdbid', 'NCBI MMDB ID (annotation) ' + me.htmlCls.wifiStr, undefined, 2);
            html += this.getLink('mn1_mmtfid', 'RCSB BCIF/MMTF ID (fast) ' + me.htmlCls.wifiStr, undefined, 2);
            html += this.getLink('mn1_pdbid', 'RCSB PDB ID ' + me.htmlCls.wifiStr, undefined, 2);

            html += this.getMenuText('mn1_afwrap', 'AlphaFold Structures', undefined, undefined, 2);
            html += "<ul>";
            
            html += this.getLink('mn1_afid', 'UniProt ID ' + me.htmlCls.wifiStr, undefined, 3);
            html += this.getLink('mn1_refseqid', 'NCBI Protein Accession ' + me.htmlCls.wifiStr, undefined, 3);
            html += "</ul>";

            
            html += this.getLink('mn1_opmid', 'OPM PDB ID ' + me.htmlCls.wifiStr, undefined, 2);
            html += this.getLink('mn1_mmcifid', 'RCSB mmCIF ID ' + me.htmlCls.wifiStr, undefined, 2);
            //html += this.getLink('mn1_gi', 'NCBI gi ' + me.htmlCls.wifiStr, undefined, 2);

            html += this.getLink('mn1_cid', 'PubChem CID/Name/InchI ' + me.htmlCls.wifiStr, 1, 2);
            html += this.getLink('mn1_smiles', 'Chemical SMILES ', undefined, 2);
            
            html += "</ul>";
            html += "</li>";

            html += this.getMenuText('mn1_openfile', 'Open File', undefined, 1, 1);
            html += "<ul>";
    //        html += this.getLink('mn1_pdbfile', 'PDB File');
    //        html += this.getLink('mn1_pdbfile_app', 'PDB File (append)');
            html += this.getLink('mn1_pdbfile_app', 'PDB Files (appendable)', 1, 2);
            html += this.getLink('mn1_mmciffile', 'mmCIF Files (appendable)', undefined, 2);
            html += this.getLink('mn1_mol2file', 'Mol2 File', undefined, 2);
            html += this.getLink('mn1_sdffile', 'SDF File', undefined, 2);
            html += this.getLink('mn1_xyzfile', 'XYZ File', undefined, 2);

            html += this.getMenuSep();

            html += this.getMenuText('mn1_msawrap', 'Multiple Seq. Alignment', undefined, undefined, 2);
            html += "<ul>";
            html += this.getLink('mn1_clustalwfile', 'CLUSTALW Format', undefined, 3);
            html += this.getLink('mn1_fastafile', 'FASTA Format', undefined, 3);
            html += "</ul>";

            html += this.getLink('mn1_afmapfile', 'AlphaFold PAE File', undefined, 2);

            html += this.getLink('mn1_urlfile', 'URL(CORS) ' + me.htmlCls.wifiStr, undefined, 2);
            
            html += this.getMenuSep();
            html += this.getLink('mn1_pngimage', 'iCn3D PNG (appendable)', 1, 2);
            html += this.getLink('mn1_state', 'State/Script File', undefined, 2);
            html += this.getLink('mn1_fixedversion', 'Share Link in Archived Ver. ' + me.htmlCls.wifiStr, undefined, 2);
            html += this.getLink('mn1_selection', 'Selection File', undefined, 2);
            html += this.getLink("mn1_collection", "Collection File", undefined, 2);

            html += this.getMenuSep();

            html += this.getMenuText('mn1_dsn6wrap', 'Electron Density', undefined, undefined, 2);
            html += "<ul>";
            html += this.getLink('mn1_dsn6', 'Local File', undefined, 3);
            html += this.getLink('mn1_dsn6url', 'URL(CORS) ' + me.htmlCls.wifiStr, undefined, 3);
            html += "</ul>";

            html += "<li><br/></li>";

            html += "</ul>";
            html += "</li>";

            //html += this.getMenuText('mn1_fold', 'AlphaFold/ESM', undefined, undefined, 1);
            html += this.getMenuText('mn1_fold', 'Predict by Seq.', undefined, undefined, 1);
            html += "<ul>";
            html += this.getLink('mn1_esmfold', 'ESMFold', undefined, 2);
            //html += this.getMenuUrl('mn1_esmfold_link', "https://colab.research.google.com/github/sokrypton/ColabFold/blob/main/ESMFold.ipynb", "ESMFold via ColabFold" + me.htmlCls.wifiStr, undefined, 2);
            html += this.getLink('mn1_alphafold', 'AlphaFold2 via ColabFold' + me.htmlCls.wifiStr, undefined, 2);
            html += "</ul>";

            
            html += this.getMenuText('mn1_alignwrap', 'Align', undefined, 1, 1);
            html += "<ul>";
            
            html += this.getMenuText('mn1_chainalignwrap', 'Multiple Chains', undefined, 1, 2);
            html += "<ul>";
            html += this.getRadio('mn1_chainalignRad', 'mn1_chainalign', 'by Structure Alignment ' + me.htmlCls.wifiStr, undefined, 1, 3);
            html += this.getRadio('mn1_chainalignRad', 'mn1_chainalign2', 'by Sequence Alignment ' + me.htmlCls.wifiStr, undefined, 1, 3);
            html += this.getRadio('mn1_chainalignRad', 'mn1_chainalign3', 'Residue by Residue', undefined, undefined, 3);
            html += "</ul>";
            html += "</li>";

            html += this.getMenuText('mn1_aligntwostru', 'Protein Complexes', undefined, 1, 2);
            html += "<ul>";
            html += this.getLink('mn1_align', 'Two PDB Structures ' + me.htmlCls.wifiStr, 1, 3);
            html += this.getLink('mn1_alignaf', 'Two AlphaFold Structures ' + me.htmlCls.wifiStr, undefined, 3);
            html += "</ul>";

            html += this.getLink('mn1_blast_rep_id', 'Sequence to Structure', undefined, 2);

            html += "</ul>";
            html += "</li>";

            html += this.getMenuText('mn2_realignWrap', 'Realign Selection', undefined, undefined, 1);
            html += "<ul>";

            html += this.getMenuText('mn2_chainrealignwrap', 'Multiple Chains', undefined, undefined, 2);
            html += "<ul>";
            html += this.getRadio('mn2_realign', 'mn2_realignonstruct', 'by Structure Alignment ' + me.htmlCls.wifiStr, undefined, undefined, 3);
            html += this.getRadio('mn2_realign', 'mn2_realignonseqalign', 'by Sequence Alignment ' + me.htmlCls.wifiStr, undefined, undefined, 3);
            html += this.getRadio('mn2_realign', 'mn2_realignresbyres', 'Residue by Residue', undefined, undefined, 3);
            html += "</ul>";

            html += this.getLink('mn2_realigntwostru', 'Protein Complexes', undefined, 2);

            html += "</ul>";
            html += "</li>";

            html += this.getMenuText('mn1_3dpprint', '3D Printing', undefined, 1, 1);
            html += "<ul>";
            if(me.cfg.cid === undefined) {
                html += this.getLink('mn1_exportVrmlStab', 'WRL/VRML(Color, W/ Stab.)', 1, 2);
                html += this.getLink('mn1_exportStlStab', 'STL(W/ Stabilizers)', 1, 2);
                html += this.getMenuSep();
                html += this.getLink('mn1_exportVrml', 'WRL/VRML(Color)', undefined, 2);
                html += this.getLink('mn1_exportStl', 'STL', undefined, 2);

                html += this.getMenuSep();
                html += this.getLink('mn1_stabilizerYes', 'Add All Stabilizers', undefined, 2);
                html += this.getLink('mn1_stabilizerNo', 'Remove All Stabilizers', undefined, 2);
                html += this.getMenuSep();
                html += this.getLink('mn1_stabilizerOne', 'Add One Stabilizer', undefined, 2);
                html += this.getLink('mn1_stabilizerRmOne', 'Remove One Stabilizer', undefined, 2);
                html += this.getMenuSep();
                html += this.getLink('mn1_thicknessSet', 'Set Thickness', undefined, 2);
            }
            else {
                html += this.getLink('mn1_exportVrml', 'VRML(Color)', 1, 2);
                html += this.getLink('mn1_exportStl', 'STL', 1, 2);
            }

            html += "</ul>";
            html += "</li>";

            html += this.getMenuText('mn1_savefile', 'Save File', undefined, 1, 1);
            html += "<ul>";
            html += this.getMenuText('mn1_savepngimage', 'iCn3D PNG Image', undefined, 1, 2);
            html += "<ul>";
            html += this.getLink('mn1_exportCanvas', 'Original Size & HTML', undefined, 3);
            html += this.getLink('mn1_exportCanvas1', 'Original Size', 1, 3);

            html += this.getLink('mn1_exportCanvas2', '2X Large', undefined, 3);
            html += this.getLink('mn1_exportCanvas4', '4X Large', undefined, 3);
            html += this.getLink('mn1_exportCanvas8', '8X Large', undefined, 3);

            html += "</ul>";
            html += "</li>";

            html += this.getLink('mn1_exportVideo', 'Video', undefined, 2);
            html += this.getLink('mn1_exportState', 'State File', undefined, 2);
            html += this.getLink('mn1_exportSelections', 'Selection File', undefined, 2);
            html += this.getLink('mn1_exportSelDetails', 'Selection Details', undefined, 2);
            html += this.getLink('mn1_exportCounts', 'Residue Counts', undefined, 2);

            html += this.getLink('mn1_exportPdbRes', 'PDB', 1, 2);
            html += this.getLink('profixpdb', 'PDB with Missing Atoms', undefined, 2);
            
            // the quality is not good to add hydrogen
            //html += this.getLink('profixpdbh', 'PDB with Hydrogens', undefined, 2);

            if(me.cfg.cid === undefined) {
                html += this.getLink('mn1_exportSecondary', 'Secondary Structure', undefined, 2);
            }

            html += this.getMenuText('m1_exportrefnum', 'Reference Numbers', undefined, undefined, 2);
            html += "<ul>";
            html += this.getLink('mn1_exportIgstrand', 'Ig Strand', undefined, 3);
            html += this.getLink('mn1_exportKabat', 'Kabat', undefined, 3);
            html += this.getLink('mn1_exportImgt', 'IMGT', undefined, 3);
            html += "</ul>";

            html += "<li><br/></li>";

            html += "</ul>";
            html += "</li>";

            html += this.getLink('mn1_sharelink', 'Share Link ' + me.htmlCls.wifiStr, 1, 1);

            html += this.getLink('mn1_replayon', 'Replay Each Step', undefined, 1);

            html += this.getMenuSep();

            html += this.getMenuText('mn1_menuwrap', 'Customize Menus', undefined, 1, 1);
            html += "<ul>";
            html += this.getLink('mn1_menuall', 'All Menus', 1, 2);
            html += this.getLink('mn1_menusimple', 'Simple Menus', 1, 2);
            html += this.getMenuSep();
            html += this.getLink('mn1_menupref', 'Preferences', 1, 2);
            html += this.getLink('mn1_menuloadpref', 'Load Preferences', 1, 2);
            html += "</ul>";
            html += "</li>";

            html += "<li><br/></li>";

            html += "</ul>";

            return html;
        }

        //Set the menu "Select" at the top of the viewer.
        setMenu2() { let me = this.icn3dui;
            if(me.bNode) return '';

            let html = "";

            html += "<div class='icn3d-menu'>";
            html += "<accordion id='" + me.pre + "accordion2' class='icn3d-accordion'>";
            html += "<h3>Select</h3>";
            html += "<div>";

            html += this.setMenu2_base();

            html += "</div>";
            html += "</accordion>";
            html += "</div>";

            return html;
        }

        setMenu2_base() { let me = this.icn3dui;
            if(me.bNode) return '';

            let html = "";

            html += "<ul class='icn3d-mn-item'>";

            html += this.getLink('mn2_definedsets', 'Defined Sets', 1, 1);
            html += this.getLink('mn2_selectall', 'All', 1, 1);
            html += this.getLink('mn2_selectdisplayed', 'Displayed Set', undefined, 1);
            html += this.getLink('mn2_aroundsphere', 'by Distance', 1, 1);

            html += this.getMenuText('mn2_selbyprop', 'by Property', undefined, undefined, 1);
            html += "<ul>";
            html += this.getLink('mn2_propPos', 'Positive', undefined, 2);
            html += this.getLink('mn2_propNeg', 'Negative', undefined, 2);
            html += this.getLink('mn2_propHydro', 'Hydrophobic', undefined, 2);
            html += this.getLink('mn2_propPolar', 'Polar', undefined, 2);
            html += this.getLink('mn2_propBfactor', 'B-factor/pLDDT', undefined, 2);
            html += this.getLink('mn2_propSolAcc', 'Solvent Accessibility', undefined, 2);
            html += "</ul>";
            html += "</li>";

            html += this.getLink('mn2_selectcomplement', 'Inverse', undefined, 1);
            html += this.getLink('mn2_selectmainchains', 'Main Chains', 1, 1);
            html += this.getLink('mn2_selectsidechains', 'Side Chains', 1, 1);
            html += this.getLink('mn2_selectmainsidechains', 'Main & Side Chains', undefined, 1);
            html += this.getLink('mn2_command', 'Advanced', 1, 1);

            if(me.cfg.cid === undefined) {
                html += this.getMenuText('mn2_selon3d', 'Select on 3D', undefined, 1, 1);
                html += "<ul>";

                html += "<li>\"Alt\"+Click: start selection</li>";
                html += "<li>\"Ctrl\"+Click: union selection</li>";
                html += "<li>\"Shift\"+Click: range Selection</li>";
                html += this.getMenuSep();
                html += this.getRadio('mn2_pk', 'mn2_pkChain', 'Chain', undefined, 1, 2);
                if(me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined) {
                    html += this.getRadio('mn2_pk', 'mn2_pkDomain', '3D Domain', undefined, undefined, 2);
                }
                html += this.getRadio('mn2_pk', 'mn2_pkStrand', 'Strand/Helix', undefined, undefined, 2);
                html += this.getRadio('mn2_pk', 'mn2_pkResidue', 'Residue', true, 1, 2);
                html += this.getRadio('mn2_pk', 'mn2_pkYes', 'Atom', undefined, 1, 2);
                html += this.getRadio('mn2_pk', 'mn2_pkNo', 'None', undefined, undefined, 2);
                html += "</ul>";
                html += "</li>";
            }
            else {
                if(me.utilsCls.isMobile()) {
                    html += "<li><span>Touch to pick</span></li>";
                }
                else {
                    html += "<li><span>Picking with<br>\"Alt\" + Click</span></li>";
                }
            }

            html += this.getMenuSep();

            html += this.getLink('mn2_saveselection', 'Save Selection', 1, 1);
            html += this.getLink('clearall', 'Clear Selection', 1, 1);
            html += this.getLink('mn2_saveresidue', 'Save Res. in Sel.', 1, 1);

            html += this.getMenuSep();

            html += this.getMenuText('mn2_hlcolor', 'Highlight Color', undefined, undefined, 1);
            html += "<ul>";
            html += this.getRadio('mn2_hl_clr', 'mn2_hl_clrYellow', 'Yellow', true, undefined, 2);
            html += this.getRadio('mn2_hl_clr', 'mn2_hl_clrGreen', 'Green', undefined, undefined, 2);
            html += this.getRadio('mn2_hl_clr', 'mn2_hl_clrRed', 'Red', undefined, undefined, 2);
            html += "</ul>";
            html += "</li>";
            html += this.getMenuText('mn2_hlstyle', 'Highlight Style', undefined, undefined, 1);
            html += "<ul>";

            html += this.getRadio('mn2_hl_style', 'mn2_hl_styleOutline', 'Outline', true, undefined, 2);
            html += this.getRadio('mn2_hl_style', 'mn2_hl_styleObject', '3D Objects', undefined, undefined, 2);

            html += "</ul>";
            html += "</li>";

            html += this.getLink('toggleHighlight2', 'Toggle Highlight', 1, 1);

            html += "<li><br/></li>";

            html += "</ul>";

            return html;
        }

        setMenu2b() { let me = this.icn3dui;
            if(me.bNode) return '';

            let html = "";

            html += "<div class='icn3d-menu'>";
            html += "<accordion id='" + me.pre + "accordion2b' class='icn3d-accordion'>";
            html += "<h3>View</h3>";
            html += "<div>";

            html += this.setMenu2b_base();

            html += "</div>";
            html += "</accordion>";
            html += "</div>";

            return html;
        }

        setMenu2b_base() { let me = this.icn3dui;
            if(me.bNode) return '';

            let html = "";
            html += "<ul class='icn3d-mn-item'>";

            html += this.getLink('mn2_show_selected', 'View Selection', 1, 1);
            html += this.getLink('mn2_hide_selected', 'Hide Selection', 1, 1);
            html += this.getLink('mn2_selectedcenter', 'Zoom in Selection', 1, 1);
            //html += this.getLink('mn6_center', 'Center Selection', undefined, 1);
            html += this.getLink('mn6_center', 'Center Selection', 1, 1);

            html += this.getLink('mn2_fullstru', 'View Full Structure');
            html += this.getLinkWrapper('mn2_alternate', 'Alternate(Key "a")', 'mn2_alternateWrap', undefined, 1);

            if(me.cfg.opmid !== undefined) {
                html += this.getLinkWrapper('togglemem', 'Toggle Membrane', 'togglememli', 1, 1);
            }
            //else if(me.cfg.mmdbafid !== undefined || me.cfg.afid !== undefined) {
            else if(me.cfg.cid === undefined) {
                // hide by default
                html += this.getLinkWrapper('togglemem', 'Toggle Membrane', 'togglememli', undefined, 1, true);
            }

            if(me.cfg.opmid !== undefined) {
                html += this.getLinkWrapper('adjustmem', 'Adjust Membrane', 'adjustmemli', undefined, 1);
                html += this.getLinkWrapper('selectplane', 'Select between<br>Two X-Y Planes</span>', 'selectplaneli', undefined, 1);
            }

            html += this.getMenuSep();

            html += this.getMenuText('mn2_vrarhints', 'VR & AR Hints', undefined, undefined, 1);
            html += "<ul>";
            html += this.getMenuUrl("vrhint", me.htmlCls.baseUrl + "icn3d/icn3d.html#vr", "VR: VR Headsets", undefined, 2);
            html += this.getMenuUrl("arhint", me.htmlCls.baseUrl + "icn3d/icn3d.html#ar", "AR: Chrome in Android", undefined, 2);
            html += "</ul>";
            html += "</li>";

            html += this.getMenuText('mn6_stereoWrapper', 'Stereo View', undefined, undefined, 1);
            html += "<ul>";
            html += this.getRadio('mn6_stereo', 'mn6_stereoYes', 'On', undefined, undefined, 2);
            html += this.getRadio('mn6_stereo', 'mn6_stereoNo', 'Off', true, undefined, 2);
            html += "</ul>";
            html += "</li>";

            html += this.getLink('mn6_sidebyside', 'Side by Side', undefined, 1);

            html += this.getMenuText('mn2_rotate', 'Rotate', undefined, 1, 1);
            html += "<ul>";

            html += this.getMenuText('mn2_rotate90', 'Rotate 90&deg;', undefined, undefined, 2);
            html += "<ul>";
            html += this.getRadio('mn6_rotate90', 'mn6_rotatex', 'rotate x', undefined, undefined, 2);
            html += this.getRadio('mn6_rotate90', 'mn6_rotatey', 'rotate y', undefined, undefined, 2);
            html += this.getRadio('mn6_rotate90', 'mn6_rotatez', 'rotate z', undefined, undefined, 2);
            html += "</ul>";
            html += "</li>";
            html += this.getMenuText('mn2_rotateauto', 'Auto Rotation', undefined, 1, 2);
            html += "<ul>";
            html += this.getRadio('mn6_rotate', 'mn6_rotateleft', 'Rotate Left', undefined, 1, 3);
            html += this.getRadio('mn6_rotate', 'mn6_rotateright', 'Rotate Right', undefined, 1, 3);
            html += this.getRadio('mn6_rotate', 'mn6_rotateup', 'Rotate Up', undefined, 1, 3);
            html += this.getRadio('mn6_rotate', 'mn6_rotatedown', 'Rotate Down', undefined, 1, 3);
            html += "</ul>";
            html += "</li>";

            html += "</ul>";
            html += "</li>";

            html += this.getLink('mn2_translate', 'Translate XYZ', undefined, 1);
            html += this.getLink('mn2_matrix', 'Rotate with Matrix', undefined, 1);

            html += this.getMenuText('mn2_camera', 'Camera', undefined, undefined, 1);
            html += "<ul>";
            html += this.getRadio('mn6_camera', 'mn6_cameraPers', 'Perspective', true, undefined, 2);
            html += this.getRadio('mn6_camera', 'mn6_cameraOrth', 'Orthographic', undefined, undefined, 2);
            html += "</ul>";
            html += "</li>";
            html += this.getMenuText('mn2_fog', 'Fog for Selection', undefined, undefined, 1);
            html += "<ul>";
            html += this.getRadio('mn6_showfog', 'mn6_showfogYes', 'On', undefined, undefined, 2);
            html += this.getRadio('mn6_showfog', 'mn6_showfogNo', 'Off', true, undefined, 2);
            html += "</ul>";
            html += "</li>";
            html += this.getMenuText('mn2_slab', 'Slab for Selection', undefined, undefined, 1);
            html += "<ul>";
            html += this.getRadio('mn6_showslab', 'mn6_showslabYes', 'On', undefined, undefined, 2);
            html += this.getRadio('mn6_showslab', 'mn6_showslabNo', 'Off', true, undefined, 2);
            html += "</ul>";
            html += "</li>";
            html += this.getMenuText('mn2_axes', 'XYZ-axes', undefined, undefined, 1);
            html += "<ul>";
            html += this.getRadio('mn6_showaxis', 'mn6_showaxisYes', 'Original', undefined, undefined, 2);
            html += this.getRadio('mn6_showaxis', 'mn6_showaxisSel', 'Prin. Axes on Sel.', undefined, undefined, 2);
            html += this.getRadio('mn6_showaxis', 'mn6_showaxisNo', 'Hide', true, undefined, 2);
            html += "</ul>";
            html += "</li>";

            html += this.getMenuSep();

            html += this.getMenuText('mn2_resetwrap', 'Reset', undefined, 1, 1);
            html += "<ul>";
            html += this.getRadio('mn6_reset', 'reset', 'All', undefined, 1, 2);
            html += this.getRadio('mn6_reset', 'mn6_resetOrientation', 'Orientation', undefined, 1, 2);
            html += "</ul>";
            html += "</li>";

            html += this.getLink('mn6_back', 'Undo', undefined, 1);
            html += this.getLink('mn6_forward', 'Redo', undefined, 1);

            html += this.getLink('mn6_fullscreen', 'Full Screen', undefined, 1);
        //    html += this.getLink('mn6_exitfullscreen', 'Exit Full Screen');

            html += "<li><br/></li>";

            html += "</ul>";

            return html;
        }

        //Set the menu "Style" at the top of the viewer.
        setMenu3() { let me = this.icn3dui;
            if(me.bNode) return '';

            let html = "";

            html += "<div class='icn3d-menu'>";
            html += "<accordion id='" + me.pre + "accordion3' class='icn3d-accordion'>";
            html += "<h3 id='" + me.pre + "style'>Style</h3>";
            html += "<div>";

            html += this.setMenu3_base();

            html += "</div>";
            html += "</accordion>";
            html += "</div>";

            return html;
        }

        setMenu3_base() { let me = this.icn3dui;
            if(me.bNode) return '';

            let html = "";

            html += "<ul class='icn3d-mn-item'>";

            if(me.cfg.cid === undefined) {
                html += this.getMenuText('mn3_proteinwrap', 'Proteins', undefined, 1, 1);
                html += "<ul>";
                if(me.cfg.align !== undefined || me.cfg.chainalign !== undefined) {
                    html += this.getRadio('mn3_proteins', 'mn3_proteinsRibbon', 'Ribbon', undefined, 1, 2);
                }
                else {
                    html += this.getRadio('mn3_proteins', 'mn3_proteinsRibbon', 'Ribbon', true, 1, 2);
                }

                html += this.getRadio('mn3_proteins', 'mn3_proteinsStrand', 'Strand', undefined, 1, 2);
                html += this.getRadio('mn3_proteins', 'mn3_proteinsCylinder', 'Cylinder and Plate', undefined, undefined, 2);
                html += this.getRadio('mn3_proteins', 'mn3_proteinsSchematic', 'Schematic', undefined, 1, 2);

                if(me.cfg.align !== undefined || me.cfg.chainalign !== undefined) {
                    html += this.getRadio('mn3_proteins', 'mn3_proteinsCalpha', 'C Alpha Trace', true, 1, 2);
                }
                else {
                    html += this.getRadio('mn3_proteins', 'mn3_proteinsCalpha', 'C Alpha Trace', undefined, 1, 2);
                }

                html += this.getRadio('mn3_proteins', 'mn3_proteinsBackbone', 'Backbone', undefined, undefined, 2);
                html += this.getRadio('mn3_proteins', 'mn3_proteinsBfactor', 'B-factor Tube', undefined, undefined, 2);
                html += this.getRadio('mn3_proteins', 'mn3_proteinsLines', 'Lines', undefined, 1, 2);
                html += this.getRadio('mn3_proteins', 'mn3_proteinsStick', 'Stick', undefined, 1, 2);
                html += this.getRadio('mn3_proteins', 'mn3_proteinsBallstick', 'Ball and Stick', undefined, 1, 2);
                html += this.getRadio('mn3_proteins', 'mn3_proteinsSphere', 'Sphere', undefined, 1, 2);
                html += this.getRadio('mn3_proteins', 'mn3_proteinsNo', 'Hide', undefined, 1, 2);
                html += "</ul>";
                html += "</li>";

                html += this.getMenuText('mn3_sidecwrap', 'Side Chains', undefined, 1, 1);
                html += "<ul>";

                html += this.getRadio('mn3_sidec', 'mn3_sidecLines', 'Lines', undefined, 1, 2);
                html += this.getRadio('mn3_sidec', 'mn3_sidecStick', 'Stick', undefined, 1, 2);
                html += this.getRadio('mn3_sidec', 'mn3_sidecBallstick', 'Ball and Stick', undefined, 1, 2);
                html += this.getRadio('mn3_sidec', 'mn3_sidecSphere', 'Sphere', undefined, 1, 2);
                html += this.getRadio('mn3_sidec', 'mn3_sidecNo', 'Hide', true, 1, 2);
                html += "</ul>";
                html += "</li>";

                html += this.getMenuText('mn3_nuclwrap', 'Nucleotides', undefined, 1, 1);
                html += "<ul>";
                html += this.getRadio('mn3_nucl', 'mn3_nuclCartoon', 'Cartoon', true, 1, 2);
                html += this.getRadio('mn3_nucl', 'mn3_nuclPhos', "O3' Trace", undefined, 1, 2);
                html += this.getRadio('mn3_nucl', 'mn3_nuclBackbone', 'Backbone', undefined, undefined, 2);
                html += this.getRadio('mn3_nucl', 'mn3_nuclSchematic', 'Schematic', undefined, 1, 2);
                html += this.getRadio('mn3_nucl', 'mn3_nuclLines', 'Lines', undefined, 1, 2);
                html += this.getRadio('mn3_nucl', 'mn3_nuclStick', 'Stick', undefined, 1, 2);
                html += this.getRadio('mn3_nucl', 'mn3_nuclBallstick', 'Ball and Stick', undefined, 1, 2);
                html += this.getRadio('mn3_nucl', 'mn3_nuclSphere', 'Sphere', undefined, 1, 2);
                html += this.getRadio('mn3_nucl', 'mn3_nuclNo', 'Hide', undefined, 1, 2);
                html += "</ul>";
                html += "</li>";

                html += this.getMenuText('mn3_ntbasewrap', 'Nucl. Bases', undefined, 1, 1);
                html += "<ul>";

                html += this.getRadio('mn3_ntbase', 'mn3_ntbaseLines', 'Lines', undefined, 1, 2);
                html += this.getRadio('mn3_ntbase', 'mn3_ntbaseStick', 'Stick', undefined, 1, 2);
                html += this.getRadio('mn3_ntbase', 'mn3_ntbaseBallstick', 'Ball and Stick', undefined, 1, 2);
                html += this.getRadio('mn3_ntbase', 'mn3_ntbaseSphere', 'Sphere', undefined, 1, 2);
                html += this.getRadio('mn3_ntbase', 'mn3_ntbaseNo', 'Hide', true, 1, 2);
                html += "</ul>";
                html += "</li>";
            }

            html += this.getMenuText('mn3_ligwrap', 'Chemicals', undefined, 1, 1);
            html += "<ul>";
            html += this.getRadio('mn3_lig', 'mn3_ligLines', 'Lines', undefined, 1, 2);
            if(me.cfg.cid === undefined) {
                html += this.getRadio('mn3_lig', 'mn3_ligStick', 'Stick', true, 1, 2);
                html += this.getRadio('mn3_lig', 'mn3_ligBallstick', 'Ball and Stick', undefined, 1, 2);
            }
            else {
                html += this.getRadio('mn3_lig', 'mn3_ligStick', 'Stick', undefined, 1, 2);
                html += this.getRadio('mn3_lig', 'mn3_ligBallstick', 'BalHydrogensl and Stick', true, 1, 2);
            }
            html += this.getRadio('mn3_lig', 'mn3_ligSchematic', 'Schematic', undefined, 1, 2);
            html += this.getRadio('mn3_lig', 'mn3_ligSphere', 'Sphere', undefined, 1, 2);
            html += this.getRadio('mn3_lig', 'mn3_ligNo', 'Hide', undefined, 1, 2);
            html += "</ul>";
            html += "</li>";

            //if(me.cfg.cid !== undefined) {
                html += this.getMenuText('mn3_hydrogenswrap', 'Hydrogens', undefined, undefined, 1);
                html += "<ul>";
                html += this.getRadio('mn3_hydrogens', 'mn3_hydrogensYes', 'Show', true, undefined, 2);
                html += this.getRadio('mn3_hydrogens', 'mn3_hydrogensNo', 'Hide', undefined, undefined, 2);
                html += "</ul>";
                html += "</li>";
            //}

            if(me.cfg.cid === undefined) {
                html += this.getMenuText('mn3_glycanwrap', 'Glycans', undefined, undefined, 1);
                html += "<ul>";
                html += this.getRadio('mn3_glycansCart', 'mn3_glycansCartYes', 'Show Cartoon', undefined, undefined, 2);
                html += this.getRadio('mn3_glycansCart', 'mn3_glycansCartNo', 'Hide Cartoon', true, undefined, 2);
                html += "</ul>";
                html += "</li>";
            }

            html += this.getMenuText('mn3_ionswrap', 'Ions', undefined, 1, 1);
            html += "<ul>";
            html += this.getRadio('mn3_ions', 'mn3_ionsSphere', 'Sphere', true, 1, 2);
            html += this.getRadio('mn3_ions', 'mn3_ionsDot', 'Dot', undefined, 1, 2);
            html += this.getRadio('mn3_ions', 'mn3_ionsNo', 'Hide', undefined, 1, 2);
            html += "</ul>";
            html += "</li>";

            html += this.getMenuText('mn3_waterwrap', 'Water', undefined, 1, 1);
            html += "<ul>";
            html += this.getRadio('mn3_water', 'mn3_waterSphere', 'Sphere', undefined, 1, 2);
            html += this.getRadio('mn3_water', 'mn3_waterDot', 'Dot', undefined, 1, 2);
            html += this.getRadio('mn3_water', 'mn3_waterNo', 'Hide', true, 1, 2);
            html += "</ul>";
            html += "</li>";

            if(me.cfg.cid === undefined) {
                html += this.getMenuText('mn2_clashedwrap', 'Clashed Residues', undefined, undefined, 1);
                html += "<ul>";
                html += this.getRadio('mn2_clashed', 'mn2_clashedYes', 'Show', true, undefined, 2);
                html += this.getRadio('mn2_clashed', 'mn2_clashedNo', 'Hide', undefined, undefined, 2);
                html += "</ul>";
                html += "</li>";
            }

            html += this.getLink('mn3_setThickness', 'Preferences', undefined, 1);

            html += this.getMenuSep();
            html += this.getLink('mn3_styleSave', 'Save Style', undefined, 2);
            html += this.getLink('mn3_styleApplySave', 'Apply Saved Style', undefined, 2);

            html += this.getMenuSep();

            html += this.getMenuText('mn5_surfacewrap', 'Surface Type', undefined, 1, 1);
            html += "<ul>";
            html += this.getRadio('mn5_surface', 'mn5_surfaceVDW', 'Van der Waals', undefined, 1, 2);
            html += this.getRadio('mn5_surface', 'mn5_surfaceVDWContext', 'VDW with Context', undefined, undefined, 2);
            html += this.getRadio('mn5_surface', 'mn5_surfaceMolecular', 'Molecular Surface', undefined, 1, 2);
            html += this.getRadio('mn5_surface', 'mn5_surfaceMolecularContext', 'MS with Context', undefined, undefined, 2);
            html += this.getRadio('mn5_surface', 'mn5_surfaceSAS', 'Solvent Accessible', undefined, 1, 2);
            html += this.getRadio('mn5_surface', 'mn5_surfaceSASContext', 'SA with Context', undefined, undefined, 2);
            html += "</ul>";
            html += "</li>";

            html += this.getLink('mn5_surfaceNo', 'Remove Surface', 1, 1);

            html += this.getMenuText('mn5_surfaceop', 'Surface Opacity', undefined, 1, 1);
            html += "<ul>";

            html += this.getMenuText('mn5_surfaceopfast', 'Fast Transparency', undefined, 1, 2);
            html += "<ul>";
            html += this.getRadio('mn5_opacity', 'mn5_opacity10', '1.0', true, 1, 3);

            for(let i = 9; i > 0; --i) {
                html += this.getRadio('mn5_opacity', 'mn5_opacity0' + i, '0.' + i, 1, 3);
            }
            html += "</ul>";
            html += "</li>";

            html += this.getMenuText('mn5_surfaceopslow', 'Slow Transparency', undefined, undefined, 2);
            html += "<ul>";
            html += this.getRadio('mn5_opacityslow', 'mn5_opacityslow10', '1.0', true, undefined, 3);

            for(let i = 9; i > 0; --i) {
                html += this.getRadio('mn5_opacityslow', 'mn5_opacityslow0' + i, '0.' + i, undefined, undefined, 3);
            }
            html += "</ul>";
            html += "</li>";

            html += "</ul>"; // end of Surface Opacity

            html += this.getMenuText('mn5_wireframewrap', 'Surface Wireframe', undefined, 1, 1);
            html += "<ul>";
            html += this.getRadio('mn5_wireframe', 'mn5_wireframeYes', 'Yes', undefined, 1, 2);
            html += this.getRadio('mn5_wireframe', 'mn5_wireframeNo', 'No', true, 1, 2);
            html += "</ul>";
            html += "</li>";

            html += this.getMenuSep();

            html += this.getLink('mn5_cartoonshape', 'Cartoon for a Set', undefined, 1);
            html += this.getLink('mn5_linebtwsets', 'Line btw. Two Sets', undefined, 1);

            if(me.cfg.cid === undefined && me.cfg.align === undefined && me.cfg.chainalign === undefined && me.cfg.mmdbaf === undefined) {
                html += this.getMenuSep();

                html += this.getLinkWrapper2('mn5_map', 'Electron Density', 'mapWrapper1', undefined, 1);

                html += "<ul>";
                html += this.getLink('mn5_elecmap2fofc', '2Fo-Fc Map', undefined, 2);
                html += this.getLink('mn5_elecmapfofc', 'Fo-Fc Map', undefined, 2);
                html += this.getLinkWrapper('mn5_elecmapNo', 'Remove Map', 'mapWrapper2', undefined, 2);

                html += "</ul>";
                html += "</li>";

                html += this.getLinkWrapper2('mn5_map3', 'Map Wireframe', 'mapWrapper3', undefined, 1);
                
                html += "<ul>";
                html += this.getRadio('mn5_mapwireframe', 'mn5_mapwireframeYes', 'Yes', true, undefined, 2);
                html += this.getRadio('mn5_mapwireframe', 'mn5_mapwireframeNo', 'No', undefined, undefined, 2);
                html += "</ul>";
                html += "</li>";

                if(me.cfg.mmtfid === undefined) {
                    html += this.getLinkWrapper('mn5_emmap', 'EM Density Map', 'emmapWrapper1', undefined, 1);
                    html += this.getLinkWrapper('mn5_emmapNo', 'Remove EM Map', 'emmapWrapper2', undefined, 1);

                    html += this.getLinkWrapper2('mn5_emmap3', 'EM Map Wireframe', 'emmapWrapper3', undefined, 1);
                    html += "<ul>";
                    html += this.getRadio('mn5_emmapwireframe', 'mn5_emmapwireframeYes', 'Yes', true, undefined, 2);
                    html += this.getRadio('mn5_emmapwireframe', 'mn5_emmapwireframeNo', 'No', undefined, undefined, 2);
                    html += "</ul>";
                    html += "</li>";
                }
            }

            html += this.getMenuSep();

            html += this.getMenuText('mn6_bkgdwrap', 'Background', undefined, 1, 1);
            html += "<ul>";
            html += this.getRadio('mn6_bkgd', 'mn6_bkgdTransparent', 'Transparent', undefined, 1, 2);
            html += this.getRadio('mn6_bkgd', 'mn6_bkgdBlack', 'Black', true, 1, 2);
            html += this.getRadio('mn6_bkgd', 'mn6_bkgdGrey', 'Gray', undefined, 1, 2);
            html += this.getRadio('mn6_bkgd', 'mn6_bkgdWhite', 'White', undefined, 1, 2);
            html += "</ul>";
            html += "</li>";

            html += this.getMenuText('mn6_themewrap', 'Dialog Color', undefined, undefined, 1);
            html += "<ul>";
            html += this.getRadio('mn6_theme', 'mn6_themeBlue', 'Blue', true, undefined, 2);
            html += this.getRadio('mn6_theme', 'mn6_themeOrange', 'Orange', undefined, undefined, 2);
            html += this.getRadio('mn6_theme', 'mn6_themeBlack', 'Black', undefined, undefined, 2);
            html += "</ul>";
            html += "</li>";

            html += "<li><br/></li>";

            html += "</ul>";

            return html;
        }

        //Set the menu "Color" at the top of the viewer.
        setMenu4() { let me = this.icn3dui;
            if(me.bNode) return '';

            let html = "";

            html += "<div class='icn3d-menu'>";
            html += "<accordion id='" + me.pre + "accordion4' class='icn3d-accordion'>";
            html += "<h3 id='" + me.pre + "color'>Color</h3>";
            html += "<div>";

            html += this.setMenu4_base();

            html += "</div>";
            html += "</accordion>";
            html += "</div>";

            return html;
        }

        setMenu4_base() { let me = this.icn3dui;
            if(me.bNode) return '';

            let html = "";

            html += "<ul class='icn3d-mn-item'>";

            html += this.getMenuText('mn4_clrwrap', 'Unicolor', 'icn3d-menupd', 1, 1);
            html += "<ul>";

            html += this.getMenuText('uniclrRedwrap', 'Red', undefined, 1, 2);
            html += "<ul>";
            html += this.getRadClr('mn4_clr', 'uniclrRed1', 'Red', 'F00', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrRed2', 'Indian Red', 'CD5C5C', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrRed3', 'Light Coral', 'F08080', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrRed4', 'Salmon', 'FA8072', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrRed5', 'Dark Salmon', 'E9967A', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrRed6', 'Light Salmon', 'FFA07A', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrRed7', 'Crimson', 'DC143C', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrRed8', 'Fire Brick', 'B22222', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrRed9', 'Dark Red', '8B0000', undefined, 1, 3);
            html += "</ul>";

            html += this.getMenuText('uniclrPinkwrap', 'Pink', undefined, 1, 2);
            html += "<ul>";
            html += this.getRadClr('mn4_clr', 'uniclrPink1', 'Pink', 'FFC0CB', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrPink2', 'Light Pink', 'FFB6C1', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrPink3', 'Hot Pink', 'FF69B4', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrPink4', 'Deep Pink', 'FF1493', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrPink5', 'Medium Violet Red', 'C71585', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrPink6', 'Pale Violet Red', 'DB7093', undefined, 1, 3);
            html += "</ul>";

            html += this.getMenuText('uniclrOrangewrap', 'Orange', undefined, 1, 2);
            html += "<ul>";
            html += this.getRadClr('mn4_clr', 'uniclrOran1', 'Orange', 'FFA500', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrOran2', 'Dark Orange', 'FF8C00', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrOran3', 'Orange Red', 'FF4500', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrOran4', 'Tomato', 'FF6347', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrOran5', 'Coral', 'FF7F50', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrOran6', 'Light Salmon', 'FFA07A', undefined, 1, 3);
            html += "</ul>";

            html += this.getMenuText('uniclrYellowwrap', 'Yellow', undefined, 1, 2);
            html += "<ul>";
            html += this.getRadClr('mn4_clr', 'uniclrYllw1', 'Yellow', 'FF0', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrYllw2', 'Gold', 'FFD700', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrYllw3', 'Light Yellow', 'FFFFE0', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrYllw4', 'Lemon Chiffon', 'FFFACD', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrYllw5', 'Light Golden Rod', 'FAFAD2', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrYllw6', 'Papaya Whip', 'FFEFD5', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrYllw7', 'Moccasin', 'FFE4B5', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrYllw8', 'Peach Puff', 'FFDAB9', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrYllw9', 'Pale Golden Rod', 'EEE8AA', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrYllw10', 'Khaki', 'F0E68C', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrYllw11', 'Dark Khaki', 'BDB76B', undefined, 1, 3);
            html += "</ul>";

            html += this.getMenuText('uniclrMagentawrap', 'Magenta', undefined, 1, 2);
            html += "<ul>";
            html += this.getRadClr('mn4_clr', 'uniclrMgnt1', 'Magenta', 'F0F', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrMgnt2', 'Orchid', 'DA70D6', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrMgnt3', 'Violet', 'EE82EE', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrMgnt4', 'Plum', 'DDA0DD', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrMgnt5', 'Thistle', 'D8BFD8', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrMgnt6', 'Lavender', 'E6E6FA', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrMgnt7', 'Medium Orchid', 'BA55D3', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrMgnt8', 'Medium Purple', '9370DB', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrMgnt9', 'Rebecca Purple', '663399', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrMgnt10', 'Blue Violet', '8A2BE2', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrMgnt11', 'Dark Violet', '9400D3', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrMgnt12', 'Dark Orchid', '9932CC', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrMgnt13', 'Dark Magenta', '8B008B', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrMgnt14', 'Purple', '800080', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrMgnt15', 'Indigo', '4B0082', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrMgnt16', 'Slat Blue', '6A5ACD', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrMgnt17', 'Dark Slate Blue', '483D8B', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrMgnt18', 'Medium Slat Blue', '6A5ACD', undefined, 1, 3);
            html += "</ul>";

            html += this.getMenuText('uniclrGreenwrap', 'Green', undefined, 1, 2);
            html += "<ul>";
            html += this.getRadClr('mn4_clr', 'uniclrGrn1', 'Green', '0F0', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGrn2', 'Dark Green', '006400', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGrn3', 'Yellow Green', '9ACD32', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGrn4', 'Olive Drab', '6B8E23', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGrn5', 'Olive', '808000', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGrn6', 'Dark Olive Green', '556B2F', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGrn7', 'Medium Aquamarine', '66CDAA', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGrn8', 'Dark Sea Green', '8FBC8B', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGrn9', 'Lignt Sea Green', '20B2AA', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGrn10', 'Dark Cyan', '008B8B', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGrn11', 'Teal', '008080', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGrn12', 'Forest Green', '228B22', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGrn13', 'Sea Green', '2E8B57', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGrn14', 'Medium Sea Green', '3CB371', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGrn15', 'Spring Green', '00FF7F', undefined, 1, 3);
            //html += this.getRadClr('mn4_clr', 'uniclrGrn16', 'Medium Spring Green', '00FA9A', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGrn16', 'Medium Spring', '00FA9A', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGrn17', 'Light Green', '90EE90', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGrn18', 'Pale Green', '98FB98', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGrn19', 'Lime Green', '32CD32', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGrn20', 'Lawn Green', '7CFC00', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGrn21', 'Chartreuse', '7FFF00', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGrn22', 'Green Yellow', 'ADFF2F', undefined, 1, 3);
            html += "</ul>";

            html += this.getMenuText('uniclrCyanwrap', 'Cyan', undefined, 1, 2);
            html += "<ul>";
            html += this.getRadClr('mn4_clr', 'uniclrCyan1', 'Cyan', '0FF', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrCyan2', 'Light Cyan', 'E0FFFF', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrCyan3', 'Pale Turquoise', 'AFEEEE', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrCyan4', 'Aquamarine', '7FFFD4', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrCyan5', 'Turquoise', '40E0D0', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrCyan6', 'Medium Turquoise', '48D1CC', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrCyan7', 'Dark Turquoise', '00CED1', undefined, 1, 3);
            html += "</ul>";

            html += this.getMenuText('uniclrBluewrap', 'Blue', undefined, 1, 2);
            html += "<ul>";
            html += this.getRadClr('mn4_clr', 'uniclrBlue1', 'Blue', '00F', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBlue2', 'Medium Blue', '0000CD', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBlue3', 'Dark Blue', '00008B', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBlue4', 'Navy', '000080', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBlue5', 'Midnight Blue', '191970', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBlue6', 'Royal Blue', '4169E1', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBlue7', 'Medium Slate Blue', '7B68EE', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBlue8', 'Corn Flower Blue', '6495ED', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBlue9', 'Dodger Blue', '1E90FF', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBlue10', 'Deep Sky Blue', '00BFFF', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBlue11', 'Light Sky Blue', '87CEFA', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBlue12', 'Sky Blue', '87CEEB', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBlue13', 'Light Blue', 'ADD8E6', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBlue14', 'Powder Blue', 'B0E0E6', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBlue15', 'Light Steel Blue', 'B0C4DE', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBlue16', 'Steel Blue', '4682B4', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBlue17', 'Cadet Blue', '5F9EA0', undefined, 1, 3);
            html += "</ul>";

            html += this.getMenuText('uniclrBrownwrap', 'Brown', undefined, 1, 2);
            html += "<ul>";
            html += this.getRadClr('mn4_clr', 'uniclrBrown1', 'Brown', 'A52A2A', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBrown2', 'Maroon', '800000', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBrown3', 'Sienna', 'A0522D', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBrown4', 'Saddle Brown', '8B4513', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBrown5', 'Chocolate', 'D2691E', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBrown6', 'Peru', 'CD853F', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBrown7', 'Dark Golden Rod', 'B8860B', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBrown8', 'Golden Rod', 'DAA520', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBrown9', 'Sandy Brown', 'F4A460', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBrown10', 'Rosy Brown', 'BC8F8F', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBrown11', 'Tan', 'D2B48C', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBrown12', 'Burlywood', 'DEB887', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBrown13', 'Wheat', 'F5DEB3', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBrown14', 'Navajo White', 'FFDEAD', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBrown15', 'Bisque', 'FFE4C4', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBrown16', 'Blanched Almond', 'FFEBCD', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrBrown17', 'Corn Silk', 'FFF8DC', undefined, 1, 3);
            html += "</ul>";

            //html += "<li><span>White</span>";
            html += this.getMenuText('uniclrWhitewrap', 'White', undefined, 1, 2);
            html += "<ul>";
            html += this.getRadClr('mn4_clr', 'uniclrWhite1', 'White', 'FFF', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrWhite2', 'Snow', 'FFFAFA', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrWhite3', 'Honey Dew', 'F0FFF0', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrWhite4', 'Mint Cream', 'F5FFFA', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrWhite5', 'Azure', 'F0FFFF', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrWhite6', 'Alice Blue', 'F0F8FF', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrWhite7', 'Ghost White', 'F8F8FF', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrWhite8', 'White Smoke', 'F5F5F5', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrWhite9', 'Sea Shell', 'FFF5EE', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrWhite10', 'Beige', 'F5F5DC', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrWhite11', 'Old Lace', 'FDF5E6', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrWhite12', 'Floral White', 'FFFAF0', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrWhite13', 'Ivory', 'FFFFF0', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrWhite14', 'Antique White', 'FAEBD7', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrWhite15', 'Linen', 'FAF0E6', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrWhite16', 'Lavenderblush', 'FFF0F5', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrWhite17', 'Misty Rose', 'FFE4E1', undefined, 1, 3);
            html += "</ul>";

            html += this.getMenuText('uniclrGraywrap', 'Gray', undefined, 1, 2);
            html += "<ul>";
            html += this.getRadClr('mn4_clr', 'uniclrGray1', 'Gray', '808080', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGray2', 'Dim Gray', '696969', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGray3', 'Light Slate Gray', '778899', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGray4', 'Slate Gray', '708090', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGray5', 'Dark Slate Gray', '2F4F4F', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGray6', 'Black', '000000', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGray7', 'Dark Gray', 'A9A9A9', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGray8', 'Silver', 'C0C0C0', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGray9', 'Light Gray', 'D3D3D3', undefined, 1, 3);
            html += this.getRadClr('mn4_clr', 'uniclrGray10', 'Gainsboro', 'DCDCDC', undefined, 1, 3);
            html += "</ul>";

            html += "</ul>";

            html += this.getRadio('mn4_clr', 'mn4_clrCustom', 'Color Picker', undefined, 1, 1);
            html += this.getMenuSep();

            if(me.cfg.cid === undefined) {
                html += this.getMenuText('mn4_clrRainbowwrap', 'Rainbow (R-V)', 'icn3d-menupd', 1, 1);
                html += "<ul>";
                html += this.getRadio('mn4_clr', 'mn4_clrRainbow', 'for Selection', undefined, 1, 2);
                html += this.getRadio('mn4_clr', 'mn4_clrRainbowChain', 'for Chains', undefined, 1, 2);
                html += this.getRadio('mn4_clr', 'mn4_clrRainbowSets', 'for Sets', undefined, undefined, 2);
                html += this.getRadio('mn4_clr', 'mn4_clrRainbowAcrossSets', 'across Sets', undefined, undefined, 2);
                html += "</ul>";

                html += this.getMenuText('mn4_clrSpectrumwrap', 'Spectrum (V-R)', 'icn3d-menupd', 1, 1);
                html += "<ul>";
                html += this.getRadio('mn4_clr', 'mn4_clrSpectrum', 'for Selection', undefined, 1, 2);
                html += this.getRadio('mn4_clr', 'mn4_clrSpectrumChain', 'for Chains', undefined, 1, 2);
                html += this.getRadio('mn4_clr', 'mn4_clrSpectrumSets', 'for Sets', undefined, undefined, 2);
                html += this.getRadio('mn4_clr', 'mn4_clrSpectrumAcrossSets', 'across Sets', undefined, undefined, 2);
                html += "</ul>";

                html += this.getMenuText('mn4_clrSSwrap', 'Secondary', 'icn3d-menupd', 1, 1);
                html += "<ul>";
                html += this.getRadio('mn4_clr', 'mn4_clrSSGreen', 'Sheet in Green', undefined, 1, 2);
                html += this.getRadio('mn4_clr', 'mn4_clrSSYellow', 'Sheet in Yellow', undefined, 1, 2);
                html += this.getRadio('mn4_clr', 'mn4_clrSSSpectrum', 'Spectrum', undefined, undefined, 2);
                html += "</ul>";

                html += this.getRadio('mn4_clr', 'mn4_clrCharge', 'Charge', undefined, 1, 1);

                html += this.getMenuText('mn4_hydrophobicwrap', 'Hydrophobicity', 'icn3d-menupd', 1, 1);
                html += "<ul>";
                html += this.getRadio('mn4_clr', 'mn4_clrNormalizedHP', 'Normalized', undefined, 1, 2);
                html += this.getRadio('mn4_clr', 'mn4_clrHydrophobic', 'Wimley-White', undefined, undefined, 2);
                html += "</ul>";

                html += this.getMenuText('mn4_clrBfactorwrap', 'B-factor', 'icn3d-menupd', 1, 1);
                html += "<ul>";
                html += this.getRadio('mn4_clr', 'mn4_clrBfactor', 'Original', undefined, 1, 2);
                html += this.getRadio('mn4_clr', 'mn4_clrBfactorNorm', 'Percentile', undefined, 1, 2);
                html += "</ul>";

                html += this.getRadio('mn4_clr', 'mn4_clrArea', 'Solvent<br><span style="padding-left:1.5em;">Accessibility</span>', undefined, 1, 1);

                html += this.getRadio('mn4_clr', 'mn4_clrStructure', 'Structure', undefined, 1, 1);

                if(me.cfg.align !== undefined || me.cfg.chainalign !== undefined || me.cfg.blast_rep_id !== undefined) {
                    html += this.getRadio('mn4_clr', 'mn4_clrChain', 'Chain', undefined, 1, 1);
                }
                else {
                    html += this.getRadio('mn4_clr', 'mn4_clrChain', 'Chain', true, 1, 1);
                }

                //if(me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined) {
                  html += this.getRadio('mn4_clr', 'mn4_clrdomain', '3D Domain', undefined, 1, 1);
                //}

                if(me.cfg.cid === undefined) {
                    html += this.getMenuText('mn4_clrsetswrap', 'Defined Sets', 'icn3d-menupd', undefined, 1);
                    html += "<ul>";
                    html += this.getRadio('mn4_clr', 'mn4_clrsets', 'Rainbow for Selected Sets<br><span style="padding-left:1.5em;">in "Analysis > Defined Sets"</span>', undefined, undefined, 2);
                    html += "</ul>";
                    html += "</li>";
                }

                html += this.getMenuText('mn4_clrResiduewrap', 'Residue', 'icn3d-menupd', 1, 1);
                html += "<ul>";
                html += this.getRadio('mn4_clr', 'mn4_clrResidue', 'Default', undefined, 1, 2);
                html += this.getRadio('mn4_clr', 'mn4_clrResidueCustom', 'Custom', undefined, undefined, 2);
                html += "</ul>";

                html += this.getRadio('mn4_clr', 'mn4_clrAtom', 'Atom', undefined, 1, 1);

                if(me.cfg.align !== undefined || me.cfg.chainalign !== undefined) {
                  html += this.getRadio('mn4_clr', 'mn4_clrIdentity', 'Identity', true, undefined, 1);
                  html += this.getRadio('mn4_clr', 'mn4_clrConserved', 'Conservation', undefined, undefined, 1);
                }
                else if(me.cfg.blast_rep_id !== undefined) {
                  html += this.getRadio('mn4_clr', 'mn4_clrIdentity', 'Identity', undefined, undefined, 1);
                  html += this.getRadio('mn4_clr', 'mn4_clrConserved', 'Conservation', true, undefined, 1);
                }
                else {
                  html += this.getRadio('mn4_clr', 'mn4_clrIdentity', 'Identity', undefined, undefined, 1);
                  html += this.getRadio('mn4_clr', 'mn4_clrConserved', 'Conservation', undefined, undefined, 1);
                }

                //if(me.cfg.afid) html += this.getRadio('mn4_clr', 'mn4_clrConfidence', 'AF Confidence');
                //if(!me.cfg.mmtfid && !me.cfg.pdbid && !me.cfg.opmid && !me.cfg.mmdbid && !me.cfg.gi && !me.cfg.uniprotid && !me.cfg.blast_rep_id && !me.cfg.cid && !me.cfg.mmcifid && !me.cfg.align && !me.cfg.chainalign) {
                    html += this.getRadio('mn4_clr', 'mn4_clrConfidence', 'pLDDT', undefined, 1, 1);
                //}

                html += this.getRadio('mn4_clr', 'mn4_clrIgstrand', 'Ig Strand', undefined, undefined, 1);
                html += this.getRadio('mn4_clr', 'mn4_clrIgproto', 'Ig Protodomain', undefined, undefined, 1);
            }
            else {
                //if(!me.cfg.hidelicense) html += this.getRadio('mn4_clr', 'mn1_delphi2', 'DelPhi<br><span style="padding-left:1.5em;">Potential ' + me.htmlCls.licenseStr + '</span>');
                html += this.getRadio('mn4_clr', 'mn4_clrAtom', 'Atom', true, 1, 1);
            }

            html += this.getMenuSep();

            html += this.getLink('mn4_clrSave', 'Save Color', undefined, 1);
            html += this.getLink('mn4_clrApplySave', 'Apply Saved Color', undefined, 1);

            html += "<li><br/></li>";
            html += "</ul>";

            return html;
        }

        //Set the menu "Surface" at the top of the viewer.
        setMenu5() { let me = this.icn3dui;
            if(me.bNode) return '';

            let html = "";

            html += "<div class='icn3d-menu'>";
            html += "<accordion id='" + me.pre + "accordion5' class='icn3d-accordion'>";
            html += "<h3 id='" + me.pre + "analysis' style='font-size:1.2em'>&nbsp;Analysis</h3>";
            html += "<div>";

            html += this.setMenu5_base();

            html += "</div>";
            html += "</accordion>";
            html += "</div>";

            return html;
        }

        setMenu5_base() { let me = this.icn3dui;
            if(me.bNode) return '';

            let html = "";

            html += "<ul class='icn3d-mn-item'>";

            if(me.cfg.cid !== undefined || me.cfg.smiles !== undefined) {
                html += this.getLink('mn2_2ddepiction', '2D Depiction ' + me.htmlCls.wifiStr, 1, 1);
            }

            if(me.cfg.cid === undefined) {
                html += this.getLink('mn6_selectannotations', 'Seq. & Annotations ' + me.htmlCls.wifiStr, 1, 1);

                //if(me.cfg.align !== undefined || me.cfg.chainalign !== undefined) { // || ic.bRealign || ic.bSymd || ic.bInputfile) {
                    html += this.getLink('mn2_alignment', 'Aligned Seq. ' + me.htmlCls.wifiStr, 1, 1);
                //}

                if(me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined || me.cfg.blast_rep_id !== undefined || me.cfg.align !== undefined || me.cfg.chainalign !== undefined) {
                  html += this.getLink('mn2_2ddgm', '2D Diagram ' + me.htmlCls.wifiStr, 1, 1);
                }

                html += this.getMenuText('2dctnwrap', '2D Cartoon', undefined, undefined, 1);
                html += "<ul>";
                html += this.getLink('2dctn_chain', 'Chain Level', undefined, 2);
                html += this.getLink('2dctn_domain', 'Domain Level', undefined, 2);
                html += this.getLink('2dctn_secondary', 'Helix/Sheet Level', undefined, 2);
                html += "</ul>";
                html += "</li>";

                html += this.getLink('definedsets2', 'Defined Sets', 1, 1);

                html += this.getMenuSep();

                html += this.getLink('mn6_hbondsYes', 'Interactions', 1, 1);

                html += this.getMenuText('mn1_window', 'Bring to Front', undefined, undefined, 1);
                html += "<ul>";
                html += this.getLink('mn1_window_table', 'Interaction Table', undefined, 2);
                html += this.getLink('mn1_window_linegraph', '2D Interaction Network', undefined, 2);
                html += this.getLink('mn1_window_scatterplot', '2D Interaction Map', undefined, 2);
                html += this.getLink('mn1_window_graph', '2D Graph(Force-Directed)', undefined, 2);
                html += "</ul>";
                html += "</li>";

                html += this.getLink('mn6_contactmap', 'Contact Map', undefined, 1);

                //if(!me.cfg.notebook) {
                    html += this.getLink('mn1_mutation', 'Mutation ' + me.htmlCls.wifiStr, 1, 1);
                //}

                //html += this.getMenuSep();
            }

            //if(!me.cfg.notebook && !me.cfg.hidelicense) {
            if(!me.cfg.hidelicense) {
                html += this.getMenuText('mn1_delphiwrap', 'DelPhi Potential', undefined, 1, 1);

                html += "<ul>";       
                    html += this.getLink('mn1_delphi', 'DelPhi Potential ' + me.htmlCls.licenseStr, 1, 2);    

                    html += this.getMenuText('mn1_phiwrap', 'Load PQR/Phi', undefined, undefined, 2);
                    html += "<ul>";
                    html += this.getLink('mn1_phi', 'Local PQR/Phi/Cube File', undefined, 3);
                    html += this.getLink('mn1_phiurl', 'URL PQR/Phi/Cube File', undefined, 3);
                    html += "</ul>";
                    html += "</li>";
                    html += this.getLink('delphipqr', 'Download PQR', undefined, 2);
                html += "</ul>";
                html += "</li>";

                //html += this.getMenuSep();
            }

            html += this.getMenuSep();

            html += this.getMenuText('mn6_distancewrap', 'Distance', undefined, 1, 1);
            html += "<ul>";
            html += this.getRadio('mn6_distance', 'mn6_distanceYes', 'between Two Atoms', undefined, 1, 2);
            html += this.getRadio('mn6_distance', 'mn6_distTwoSets', 'between Two Sets', undefined, undefined, 2);
            html += this.getRadio('mn6_distance', 'mn6_distManySets', 'among Many Sets', undefined, undefined, 2);
            html += this.getRadio('mn6_distance', 'mn6_distanceNo', 'Hide', true, 1, 2);
            html += "</ul>";
            html += "</li>";

            html += this.getMenuText('mn6_anglewrap', 'Angle', undefined, undefined, 1);
            html += "<ul>";
            html += this.getRadio('mn6_angle', 'mn6_angleManySets', 'among Many Sets', undefined, undefined, 2);
            html += this.getRadio('mn6_angle', 'mn6_angleTwoSets', 'b/w Two Vectors', undefined, undefined, 2);
            html += "</ul>";
            html += "</li>";

            html += this.getLink('mn6_area', 'Surface Area', undefined, 1);

            html += this.getMenuText('mn6_addlabelwrap', 'Label', undefined, 1, 1);
            html += "<ul>";
            html += this.getRadio('mn6_addlabel', 'mn6_addlabelYes', 'by Picking Atoms', undefined, undefined, 2);
            html += this.getRadio('mn6_addlabel', 'mn6_addlabelSelection', 'per Selection', undefined, undefined, 2);
            html += this.getRadio('mn6_addlabel', 'mn6_addlabelAtoms', 'per Atom', undefined, undefined, 2);
            html += this.getRadio('mn6_addlabel', 'mn6_addlabelElements', 'per Atom Element', undefined, undefined, 2);
            if(me.cfg.cid === undefined) {
                html += this.getRadio('mn6_addlabel', 'mn6_addlabelResidues', 'per Residue', undefined, 1, 2);
                html += this.getRadio('mn6_addlabel', 'mn6_addlabelResnum', 'per Residue & Number', undefined, 1, 2);

                html += this.getRadio('mn6_addlabel', 'mn6_addlabelRefnum', 'per Reference Number', undefined, undefined, 2);
                html += this.getRadio('mn6_addlabel', 'mn6_addlabelIg', 'per Ig Domain', undefined, undefined, 2);

                html += this.getRadio('mn6_addlabel', 'mn6_addlabelChains', 'per Chain', undefined, undefined, 2);
                html += this.getRadio('mn6_addlabel', 'mn6_addlabelTermini', 'N- & C-Termini', undefined, 1, 2);
            }

            html += this.getMenuSep();
            html += this.getRadio('mn6_addlabel', 'mn6_labelColor', 'Change Label Color', undefined, 1, 2);
            html += this.getRadio('mn6_addlabel', 'mn6_addlabelNo', 'Remove', true, 1, 2);
            html += "</ul>";
            html += "</li>";

            html += this.getMenuText('labelscalewrap', 'Label Scale', undefined, 1, 1);
            html += "<ul>";

            for(let i = 1; i <= 4; ++i) {
                let twoi = 2 * i;
                html += this.getRadio('mn6_labelscale', 'mn6_labelscale0' + twoi, '0.' + twoi, undefined, 1, 2);
            }

            for(let i = 2; i <= 10; ++i) {
                let value = (i / 2.0).toFixed(1);

                if(i == 2) {
                    html += this.getRadio('mn6_labelscale', 'mn6_labelscale' + i + '0', value, true, 1, 2);
                }
                else {
                    html += this.getRadio('mn6_labelscale', 'mn6_labelscale' + i + '0', value, undefined, 1, 2);
                }
            }

            html += "</ul>";
            html += "</li>";

            html += this.getMenuSep();

            if(me.cfg.cid === undefined) {
                html += this.getMenuText('mn6_chemicalbindingwrap', 'Chem. Binding', undefined, 1, 1);
                html += "<ul>";
                html += this.getRadio('mn6_chemicalbinding', 'mn6_chemicalbindingshow', 'Show', undefined, 1, 2);
                html += this.getRadio('mn6_chemicalbinding', 'mn6_chemicalbindinghide', 'Hide', true, 1, 2);
                html += "</ul>";
                html += "</li>";

                html += this.getMenuText('mn6_ssbondswrap', 'Disulfide Bonds', undefined, 1, 1);
                html += "<ul>";
                html += this.getRadio('mn6_ssbonds', 'mn6_ssbondsYes', 'Show', true, 1, 2);
                html += this.getRadio('mn6_ssbonds', 'mn6_ssbondsExport', 'Export Pairs', undefined, undefined, 2);
                html += this.getRadio('mn6_ssbonds', 'mn6_ssbondsNo', 'Hide', undefined, 1, 2);
                html += "</ul>";
                html += "</li>";

                html += this.getMenuText('mn6_clbondswrap', 'Cross-Linkages', undefined, undefined, 1);
                html += "<ul>";
                html += this.getRadio('mn6_clbonds', 'mn6_clbondsYes', 'Show', true, undefined, 2);
                html += this.getRadio('mn6_clbonds', 'mn6_clbondsExport', 'Export Pairs', undefined, undefined, 2);
                html += this.getRadio('mn6_clbonds', 'mn6_clbondsNo', 'Hide', undefined, undefined, 2);
                html += "</ul>";
                html += "</li>";

                html += this.getLink('mn6_DSSP', 'DSSP Secondary', undefined, 1);

                let bOnePdb = me.cfg.mmtfid !== undefined || me.cfg.pdbid !== undefined || me.cfg.opmid !== undefined || me.cfg.mmcifid !== undefined || me.cfg.mmdbid !== undefined || me.cfg.mmdbafid !== undefined || me.cfg.gi !== undefined || me.cfg.blast_rep_id !== undefined;

                if(bOnePdb) {
                  html += this.getMenuText('assemblyWrapper', 'Assembly', undefined, 1, 1);
                  html += "<ul>";

                  if(!me.cfg.bu) {
                    html += this.getRadio('mn6_assembly', 'mn6_assemblyYes', 'Biological Assembly', undefined, 1, 2);
                    html += this.getRadio('mn6_assembly', 'mn6_assemblyNo', 'Asymmetric Unit', true, 1, 2);
                  }
                  else {
                    html += this.getRadio('mn6_assembly', 'mn6_assemblyYes', 'Biological Assembly', true, 1, 2);
                    html += this.getRadio('mn6_assembly', 'mn6_assemblyNo', 'Asymmetric Unit', undefined, 1, 2);
                  }

                  html += "</ul>";
                  html += "</li>";
                }

                html += this.getMenuText('mn6_symmetrywrap', 'Symmetry', undefined, undefined, 1);

                html += "<ul>";
                if(bOnePdb) html += this.getLink('mn6_symmetry', 'from PDB(precalculated) ' + me.htmlCls.wifiStr, undefined, 2);

                html += this.getLink('mn6_symd', 'from SymD(Dynamic) ' + me.htmlCls.wifiStr, undefined, 2);
                html += this.getLink('mn6_clear_sym', 'Clear SymD Symmetry', undefined, 2);
                html += this.getLink('mn6_axes_only', 'Show Axes Only', undefined, 2);

                html += "</ul>";
                html += "</li>";

                html += this.getMenuText('mn6_igrefwrap', 'Ref. Number', undefined, undefined, 1);

                html += "<ul>";

                html += this.getLink('mn6_igrefYes', 'Show Ig for Selection', undefined, 2);
                html += this.getLink('mn6_igrefTpl', 'Ig w/ Specified Template', undefined, 2);
                html += this.getLink('mn6_alignrefTpl', 'Align w/ Specified Template', undefined, 2);
                html += this.getLink('mn6_igrefNo', 'Reset Ig Ref. Number', undefined, 2);

                html += this.getMenuSep();

                html += this.getLink('mn6_customref', 'Custom Ref. Number', undefined, 2);
                html += "</ul>";
                html += "</li>";

                html += this.getMenuSep();
            }

            html += this.getLink('mn6_yournote', 'Window Title', undefined, 1);

            if(me.cfg.cid !== undefined) {
                html += this.getMenuText('mn1_linkwrap', 'Links', undefined, undefined, 1);
                
                html += "<ul>";
                html += this.getLink('mn1_link_structure', 'Compound Summary ' + me.htmlCls.wifiStr, undefined, 2);
                html += this.getLink('mn1_link_vast', 'Similar Compounds ' + me.htmlCls.wifiStr, undefined, 2);
                html += this.getLink('mn1_link_bind', 'Structures Bound ' + me.htmlCls.wifiStr, undefined, 2);
                html += "</ul>";
                html += "</li>";
            }
            else {
                html += this.getMenuText('mn1_linkwrap', 'Links', undefined, undefined, 1);
                html += "<ul>";
                html += this.getLink('mn1_link_structure', 'Structure Summary ' + me.htmlCls.wifiStr, undefined, 2);
                html += this.getLink('mn1_link_vast', 'Similar Structures ' + me.htmlCls.wifiStr, undefined, 2);
                html += this.getLink('mn1_link_pubmed', 'Literature ' + me.htmlCls.wifiStr, undefined, 2);
                html += this.getLink('mn1_link_protein', 'Protein ' + me.htmlCls.wifiStr, undefined, 2);
                //html += this.getLink('mn1_link_gene', 'Gene');
                //html += this.getLink('mn1_link_chemicals', 'Chemicals');
                html += "</ul>";
                html += "</li>";
            }

            html += "<li><br/></li>";

            html += "</ul>";

            return html;
        }

        //Set the menu "Other" at the top of the viewer.
        setMenu6() { let me = this.icn3dui;
            if(me.bNode) return '';

            let html = "";

            html += "<div class='icn3d-menu'>";
            html += "<accordion id='" + me.pre + "accordion6' class='icn3d-accordion'>";
            html += "<h3>Help</h3>";
            html += "<div>";

            html += this.setMenu6_base();

            html += "</div>";
            html += "</accordion>";
            html += "</div>";

            return html;
        }

        setMenu6_base() { let me = this.icn3dui;
            if(me.bNode) return '';

            let html = "";

            html += "<ul class='icn3d-mn-item'>";

            html += this.getMenuUrl('abouticn3d', me.htmlCls.baseUrl + "icn3d/icn3d.html#about", "About iCn3D<span style='font-size:0.9em'> " + me.REVISION + "</span>", 1, 1);

            html += this.getMenuUrl('gallery', me.htmlCls.baseUrl + "icn3d/icn3d.html#gallery", "Live Gallery " + me.htmlCls.wifiStr, 1, 1);
            html += this.getMenuUrl('video', me.htmlCls.baseUrl + "icn3d/icn3d.html#videos", "Videos & Tutorials", 1, 1);

            html += this.getMenuText('mn6_faq', 'FAQ', undefined, 1, 1);

            html += "<ul>";
            html += this.getMenuUrl('faq_viewstru', me.htmlCls.baseUrl + "icn3d/icn3d.html#viewstru", "View structure", 1, 2);
            html += this.getMenuUrl('faq_tfstru', me.htmlCls.baseUrl + "icn3d/icn3d.html#tfstru", "Transform Structure", 1, 2);
            html += this.getMenuUrl('faq_selsubset', me.htmlCls.baseUrl + "icn3d/icn3d.html#selsubset", "Select Subsets", 1, 2);
            html += this.getMenuUrl('faq_stylecolor', me.htmlCls.baseUrl + "icn3d/icn3d.html#changestylecolor", "Change Style/Color", 1, 2);
            html += this.getMenuUrl('faq_savework', me.htmlCls.baseUrl + "icn3d/icn3d.html#saveview", "Save Work", 1, 2);
            html += this.getMenuUrl('faq_showanno', me.htmlCls.baseUrl + "icn3d/icn3d.html#showanno", "Show Annotations", 1, 2);
            html += this.getMenuUrl('faq_exportanno', me.htmlCls.baseUrl + "icn3d/icn3d.html#exportanno", "Export Annotations", 1, 2);
            html += this.getMenuUrl('faq_interanal', me.htmlCls.baseUrl + "icn3d/icn3d.html#interanalysis", "Interaction Analysis", 1, 2);
            html += this.getMenuUrl('faq_mutanal', me.htmlCls.baseUrl + "icn3d/icn3d.html#mutationanalysis", "Mutation Analysis", 1, 2);
            html += this.getMenuUrl('faq_elecpot', me.htmlCls.baseUrl + "icn3d/icn3d.html#elecpot", "Electrostatic Pot.", 1, 2);
            html += this.getMenuUrl('faq_simipdb', me.htmlCls.baseUrl + "icn3d/icn3d.html#simivast", "Similar PDB", 1, 2);
            html += this.getMenuUrl('faq_simialphapdb', me.htmlCls.baseUrl + "icn3d/icn3d.html#simifoldseek", "Similar AlphaFold/PDB", 1, 2);
            html += this.getMenuUrl('faq_alnstru', me.htmlCls.baseUrl + "icn3d/icn3d.html#alignmul", "Align Multiple Structures", 1, 2);
            html += this.getMenuUrl('faq_batchanal', me.htmlCls.baseUrl + "icn3d/icn3d.html#batchanalysis", "Batch Analysis", 1, 2);
            html += this.getMenuUrl('faq_batchanal', me.htmlCls.baseUrl + "icn3d/icn3d.html#igrefnum", "Assign Ig Ref. Numbers", 1, 2);
            html += this.getMenuUrl('faq_embedicn3d', me.htmlCls.baseUrl + "icn3d/icn3d.html#embedicn3d", "Embed iCn3D", 1, 2);
            html += "</ul>";
            html += "</li>";

            //html += liStr + "https://www.ncbi.nlm.nih.gov/structure' target='_blank'>Search Structure " + me.htmlCls.wifiStr + "</a></li>";
            //html += liStr + me.htmlCls.baseUrl + "icn3d/icn3d.html#citing' target='_blank'>Citing iCn3D</a></li>";
            html += this.getMenuUrl('citing', me.htmlCls.baseUrl + "icn3d/icn3d.html#citing", "Citing iCn3D", 1, 1);

            html += this.getMenuText('mn6_source', 'Source Code', undefined, 1, 1);
            html += "<ul>";
            html += this.getMenuUrl('github', "https://github.com/ncbi/icn3d", "GitHub (browser) " + me.htmlCls.wifiStr, 1, 2);
            html += this.getMenuUrl('npm', "https://www.npmjs.com/package/icn3d", "npm (Node.js) " + me.htmlCls.wifiStr, 1, 2);
            html += this.getMenuUrl('notebook', "https://pypi.org/project/icn3dpy", "Jupyter Notebook " + me.htmlCls.wifiStr, 1, 2);
            html += "</ul>";
            html += "</li>";

            html += this.getMenuText('mn6_develop', 'Develop', undefined, undefined, 1);
            html += "<ul>";
            html += this.getMenuUrl('dev_embedicn3d2', me.htmlCls.baseUrl + "icn3d/icn3d.html#HowToUse", "Embed iCn3D", undefined, 2);
            html += this.getMenuUrl('dev_urlpara', me.htmlCls.baseUrl + "icn3d/icn3d.html#parameters", "URL Parameters", undefined, 2);
            html += this.getMenuUrl('dev_command', me.htmlCls.baseUrl + "icn3d/icn3d.html#commands", "Commands", undefined, 2);

            html += this.getMenuUrl('dev_datastru', me.htmlCls.baseUrl + "icn3d/icn3d.html#datastructure", "Data Structure", undefined, 2);
            html += this.getMenuUrl('dev_classstru', me.htmlCls.baseUrl + "icn3d/icn3d.html#classstructure", "Class Structure", undefined, 2);
            html += this.getMenuUrl('dev_addclass', me.htmlCls.baseUrl + "icn3d/icn3d.html#addclass", "Add New Classes", undefined, 2);
            html += this.getMenuUrl('dev_modfunc', me.htmlCls.baseUrl + "icn3d/icn3d.html#modifyfunction", "Modify Functions", undefined, 2);
            html += this.getMenuUrl('dev_restful', me.htmlCls.baseUrl + "icn3d/icn3d.html#restfulapi", "RESTful APIs", undefined, 2);
            html += this.getMenuUrl('dev_contributor', me.htmlCls.baseUrl + "icn3d/icn3d.html#contributors", "iCn3D Contributors", undefined, 2);
            html += "</ul>";
            html += "</li>";

            html += this.getMenuUrl('helpdoc', me.htmlCls.baseUrl + "icn3d/docs/icn3d_help.html", "Help Doc " + me.htmlCls.wifiStr, 1, 1);

            html += this.getMenuSep();

            html += this.getMenuText('mn6_tfhint', 'Transform Hints', undefined, 1, 1);
            html += "<ul>";
            html += this.getMenuText('mn6_rotate', 'Rotate', undefined, 1, 2);
            html += "<ul>";
            html += "<li>Left Mouse (Click & Drag)</li>";
            html += "<li>Key l: Left</li>";
            html += "<li>Key j: Right</li>";
            html += "<li>Key i: Up</li>";
            html += "<li>Key m: Down</li>";
            html += "<li>Shift + Key l: Left 90&deg;</li>";
            html += "<li>Shift + Key j: Right 90&deg;</li>";
            html += "<li>Shift + Key i: Up 90&deg;</li>";
            html += "<li>Shift + Key m: Down 90&deg;</li>";
            html += "</ul>";
            html += "</li>";
            html += this.getMenuText('mn6_zoom', 'Zoom', undefined, 1, 2);
            html += "<ul>";
            html += "<li>Middle Mouse <br>(Pinch & Spread)</li>";
            html += "<li>Key z: Zoom in</li>";
            html += "<li>Key x: Zoom out</li>";
            html += "</ul>";
            html += "</li>";
            html += this.getMenuText('mn6_translate', 'Translate', undefined, 1, 2);
            html += "<ul>";
            html += "<li>Right Mouse <br>(Two Finger Click & Drag)</li>";
            html += "</ul>";
            html += "</li>";
            html += "</ul>";
            html += "</li>";

            html += this.getMenuUrl('selhints', me.htmlCls.baseUrl + "icn3d/icn3d.html#selsubset", "Selection Hints", undefined, 1);
            html += this.getMenuUrl('helpdesk', "https://support.nlm.nih.gov/support/create-case/", "Write to Help Desk", 1, 1);

            html += "<li><br/></li>";
            html += "</ul>";

            return html;
        }

        //Hide the menu at the top and just show the canvas. "width" and "height" are the width and height of the canvas.
        hideMenu() { let me = this.icn3dui;
          if(me.bNode) return;

          if($("#" + me.pre + "mnlist")[0] !== undefined) $("#" + me.pre + "mnlist")[0].style.display = "none";
          if($("#" + me.pre + "mnLogSection")[0] !== undefined) $("#" + me.pre + "mnLogSection")[0].style.display = "none";
          if($("#" + me.pre + "cmdlog")[0] !== undefined) $("#" + me.pre + "cmdlog")[0].style.display = "none";
          $("#" + me.pre + "title")[0].style.margin = "10px 0 0 10px";
        }

        //Show the menu at the top and the canvas. "width" and "height" are the width and height of the canvas.
        showMenu() { let me = this.icn3dui;
          if(me.bNode) return;

          if($("#" + me.pre + "mnlist")[0] !== undefined) $("#" + me.pre + "mnlist")[0].style.display = "block";
          if($("#" + me.pre + "mnLogSection")[0] !== undefined) $("#" + me.pre + "mnLogSection")[0].style.display = "block";
          if($("#" + me.pre + "cmdlog")[0] !== undefined) $("#" + me.pre + "cmdlog")[0].style.display = "block";
          //if($("#" + me.pre + "title")[0] !== undefined) $("#" + me.pre + "title")[0].style.display = "block";
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Dialog {
        constructor(icn3dui) {
            this.icn3dui = icn3dui;
        }

        //Open a dialog to input parameters. "id" is the id of the div section holding the html content.
        //"title" is the title of the dialog. The dialog can be out of the viewing area.
        openDlg(id, title) {  let me = this.icn3dui; me.icn3d;
            if(me.bNode) return;

            id = me.pre + id;

            if(!me.cfg.notebook) {
                this.openDlgRegular(id, title);
            }
            else {
                this.openDlgNotebook(id, title);
            }

            if(!me.htmlCls.themecolor) me.htmlCls.themecolor = 'blue';

            me.htmlCls.setMenuCls.setTheme(me.htmlCls.themecolor);
        }

        addSaveButton(id) {  let me = this.icn3dui; me.icn3d;
            if(me.bNode) return;

            // adda save button
            if(this.dialogHashSave === undefined || !this.dialogHashSave.hasOwnProperty(id)) {
                $("#" + id).parent().children('.ui-dialog-titlebar')
                .append("<div pid='" + id + "' class='icn3d-saveicon ui-icon ui-icon-disk' title='Save as an HTML file' style='background-color:white; background-image: url(&quot;https://www.ncbi.nlm.nih.gov/Structure/icn3d/lib/images/ui-icons_228ef1_256x240.png&quot;);'></div>");

                if(this.dialogHashSave === undefined) this.dialogHashSave = {};
                this.dialogHashSave[id] = 1;
            }
        }

        addHideButton(id) {  let me = this.icn3dui; me.icn3d;
            if(me.bNode) return;

            // adda save button
            if(this.dialogHashHide === undefined || !this.dialogHashHide.hasOwnProperty(id)) {
                $("#" + id).parent().children('.ui-dialog-titlebar')
                .append("<div pid='" + id + "' class='icn3d-hideicon ui-icon ui-icon-arrowthick-2-ne-sw' title='Resize the window' style='background-color:white; background-image: url(&quot;https://www.ncbi.nlm.nih.gov/Structure/icn3d/lib/images/ui-icons_228ef1_256x240.png&quot;);'></div>");

                if(this.dialogHashHide === undefined) this.dialogHashHide = {};
                this.dialogHashHide[id] = 1;
            }
        }

        getDialogStatus() {  let me = this.icn3dui; me.icn3d;
            if(me.bNode) return;

            let status = {};
            let id2flag = {};

            // determine whether dialogs initilaized
            let bSelectannotationsInit = $('#' + me.pre + 'dl_selectannotations').hasClass('ui-dialog-content'); // initialized
            let bGraph = $('#' + me.pre + 'dl_graph').hasClass('ui-dialog-content'); // initialized
            let bLineGraph = $('#' + me.pre + 'dl_linegraph').hasClass('ui-dialog-content'); // initialized
            let bScatterplot = $('#' + me.pre + 'dl_scatterplot').hasClass('ui-dialog-content'); // initialized
            let bLigplot = $('#' + me.pre + 'dl_ligplot').hasClass('ui-dialog-content'); // initialized
            let bContactmap = $('#' + me.pre + 'dl_contactmap').hasClass('ui-dialog-content'); // initialized
            let bAlignerrormap = $('#' + me.pre + 'dl_alignerrormap').hasClass('ui-dialog-content'); // initialized
            let bTable = $('#' + me.pre + 'dl_interactionsorted').hasClass('ui-dialog-content'); // initialized
            let bAlignmentInit = $('#' + me.pre + 'dl_alignment').hasClass('ui-dialog-content'); // initialized
            let bTwoddgmInit = $('#' + me.pre + 'dl_2ddgm').hasClass('ui-dialog-content'); // initialized
            let bTwodctnInit = $('#' + me.pre + 'dl_2dctn').hasClass('ui-dialog-content'); // initialized
            let bSetsInit = $('#' + me.pre + 'dl_definedsets').hasClass('ui-dialog-content'); // initialized

            status.bSelectannotationsInit2 = false, status.bGraph2 = false, status.bLineGraph2 = false;
            status.bScatterplot2 = false, status.bLigplot2 = false, status.bTable2 = false, status.bAlignmentInit2 = false;
            status.bTwoddgmInit2 = false, status.bTwodctnInit2 = false, status.bSetsInit2 = false;

            id2flag.dl_selectannotations = 'bSelectannotationsInit2';
            id2flag.dl_graph = 'bGraph2';
            id2flag.dl_linegraph = 'bLineGraph2';
            id2flag.dl_scatterplot = 'bScatterplot2';
            id2flag.dl_ligplot = 'bLigplot2';	
            id2flag.dl_contactmap = 'bContactmap2';
            id2flag.dl_alignerrormap = 'bAlignerrormap2';
            id2flag.dl_interactionsorted = 'bTable2';
            id2flag.dl_alignment = 'bAlignmentInit2';
            id2flag.dl_2ddgm = 'bTwoddgmInit2';
            id2flag.dl_2dctn = 'bTwodctnInit2';
            id2flag.dl_definedsets = 'bSetsInit2';

            if(bSelectannotationsInit) status.bSelectannotationsInit2 = $('#' + me.pre + 'dl_selectannotations').dialog( 'isOpen' );
            if(bGraph) status.bGraph2 = $('#' + me.pre + 'dl_graph').dialog( 'isOpen' );
            if(bLineGraph) status.bLineGraph2 = $('#' + me.pre + 'dl_linegraph').dialog( 'isOpen' );
            if(bScatterplot) status.bScatterplot2 = $('#' + me.pre + 'dl_scatterplot').dialog( 'isOpen' );
            if(bLigplot) status.bLigplot2 = $('#' + me.pre + 'dl_ligplot').dialog( 'isOpen' );
            if(bContactmap) status.bContactmap2 = $('#' + me.pre + 'dl_contactmap').dialog( 'isOpen' );
            if(bAlignerrormap) status.bAlignerror2 = $('#' + me.pre + 'dl_alignerrormap').dialog( 'isOpen' );
            if(bTable) status.bTable2 = $('#' + me.pre + 'dl_interactionsorted').dialog( 'isOpen' );
            if(bAlignmentInit) status.bAlignmentInit2 = $('#' + me.pre + 'dl_alignment').dialog( 'isOpen' );
            if(bTwoddgmInit) status.bTwoddgmInit2 = $('#' + me.pre + 'dl_2ddgm').dialog( 'isOpen' );
            if(bTwodctnInit) status.bTwodctnInit2 = $('#' + me.pre + 'dl_2dctn').dialog( 'isOpen' );
            if(bSetsInit) status.bSetsInit2 = $('#' + me.pre + 'dl_definedsets').dialog( 'isOpen' );

            return {status: status, id2flag: id2flag};
        }

        openDlgHalfWindow(id, title, dialogWidth, bForceResize) {  let me = this.icn3dui, ic = me.icn3d;
            if(me.bNode) return;

            let thisClass = this;

            let twoddgmWidth = me.htmlCls.width2d + 20;

            //ic.resizeCanvasCls.resizeCanvas(me.htmlCls.WIDTH - dialogWidth - me.htmlCls.LESSWIDTH, me.htmlCls.HEIGHT - me.htmlCls.LESSHEIGHT - me.htmlCls.EXTRAHEIGHT, bForceResize);
            ic.resizeCanvasCls.resizeCanvas(me.htmlCls.WIDTH - dialogWidth, me.htmlCls.HEIGHT, bForceResize);

            //height = me.htmlCls.HEIGHT - me.htmlCls.LESSHEIGHT - me.htmlCls.EXTRAHEIGHT;
            let height = me.htmlCls.HEIGHT;
            let width = dialogWidth;

            let position;
            if(me.cfg.showmenu && !me.utilsCls.isMobile() && !me.cfg.mobilemenu) {
                position ={ my: "left top", at: "right top+40", of: "#" + me.pre + "viewer", collision: "none" };
            }
            else {
                position ={ my: "left top", at: "right top", of: "#" + me.pre + "viewer", collision: "none" };
            }

            // disable resize
            me.cfg.resize = false;

            window.dialog = $( "#" + id ).dialog({
              autoOpen: true,
              title: title,
              height: height,
              width: width,
              modal: false,
              position: position,
              close: function(e) {
                  let result = thisClass.getDialogStatus();
                  let status = result.status;
                  let id2flag = result.id2flag;

                  // check the condition when all the rest dialogs are closed
                  let bCheckAll = false;
                  for(let idname in id2flag) {
                    let bCheckRest = (id === me.pre + idname);
                    for(let idstatus in status) {
                        // just check the rest, not itself
                        if(status.hasOwnProperty(idstatus)) continue;
                        bCheckRest = bCheckRest && !status[idstatus];
                    }
                    bCheckAll = bCheckAll || bCheckRest;
                  }

                  if(bCheckAll) {
                      if(status.bTwoddgmInit2 || status.bTwodctnInit2 || status.bSetsInit2) {
                          //ic.resizeCanvasCls.resizeCanvas(me.htmlCls.WIDTH - me.htmlCls.LESSWIDTH - twoddgmWidth, me.htmlCls.HEIGHT - me.htmlCls.LESSHEIGHT - me.htmlCls.EXTRAHEIGHT, true);
                          let canvasWidth = me.utilsCls.isMobile() ? me.htmlCls.WIDTH : me.htmlCls.WIDTH - twoddgmWidth;
                          ic.resizeCanvasCls.resizeCanvas(canvasWidth, me.htmlCls.HEIGHT, true);

                          if(status.bTwoddgmInit2) thisClass.openDlg2Ddgm(me.pre + 'dl_2ddgm', undefined, status.bSetsInit2);
                          if(status.bTwodctnInit2) thisClass.openDlg2Ddgm(me.pre + 'dl_2dctn', undefined, status.bSetsInit2);
                          if(status.bSetsInit2) thisClass.openDlg2Ddgm(me.pre + 'dl_definedsets');
                      }
                      else {
                          //ic.resizeCanvasCls.resizeCanvas(me.htmlCls.WIDTH - me.htmlCls.LESSWIDTH, me.htmlCls.HEIGHT - me.htmlCls.LESSHEIGHT - me.htmlCls.EXTRAHEIGHT, true);
                          ic.resizeCanvasCls.resizeCanvas(me.htmlCls.WIDTH, me.htmlCls.HEIGHT, true);
                      }
                  }
              },
              resize: function(e) {
                  if(id == me.pre + 'dl_selectannotations') {
                      ic.annotationCls.hideFixedTitle();
                  }
                  else if(id == me.pre + 'dl_graph') {
                      let width = $("#" + id).width();
                      let height = $("#" + id).height();

                      d3.select("#" + me.svgid).attr("width", width).attr("height", height);
                  }
                  else if(id == me.pre + 'dl_linegraph' || id == me.pre + 'dl_scatterplot' || id == me.pre + 'dl_ligplot' || id == me.pre + 'dl_contactmap' || id == me.pre + 'dl_alignerrormap') {
                      let oriWidth =(status.bTwoddgmInit2 || status.bSetsInit2) ?(me.htmlCls.WIDTH - twoddgmWidth)/2 : me.htmlCls.WIDTH / 2;
                      let ratio = $("#" + id).width() / oriWidth;

                      if(id == me.pre + 'dl_linegraph') {
                          let width = ic.linegraphWidth * ratio;
                          $("#" + me.linegraphid).attr("width", width);
                      }
                      else if(id == me.pre + 'dl_scatterplot') {
                          let width = ic.scatterplotWidth * ratio;
                          $("#" + me.scatterplotid).attr("width", width);
                      }
                      else if(id == me.pre + 'dl_ligplot') {
                        let width = ic.ligplotWidth * ratio;
                        $("#" + me.ligplotid).attr("width", width);
                      }
                      else if(id == me.pre + 'dl_ligplot') {
                        let width = ic.ligplotWidth * ratio;
                        $("#" + me.ligplotid).attr("width", width);
                    }
                      else if(id == me.pre + 'dl_contactmap') {
                          let width = ic.contactmapWidth * ratio;
                          $("#" + me.contactmapid).attr("width", width);
                      }
                      else if(id == me.pre + 'dl_alignerrormap') {
                        let width = ic.alignerrormapWidth * ratio;
                        $("#" + me.alignerrormapid).attr("width", width);
                    }
                  }
              }
            });

            this.addSaveButton(id);
            this.addHideButton(id);
        }

        openDlg2Ddgm(id, inHeight, bDefinedSets) {  let me = this.icn3dui, ic = me.icn3d;
            if(me.bNode) return;

            let thisClass = this;

            let twoddgmWidth = me.htmlCls.width2d + 20;
            let at, title;
            if(id === me.pre + 'dl_definedsets') {
                at = "right top";
                title = 'Select sets';
            }
            else if(id === me.pre + 'dl_2ddgm' || id === me.pre + 'dl_2dctn') {
                if(bDefinedSets) {
                    at = "right top+240";
                }
                else {
                    at = "right top";
                }

                title = (id === me.pre + 'dl_2ddgm') ? '2D Diagram' : '2D Cartoon';
            }

            //var position ={ my: "left top", at: at, of: "#" + me.pre + "canvas", collision: "none" }
            let position ={ my: "left top+" + me.htmlCls.MENU_HEIGHT, at: at, of: "#" + me.pre + "viewer", collision: "none" };

            let height = 'auto';

            window.dialog = $( '#' + id ).dialog({
              autoOpen: true,
              title: title,
              height: height,
              width: twoddgmWidth,
              modal: false,
              position: position,
              close: function(e) {
                  let status = thisClass.getDialogStatus().status;

                  if((!status.bSelectannotationsInit2) &&(!status.bGraph2) &&(!status.bLineGraph2) &&(!status.bScatterplot2) &&(!status.bLigplot2) &&(!status.bTable2) &&(!status.bAlignmentInit2) ) {
                        //ic.resizeCanvasCls.resizeCanvas(me.htmlCls.WIDTH - me.htmlCls.LESSWIDTH, me.htmlCls.HEIGHT - me.htmlCls.LESSHEIGHT - me.htmlCls.EXTRAHEIGHT, true);
                        ic.resizeCanvasCls.resizeCanvas(me.htmlCls.WIDTH, me.htmlCls.HEIGHT, true);
                  }
              },
              resize: function(e, ui) {
                  if(id == me.pre + 'dl_2dctn') {
                    ic.resizeRatioX = ui.size.width / me.htmlCls.width2d; //ui.originalSize.width;
                    ic.resizeRatioY = ui.size.height / (me.htmlCls.width2d + 70); //ui.originalSize.height;
                  }
              },
              resizeStop: function(e, ui) {
                ic.resizeRatioX = ui.size.width / me.htmlCls.width2d; //ui.originalSize.width;
                ic.resizeRatioY = ui.size.height / (me.htmlCls.width2d + 70); //ui.originalSize.height;
              }
            });

            this.addSaveButton(id);
            this.addHideButton(id);
        }

        openDlgRegular(id, title) {  let me = this.icn3dui, ic = me.icn3d;
            if(me.bNode) return;

            let width = 400, height = 150;
            let twoddgmWidth = me.htmlCls.width2d + 20;

            let status = this.getDialogStatus().status;

            if(id === me.pre + 'dl_selectannotations' || id === me.pre + 'dl_graph' || id === me.pre + 'dl_linegraph' || id === me.pre + 'dl_scatterplot' || id === me.pre + 'dl_ligplot' || id === me.pre + 'dl_contactmap'  || id === me.pre + 'dl_alignerrormap' || id === me.pre + 'dl_interactionsorted' || id === me.pre + 'dl_alignment') {
                //var dialogWidth = 0.5 *(me.htmlCls.WIDTH - me.htmlCls.LESSWIDTH) - twoddgmWidth * 0.5;
                let dialogWidth = 0.5 *(me.htmlCls.WIDTH) - twoddgmWidth * 0.5;

                //if(me.htmlCls.WIDTH - me.htmlCls.LESSWIDTH >= me.htmlCls.HEIGHT - me.htmlCls.LESSHEIGHT - me.htmlCls.EXTRAHEIGHT) {
                if(me.htmlCls.WIDTH >= me.htmlCls.HEIGHT) {
                    this.openDlgHalfWindow(id, title, dialogWidth, true);

                    if(status.bTwoddgmInit2 || status.bTwodctnInit2 || status.bSetsInit2) {
                        ic.resizeCanvasCls.resizeCanvas(me.htmlCls.WIDTH - dialogWidth - twoddgmWidth, me.htmlCls.HEIGHT, true);

                        if(status.bTwoddgmInit2) this.openDlg2Ddgm(me.pre + 'dl_2ddgm', undefined, status.bSetsInit2);
                        if(status.bTwodctnInit2) this.openDlg2Ddgm(me.pre + 'dl_2dctn', undefined, status.bSetsInit2);
                        if(status.bSetsInit2) this.openDlg2Ddgm(me.pre + 'dl_definedsets');
                    }
                }
                else {
                    //ic.resizeCanvasCls.resizeCanvas(me.htmlCls.WIDTH - me.htmlCls.LESSWIDTH,(me.htmlCls.HEIGHT - me.htmlCls.LESSHEIGHT - me.htmlCls.EXTRAHEIGHT) * 0.5, true);
                    ic.resizeCanvasCls.resizeCanvas(me.htmlCls.WIDTH,(me.htmlCls.HEIGHT) * 0.5, true);

                    //height =(me.htmlCls.HEIGHT - me.htmlCls.LESSHEIGHT - me.htmlCls.EXTRAHEIGHT) * 0.5;
                    height =(me.htmlCls.HEIGHT) * 0.5;

                    //width = me.htmlCls.WIDTH - me.htmlCls.LESSWIDTH;
                    width = me.htmlCls.WIDTH;

                    let position ={ my: "left top", at: "left bottom+32", of: "#" + me.pre + "canvas", collision: "none" };

                    window.dialog = $( "#" + id ).dialog({
                      autoOpen: true,
                      title: title,
                      height: height,
                      width: width,
                      modal: false,
                      position: position,
                      close: function(e) {
                          if((id === me.pre + 'dl_selectannotations' &&(!status.bAlignmentInit2) &&(!status.bGraph2) &&(!status.bTable2) &&(!status.bLineGraph2) &&(!status.bScatterplot2) &&(!status.bLigplot2) &&(!status.bContactmap2) &&(!status.bAlignerrormap2))
                            ||(id === me.pre + 'dl_graph' &&(!status.bSelectannotationsInit2) &&(!status.bAlignmentInit2) &&(!status.bTable2) &&(!status.bLineGraph2) &&(!status.bScatterplot2) &&(!status.bLigplot2) &&(!status.bContactmap2) &&(!status.bAlignerrormap2))
                            ||(id === me.pre + 'dl_alignment' &&(!status.bSelectannotationsInit2) &&(!status.bGraph2) &&(!status.bTable2) &&(!status.bLineGraph2) &&(!status.bScatterplot2) &&(!status.bLigplot2) &&(!status.bContactmap2) &&(!status.bAlignerrormap2))
                            ||(id === me.pre + 'dl_interactionsorted' &&(!status.bSelectannotationsInit2) &&(!status.bGraph2) &&(!status.bAlignmentInit2) &&(!status.bLineGraph2) &&(!status.bScatterplot2) &&(!status.bLigplot2) &&(!status.bContactmap2) &&(!status.bAlignerrormap2))
                            ||(id === me.pre + 'dl_linegraph' &&(!status.bSelectannotationsInit2) &&(!status.bGraph2) &&(!status.bAlignmentInit2) &&(!status.bTable2) &&(!status.bScatterplot2) &&(!status.bLigplot2) &&(!status.bContactmap2) &&(!status.bAlignerrormap2))
                            ||(id === me.pre + 'dl_scatterplot' &&(!status.bSelectannotationsInit2) &&(!status.bGraph2) &&(!status.bAlignmentInit2) &&(!status.bTable2) &&(!status.bLineGraph2) &&(!status.bLigplot2) &&(!status.bContactmap2) &&(!status.bAlignerrormap2))
                            ||(id === me.pre + 'dl_ligplot' &&(!status.bSelectannotationsInit2) &&(!status.bGraph2) &&(!status.bAlignmentInit2) &&(!status.bTable2) &&(!status.bLineGraph2) &&(!status.bScatterplot2) &&(!status.bContactmap2) &&(!status.bAlignerrormap2))
                            ||(id === me.pre + 'dl_contactmap' &&(!status.bSelectannotationsInit2) &&(!status.bGraph2) &&(!status.bAlignmentInit2) &&(!status.bTable2) &&(!status.bLineGraph2) &&(!status.bScatterplot2) &&(!status.bLigplot2) &&(!status.bAlignerrormap2))
                            ||(id === me.pre + 'dl_alignerrormap' &&(!status.bSelectannotationsInit2) &&(!status.bGraph2) &&(!status.bAlignmentInit2) &&(!status.bTable2) &&(!status.bLineGraph2) &&(!status.bScatterplot2) &&(!status.bLigplot2) &&(!status.bContactmap2))
                            ) {
                              if(status.bTwoddgmInit2 || status.bTwodctnInit2 || status.bSetsInit2) {
                                  let canvasWidth = me.utilsCls.isMobile() ? me.htmlCls.WIDTH : me.htmlCls.WIDTH - twoddgmWidth;
                                  ic.resizeCanvasCls.resizeCanvas(canvasWidth, me.htmlCls.HEIGHT, true);

                                  if(status.bTwoddgmInit2) thisClass.openDlg2Ddgm(me.pre + 'dl_2ddgm', undefined, status.bSetsInit2);
                                  if(status.bTwodctnInit2) thisClass.openDlg2Ddgm(me.pre + 'dl_2dctn', undefined, status.bSetsInit2);
                                  if(status.bSetsInit2) thisClass.openDlg2Ddgm(me.pre + 'dl_definedsets');
                              }
                              else {
                                  //ic.resizeCanvasCls.resizeCanvas(me.htmlCls.WIDTH - me.htmlCls.LESSWIDTH, me.htmlCls.HEIGHT - me.htmlCls.LESSHEIGHT - me.htmlCls.EXTRAHEIGHT, true);
                                  ic.resizeCanvasCls.resizeCanvas(me.htmlCls.WIDTH, me.htmlCls.HEIGHT, true);
                              }
                          }
                      },
                      resize: function(e) {
                          if(id == me.pre + 'dl_selectannotations') {
                              ic.annotationCls.hideFixedTitle();
                          }
                          else if(id == me.pre + 'dl_graph') {
                              let width = $("#" + id).width();
                              let height = $("#" + id).height();

                              d3.select("#" + me.svgid).attr("width", width).attr("height", height);
                          }
                          else if(id == me.pre + 'dl_linegraph' || id == me.pre + 'dl_scatterplot' || id == me.pre + 'dl_ligplot' || id == me.pre + 'dl_contactmap' || id == me.pre + 'dl_alignerrormap') {
                              let oriWidth =(status.bTwoddgmInit2 || status.bSetsInit2) ?(me.htmlCls.WIDTH - twoddgmWidth)/2 : me.htmlCls.WIDTH / 2;
                              let ratio = $("#" + id).width() / oriWidth;

                              if(id == me.pre + 'dl_linegraph') {
                                  let width = ic.linegraphWidth * ratio;
                                  $("#" + me.linegraphid).attr("width", width);
                              }
                              else if(id == me.pre + 'dl_scatterplot') {
                                  let width = ic.scatterplotWidth * ratio;
                                  $("#" + me.scatterplotid).attr("width", width);
                              }
                              else if(id == me.pre + 'dl_ligplot') {
                                let width = ic.ligplotWidth * ratio;
                                $("#" + me.ligplotid).attr("width", width);
                            }
                              else if(id == me.pre + 'dl_contactmap') {
                                  let width = ic.contactmapWidth * ratio;
                                  $("#" + me.contactmapid).attr("width", width);
                              }
                              else if(id == me.pre + 'dl_alignerrormap') {
                                let width = ic.alignerrormapWidth * ratio;
                                $("#" + me.alignerrormapid).attr("width", width);
                            }
                          }
                      }
                    });

                    this.addSaveButton(id);
                    this.addHideButton(id);
                }
            }
            else if(id === me.pre + 'dl_2ddgm' || id === me.pre + 'dl_2dctn') {
                let tmpWidth = 0;

                //if(me.htmlCls.WIDTH - me.htmlCls.LESSWIDTH >= me.htmlCls.HEIGHT - me.htmlCls.LESSHEIGHT - me.htmlCls.EXTRAHEIGHT) {
                if(me.htmlCls.WIDTH >= me.htmlCls.HEIGHT) {
                    if(status.bSelectannotationsInit2 || status.bGraph2 || status.bLineGraph2 || status.bScatterplot2 || status.bLigplot2 || status.bTable2 || status.bAlignmentInit2) {
                        //tmpWidth = 0.5 *(me.htmlCls.WIDTH - me.htmlCls.LESSWIDTH) - twoddgmWidth * 0.5;
                        tmpWidth = 0.5 *(me.htmlCls.WIDTH) - twoddgmWidth * 0.5;
                    }
                    //ic.resizeCanvasCls.resizeCanvas(me.htmlCls.WIDTH - me.htmlCls.LESSWIDTH - tmpWidth - twoddgmWidth, me.htmlCls.HEIGHT - me.htmlCls.LESSHEIGHT - me.htmlCls.EXTRAHEIGHT, true);
                    ic.resizeCanvasCls.resizeCanvas(me.htmlCls.WIDTH - tmpWidth - twoddgmWidth, me.htmlCls.HEIGHT, true);

                    this.openDlg2Ddgm(id, undefined, status.bSetsInit2);
                }
                else {
                    //ic.resizeCanvasCls.resizeCanvas(me.htmlCls.WIDTH - me.htmlCls.LESSWIDTH - tmpWidth - twoddgmWidth,(me.htmlCls.HEIGHT - me.htmlCls.LESSHEIGHT - me.htmlCls.EXTRAHEIGHT)*0.5, true);
                    let canvasWidth = me.utilsCls.isMobile() ? me.htmlCls.WIDTH : me.htmlCls.WIDTH - twoddgmWidth;
                    ic.resizeCanvasCls.resizeCanvas(canvasWidth,(me.htmlCls.HEIGHT)*0.5, true);
                    //this.openDlg2Ddgm(id,(me.htmlCls.HEIGHT - me.htmlCls.LESSHEIGHT - me.htmlCls.EXTRAHEIGHT)*0.5);
                    this.openDlg2Ddgm(id,(me.htmlCls.HEIGHT)*0.5);

                    //this.openDlg2Ddgm(id,(me.htmlCls.HEIGHT - me.htmlCls.LESSHEIGHT - me.htmlCls.EXTRAHEIGHT)*0.5, bSetsInit2);
                    this.openDlg2Ddgm(id,(me.htmlCls.HEIGHT)*0.5, status.bSetsInit2);
                }
            }
            else {
                height = 'auto';
                width = 'auto';

                if(id === me.pre + 'dl_addtrack') {
                    width='50%';
                }
                else if(id === me.pre + 'dl_menupref') {
                    width = 800;
                    height = 500;
                }
                
                let position;

                if(id === me.pre + 'dl_definedsets') {
                    let tmpWidth = 0;

                    //if(me.htmlCls.WIDTH - me.htmlCls.LESSWIDTH >= me.htmlCls.HEIGHT - me.htmlCls.LESSHEIGHT - me.htmlCls.EXTRAHEIGHT) {
                    if(me.htmlCls.WIDTH >= me.htmlCls.HEIGHT) {
                        if(status.bSelectannotationsInit2 || status.bGraph2 || status.bLineGraph2 || status.bScatterplot2 || status.bLigplot2 || status.bTable2 || status.bAlignmentInit2) {
                            //tmpWidth = 0.5 *(me.htmlCls.WIDTH - me.htmlCls.LESSWIDTH) - twoddgmWidth * 0.5;
                            tmpWidth = 0.5 *(me.htmlCls.WIDTH) - twoddgmWidth * 0.5;
                        }
                        //ic.resizeCanvasCls.resizeCanvas(me.htmlCls.WIDTH - me.htmlCls.LESSWIDTH - tmpWidth - twoddgmWidth, me.htmlCls.HEIGHT - me.htmlCls.LESSHEIGHT - me.htmlCls.EXTRAHEIGHT, true);
                        ic.resizeCanvasCls.resizeCanvas(me.htmlCls.WIDTH - tmpWidth - twoddgmWidth, me.htmlCls.HEIGHT, true);
                        this.openDlg2Ddgm(id);

                        if(status.bTwoddgmInit2) this.openDlg2Ddgm(me.pre + 'dl_2ddgm', undefined, true);
                        if(status.bTwodctnInit2) this.openDlg2Ddgm(me.pre + 'dl_2dctn', undefined, true);
                    }
                    else {
                        //ic.resizeCanvasCls.resizeCanvas(me.htmlCls.WIDTH - me.htmlCls.LESSWIDTH - tmpWidth - twoddgmWidth,(me.htmlCls.HEIGHT - me.htmlCls.LESSHEIGHT - me.htmlCls.EXTRAHEIGHT)*0.5, true);
                        let canvasWidth = me.utilsCls.isMobile() ? me.htmlCls.WIDTH : me.htmlCls.WIDTH - twoddgmWidth;
                        ic.resizeCanvasCls.resizeCanvas(canvasWidth,(me.htmlCls.HEIGHT)*0.5, true);
                        //this.openDlg2Ddgm(id,(me.htmlCls.HEIGHT - me.htmlCls.LESSHEIGHT - me.htmlCls.EXTRAHEIGHT)*0.5);
                        this.openDlg2Ddgm(id,(me.htmlCls.HEIGHT)*0.5);

                        //if(bTwoddgmInit2) this.openDlg2Ddgm(me.pre + 'dl_2ddgm',(me.htmlCls.HEIGHT - me.htmlCls.LESSHEIGHT - me.htmlCls.EXTRAHEIGHT)*0.5, true);
                        if(status.bTwoddgmInit2) this.openDlg2Ddgm(me.pre + 'dl_2ddgm',(me.htmlCls.HEIGHT)*0.5, true);
                        if(status.bTwodctnInit2) this.openDlg2Ddgm(me.pre + 'dl_2dctn',(me.htmlCls.HEIGHT)*0.5, true);
                    }
                }
                else {
                    if(me.utilsCls.isMobile()) {
                        position ={ my: "left top", at: "left bottom-50", of: "#" + me.pre + "canvas", collision: "none" };
                    }
                    else if(id === me.pre + 'dl_allinteraction' || id === me.pre + 'dl_buriedarea') {
                        //position ={ my: "right top", at: "right top+50", of: "#" + me.pre + "dl_selectannotations", collision: "none" }
                        position ={ my: "right top", at: "right top+50", of: "#" + ic.divid, collision: "none" };

                        width = 700;
                        height = 500;
                    }
                    else if(id === me.pre + 'dl_rmsd') {
                        position ={ my: "left bottom", at: "left+20 bottom-20", of: "#" + me.pre + "canvas", collision: "none" };
                    }
                    else if(id === me.pre + 'dl_legend') {
                        position ={ my: "left bottom", at: "left+20 bottom-20", of: "#" + me.pre + "canvas", collision: "none" };
                    }
                    else if(id === me.pre + 'dl_symd') {
                        position ={ my: "left top", at: "right-200 bottom-200", of: "#" + me.pre + "canvas", collision: "none" };
                    }
                    else {
                        if(me.cfg.align) {
                            position ={ my: "left top", at: "left top+90", of: "#" + me.pre + "canvas", collision: "none" };
                        }
                        else if(id === me.pre + 'dl_mmdbafid') {
                            position ={ my: "left top", at: "left top+130", of: "#" + me.pre + "canvas", collision: "none" };
                        }
                        else {
                            position ={ my: "left top", at: "left top+50", of: "#" + me.pre + "canvas", collision: "none" };
                        }
                    }

                    window.dialog = $( "#" + id ).dialog({
                      autoOpen: true,
                      title: title,
                      height: height,
                      width: width,
                      modal: false,
                      position: position
                    });

                    this.addSaveButton(id);
                    this.addHideButton(id);
                }
            }

            $(".ui-dialog .ui-button span")
              .removeClass("ui-icon-closethick")
              .addClass("ui-icon-close");
        }

        openDlgNotebook(id, title) {  let me = this.icn3dui, ic = me.icn3d;
            if(me.bNode) return;

            let width = 400, height = 150;
            let twoddgmWidth = me.htmlCls.width2d + 20;

            if(id === me.pre + 'dl_selectannotations' || id === me.pre + 'dl_graph' || id === me.pre + 'dl_linegraph' || id === me.pre + 'dl_scatterplot' || id === me.pre + 'dl_ligplot' || id === me.pre + 'dl_contactmap'  || id === me.pre + 'dl_alignerrormap' || id === me.pre + 'dl_interactionsorted' || id === me.pre + 'dl_alignment') {
                $( "#" + id ).show();
                $( "#" + id + "_nb").show();
                $( "#" + id + "_title").html(title);

                height =(me.htmlCls.HEIGHT) * 0.5;

                width = me.htmlCls.WIDTH;

                $( "#" + id ).width(width);
                $( "#" + id ).height(height);

                $( "#" + id ).resize(function(e) {
                      let oriWidth = me.htmlCls.WIDTH / 2;
                      let ratio = $("#" + id).width() / oriWidth;

                      if(id == me.pre + 'dl_selectannotations') {
                          ic.annotationCls.hideFixedTitle();
                      }
                      else if(id == me.pre + 'dl_graph') {
                          let width = $("#" + id).width();
                          let height = $("#" + id).height();

                          d3.select("#" + me.svgid).attr("width", width).attr("height", height);
                      }
                      else if(id == me.pre + 'dl_linegraph') {
                          let width = ic.linegraphWidth * ratio;

                          $("#" + me.linegraphid).attr("width", width);
                      }
                      else if(id == me.pre + 'dl_scatterplot') {
                          let width = ic.scatterplotWidth * ratio;

                          $("#" + me.scatterplotid).attr("width", width);
                      }
                      else if(id == me.pre + 'dl_ligplot') {
                        let width = ic.ligplotWidth * ratio;

                        $("#" + me.ligplotid).attr("width", width);
                      }
                      else if(id == me.pre + 'dl_contactmap') {
                          let width = ic.contactmapWidth * ratio;

                          $("#" + me.contactmapid).attr("width", width);
                      }
                      else if(id == me.pre + 'dl_alignerrormap') {
                        let width = ic.alignerrormapWidth * ratio;

                        $("#" + me.alignerrormapid).attr("width", width);
                    }
                });
            }
            else {
                if(ic.bRender) {
                    $( "#" + id ).show();
                    $( "#" + id + "_nb").show();
                    $( "#" + id + "_title").html(title);
                }

                height = 'auto';
                width = 'auto';

                if(id === me.pre + 'dl_addtrack') {
                    width='50%';
                }
                else if(id === me.pre + 'dl_2ddgm' || id === me.pre + 'dl_2dctn' || id === me.pre + 'dl_definedsets') {
                    width=twoddgmWidth;
                }
                else if(id === me.pre + 'dl_allinteraction' || id === me.pre + 'dl_buriedarea') {
                    width = 700;
                    height = 500;
                }

                $( "#" + id ).width(width);
                $( "#" + id ).height(height);
            }
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class SetDialog {
        constructor(icn3dui) {
            this.icn3dui = icn3dui;
        }

        //A placeholder for all custom dialogs.
        setCustomDialogs() { let me = this.icn3dui; me.icn3d;
            if(me.bNode) return '';

            let html = "";
            return html;
        }

        getHtmlAlignResidueByResidue(chainids, predefinedid, buttonid) { let me = this.icn3dui; me.icn3d;
            let html = '';

            html += "All chains will be aligned to the first chain in the comma-separated chain IDs. Each chain ID has the form of PDBID_chain (e.g., 1HHO_A, case sensitive) or UniprotID (e.g., P69905 for AlphaFold structures).<br/><br/>";
            html += "<b>Chain IDs</b>: " + me.htmlCls.inputTextStr + "id='" + me.pre + chainids + "' value='P69905,P01942,1HHO_A' size=50><br/><br/>";
            
            html += "Each alignment is defined as \" | \"-separated residue lists in one line. \"10-50\" means a range of residues from 10 to 50.<br><textarea id='" + me.pre + predefinedid + "' rows='5' style='width: 100%; height: " +(me.htmlCls.LOG_HEIGHT) + "px; padding: 0px; border: 0px;'>1,5,10-50 | 1,5,10-50\n2,6,11-51 | 1,5,10-50</textarea><br/>";
            html += me.htmlCls.buttonStr + buttonid + "'><b>Align Residue by Residue</b></button><br/>";
            return html;
        }

        addNotebookTitle(id, title, bAddExtraDiv) { let me = this.icn3dui; me.icn3d;
            //return '<div id="' + me.pre + id + '_nb" style="display:none; background-color:#1c94c4; width:100%"><span style="color:white; font-weight:bold">' + title + '</span>&nbsp;&nbsp;&nbsp;<span onclick="$(\'#' + me.pre + id + '\').hide(); return false;" class="icn3d-nbclose" title="Close">x</span></div>';

            let html = '<div id="' + me.pre + id + '_nb" style="display:none; background-color:#5C9CCC; width:100%"><span id="' + me.pre + id + '_title" style="color:white; font-weight:bold">' + title + '</span>&nbsp;&nbsp;&nbsp;<div onclick="$(\'#' + me.pre + id + '\').hide(); return false;" class="icn3d-nbclose ui-icon ui-icon-close" title="Close"></div></div>';

            if(bAddExtraDiv) {
                html += '<div id="' + me.pre + id + '_html"></div>';
            }

            return html;
        }

        //Set the html for all popup dialogs.
        setDialogs() { let me = this.icn3dui, ic = me.icn3d;
            if(me.bNode) return '';

            let html = "";

            let defaultColor = "#ffff00"; //ic.colorBlackbkgd; 
     
            me.htmlCls.optionStr = "<option value=";

            html += "<!-- dialog will not be part of the form -->";

            let divClass =(me.cfg.notebook) ? '' : 'icn3d-hidden';
            let dialogClass =(me.cfg.notebook) ? 'icn3d-hidden' : '';
            //html += me.htmlCls.divStr + "alldialogs' class='" + divClass + " icn3d-dialog' style='margin-top:" + me.htmlCls.CMD_HEIGHT + "px'>";
            html += me.htmlCls.divStr + "alldialogs' class='" + divClass + " icn3d-dialog' style='margin-top:12px'>";

            html += me.htmlCls.divStr + "dl_2ddgm' class='" + dialogClass + " icn3d-dl_2ddgm' style='background-color:white'>";
            html += this.addNotebookTitle('dl_2ddgm', '2D Diagram', true);
            html += "</div>";

            html += me.htmlCls.divStr + "dl_2dctn' class='" + dialogClass + " icn3d-dl_2dctn' style='background-color:white'>";
            html += this.addNotebookTitle('dl_2dctn', '2D Cartoon');

            me.svgid_ct = me.pre + "icn3d_cartoon";

            let buttonStrTmp = '<button class="icn3d-commandTitle" style="-webkit-appearance:button; height:24px;background-color:#DDD;" id="';
            let tmpStr = 'icn3d-node-text';
            html += me.htmlCls.divNowrapStr + "Dynamically generated for selected residues. <br>Nodes can be dragged or clicked.</div>";
            html += me.htmlCls.divNowrapStr + buttonStrTmp + me.svgid_ct + '_svg">SVG</button>' + me.htmlCls.space2;
            html += buttonStrTmp + me.svgid_ct + '_png">PNG</button>' + me.htmlCls.space2;
            html += buttonStrTmp + me.svgid_ct + '_json">JSON</button><br>';
            html += "<b>Label</b>: <select id='" + me.svgid_ct + "_label'>";
            html += me.htmlCls.optionStr + "'" + tmpStr + "0'>No</option>";
            html += me.htmlCls.optionStr + "'" + tmpStr + "4'>4px</option>";
            html += me.htmlCls.optionStr + "'" + tmpStr + "8' selected>8px</option>";
            html += me.htmlCls.optionStr + "'" + tmpStr + "12'>12px</option>";
            html += me.htmlCls.optionStr + "'" + tmpStr + "16'>16px</option>";
            html += me.htmlCls.optionStr + "'" + tmpStr + "24'>24px</option>";
            html += me.htmlCls.optionStr + "'" + tmpStr + "32'>32px</option>";
            html += "</select>";
            html += "</div>";

            html += "<svg id='" + me.svgid_ct + "' viewBox='" + "0,0," + me.htmlCls.width2d + "," + me.htmlCls.width2d + "'>";
            html += "</svg>";

            html += "</div>";

        //    if(me.cfg.align !== undefined || me.cfg.chainalign !== undefined || ic.bRealign || ic.bSymd) {
              html += me.htmlCls.divStr + "dl_alignment' class='" + dialogClass + "' style='background-color:white;'>";
              html += this.addNotebookTitle('dl_alignment', 'Dynamically Calculated Symmetry using SymD');
              html += me.htmlCls.divStr + "symd_info'></div>";
              html += me.htmlCls.divStr + "alignseqguide_wrapper'><br>" + me.htmlCls.setHtmlCls.setAlignSequenceGuide() + "</div>";
              html += me.htmlCls.divStr + "dl_sequence2' class='icn3d-dl_sequence'>";
              html += this.addNotebookTitle('dl_sequence2', 'Select Residues in Aligned Sequences');
              html += "</div>";
              html += "</div>";
        //    }

            html += me.htmlCls.divStr + "dl_definedsets' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_definedsets', 'Defined Sets');
            html += me.htmlCls.divStr + "dl_setsmenu'>";
            html += "<b>Defined Sets:</b> <br/>";
            html += "<select id='" + me.pre + "atomsCustom' multiple size='6' style='min-width:130px;'>";
            html += "</select>";
            html += "<div style='margin: 6px 0 6px 0;'>" + me.htmlCls.buttonStr + "deletesets'><b>Delete Selected Sets</b></button></div>";
            html += '        <b>Set Operations</b>: <div style="width:20px; margin-top:6px; display:inline-block;"><span id="' + me.pre + 'dl_command_expand" class="ui-icon ui-icon-plus icn3d-expand icn3d-link" style="width:15px;" title="Expand"></span><span id="' + me.pre + 'dl_command_shrink" class="ui-icon ui-icon-minus icn3d-shrink icn3d-link" style="display:none; width:15px;" title="Shrink"></span></div><br>';
            html += "</div>";

            html += me.htmlCls.divStr + "dl_command' style='display:none;'>";
            html += me.htmlCls.divStr + "dl_setoperations'>";
            html += "<label for='" + me.pre + "setOr'>" + me.htmlCls.inputRadioStr + "name='" + me.pre + "setOperation' id='" + me.pre + "setOr' checked> Union(or) </label><br/>";
            html += "<label for='" + me.pre + "setAnd'>" + me.htmlCls.inputRadioStr + "name='" + me.pre + "setOperation' id='" + me.pre + "setAnd'> Intersection(and) </label><br/>";
            html += "<label for='" + me.pre + "setNot'>" + me.htmlCls.inputRadioStr + "name='" + me.pre + "setOperation' id='" + me.pre + "setNot'> Exclusion(not) </label>";
            html += "</div><br>";

            html += me.htmlCls.setHtmlCls.setAdvanced();

            html += "</div>";
            html += "</div>";

            html += me.htmlCls.setHtmlCls.setAdvanced(2);

            html += me.htmlCls.divStr + "dl_vastplus' class='" + dialogClass + "' style='max-width:500px'>";
            html += this.addNotebookTitle('dl_vastplus', 'Please input PDB ID for VAST+');
            html += "Note: <b>VAST+</b> finds other macromolecular structures that have a similar biological unit. To do this, VAST+ takes into consideration the complete set of 3D domains that VAST identified within a query structure, throughout all of its component protein molecules, and finds other macromolecular structures that have a similar set of proteins/3D domains.<br><br>"; 
            html += "PDB ID: " + me.htmlCls.inputTextStr + "id='" + me.pre + "vastpluspdbid' value='6VXX' size=8><br>";
            html += me.htmlCls.buttonStr + "reload_vastplus'>VAST+</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_vast' class='" + dialogClass + "' style='max-width:500px'>";
            html += this.addNotebookTitle('dl_vast', 'Pleaes input chain or PDB file for VAST');
            html += 'Note: <b>VAST</b> identifies 3D domains (substructures) within each protein structure in the Molecular Modeling Database (MMDB), and then finds other protein structures that have one or more similar 3D domains, using purely geometric criteria. You have two ways to do a VAST search.<br><br>'; 

            html += '<b>Option 1</b>, search with your selection (all residues are selected by default) in the loaded structures:<br>'; 
            html += '<form data-ncbi-sg-search="true" method=post enctype=multipart/form-data action="https://www.ncbi.nlm.nih.gov/Structure/vast/VSMmdb.cgi" id="' + me.pre + 'newvs2" name="newvs2" target="_blank">';
            html += '<input type=hidden id="' + me.pre + 'pdbstr" name="pdbstr">';
            html += "Searching against: <input type='radio' name='dataset' value='Non-redundant subset' checked> Medium-redundancy Subset of PDB <a href='https://www.ncbi.nlm.nih.gov/Structure/VAST/vasthelp.html#VASTNR' title='Medium-redundancy Subset' target='_blank'>?</a> <input type='radio' name='dataset' value='All'>All of PDB <br>";
            // the submit value has to be "Submit" in order to make the backend cgi works
            //html += '<input type="submit" name="' + me.pre + 'cmdVSMmdb" value="VAST Search"></input>';
            html += '<input type="submit" id="' + me.pre + 'cmdVSMmdb2" name="cmdVSMmdb" value="Submit"></input>';
            html += "</form><br>";

            html += '<b>Option 2</b>, search with PDB ID and chain name:<br>'; 
            html += "PDB ID: " + me.htmlCls.inputTextStr + "id='" + me.pre + "vastpdbid' value='4N7N' size=8> &nbsp;&nbsp;";
            html += "Chain Name: " + me.htmlCls.inputTextStr + "id='" + me.pre + "vastchainid' value='A' size=8> <br>";
            html += me.htmlCls.buttonStr + "reload_vast'>VAST</button><br><br>";

            html += '<b>Option 3</b>, search with a PDB file:<br>'; 
            html += '<form data-ncbi-sg-search="true" method=post enctype=multipart/form-data action="https://www.ncbi.nlm.nih.gov/Structure/vast/VSMmdb.cgi" id="' + me.pre + 'newvs" name="newvs" target="_blank">';
            html += "PDB File: " + me.htmlCls.inputFileStr + " name='pdbfile' size=8><br>";
            html += "Searching against: <input type='radio' name='dataset' value='Non-redundant subset' checked> Medium-redundancy Subset of PDB <a href='https://www.ncbi.nlm.nih.gov/Structure/VAST/vasthelp.html#VASTNR' title='Medium-redundancy Subset' target='_blank'>?</a> <input type='radio' name='dataset' value='All'>All of PDB <br>";
            // the submit value has to be "Submit" in order to make the backend cgi works
            //html += '<input type="submit" name="' + me.pre + 'cmdVSMmdb" value="VAST Search"></input>';
            html += '<input type="submit" id="' + me.pre + 'cmdVSMmdb" name="cmdVSMmdb" value="Submit"></input>';
            html += "</form><br>";

            html += "</div>";

            html += me.htmlCls.divStr + "dl_foldseek' class='" + dialogClass + "' style='max-width:500px'>";
            html += this.addNotebookTitle('dl_foldseek', 'Submit your selection to Foldseek');
            html += '1. <input type="submit" id="' + me.pre + 'fssubmit" name="fssubmit" value="Submit"></input> your selection (all residues are selected by default) in the loaded structures to <a href="https://search.foldseek.com/search" target="_blank">Foldseek</a> web server.<br><br>';
            html += '2 (Optional). Once you see the structure neighbors, you can view the alignment in iCn3D by inputing a list of PDB chain IDs or AlphaFold UniProt IDs below. <br><br>The PDB chain IDs are the same as the record names such as "1HHO_A". The UniProt ID is the text between "AF-" and "-F1". For example, the UniProt ID for the record name "AF-P69905-F1-model_v4" is "P69905".<br><br>'; 

            html += "Chain ID List: " + me.htmlCls.inputTextStr + "id='" + me.pre + "foldseekchainids' value='P69905,P01942,1HHO_A' size=30> ";
            html += me.htmlCls.buttonStr + "reload_foldseek'>Align</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_mmtfid' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_mmtfid', 'Please input an BCIF/MMTF ID');
            html += "BCIF/MMTF ID: " + me.htmlCls.inputTextStr + "id='" + me.pre + "mmtfid' value='1TUP' size=8> ";
            html += me.htmlCls.buttonStr + "reload_mmtf'>Load</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_pdbid' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_pdbid', 'Please input a PDB ID');
            html += "PDB ID: " + me.htmlCls.inputTextStr + "id='" + me.pre + "pdbid' value='1TUP' size=8> ";
            html += me.htmlCls.buttonStr + "reload_pdb'>Load</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_afid' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_afid', 'Please input an AlphaFold UniProt ID');
            html += "Note: AlphaFold produces a per-residue confidence score (pLDDT) between 0 and 100:<br>";
            html += me.htmlCls.clickMenuCls.setAlphaFoldLegend() + "<br>";

            let afid = (me.cfg.afid) ? me.cfg.afid : 'A4D1S0';

            html += "<a href='https://alphafold.ebi.ac.uk/' target='_blank'>AlphaFold Uniprot</a> ID: " + me.htmlCls.inputTextStr + "id='" + me.pre + "afid' value='" + afid + "' size=10><br><br>";
            html += me.htmlCls.buttonStr + "reload_af'>Load Structure</button><br><br>"; 
            html += "PAE Map: " + me.htmlCls.buttonStr + "reload_afmap'>Load Half</button>"
                + me.htmlCls.buttonStr + "reload_afmapfull' style='margin-left:30px'>Load Full (slow)</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_refseqid' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_refseqid', 'Please input an NCBI protein accession');
            html += "NCBI Protein Accession: " + me.htmlCls.inputTextStr + "id='" + me.pre + "refseqid' value='NP_001743.1' size=8> ";
            html += me.htmlCls.buttonStr + "reload_refseq'>Load</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_opmid' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_opmid', 'Please input an OPM PDB ID');
            html += "<a href='https://opm.phar.umich.edu' target='_blank'>Orientations of Proteins in Membranes(OPM)</a> PDB ID: " + me.htmlCls.inputTextStr + "id='" + me.pre + "opmid' value='6JXR' size=8> ";
            html += me.htmlCls.buttonStr + "reload_opm'>Load</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_pdbfile' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_pdbfile', 'Please input a PDB file');
            html += "Note: Several PDB files could be concatenated into a single PDB file. Use the line \"ENDMDL\" to separate PDB files.<br><br>";
            html += "PDB File: " + me.htmlCls.inputFileStr + " id='" + me.pre + "pdbfile' size=8> ";
            html += me.htmlCls.buttonStr + "reload_pdbfile'>Load</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_pdbfile_app' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_pdbfile_app', 'Please append PDB files');
            html += "Multiple PDB Files: <input type='file' multiple id='" + me.pre + "pdbfile_app' size=8> ";
            html += me.htmlCls.buttonStr + "reload_pdbfile_app'>Append</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_rescolorfile' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_rescolorfile', 'Please input a residue color file');
            html += '<div style="width:450px;">The custom JSON file on residue colors has the following format for proteins("ALA" and "ARG") and nucleotides("G" and "A"):<br>';
            html += '{"ALA":"#C8C8C8", "ARG":"#145AFF", ..., "G":"#008000", "A":"#6080FF", ...}</div><br>';
            html += "Residue Color File: " + me.htmlCls.inputFileStr + "id='" + me.pre + "rescolorfile' size=8> ";
            html += me.htmlCls.buttonStr + "reload_rescolorfile'>Load</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_customcolor' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_customcolor', 'Please input a custom color file');
            html += " <input type='hidden' id='" + me.pre + "customcolor_chainid' value=''>";
            html += '<div style="width:450px;">The custom file for the structure has two columns separated by space or tab: ';
            html += 'residue number, and score in the range of 0-100. If you click "Apply Custom Color" button, ';
            html += 'the scores 0, 50 and 100 correspond to the three colors specified below. If you click "Apply Custom Tube", ';
            html += 'the selected residues will be displayed in a style similar to "B-factor Tube".</div><br>';
            html += "Custom File: " + me.htmlCls.inputFileStr + "id='" + me.pre + "cstcolorfile' size=8> <br><br>";
            html += "1. " + me.htmlCls.buttonStr + "reload_customcolorfile'>Apply Custom Color</button>" + me.htmlCls.buttonStr + "remove_legend' style='margin-left:30px;'>Remove Legend</button><br>";
            html += "<span style='margin-left:15px'>Score to Color: 0:</span> <select id='" + me.pre + "startColor'>";
            html += me.htmlCls.optionStr + "'red'>Red</option>";
            html += me.htmlCls.optionStr + "'green'>Green</option>";
            html += me.htmlCls.optionStr + "'blue' selected>Blue</option>";
            html += "</select>";
            html += "<span style='margin-left:30px'>50</span>: <select id='" + me.pre + "midColor'>";
            html += me.htmlCls.optionStr + "'white' selected>White</option>";
            html += me.htmlCls.optionStr + "'black'>Black</option>";
            html += "</select>";
            html += "<span style='margin-left:30px'>100</span>: <select id='" + me.pre + "endColor'>";
            html += me.htmlCls.optionStr + "'red' selected>Red</option>";
            html += me.htmlCls.optionStr + "'green'>Green</option>";
            html += me.htmlCls.optionStr + "'blue'>Blue</option>";
            html += "</select><br>";
            html += "or<br><br>";
            html += "2. " + me.htmlCls.buttonStr + "reload_customtubefile'>Apply Custom Tube</button>";

            html += "</div>";

            html += me.htmlCls.divStr + "dl_customref' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_customref', 'Please input a reference number file');
            html += '<div style="width:550px;">You can define your own reference numbers in a custom file using Excel, and then export it as a CSV file. An example file is shown below with cells separated by commas.<br>';
            html += '<pre>refnum,11,12,,21,22,,10C,11C,20C<br>';
            html += '1TUP_A,100,101,,,132,,,,<br>';
            html += '1TUP_B,110,111,,141,142,,,,<br>';
            html += '1TUP_C,,,,,,,200,201,230</pre>';
            html += 'The first row defines the reference residue numbers, which could be any strings. The 1st cell could be anything. The rest cells are reference residue numbers (e.g., 11, 21, 10C, etc.) or empty cells. Each chain has a separate row. The first cell of the second row is the chain ID "1TUP_A". The rest cells are the corresponding real residue numbers for reference residue numbers in the first row. For example, the reference numbers for residues 100, 101, and 132 in the chain 1TUP_A are 11, 12, and 22, respectively. The fourth row shows another set of reference numners for the chain "1TUP_C". It could be a chain from a different structure.<br><br>';
            html += 'To select all residues corresponding to the reference numbers, you can simplay replace ":" with "%" in the <a href="https://www.ncbi.nlm.nih.gov/Structure/icn3d/icn3d.html#selectb" target="_blank">Specification</a>. For example, "%12"  selects the residue 101 in 1TUP_A and the residue 111 in 1TUP_B. ".A%12" has the chain "A" filter and selects the residue 101 in 1TUP_A.<br>';
            html += '</div><br>';
            html += "Custom File: " + me.htmlCls.inputFileStr + "id='" + me.pre + "cstreffile' size=8> <br><br>";
            html += me.htmlCls.buttonStr + "reload_customreffile'>Apply Custom Reference Numbers</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_align' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_align', 'Please select residues in aligned sequences');
            html += "Enter the PDB IDs or MMDB IDs of the structures: <br/><br/>ID1: " + me.htmlCls.inputTextStr + "id='" + me.pre + "alignid1' value='2DN3' size=8>" + me.htmlCls.space3 + me.htmlCls.space3 + "ID2: " + me.htmlCls.inputTextStr + "id='" + me.pre + "alignid2' value='4N7N' size=8><br/><br/>";
            html += "<b>VAST+ based on VAST</b>: " + me.htmlCls.buttonStr + "reload_align_ori'>All Matching Molecules Superposed</button>" + me.htmlCls.space3 + me.htmlCls.buttonStr + "reload_align_refined'>Invariant Substructure Superposed</button><br><br>";
            html += "<b>VAST+ based on TM-align</b>: " + me.htmlCls.buttonStr + "reload_align_tmalign'>All Matching Molecules Superposed</button><br><br>";
            html += "</div>";
            
            html += me.htmlCls.divStr + "dl_alignaf' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_alignaf', 'Align AlphaFold structures');
            html += "Enter two <a href='https://alphafold.ebi.ac.uk/' target='_blank'>AlphaFold Uniprot</a> IDs: <br/><br/>ID1: " + me.htmlCls.inputTextStr + "id='" + me.pre + "alignafid1' value='P41327' size=8>" + me.htmlCls.space3 + me.htmlCls.space3 + "ID2: " + me.htmlCls.inputTextStr + "id='" + me.pre + "alignafid2' value='P41331' size=8><br/><br/>";
            html += me.htmlCls.buttonStr + "reload_alignaf_tmalign'>Align with TM-align</button>" + me.htmlCls.buttonStr + "reload_alignaf' style='margin-left:30px'>Align with VAST</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_chainalign' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_chainalign', 'Align chains');
            html += "<div style='width:550px'>";
            html += "All chains will be aligned to the first chain in the comma-separated chain IDs. Each chain ID has the form of PDBID_chain (e.g., 1HHO_A, case sensitive) or UniprotID (e.g., P69905 for AlphaFold structures).<br/><br/>";
            html += "<b>Chain IDs</b>: " + me.htmlCls.inputTextStr + "id='" + me.pre + "chainalignids' value='P69905,P01942,1HHO_A' size=50><br/><br/>";
            html += me.htmlCls.buttonStr + "reload_chainalign_tmalign'><b>Align with TM-align</b></button>" + me.htmlCls.buttonStr + "reload_chainalign_asym' style='margin-left:30px'><b>Align with VAST</b></button><br/><br/>";

            html += "(Note: To align chains in custom PDB files, you could load them in \"File > Open File > PDB Files (appendable)\" and click \"Analysis > Defined Sets\". Finally select multiple chains in Defined Sets and click \"File > Realign Selection\".)<br><br>";
            html += "</div></div>";

            html += me.htmlCls.divStr + "dl_chainalign2' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_chainalign2', 'Align chains');
            html += "<div style='width:550px'>";
            html += "All chains will be aligned to the first chain in the comma-separated chain IDs. Each chain ID has the form of PDBID_chain (e.g., 1HHO_A, case sensitive) or UniprotID (e.g., P69905 for AlphaFold structures).<br/><br/>";
            html += "<b>Chain IDs</b>: " + me.htmlCls.inputTextStr + "id='" + me.pre + "chainalignids2' value='P69905,P01942,1HHO_A' size=50><br/><br/>";

            html += "The sequence alignment (followed by structure alignment) is based on residue numbers in the First/Master chain: <br>" + me.htmlCls.inputTextStr + "id='" + me.pre + "resalignids' value='1,5,10-50' size=50><br/>";
            html += me.htmlCls.buttonStr + "reload_chainalign_asym2' style='margin-top:3px;'><b>Align by Sequence Alignment</b></button><br/><br/>";

            html += "(Note: To align chains in custom PDB files, you could load them in \"File > Open File > PDB Files (appendable)\" and click \"Analysis > Defined Sets\". Finally select multiple chains in Defined Sets and click \"File > Realign Selection\".)<br><br>";
            html += "</div></div>";

            html += me.htmlCls.divStr + "dl_chainalign3' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_chainalign3', 'Align chains');
            html += "<div style='width:550px'>";
            html += this.getHtmlAlignResidueByResidue('chainalignids3', 'predefinedres', 'reload_chainalign_asym3');
            html += "</div></div>";

            html += me.htmlCls.divStr + "dl_realignresbyres' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_realignresbyres', 'Realign residue by residue');
            html += "<div style='width:550px'>";
            html += "<b>Option 1</b>: " + me.htmlCls.buttonStr + "realignSelection'><b>Realign Current Selection Residue by Residue</b></button><br/><br/>";
            html += "<b>Option 2</b>: <br>";
            html += "<div class='icn3d-box'>" + this.getHtmlAlignResidueByResidue('chainalignids4', 'predefinedres2', 'reload_chainalign_asym4') + "</div>";
            html += "</div></div>";

            html += me.htmlCls.divStr + "dl_mutation' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_mutation', 'Mutation analysis');
            html += "<div style='width:500px'>";
            html += 'Please specify the mutations with a comma separated mutation list. Each mutation can be specified as "[<b>uppercase</b> PDB ID or AlphaFold UniProt ID]_[Chain Name]_[Residue Number]_[One Letter Mutant Residue]". E.g., the mutation of N501Y in the E chain of PDB 6M0J can be specified as "6M0J_E_501_Y". For AlphaFold structures, the "Chain ID" is "A".<br/>If you load a custom structure without PDB or UniProt ID, you can open "Seq. & Annotations" window and find the chain ID such as "stru_A". The part before the underscore is the structure ID, which can be used to specify the mutation such as "stru_A_...". Remember to choose "Show Mutation in: Current Page".<br/><br/>';
            html += "<div style='display:inline-block; width:110px'>Mutations: </div>" + me.htmlCls.inputTextStr + "id='" + me.pre + "mutationids' value='6M0J_E_484_K,6M0J_E_501_Y,6M0J_E_417_N' size=50><br/><br/>";
     
            html += '<b>ID Type</b>: ';
            html += '<input type="radio" name="' + me.pre + 'idsource" id="' + me.pre + 'type_mmdbid" value="mmdbid" checked>PDB ID';
            html += '<input type="radio" name="' + me.pre + 'idsource" id="' + me.pre + 'type_afid" value="afid" style="margin-left:20px">AlphaFold UniProt ID<br><br>';

            html += '<b>Show Mutation in</b>: ';
            html += '<input type="radio" name="' + me.pre + 'pdbsource" id="' + me.pre + 'showin_currentpage" value="currentpage">Current Page';
            html += '<input type="radio" name="' + me.pre + 'pdbsource" id="' + me.pre + 'showin_newpage" value="newpage" style="margin-left:20px" checked>New Page<br><br>';

            html += me.htmlCls.buttonStr + "reload_mutation_3d' title='Show the mutations in 3D using the scap program'>3D with scap</button>";
            html += me.htmlCls.buttonStr + "reload_mutation_inter' style='margin-left:20px' title='Show the mutations in 3D and the change of interactions'>Interactions</button>";
            html += me.htmlCls.buttonStr + "reload_mutation_pdb' style='margin-left:20px' title='Show the mutations in 3D and export the PDB of the mutant within 10 angstrom'>PDB</button>";
            html += "<br/><br/></div></div>";

            html += me.htmlCls.divStr + "dl_mol2file' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_mol2file', 'Please input a Mol2 file');
            html += "Mol2 File: " + me.htmlCls.inputFileStr + "id='" + me.pre + "mol2file' size=8> ";
            html += me.htmlCls.buttonStr + "reload_mol2file'>Load</button>";
            html += "</div>";
            html += me.htmlCls.divStr + "dl_sdffile' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_sdffile', 'Please input an SDF file');
            html += "SDF File: " + me.htmlCls.inputFileStr + "id='" + me.pre + "sdffile' size=8> ";
            html += me.htmlCls.buttonStr + "reload_sdffile'>Load</button>";
            html += "</div>";
            html += me.htmlCls.divStr + "dl_xyzfile' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_xyzfile', 'Please input an XYZ file');
            html += "XYZ File: " + me.htmlCls.inputFileStr + "id='" + me.pre + "xyzfile' size=8> ";
            html += me.htmlCls.buttonStr + "reload_xyzfile'>Load</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_clustalwfile' class='" + dialogClass + "' style='max-width:500px'>";
            html += this.addNotebookTitle('dl_clustalwfile', 'Please input a CLUSTALW MSA file');
            html += "Note the sequence names are either UniProt ID (e.g., A4D1S0 or A4D1S0_A), RefSeq ID (e.g., NP_001743), or PDB chain ID (e.g., 1HHO_A).<br><br>";
            html += "CLUSTALW File: " + me.htmlCls.inputFileStr + "id='" + me.pre + "clustalwfile' size=8> ";
            html += me.htmlCls.buttonStr + "reload_clustalwfile'>Load</button><br>";
            html += "</div>";
            html += me.htmlCls.divStr + "dl_fastafile' class='" + dialogClass + "' style='max-width:500px'>";
            html += this.addNotebookTitle('dl_fastafile', 'Please input a FASTA file');
            html += "Note the sequence IDs following the symbol \">\" contain either UniProt ID (e.g., sp| or tr|), RefSeq ID (e.g., ref|), PDB chain ID (e.g., pdb|1HHO|A), or iCn3D chain ID (e.g., A4D1S0_A, 1HHO_A).<br><br>";
            html += "FASTA File: " + me.htmlCls.inputFileStr + "id='" + me.pre + "fastafile' size=8> ";
            html += me.htmlCls.buttonStr + "reload_fastafile'>Load</button><br>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_afmapfile' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_afmapfile', 'Please input an AlphaFold PAE file');
            html += "AlphaFold PAE File: " + me.htmlCls.inputFileStr + "id='" + me.pre + "afmapfile' size=8> <br><br>";
            html += me.htmlCls.buttonStr + "reload_afmapfile'>Load Half PAE Map</button>" 
              + me.htmlCls.buttonStr + "reload_afmapfilefull' style='margin-left:30px'>Load Full PAE Map (slow)</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_urlfile' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_urlfile', 'Please input a file via URL');
            html += "File type: ";
            html += "<select id='" + me.pre + "filetype'>";
            html += me.htmlCls.optionStr + "'pdb' selected>PDB</option>";
            html += me.htmlCls.optionStr + "'mmcif'>mmCIF</option>";
            html += me.htmlCls.optionStr + "'mol2'>Mol2</option>";
            html += me.htmlCls.optionStr + "'sdf'>SDF</option>";
            html += me.htmlCls.optionStr + "'xyz'>XYZ</option>";
            html += me.htmlCls.optionStr + "'icn3dpng'>iCn3D PNG</option>";
            html += me.htmlCls.optionStr + "'pae'>AlphaFold PAE</option>";
            html += "</select><br/>";
            html += "URL in the same host: " + me.htmlCls.inputTextStr + "id='" + me.pre + "urlfile' size=20><br/> ";
            html += me.htmlCls.buttonStr + "reload_urlfile'>Load</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_mmciffile' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_mmciffile', 'Please append mmCIF files');
            html += "Multiple mmCIF Files: <input type='file' multiple id='" + me.pre + "mmciffile' size=8> ";
            html += me.htmlCls.buttonStr + "reload_mmciffile'>Load</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_mmcifid' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_mmcifid', 'Please input an mmCIF ID');
            html += "mmCIF ID: " + me.htmlCls.inputTextStr + "id='" + me.pre + "mmcifid' value='1TUP' size=8> ";
            html += me.htmlCls.buttonStr + "reload_mmcif'>Load</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_mmdbid' class='" + dialogClass + "' style='max-width:500px'>";
            html += this.addNotebookTitle('dl_mmdbid', 'Please input an MMDB ID');
            html += "MMDB or PDB ID: " + me.htmlCls.inputTextStr + "id='" + me.pre + "mmdbid' value='1TUP' size=8> <br><br>";
            html += me.htmlCls.buttonStr + "reload_mmdb'>Load Biological Unit</button>" + me.htmlCls.buttonStr + "reload_mmdb_asym' style='margin-left:30px'>Load Asymmetric Unit (All Chains)</button><br/><br/><br/>";
            html += '<b>Note</b>: The "<b>biological unit</b>" is the <b>biochemically active form of a biomolecule</b>, <div style="width:20px; margin:6px 0 0 20px; display:inline-block;"><span id="'
              + me.pre + 'asu_bu_expand" class="ui-icon ui-icon-plus icn3d-expand icn3d-link" style="width:15px;" title="Expand"></span><span id="'
              + me.pre + 'asu_bu_shrink" class="ui-icon ui-icon-minus icn3d-shrink icn3d-link" style="display:none; width:15px;" title="Shrink"></span></div>';

            html += me.htmlCls.divStr + "asu_bu' style='display:none;'>";
            html += 'which can range from a monomer (single protein molecule) to an oligomer of 100+ protein molecules.<br><br>The "<b>asymmetric unit</b>" is the raw 3D structure data resolved by X-ray crystallography, NMR, or Cryo-electron microscopy. The asymmetric unit is equivalent to the biological unit in approximately 60% of structure records. In the remaining 40% of the records, the asymmetric unit represents a portion of the biological unit that can be reconstructed using crystallographic symmetry, or it represents multiple copies of the biological unit.</div>';

            html += "</div>";

            html += me.htmlCls.divStr + "dl_mmdbafid' class='" + dialogClass + "' style='max-width:600px'>";
            html += this.addNotebookTitle('dl_mmdbafid', 'Please input a list of PDB/AlphaFold IDs');
            html += "List of PDB, MMDB, or AlphaFold UniProt structures: " + me.htmlCls.inputTextStr + "id='" + me.pre + "mmdbafid' placeholder='e.g., 1HHO,4N7N,P69905,P01942' size=30> <br><br>";
            html += "<div style='display:inline-block; width:20px'></div>" + me.htmlCls.buttonStr + "reload_mmdbaf' style='width:150px'>Load Biological Unit</button>" + me.htmlCls.buttonStr + "reload_mmdbaf_asym' style='margin-left:30px; width:250px'>Load Asymmetric Unit (All Chains)</button>" + "<br/><br/>";
            html += "<div style='display:inline-block; width:20px'>or</div>" + me.htmlCls.buttonStr + "reload_mmdbaf_append' style='width:150px'>Append Biological Unit</button>" + me.htmlCls.buttonStr + "reload_mmdbaf_asym_append' style='margin-left:30px; width:250px'>Append Asymmetric Unit (All Chains)</button>" + "<br/><br/>";

            html += '<b>Note</b>: The "<b>biological unit</b>" is the <b>biochemically active form of a biomolecule</b>, <div style="width:20px; margin:6px 0 0 20px; display:inline-block;"><span id="'
            + me.pre + 'asu_bu2_expand" class="ui-icon ui-icon-plus icn3d-expand icn3d-link" style="width:15px;" title="Expand"></span><span id="'
            + me.pre + 'asu_bu2_shrink" class="ui-icon ui-icon-minus icn3d-shrink icn3d-link" style="display:none; width:15px;" title="Shrink"></span></div>';

            html += me.htmlCls.divStr + "asu_bu2' style='display:none;'>";
            html += 'which can range from a monomer (single protein molecule) to an oligomer of 100+ protein molecules.<br><br>The "<b>asymmetric unit</b>" is the raw 3D structure data resolved by X-ray crystallography, NMR, or Cryo-electron microscopy. The asymmetric unit is equivalent to the biological unit in approximately 60% of structure records. In the remaining 40% of the records, the asymmetric unit represents a portion of the biological unit that can be reconstructed using crystallographic symmetry, or it represents multiple copies of the biological unit.</div>';

            html += "</div>";

            html += me.htmlCls.divStr + "dl_blast_rep_id' style='max-width:600px;' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_blast_rep_id', 'Align sequence to structure');
            html += "Enter a protein sequence ID (or FASTA sequence) and the aligned protein accession, which can be found using the <a href='https://blast.ncbi.nlm.nih.gov/Blast.cgi?PROGRAM=blastp&PAGE_TYPE=BlastSearch' target='_blank'>BLAST</a> search with the protein sequence ID or FASTA sequence as input. If the protein accession is not a PDB chain, the corresponding AlphaFold UniProt structure is used.<br><br> ";
            html += "<b>Protein Sequence ID</b>(NCBI protein accession of a sequence): " + me.htmlCls.inputTextStr + "id='" + me.pre + "query_id' value='NP_001108451.1' size=8><br> ";
            html += "or FASTA sequence: <br><textarea id='" + me.pre + "query_fasta' rows='5' style='width: 100%; height: " +(me.htmlCls.LOG_HEIGHT) + "px; padding: 0px; border: 0px;'></textarea><br><br>";
            html += "<b>Aligned Protein Accession</b> (or a chain of a PDB): " + me.htmlCls.inputTextStr + "id='" + me.pre + "blast_rep_id' value='1TSR_A' size=8><br> ";
            //html += me.htmlCls.buttonStr + "reload_blast_rep_id'>Load</button>";
            html += me.htmlCls.buttonStr + "reload_blast_rep_id'>Align with BLAST</button> " + me.htmlCls.wifiStr
                + me.htmlCls.buttonStr + "reload_alignsw' style='margin-left:30px'>Align with Global Smith-Waterman</button>"
                + me.htmlCls.buttonStr + "reload_alignswlocal' style='margin-left:30px'>Align with Local Smith-Waterman</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_esmfold' style='max-width:600px;' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_esmfold', 'Sequence to structure prediction with ESMFold');
            html += "The sequence to structure prediction is done via <a href='https://esmatlas.com/resources?action=fold' target='_blank'>ESM Metagenomic Atlas</a>. The sequence should be less than 400 characters. For any sequence longer than 400, please see the discussion <a href='https://github.com/facebookresearch/esm/issues/21' target='_blank'>here</a>.<br><br> ";
            html += "FASTA sequence: <br><textarea id='" + me.pre + "esmfold_fasta' rows='5' style='width: 100%; height: " +(me.htmlCls.LOG_HEIGHT) + "px; padding: 0px; border: 0px;'></textarea><br><br>";
            html += me.htmlCls.buttonStr + "run_esmfold'>ESMFold</button> ";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_yournote' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_yournote', 'Your Note');
            html += "Your note will be saved in the HTML file when you click \"File > Save File > iCn3D PNG Image\".<br><br>";
            html += "<textarea id='" + me.pre + "yournote' rows='5' style='width: 100%; height: " +(me.htmlCls.LOG_HEIGHT) + "px; padding: 0px; border: 0px;' placeholder='Enter your note here'></textarea><br>";
            html += me.htmlCls.buttonStr + "applyyournote'>Save</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_proteinname' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_proteinname', 'Please input a protein/gene name');
            html += "Protein/Gene name: " + me.htmlCls.inputTextStr + "id='" + me.pre + "proteinname' value='TP53' size=8> ";
            html += me.htmlCls.buttonStr + "reload_proteinname'>Search</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_cid' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_cid', 'Please input a PubChem Compound');
            html += "PubChem CID/Name/InchI: " + me.htmlCls.inputTextStr + "id='" + me.pre + "cid' value='2244' size=8> ";
            html += me.htmlCls.buttonStr + "reload_cid'>Load</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_smiles' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_cid', 'Please input a chemical SMILES');
            html += "Chemical SMILES: " + me.htmlCls.inputTextStr + "id='" + me.pre + "smiles' value='CC(=O)OC1=CC=CC=C1C(=O)O' size=30> ";
            html += me.htmlCls.buttonStr + "reload_smiles'>Load</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_pngimage' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_pngimage', 'Please append iCn3D PNG Image files');
            html += "Multiple iCn3D PNG images: " + me.htmlCls.inputFileStr + " multiple id='" + me.pre + "pngimage' size=8><br/>";
            html += me.htmlCls.buttonStr + "reload_pngimage' style='margin-top: 6px;'>Append</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_state' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_state', 'Please input a state file');
            html += "State file: " + me.htmlCls.inputFileStr + "id='" + me.pre + "state'><br/>";
            html += me.htmlCls.buttonStr + "reload_state' style='margin-top: 6px;'>Load</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_video' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_video', 'Save canvas changes in a video');
            html += me.htmlCls.buttonStr + "video_start' style='margin-top: 6px;'>Video Start</button>";
            html += me.htmlCls.buttonStr + "video_end' style='margin: 6px 0px 0px 30px;'>Video End</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_fixedversion' style='max-width:500px' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_fixedversion', 'Use fixed version of iCn3D');
            html += "Since January 6, 2021, you can show the original view with the archived version of iCn3D by pasting your URL below and click \"Show Originial View\". Note the version in the parameter \"v\" was used to replace \"full.html\" with \"full_[v].html\" in the URL.<br><br>";
            html += "Share Link URL: " + me.htmlCls.inputTextStr + "id='" + me.pre + "sharelinkurl' size=60><br>";
            html += me.htmlCls.buttonStr + "reload_fixedversion'>Show Original View</button><br><br>";
            html += "</div>";


            html += me.htmlCls.divStr + "dl_selection' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_selection', 'Please input the selection file');
            html += "Selection file: " + me.htmlCls.inputFileStr + "id='" + me.pre + "selectionfile'><br/>";
            html += me.htmlCls.buttonStr + "reload_selectionfile' style='margin-top: 6px;'>Load</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_selectCollections' class='" + dialogClass + "'>";
            html += me.htmlCls.divStr + "dl_collectionsMenu'>";
            html += '<b>Collection File</b>: <div style="width:20px; margin-top:6px; display:inline-block;"><span id="' + me.pre + 'dl_collection_file_expand" class="ui-icon ui-icon-plus icn3d-expand icn3d-link" style="display:none; width:15px;" title="Expand"></span><span id="' + me.pre + 'dl_collection_file_shrink" class="ui-icon ui-icon-minus icn3d-shrink icn3d-link" style="width:15px;" title="Shrink"></span></div><br>';
            html += me.htmlCls.divStr + "dl_collection_file' style=''>";
            html += "You can load a collection of structures via a file. Here are <a href='https://github.com/ncbi/icn3d/blob/master/example/collection/' target='_blank'>some example files</a><br><br>";
            html += "Collection file: " + me.htmlCls.inputFileStr + "id='" + me.pre + "collectionfile'><br/>";
            html += "<input type='radio' id='dl_collectionAppendStructureNone' name='appendStructure' value='none' checked/>";
            html += "<label for='dl_collectionAppendStructureNone'>Default</label>";
            html += "<input type='radio' id='dl_collectionAppendStructure' name='appendStructure' value='append' />";
            html += "<label for='dl_collectionAppendStructure'>Append</label><br/>";
            html += me.htmlCls.buttonStr + "reload_collectionfile' style='margin-top: 6px;'>Load</button>";
            html += "</div>";
            html += "</div>";
            html += '<br/><b>Structures</b>: <div style="width:20px; margin-top:6px; display:inline-block;"><span id="' + me.pre + 'dl_collection_structures_expand" class="ui-icon ui-icon-plus icn3d-expand icn3d-link" style="width:15px;" title="Expand"></span><span id="' + me.pre + 'dl_collection_structures_shrink" class="ui-icon ui-icon-minus icn3d-shrink icn3d-link" style="display:none; width:15px;" title="Shrink"></span></div><br>';
            html += me.htmlCls.divStr + "dl_collection_structures' style='display: none'>";
            html += "<select id='" + me.pre + "collections_menu'multiple size='6' style='min-width:300px;'></select>";
            html += '<br/>';
            html += me.htmlCls.buttonStr + "collections_clear_commands' style='margin-top: 6px;'>Clear Commands</button>";
            html += me.htmlCls.buttonStr + "opendl_export_collections'>Export JSON</button>";
            html += "</div>";
            html += '<br/>'; 
            html += "</div>";

            html += me.htmlCls.divStr + "dl_export_collections' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_export_collections', 'Export Collections');
            html += "<label for='dl_collectionTitle'>Collection Title: </label>";
            html += "<input type='text' id='dl_collectionTitle' name='collectionTitle' placeholder='Enter collection title' />";
            html += '<br/>';
            html += "<label for='dl_collectionDescription'>Collection Description: </label>";
            html += "<input type='text' id='dl_collectionDescription' name='collectionDescription' placeholder='Enter collection description' />";
            html += '<br/>';
            html += "<input type='radio' id='dl_collectionExportSelected' name='exportOption' value='selected' />";
            html += "<label for='dl_collectionExportSelected'>Selected</label>";
            html += "<input type='radio' id='dl_collectionExportAll' name='exportOption' value='all' />";
            html += "<label for='dl_collectionExportAll'>All</label>";
            html += '<br/>';
            html += me.htmlCls.buttonStr + "export_collections'>Export</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_menuloadpref' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_menuloadpref', 'Load a preference file');
            html += "Preference file: " + me.htmlCls.inputFileStr + "id='" + me.pre + "menupreffile'><br/>";
            html += me.htmlCls.buttonStr + "reload_menupreffile' style='margin-top: 6px;'>Load</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_dsn6' class='" + dialogClass + "' style='max-width:600px'>";
            html += this.addNotebookTitle('dl_dsn6', 'Load a map file');
            html += "<b>Note</b>: Always load a PDB file before loading map files. If you don't specify the threshold below, a default one will be chosen.<br/><br/><br/>";

            html += "<span style='white-space:nowrap;font-weight:bold;'>2fofc contour at default threshold or at: " 
              + me.htmlCls.inputTextStr + "id='" + me.pre + "dsn6sigma2fofc' value='' size=8> &sigma;</span><br/>";
            //html += me.htmlCls.inputFileStr + "id='" + me.pre + "dsn6file2fofc'><br>" + me.htmlCls.buttonStr + "reload_dsn6file2fofc' style='margin: 6px 20px 0 0;'>Load DSN6</button>" + me.htmlCls.buttonStr + "reload_ccp4file2fofc' style='margin: 6px 20px 0 0;'>Load CCP4</button>" + me.htmlCls.buttonStr + "reload_mtzfile2fofc' style='margin: 6px 20px 0 0;'>Load MTZ</button>" + me.htmlCls.buttonStr + "reload_rcsbmtzfile2fofc' style='margin-top: 6px;'>Load RCSB MTZ</button><br><br><br/>";
            html += me.htmlCls.inputFileStr + "id='" + me.pre + "dsn6file2fofc'><br>" + me.htmlCls.buttonStr + "reload_ccp4file2fofc' style='margin: 6px 20px 0 0;'>Load CCP4</button>" + me.htmlCls.buttonStr + "reload_mtzfile2fofc' style='margin: 6px 20px 0 0;'>Load MTZ</button>" + me.htmlCls.buttonStr + "reload_rcsbmtzfile2fofc' style='margin-top: 6px;'>Load RCSB MTZ</button><br><br><br/>";

            html += "<span style='white-space:nowrap;font-weight:bold;'>fofc contour at default threshold or at: "
              + me.htmlCls.inputTextStr + "id='" + me.pre + "dsn6sigmafofc' value='' size=8> &sigma;</span><br/>";

            //html += me.htmlCls.inputFileStr + "id='" + me.pre + "dsn6filefofc'><br>" + me.htmlCls.buttonStr + "reload_dsn6filefofc' style='margin: 6px 20px 0 0;'>Load DSN6</button>" + me.htmlCls.buttonStr + "reload_ccp4filefofc' style='margin: 6px 20px 0 0;'>Load CCP4</button>"  + me.htmlCls.buttonStr + "reload_mtzfilefofc' style='margin: 6px 20px 0 0;'>Load MTZ</button>"  + me.htmlCls.buttonStr + "reload_rcsbmtzfilefofc' style='margin-top: 6px;'>Load RCSB MTZ</button><br><br><br>";
            html += me.htmlCls.inputFileStr + "id='" + me.pre + "dsn6filefofc'><br>" + me.htmlCls.buttonStr + "reload_ccp4filefofc' style='margin: 6px 20px 0 0;'>Load CCP4</button>"  + me.htmlCls.buttonStr + "reload_mtzfilefofc' style='margin: 6px 20px 0 0;'>Load MTZ</button>"  + me.htmlCls.buttonStr + "reload_rcsbmtzfilefofc' style='margin-top: 6px;'>Load RCSB MTZ</button><br><br><br>";


            html += me.htmlCls.buttonStr + "elecmapNo4'>Remove Map</button><br>";

            html += "</div>";

            html += me.htmlCls.divStr + "dl_dsn6url' class='" + dialogClass + "' style='max-width:600px'>";
            html += this.addNotebookTitle('dl_dsn6url', 'Load a selection file via a URL');
            html += "<b>Note</b>: Always load a PDB file before loading map files. If you don't specify the threshold below, a default one will be chosen.<br/><br/><br/>";

            html += "<span style='white-space:nowrap;font-weight:bold;'>2fofc contour at default threshold or at: "
              + me.htmlCls.inputTextStr + "id='" + me.pre + "dsn6sigmaurl2fofc' value='' size=8> &sigma;</span><br/>";

            //html += "URL in the same host: " + me.htmlCls.inputTextStr + "id='" + me.pre + "dsn6fileurl2fofc' size=20><br>" + me.htmlCls.buttonStr + "reload_dsn6fileurl2fofc' style='margin: 6px 20px 0 0;'>Load DSN6</button>" + me.htmlCls.buttonStr + "reload_ccp4fileurl2fofc' style='margin: 6px 20px 0 0;'>Load CCP4</button>" + me.htmlCls.buttonStr + "reload_mtzfileurl2fofc' style='margin: 6px 20px 0 0;'>Load MTZ</button>" + me.htmlCls.buttonStr + "reload_rcsbmtzfileurl2fofc' style='margin-top: 6px;'>Load RCSB MTZ</button><br><br><br/>";

            html += "URL in the same host: " + me.htmlCls.inputTextStr + "id='" + me.pre + "dsn6fileurl2fofc' size=20><br>" + me.htmlCls.buttonStr + "reload_ccp4fileurl2fofc' style='margin: 6px 20px 0 0;'>Load CCP4</button>" + me.htmlCls.buttonStr + "reload_mtzfileurl2fofc' style='margin: 6px 20px 0 0;'>Load MTZ</button>" + me.htmlCls.buttonStr + "reload_rcsbmtzfileurl2fofc' style='margin-top: 6px;'>Load RCSB MTZ</button><br><br><br/>";

            html += "<span style='white-space:nowrap;font-weight:bold;'>fofc contour at default threshold or at: "
            + me.htmlCls.inputTextStr + "id='" + me.pre + "dsn6sigmaurlfofc' value='' size=8> &sigma;</span><br/>";

            //html += "URL in the same host: " + me.htmlCls.inputTextStr + "id='" + me.pre + "dsn6fileurlfofc' size=20><br>" + me.htmlCls.buttonStr + "reload_dsn6fileurlfofc' style='margin: 6px 20px 0 0;'>Load DSN6</button>" + me.htmlCls.buttonStr + "reload_ccp4fileurlfofc' style='margin: 6px 20px 0 0;'>Load CCP4</button>"  + me.htmlCls.buttonStr + "reload_mtzfileurlfofc' style='margin: 6px 20px 0 0;'>Load MTZ</button>"  + me.htmlCls.buttonStr + "reload_rcsbmtzfileurlfofc' style='margin-top: 6px;'>Load RCSB MTZ</button><br><br><br>";

            html += "URL in the same host: " + me.htmlCls.inputTextStr + "id='" + me.pre + "dsn6fileurlfofc' size=20><br>" + me.htmlCls.buttonStr + "reload_ccp4fileurlfofc' style='margin: 6px 20px 0 0;'>Load CCP4</button>"  + me.htmlCls.buttonStr + "reload_mtzfileurlfofc' style='margin: 6px 20px 0 0;'>Load MTZ</button>"  + me.htmlCls.buttonStr + "reload_rcsbmtzfileurlfofc' style='margin-top: 6px;'>Load RCSB MTZ</button><br><br><br>";

            html += me.htmlCls.buttonStr + "elecmapNo5'>Remove Map</button><br>";

            html += "</div>";

            html += me.htmlCls.divStr + "dl_clr' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_clr', 'Pick a color');
            html += "Click in the input box to use the color picker:<br><br> ";
            html += "Custom Color: " + me.htmlCls.inputTextStr + "id='" + me.pre + "colorcustom' value='FF0000' size=8> ";
            html += me.htmlCls.buttonStr + "applycustomcolor'>Apply</button>";
            html += "</div>";

            html += me.htmlCls.setHtmlCls.getPotentialHtml('delphi', dialogClass);

            html += me.htmlCls.setHtmlCls.getPotentialHtml('local', dialogClass);
            html += me.htmlCls.setHtmlCls.getPotentialHtml('url', dialogClass);

            html += me.htmlCls.divStr + "dl_symmetry' class='" + dialogClass + "'><br>";
            html += this.addNotebookTitle('dl_symmetry', 'Symmetry');
            html += me.htmlCls.divNowrapStr + "Symmetry: <select id='" + me.pre + "selectSymmetry'>";
            html += "</select>" + me.htmlCls.space3;
            html += me.htmlCls.buttonStr + "applysymmetry'>Apply</button>" + me.htmlCls.space3;
            html += me.htmlCls.buttonStr + "clearsymmetry'>Clear</button></div>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_symd' style='max-width:400px' class='" + dialogClass + "'><br>";
            html += this.addNotebookTitle('dl_symd', 'Dynamically symmetry calculation using SymD');

            html += "</div>";

            html += me.htmlCls.divStr + "dl_contact' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_contact', 'Contact Map');
            html += "<span style='white-space:nowrap;font-weight:bold;'>Distance: <select id='" + me.pre + "contactdist'>";
            html += me.htmlCls.setHtmlCls.getOptionHtml(['4', '5', '6', '7', '8', '9', '10'], 4);
            html += "</select></span>";
            html += "<span style='margin-left:30px; white-space:nowrap;font-weight:bold;'>Contact Type: <select id='" + me.pre + "contacttype'>";
            html += me.htmlCls.optionStr + "'calpha' >between C-alpha Atoms</option>";
            html += me.htmlCls.optionStr + "'cbeta' selected>between C-beta Atoms</option>";
            html += me.htmlCls.optionStr + "'heavyatoms' >between Heavy Atoms</option>";
            html += "</select></span><br><br>";
            html += "<span style='white-space:nowrap;'>" + me.htmlCls.buttonStr + "applycontactmap'>Display</button></span><br>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_hbonds' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_hbonds', 'Interaction Analysis');
            html += "1. Choose interaction types and their thresholds:<br>";
            html += "<div class='icn3d-box'><table border=0 width=450><tr>";
            html += "<td style='white-space:nowrap'>" + me.htmlCls.inputCheckStr + "id='" + me.pre + "analysis_hbond' checked>Hydrogen Bonds <span style='background-color:#" + me.htmlCls.hbondColor + "'>" + me.htmlCls.space3 + "</span></td>";
            html += "<td>";
            html += me.htmlCls.divNowrapStr + " <select id='" + me.pre + "hbondthreshold'>";

            let optArray2 = ['3.2', '3.3', '3.4', '3.5', '3.6', '3.7', '3.8', '3.9', '4.0', '4.1', '4.2'];
            html += me.htmlCls.setHtmlCls.getOptionHtml(optArray2, 6);

            html += "</select> &#197;" + me.htmlCls.space3 + "</div></td>";
            html += "<td style='white-space:nowrap'>" + me.htmlCls.inputCheckStr + "id='" + me.pre + "analysis_saltbridge' checked>Salt Bridge/Ionic <span style='background-color:#" + me.htmlCls.ionicColor + "'>" + me.htmlCls.space3 + "</span></td>";
            html += "<td>";
            html += me.htmlCls.divNowrapStr + " <select id='" + me.pre + "saltbridgethreshold'>";

            let optArray3 = ['3', '4', '5', '6', '7', '8'];
            html += me.htmlCls.setHtmlCls.getOptionHtml(optArray3, 3);

            html += "</select> &#197;" + me.htmlCls.space3 + "</div></td>";
            html += "<td style='white-space:nowrap'>" + me.htmlCls.inputCheckStr + "id='" + me.pre + "analysis_contact' checked>Contacts/Interactions <span style='background-color:#" + me.htmlCls.contactColor + "'>" + me.htmlCls.space3 + "</span></td>";
            html += "<td>";
            html += me.htmlCls.divNowrapStr + " <select id='" + me.pre + "contactthreshold'>";

            html += me.htmlCls.setHtmlCls.getOptionHtml(optArray3, 1);

            html += "</select> &#197;" + me.htmlCls.space3 + "</div></td>";
            html += "</tr>";

            html += "<tr>";
            html += "<td style='white-space:nowrap'>" + me.htmlCls.inputCheckStr + "id='" + me.pre + "analysis_halogen' checked>Halogen Bonds <span style='background-color:#" + me.htmlCls.halogenColor + "'>" + me.htmlCls.space3 + "</span></td>";
            html += "<td>";
            html += me.htmlCls.divNowrapStr + " <select id='" + me.pre + "halogenthreshold'>";

            html += me.htmlCls.setHtmlCls.getOptionHtml(optArray2, 6);

            html += "</select> &#197;" + me.htmlCls.space3 + "</div></td>";
            html += "<td style='white-space:nowrap'>" + me.htmlCls.inputCheckStr + "id='" + me.pre + "analysis_pication' checked>&pi;-Cation <span style='background-color:#" + me.htmlCls.picationColor + "'>" + me.htmlCls.space3 + "</span></td>";
            html += "<td>";
            html += me.htmlCls.divNowrapStr + " <select id='" + me.pre + "picationthreshold'>";

            html += me.htmlCls.setHtmlCls.getOptionHtml(optArray3, 3);

            html += "</select> &#197;" + me.htmlCls.space3 + "</div></td>";
            html += "<td style='white-space:nowrap'>" + me.htmlCls.inputCheckStr + "id='" + me.pre + "analysis_pistacking' checked>&pi;-Stacking <span style='background-color:#" + me.htmlCls.pistackingColor + "'>" + me.htmlCls.space3 + "</span></td>";
            html += "<td>";
            html += me.htmlCls.divNowrapStr + " <select id='" + me.pre + "pistackingthreshold'>";

            html += me.htmlCls.setHtmlCls.getOptionHtml(['3', '4', '5'], 99);

            html += me.htmlCls.optionStr + "'5.5' selected>5.5</option>";

            html += me.htmlCls.setHtmlCls.getOptionHtml(['6', '7', '8'], 99);

            html += "</select> &#197;" + me.htmlCls.space3 + "</div></td>";
            html += "</tr></table></div>";

            html += "<table border=0 width=400 cellspacing=10><tr><td>";

            html += me.htmlCls.divNowrapStr + "2. Select the first set:</div>";
            html += "<div style='text-indent:1.1em'><select style='max-width:200px' id='" + me.pre + "atomsCustomHbond2' multiple size='5' style='min-width:130px;'>";
            html += "</select></div>";

            html += "</td><td>";

            html += me.htmlCls.divNowrapStr + "3. Select the second set:</div>";
            html += "<div style='text-indent:1.1em'><select style='max-width:200px' id='" + me.pre + "atomsCustomHbond' multiple size='5' style='min-width:130px;'>";
            html += "</select></div>";

            html += "</td></tr></table>";
            
            html += "<div>4. " + me.htmlCls.buttonStr + "applyhbonds'>3D Display Interactions</button></div><br>";

            html += "<div style='text-indent:1.1em'>" + me.htmlCls.buttonStr + "hbondWindow'>Highlight Interactions in Table</button><span style='margin-left:30px; font-wieght:bold'>Sort Interactions on</span>: " + me.htmlCls.buttonStr + "sortSet1'> Set 1</button>" + me.htmlCls.buttonStr + "sortSet2' style='margin-left:12px'>Set 2</button></div><br>";

            html += "<div style='text-indent:1.1em'>" + me.htmlCls.buttonStr + "hbondLineGraph'>2D Interaction Network</button> " + me.htmlCls.buttonStr + "hbondLineGraph2' style='margin-left:12px'>2D Network with Reference Numbers</button> to show two lines of residue nodes</div><br>";

            html += "<div style='text-indent:1.1em'>" + me.htmlCls.buttonStr + "hbondScatterplot'>2D Interaction Map</button> " + me.htmlCls.buttonStr + "hbondScatterplot2' style='margin-left:12px'>2D Map with Reference Numbers</button> to show map</div><br>";

            html += "<div style='text-indent:1.1em'>" + me.htmlCls.buttonStr + "hbondLigplot'>2D Interaction for One Ligand/Residue</button> with atom details</div><br>";

            tmpStr = ': </td><td><input style="margin-left:-12px" type="text" id="';

            html += "<div style='text-indent:1.1em'>" + me.htmlCls.buttonStr + "hbondGraph'>2D Graph(Force-Directed)</button> to show interactions with strength parameters in 0-200:</div>";
            html += '<div style="text-indent:1.1em"><table><tr><td>Helix or Sheet' + tmpStr + me.pre + 'dist_ss" size="4" value="100"></td>';
            html += '<td>Coil or Nucleotide' + tmpStr + me.pre + 'dist_coil" size="4" value="50"></td>';
            html += '<td>Disulfide Bonds' + tmpStr + me.pre + 'dist_ssbond" size="4" value="50"></td></tr>';
            html += '<tr><td>Hydrogen Bonds' + tmpStr + me.pre + 'dist_hbond" size="4" value="50"></td>';
            html += '<td>Salt Bridge/Ionic' + tmpStr + me.pre + 'dist_ionic" size="4" value="50"></td>';
            html += '<td>Contacts' + tmpStr + me.pre + 'dist_inter" size="4" value="25"></td></tr>';
            html += '<tr><td>Halogen Bonds' + tmpStr + me.pre + 'dist_halogen" size="4" value="50"></td>';
            html += '<td>&pi;-Cation' + tmpStr + me.pre + 'dist_pication" size="4" value="50"></td>';
            html += '<td>&pi;-Stacking' + tmpStr + me.pre + 'dist_pistacking" size="4" value="50"></td></tr></table></div>';
            html += '<div style="text-indent:1.1em">(Note: you can also adjust thresholds at #1 to add/remove interactions.)</div><br>';

        //    html += "<div style='text-indent:1.1em'>" + me.htmlCls.buttonStr + "hbondExport'>Save</button> H-bond/contact pairs in a file</div><br>";
            html += "<div style='text-indent:1.1em'>" + me.htmlCls.buttonStr + "areaWindow'>Buried Surface Area</button></div><br>";

            html += "<div>5. " + me.htmlCls.buttonStr + "hbondReset'>Reset</button> and select new sets</div>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_realign' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_realign', 'Realign by sequence');

            html += me.htmlCls.divNowrapStr + "1. Select sets below <br>or use your current selection:</div><br>";
            html += "<div style='text-indent:1.1em'><select id='" + me.pre + "atomsCustomRealign' multiple size='5' style='min-width:130px;'>";
            html += "</select></div><br>";

            html += "<div>2. " + me.htmlCls.buttonStr + "applyRealign'>Realign by Sequence</button></div><br>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_realignbystruct' class='" + dialogClass + "' style='max-width:500px'>";
            html += this.addNotebookTitle('dl_realignbystruct', 'Realign by structure');

            //html += "<div><b>1</b>. There are two options to align chains. Option \"a\" is to select a list of chains below, and align all chains to the first chain. Option \"b\" is to select sets below or use your current selection, and align all chains pairwise.</div><br>";
            html += "<div><b>1</b>. Select sets below or use your current selection.</div><br>";
            html += "<div style='text-indent:1.1em'><select id='" + me.pre + "atomsCustomRealignByStruct' multiple size='5' style='min-width:130px;'>";
            html += "</select></div><br>";

            // some issues in aligning 4orz_C and 5esv_H due to insertion code
            //html += "<div><b>2a</b>. <div style='display:inline-block; width:170px'>Align to First Chain:</div> " + me.htmlCls.buttonStr + "applyRealignByStructMsa_tmalign'>Realign with TM-align</button>" + me.htmlCls.buttonStr + "applyRealignByStructMsa' style='margin-left:30px'>Realign with VAST</button></div><br>";

            //html += "<div>or <b>2b</b>. <div style='display:inline-block; width:155px'>Align All Chains Pairwise:</div> " + me.htmlCls.buttonStr + "applyRealignByStruct_tmalign'>Realign with TM-align</button>" + me.htmlCls.buttonStr + "applyRealignByStruct' style='margin-left:30px'>Realign with VAST</button></div><br>";
            html += "<div><b>2</b>. " + me.htmlCls.buttonStr + "applyRealignByStruct_tmalign'>Realign with TM-align</button>" + me.htmlCls.buttonStr + "applyRealignByStruct' style='margin-left:30px'>Realign with VAST</button></div><br>";

            html += "</div>";

            html += me.htmlCls.divStr + "dl_realigntwostru' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_realigntwostru', 'Realign two structure complexes');

            html += me.htmlCls.divNowrapStr + "1. Select sets below or use your current selection:</div><br>";
            html += "<div style='text-indent:1.1em'><select id='" + me.pre + "atomsCustomRealignByStruct2' multiple size='5' style='min-width:130px;'>";
            html += "</select></div><br>";

            html += "2. Overall maximum RMSD: " + me.htmlCls.inputTextStr + "id='" + me.pre + "maxrmsd' value='30' size='2'> &#197; <br><br>";

            html += "<div>3. " + me.htmlCls.buttonStr + "applyRealignByStruct_vastplus'>VAST+ Alignment based on TM-align</button></div><br>";
            html += "</div>";


            html += me.htmlCls.divStr + "dl_colorspectrumacrosssets' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_colorspectrumacrosssets', 'Set color spectrum across sets');

            html += me.htmlCls.divNowrapStr + "1. Select sets below:</div><br>";
            html += "<div style='text-indent:1.1em'><select id='" + me.pre + "atomsCustomColorSpectrumAcross' multiple size='5' style='min-width:130px;'>";
            html += "</select></div>";

            html += "<div>2. " + me.htmlCls.buttonStr + "applyColorSpectrumAcrossSets'>Spectrum Color for Sets</button></div><br>";
            html += "</div>";

            
            html += me.htmlCls.divStr + "dl_colorspectrumbysets' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_colorspectrumbysets', 'Set color spectrum for residues in sets');
            html += me.htmlCls.divNowrapStr + "1. Select sets below:</div><br>";
            html += "<div style='text-indent:1.1em'><select id='" + me.pre + "atomsCustomColorSpectrum' multiple size='5' style='min-width:130px;'>";
            html += "</select></div>";

            html += "<div>2. " + me.htmlCls.buttonStr + "applyColorSpectrumBySets'>Spectrum Color for Residues in Sets</button></div><br>";
            html += "</div>";

            
            html += me.htmlCls.divStr + "dl_colorrainbowacrosssets' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_colorrainbowacrosssets', 'Set color rainbow across sets');
            html += me.htmlCls.divNowrapStr + "1. Select sets below:</div><br>";
            html += "<div style='text-indent:1.1em'><select id='" + me.pre + "atomsCustomColorRainbowAcross' multiple size='5' style='min-width:130px;'>";
            html += "</select></div>";

            html += "<div>2. " + me.htmlCls.buttonStr + "applyColorRainbowAcrossSets'>Rainbow Color for Sets</button></div><br>";
            html += "</div>";


            html += me.htmlCls.divStr + "dl_colorrainbowbysets' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_colorrainbowbysets', 'Set color rainbow for residues in sets');
            html += me.htmlCls.divNowrapStr + "1. Select sets below:</div><br>";
            html += "<div style='text-indent:1.1em'><select id='" + me.pre + "atomsCustomColorRainbow' multiple size='5' style='min-width:130px;'>";
            html += "</select></div>";

            html += "<div>2. " + me.htmlCls.buttonStr + "applyColorRainbowBySets'>Rainbow Color for Residues in Sets</button></div><br>";
            html += "</div>";


            html += me.htmlCls.divStr + "dl_allinteraction' style='background-color:white' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_allinteraction', 'All interactions', true);
            html += "</div>";

            html += me.htmlCls.divStr + "dl_interactionsorted' style='background-color:white' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_interactionsorted', 'Sorted interactions', true);
            html += "</div>";

            html += me.htmlCls.divStr + "dl_linegraph' style='background-color:white' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_linegraph', '2D Interaction Network');

            html += me.htmlCls.divNowrapStr + '<div style="width:20px; margin-top:6px; display:inline-block;"><span id="'
              + me.pre + 'dl_linegraphcolor_expand" class="ui-icon ui-icon-plus icn3d-expand icn3d-link" style="display:none; width:15px;" title="Expand"></span><span id="'
              + me.pre + 'dl_linegraphcolor_shrink" class="ui-icon ui-icon-minus icn3d-shrink icn3d-link" style="width:15px;" title="Shrink"></span></div>';

            html += me.htmlCls.space2 + "Hold Ctrl key to select multiple nodes/lines.</div>";

            html += me.htmlCls.divStr + "dl_linegraphcolor' style='display:block;'>";

            html += me.htmlCls.setHtmlCls.setColorHints();

            html += "</div><br>";

            //let buttonStrTmp = '<button class="icn3d-commandTitle" style="-webkit-appearance:button; height:24px;background-color:#DDD;" id="';

            me.linegraphid = me.pre + 'linegraph';
            html += me.htmlCls.divNowrapStr + buttonStrTmp + me.linegraphid + '_svg">SVG</button>' + me.htmlCls.space2;
            html += buttonStrTmp + me.linegraphid + '_png">PNG</button>' + me.htmlCls.space2;
            html += buttonStrTmp + me.linegraphid + '_json">JSON</button>' + me.htmlCls.space4;
            html += "<b>Scale</b>: <select id='" + me.linegraphid + "_scale'>";

            let optArray4 = ['0.1', '0.2', '0.4', '0.6', '0.8', '1', '2', '4', '6', '8', '10'];
            html += me.htmlCls.setHtmlCls.getOptionHtml(optArray4, 5);

            html += "</select></div><br>";
            html += '<div id="' + me.pre + 'linegraphDiv"></div>';

            html += "</div>";

            html += me.htmlCls.divStr + "dl_scatterplot' style='background-color:white' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_scatterplot', '2D Interaction Map');

            html += me.htmlCls.divNowrapStr + "Hold Ctrl key to select multiple nodes." + me.htmlCls.space3;

            html += '<div style="width:20px; margin-top:6px; display:inline-block;"><span id="'
              + me.pre + 'dl_scatterplotcolor_expand" class="ui-icon ui-icon-plus icn3d-expand icn3d-link" style="width:15px;" title="Expand"></span><span id="'
              + me.pre + 'dl_scatterplotcolor_shrink" class="ui-icon ui-icon-minus icn3d-shrink icn3d-link" style="display:none; width:15px;" title="Shrink"></span></div></div>';
            html += me.htmlCls.divStr + "dl_scatterplotcolor' style='display:none;'>";

            html += me.htmlCls.setHtmlCls.setColorHints();

            html += "</div>";

            me.scatterplotid = me.pre + 'scatterplot';
            html += me.htmlCls.divNowrapStr + buttonStrTmp + me.scatterplotid + '_svg">SVG</button>' + me.htmlCls.space2;
            html += buttonStrTmp + me.scatterplotid + '_png">PNG</button>' + me.htmlCls.space2;
            html += buttonStrTmp + me.scatterplotid + '_json">JSON</button>' + me.htmlCls.space4;
            html += "<b>Scale</b>: <select id='" + me.scatterplotid + "_scale'>";

            html += me.htmlCls.setHtmlCls.getOptionHtml(optArray4, 5);

            html += "</select></div><br>";
            html += '<div id="' + me.pre + 'scatterplotDiv"></div>';

            html += "</div>";


            html += me.htmlCls.divStr + "dl_ligplot' style='background-color:white' class='" + dialogClass + "'>";

            if(me.cfg.cid !== undefined || me.cfg.smiles !== undefined) {
                html += this.addNotebookTitle('dl_ligplot', '2D Depiction for Chemicals');
            }
            else {
                html += this.addNotebookTitle('dl_ligplot', '2D Interaction for One Ligand/Residue with Atom Details');

                html += me.htmlCls.divNowrapStr + "<b>Note</b>: Nodes/Residues can be dragged. Both nodes and dashed lines/interactions can be clicked to select residues. " + me.htmlCls.space3;

                html += '<div style="width:20px; margin-top:6px; display:inline-block;"><span id="'
                + me.pre + 'dl_ligplotcolor_expand" class="ui-icon ui-icon-plus icn3d-expand icn3d-link" style="display:none; width:15px;" title="Expand"></span><span id="'
                + me.pre + 'dl_ligplotcolor_shrink" class="ui-icon ui-icon-minus icn3d-shrink icn3d-link" style="width:15px;" title="Shrink"></span></div></div>';

                html += me.htmlCls.divStr + "dl_ligplotcolor' style='inline-block;'>";

                // html += "The real interaction distances are not in scale, and are about twice the distances of dashed line segments.<br>Some \"Contact\" lines are only shown partially to simplify the view.<br>";
                // html += "Mouseover the dashed lines to see interaction types and distances.<br>";
                html += "<b>Color legend</b> for interactions (dashed lines): <br>";

                html += me.htmlCls.setHtmlCls.setColorHints();

                html += "<br></div>";
            }

            me.ligplotid = me.pre + 'ligplot';
            html += me.htmlCls.divNowrapStr + buttonStrTmp + me.ligplotid + '_svg">SVG</button>' + me.htmlCls.space2;
            html += buttonStrTmp + me.ligplotid + '_png">PNG</button>' + me.htmlCls.space2;
            // html += buttonStrTmp + me.ligplotid + '_json">JSON</button>' + me.htmlCls.space4;
            html += "<b>Scale</b>: <select id='" + me.ligplotid + "_scale'>";

            html += me.htmlCls.setHtmlCls.getOptionHtml(optArray4, 5);

            html += "</select></div><br>";
            html += '<div id="' + me.pre + 'ligplotDiv"></div>';

            html += "</div>";



            html += me.htmlCls.divStr + "dl_contactmap' style='background-color:white' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_contactmap', 'Contact Map');

            html += me.htmlCls.divNowrapStr + "Hold Ctrl key to select multiple nodes." + me.htmlCls.space3 + "</div>";

            me.contactmapid = me.pre + 'contactmap';
            html += me.htmlCls.divNowrapStr + buttonStrTmp + me.contactmapid + '_svg">SVG</button>' + me.htmlCls.space2;
            html += buttonStrTmp + me.contactmapid + '_png">PNG</button>' + me.htmlCls.space2;
            html += buttonStrTmp + me.contactmapid + '_json">JSON</button>' + me.htmlCls.space4;
            html += "<b>Scale</b>: <select id='" + me.contactmapid + "_scale'>";

            let optArray5 = ['0.01', '0.02', '0.04', '0.06', '0.08', '0.1', '0.2', '0.4', '0.6', '0.8', '1'];
            html += me.htmlCls.setHtmlCls.getOptionHtml(optArray5, 10);

            html += "</select></div><br>";
            html += '<div id="' + me.pre + 'contactmapDiv"></div>';

            html += "</div>";

            html += me.htmlCls.divStr + "dl_alignerrormap' style='background-color:white' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_alignerrormap', 'PAE Map');

            html += me.htmlCls.divNowrapStr + "Hold Ctrl key to select multiple nodes." + me.htmlCls.space3 + "</div>";
          
            me.alignerrormapid = me.pre + 'alignerrormap';
            html += me.htmlCls.divNowrapStr + buttonStrTmp + me.alignerrormapid + '_svg">SVG</button>' + me.htmlCls.space2;
            html += buttonStrTmp + me.alignerrormapid + '_png">PNG (slow)</button>' + me.htmlCls.space2;
            html += buttonStrTmp + me.alignerrormapid + '_json">JSON</button>' + me.htmlCls.space4;
            html += '<b>Scale</b>: <select id="' + me.alignerrormapid + '_scale">';

            //let optArray5 = ['0.01', '0.02', '0.04', '0.06', '0.08', '0.1', '0.2', '0.4', '0.6', '0.8', '1'];
            html += me.htmlCls.setHtmlCls.getOptionHtml(optArray5, 2);

            html += "</select></div><br>";

            //min: 004d00, max: FFFFFF
            let startColorStr = '#004d00';
            let endColorStr = '#FFFFFF';
            let rangeStr = startColorStr + ' 0%, ' + endColorStr + ' 100%';

            html += "<div style='width:200px'><div style='height: 12px; border: 1px solid #000; background: linear-gradient(to right, " + rangeStr + ");'></div>";
            html += "<table width='100%' border='0' cellspacing='0' cellpadding='0'><tr><td width='15%'>0</td><td width='15%'>5</td><td width='15%'>10</td><td width='15%'>15</td><td width='15%'>20</td><td width='15%'>25</td><td>30</td></tr><tr><td colspan='7' align='center'>Expected position error (Angstroms)</td></tr></table></div><br>";
      
            html += '<div id="' + me.pre + 'alignerrormapDiv"></div>';

            html += "</div>";

            html += me.htmlCls.divStr + "dl_elecmap2fofc' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_elecmap2fofc', 'Electron Density 2F0-Fc Map');
            html += "<span style='white-space:nowrap;font-weight:bold;'>Contour at: <select id='" + me.pre + "sigma2fofc'>";

            let optArray1 = ['0', '0.5', '1', '1.5', '2', '3', '4', '5', '6', '7', '8', '9', '10'];
            html += me.htmlCls.setHtmlCls.getOptionHtml(optArray1, 3);

            html += "</select> &sigma;</span> <span style='white-space:nowrap; margin-left:30px;'>" + me.htmlCls.buttonStr + "applymap2fofc'>Display</button></span> <span style='white-space:nowrap; margin-left:30px;'>" + me.htmlCls.buttonStr + "elecmapNo2'>Remove Map</button></span>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_elecmapfofc' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_elecmapfofc', 'Electron Density F0-Fc Map');
            html += "<span style='white-space:nowrap;font-weight:bold;'>Contour at: <select id='" + me.pre + "sigmafofc'>";

            html += me.htmlCls.setHtmlCls.getOptionHtml(optArray1, 5);

            html += "</select> &sigma;</span> <span style='white-space:nowrap; margin-left:30px;'>" + me.htmlCls.buttonStr + "applymapfofc'>Display</button></span> <span style='white-space:nowrap; margin-left:30px;'>" + me.htmlCls.buttonStr + "elecmapNo3'>Remove Map</button></span>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_emmap' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_emmap', 'EM Density Map');
            html += "<span style='white-space:nowrap;font-weight:bold;'>Contour at: <select id='" + me.pre + "empercentage'>";

            html += me.htmlCls.setHtmlCls.getOptionHtml(['0', '10', '20', '30', '40', '50', '60', '70', '80', '90', '100'], 3);

            html += "</select> % of maximum EM values</span><br><span style='white-space:nowrap; margin-left:30px;'>" + me.htmlCls.buttonStr + "applyemmap'>Display</button></span> <span style='white-space:nowrap; margin-left:30px;'>" + me.htmlCls.buttonStr + "emmapNo2'>Remove EM Map</button></span>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_aroundsphere' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_aroundsphere', 'Select a sphere around a set of residues');
            html += me.htmlCls.divNowrapStr + "1. Select the first set:</div>";
            html += "<div style='text-indent:1.1em'><select id='" + me.pre + "atomsCustomSphere2' multiple size='3' style='min-width:130px;'>";
            html += "</select></div><br>";
            html += me.htmlCls.divNowrapStr + "2. Sphere with a radius: " + me.htmlCls.inputTextStr + "id='" + me.pre + "radius_aroundsphere' value='4' size='2'> &#197;</div><br/>";

            html += me.htmlCls.divNowrapStr + "3. Select the second set to apply the sphere:</div>";
            html += "<div style='text-indent:1.1em'><select id='" + me.pre + "atomsCustomSphere' multiple size='3' style='min-width:130px;'>";
            html += "</select></div><br>";

            html += me.htmlCls.divNowrapStr + "4. " + me.htmlCls.buttonStr + "applypick_aroundsphere'>Display</button> the sphere around the first set of atoms</div><br>";
            html += "<div style='text-indent:1.1em'>" + me.htmlCls.buttonStr + "sphereExport'>Save</button> interacting/contacting residue pairs in a file</div>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_adjustmem' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_adjustmem', 'Adjust membranes');
            html += "<b>Note</b>: The membranes are parallel to the X-Y plane. The center of the membranes is at Z = 0. <br/><br/>";
            html += me.htmlCls.divNowrapStr + "1. Extracellular membrane Z-axis position: " + me.htmlCls.inputTextStr + "id='" + me.pre + "extra_mem_z' value='' size='3'> &#197;</div><br/>";
            html += me.htmlCls.divNowrapStr + "2. intracellular membrane Z-axis position: " + me.htmlCls.inputTextStr + "id='" + me.pre + "intra_mem_z' value='' size='3'> &#197;</div><br/>";
            html += me.htmlCls.divNowrapStr + "3. " + me.htmlCls.buttonStr + "apply_adjustmem'>Display</button> the adjusted membranes</div><br>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_selectplane' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_selectplane', 'Select a plane');
            html += "<b>Note</b>: The membranes are parallel to the X-Y plane. The center of the membranes is at Z = 0. <br/><br/>";
            html += me.htmlCls.divNowrapStr + "1. Z-axis position of the first X-Y plane: " + me.htmlCls.inputTextStr + "id='" + me.pre + "selectplane_z1' value='15' size='3'> &#197;</div><br/>";
            html += me.htmlCls.divNowrapStr + "2. Z-axis position of the second X-Y plane: " + me.htmlCls.inputTextStr + "id='" + me.pre + "selectplane_z2' value='-15' size='3'> &#197;</div><br/>";
            html += me.htmlCls.divNowrapStr + "3. " + me.htmlCls.buttonStr + "apply_selectplane'>Save</button> the region between the planes to Defined Sets</div><br>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_addlabel' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_addlabel', 'Add labels between two atoms');
            html += "1. Text: " + me.htmlCls.inputTextStr + "id='" + me.pre + "labeltext' value='Text' size=4><br/>";
            html += "2. Size: " + me.htmlCls.inputTextStr + "id='" + me.pre + "labelsize' value='18' size=4 maxlength=2><br/>";
            html += "3. Color: " + me.htmlCls.inputTextStr + "id='" + me.pre + "labelcolor' value='" + defaultColor + "' size=4><br/>";
            //html += "4. Background: " + me.htmlCls.inputTextStr + "id='" + me.pre + "labelbkgd' value='' size=4><br/>";
            if(me.utilsCls.isMobile()) {
                html += me.htmlCls.spanNowrapStr + "4. Touch TWO atoms</span><br/>";
            }
            else {
                html += me.htmlCls.spanNowrapStr + "4. Pick TWO atoms while holding \"Alt\" key</span><br/>";
            }
            html += me.htmlCls.spanNowrapStr + "5. " + me.htmlCls.buttonStr + "applypick_labels'>Display</button></span>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_addlabelselection' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_addlabelselection', 'Add labels for your selection');
            html += "1. Text: " + me.htmlCls.inputTextStr + "id='" + me.pre + "labeltext2' value='Text' size=4><br/>";
            html += "2. Size: " + me.htmlCls.inputTextStr + "id='" + me.pre + "labelsize2' value='18' size=4 maxlength=2><br/>";
            html += "3. Color: " + me.htmlCls.inputTextStr + "id='" + me.pre + "labelcolor2' value='" + defaultColor + "' size=4><br/>";
            //html += "4. Background: " + me.htmlCls.inputTextStr + "id='" + me.pre + "labelbkgd2' value='' size=4><br/>";
            html += me.htmlCls.spanNowrapStr + "4. " + me.htmlCls.buttonStr + "applyselection_labels'>Display</button></span>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_labelColor' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_labelColor', 'Change label color');
            html += "Color for all labels: " + me.htmlCls.inputTextStr + "id='" + me.pre + "labelcolorall' value='" + defaultColor + "' size=4><br/><br/>";
            html += me.htmlCls.spanNowrapStr + me.htmlCls.buttonStr + "applylabelcolor'>Display</button></span>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_distance' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_distance', 'Measure distance');
            if(me.utilsCls.isMobile()) {
                html += me.htmlCls.spanNowrapStr + "1. Touch TWO atoms</span><br/>";
            }
            else {
                html += me.htmlCls.spanNowrapStr + "1. Pick TWO atoms while holding \"Alt\" key</span><br/>";
            }
            html += me.htmlCls.spanNowrapStr + "2. Line Color: " + me.htmlCls.inputTextStr + "id='" + me.pre + "distancecolor' value='" + defaultColor + "' size=4><br/>";
            html += me.htmlCls.spanNowrapStr + "3. " + me.htmlCls.buttonStr + "applypick_measuredistance'>Display</button></span>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_stabilizer' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_stabilizer', 'Add a stabilizer');
            if(me.utilsCls.isMobile()) {
                html += me.htmlCls.spanNowrapStr + "1. Touch TWO atoms</span><br/>";
            }
            else {
                html += me.htmlCls.spanNowrapStr + "1. Pick TWO atoms while holding \"Alt\" key</span><br/>";
            }
            html += me.htmlCls.spanNowrapStr + "2. Color: " + me.htmlCls.inputTextStr + "id='" + me.pre + "stabilizercolor' value='ffffff' size=4><br/>";
            html += me.htmlCls.spanNowrapStr + "3. " + me.htmlCls.buttonStr + "applypick_stabilizer'>Add</button></span>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_disttwosets' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_disttwosets', 'Measure the distance between two sets');
            html += me.htmlCls.spanNowrapStr + "1. Select two sets</span><br/>";
            html += "<table border=0 width=400 cellspacing=10><tr><td>";

            html += me.htmlCls.divNowrapStr + "First set:</div>";
            html += "<div style='text-indent:1.1em'><select style='max-width:200px' id='" + me.pre + "atomsCustomDist2' multiple size='5' style='min-width:130px;'>";
            html += "</select></div>";

            html += "</td><td>";

            html += me.htmlCls.divNowrapStr + "Second set:</div>";
            html += "<div style='text-indent:1.1em'><select style='max-width:200px' id='" + me.pre + "atomsCustomDist' multiple size='5' style='min-width:130px;'>";
            html += "</select></div>";

            html += "</td></tr></table>";

            html += me.htmlCls.spanNowrapStr + "2. Color: " + me.htmlCls.inputTextStr + "id='" + me.pre + "distancecolor2' value='" + defaultColor + "' size=4><br/><br/>";
            html += me.htmlCls.spanNowrapStr + "3. " + me.htmlCls.buttonStr + "applydist2'>Display</button></span>";
            html += "</div>";

            
            html += me.htmlCls.divStr + "dl_linebtwsets' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_linebtwsets', 'Add a line between  two sets');
            html += me.htmlCls.spanNowrapStr + "1. Select two sets</span><br/>";
            html += "<table border=0 width=400 cellspacing=10><tr><td>";

            html += me.htmlCls.divNowrapStr + "First set:</div>";
            html += "<div style='text-indent:1.1em'><select style='max-width:200px' id='" + me.pre + "linebtwsets2' multiple size='5' style='min-width:130px;'>";
            html += "</select></div>";

            html += "</td><td>";

            html += me.htmlCls.divNowrapStr + "Second set:</div>";
            html += "<div style='text-indent:1.1em'><select style='max-width:200px' id='" + me.pre + "linebtwsets' multiple size='5' style='min-width:130px;'>";
            html += "</select></div>";

            html += "</td></tr></table>";

            html += me.htmlCls.divNowrapStr + "2. Line style: <select id='" + me.pre + "linebtwsets_style'>";
            html += me.htmlCls.setHtmlCls.getOptionHtml(['Solid', 'Dashed'], 0);
            html += "</select></div><br>";

            html += "3. Line radius: " + me.htmlCls.inputTextStr + "id='" + me.pre + "linebtwsets_radius' value='0.4' size=4><br/><br/>";
            
            html += "4. Color: " + me.htmlCls.inputTextStr + "id='" + me.pre + "linebtwsets_customcolor' value='" + defaultColor + "' size=4><br/><br/>";

            html += me.htmlCls.divNowrapStr + "5. Opacity: <select id='" + me.pre + "linebtwsets_opacity'>";
            html += me.htmlCls.setHtmlCls.getOptionHtml(['1.0', '0.9', '0.8', '0.7', '0.6', '0.5', '0.4', '0.3', '0.2', '0.1'], 7);
            html += "</select></div><br>";

            html += me.htmlCls.spanNowrapStr + "6. " + me.htmlCls.buttonStr + "applylinebtwsets'>Display</button></span>";
            html += me.htmlCls.space3 + me.htmlCls.spanNowrapStr + me.htmlCls.buttonStr + "clearlinebtwsets'>Clear</button></span>";
            html += "</div>";


            html += me.htmlCls.divStr + "dl_cartoonshape' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_cartoonshape', 'Cartoon Shape');
            html += me.htmlCls.spanNowrapStr + "1. Select a set:</span><br/>";
            html += "<div style='text-indent:1.1em'><select style='max-width:200px' id='" + me.pre + "cartoonshape' multiple size='5' style='min-width:130px;'>";
            html += "</select></div><br>";

            html += me.htmlCls.divNowrapStr + "2. Shape: <select id='" + me.pre + "cartoonshape_shape'>";
            html += me.htmlCls.setHtmlCls.getOptionHtml(['Sphere', 'Cube'], 0);
            html += "</select></div><br>";

            html += "3. Radius: " + me.htmlCls.inputTextStr + "id='" + me.pre + "cartoonshape_radius' value='1.5' size=4><br/><br/>";
            
            html += "4. Color: " + me.htmlCls.inputTextStr + "id='" + me.pre + "cartoonshape_customcolor' value='" + defaultColor + "' size=4><br/><br/>";

            html += me.htmlCls.divNowrapStr + "5. Opacity: <select id='" + me.pre + "cartoonshape_opacity'>";
            html += me.htmlCls.setHtmlCls.getOptionHtml(['1.0', '0.9', '0.8', '0.7', '0.6', '0.5', '0.4', '0.3', '0.2', '0.1'], 7);
            html += "</select></div><br>";
            
            html += me.htmlCls.spanNowrapStr + "6. " + me.htmlCls.buttonStr + "applycartoonshape'>Display</button></span>";
            html += me.htmlCls.space3 + me.htmlCls.spanNowrapStr + me.htmlCls.buttonStr + "clearcartoonshape'>Clear</button></span>";
            html += "</div>";


            html += me.htmlCls.divStr + "dl_distmanysets' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_distmanysets', 'Measure distances among many sets');
            html += me.htmlCls.spanNowrapStr + "1. Select sets for pairwise distances</span><br/>";
            html += "<table border=0 width=400 cellspacing=10><tr><td>";

            html += me.htmlCls.divNowrapStr + "First sets:</div>";
            html += "<div style='text-indent:1.1em'><select style='max-width:200px' id='" + me.pre + "atomsCustomDistTable2' multiple size='5' style='min-width:130px;'>";
            html += "</select></div>";

            html += "</td><td>";

            html += me.htmlCls.divNowrapStr + "Second sets:</div>";
            html += "<div style='text-indent:1.1em'><select style='max-width:200px' id='" + me.pre + "atomsCustomDistTable' multiple size='5' style='min-width:130px;'>";
            html += "</select></div>";

            html += "</td></tr></table>";

            html += me.htmlCls.spanNowrapStr + "2. " + me.htmlCls.buttonStr + "applydisttable'>Distances in Table</button></span>";
            html += "</div>";


            html += me.htmlCls.divStr + "dl_anglemanysets' class='" + dialogClass + "' style='max-width:500px'>";
            html += this.addNotebookTitle('dl_anglemanysets', 'Measure angles among many sets');
            html += me.htmlCls.spanNowrapStr + "Note: Each set is represented by a vector, which is the X-axis of the principle axes. The angles between the vectors are then calculated.<br/><br/>";
            html += me.htmlCls.spanNowrapStr + "1. Select sets for pairwise angles</span><br/>";
            html += "<table border=0 width=400 cellspacing=10><tr><td>";

            html += me.htmlCls.divNowrapStr + "First sets:</div>";
            html += "<div style='text-indent:1.1em'><select style='max-width:200px' id='" + me.pre + "atomsCustomAngleTable2' multiple size='5' style='min-width:130px;'>";
            html += "</select></div>";

            html += "</td><td>";

            html += me.htmlCls.divNowrapStr + "Second sets:</div>";
            html += "<div style='text-indent:1.1em'><select style='max-width:200px' id='" + me.pre + "atomsCustomAngleTable' multiple size='5' style='min-width:130px;'>";
            html += "</select></div>";

            html += "</td></tr></table>";

            html += me.htmlCls.spanNowrapStr + "2. " + me.htmlCls.buttonStr + "applyangletable'>Angles in Table</button></span>";
            html += "</div>";


            html += me.htmlCls.divStr + "dl_stabilizer_rm' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_stabilizer_rm', 'Remove a stabilizer');
            if(me.utilsCls.isMobile()) {
                html += me.htmlCls.spanNowrapStr + "1. Touch TWO atoms</span><br/>";
            }
            else {
                html += me.htmlCls.spanNowrapStr + "1. Pick TWO atoms while holding \"Alt\" key</span><br/>";
            }
            html += me.htmlCls.spanNowrapStr + "2. " + me.htmlCls.buttonStr + "applypick_stabilizer_rm'>Remove</button></span>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_thickness' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_thickness', 'Set thickness');
            html += me.htmlCls.setHtmlCls.setThicknessHtml('3dprint');
            html += "</div>";

            html += me.htmlCls.divStr + "dl_thickness2' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_thickness2', 'Set thickness');
            html += me.htmlCls.setHtmlCls.setThicknessHtml('style');
            html += "</div>";

            html += me.htmlCls.divStr + "dl_menupref' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_menupref', 'Preferences for menus');
            html += "<b>Note</b>: The following parameters will be saved in cache. You just need to set them once. <br><br>";

            html += me.htmlCls.spanNowrapStr + "" + me.htmlCls.buttonStr + "apply_menupref'>Apply</button></span>";
            html += me.htmlCls.spanNowrapStr + "" + me.htmlCls.buttonStr + "reset_menupref' style='margin-left:30px'>Reset to Simple Menus</button></span>";
            html += me.htmlCls.spanNowrapStr + "" + me.htmlCls.buttonStr + "reset_menupref_all' style='margin-left:30px'>Reset to All Menus</button></span>";
            html += me.htmlCls.spanNowrapStr + "" + me.htmlCls.buttonStr + "savepref' style='margin-left:30px'>Save Preferences</button></span>";
            html += me.htmlCls.spanNowrapStr + "" + me.htmlCls.buttonStr + "loadpref' style='margin-left:30px'>Load Preferences</button></span><br><br>";

            html += "<div id='" + me.pre + "menulist'></div><br><br>";
            html += me.htmlCls.spanNowrapStr + "" + me.htmlCls.buttonStr + "apply_menupref2'>Apply</button></span>";
            html += me.htmlCls.spanNowrapStr + "" + me.htmlCls.buttonStr + "reset_menupref2' style='margin-left:30px'>Reset to Simple Menus</button></span>";
            html += me.htmlCls.spanNowrapStr + "" + me.htmlCls.buttonStr + "reset_menupref_all2' style='margin-left:30px'>Reset to All Menus</button></span>";
            html += me.htmlCls.spanNowrapStr + "" + me.htmlCls.buttonStr + "savepref2' style='margin-left:30px'>Save Preferences</button></span>";
            html += me.htmlCls.spanNowrapStr + "" + me.htmlCls.buttonStr + "loadpref2' style='margin-left:30px'>Load Preferences</button></span>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_addtrack' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_addtrack', 'Add a track');
            html += " <input type='hidden' id='" + me.pre + "track_chainid' value=''>";

            html += me.htmlCls.divStr + "dl_addtrack_tabs' style='border:0px;'>";
            html += "<ul>";
            html += "<li><a href='#" + me.pre + "tracktab2c'>Isoforms & Exons</a></li>";
            html += "<li><a href='#" + me.pre + "tracktab2b'>MSA</a></li>";
            html += "<li><a href='#" + me.pre + "tracktab1'>NCBI gi/Accession</a></li>";
            html += "<li><a href='#" + me.pre + "tracktab2'>FASTA</a></li>";
            html += "<li><a href='#" + me.pre + "tracktab3'>BED File</a></li>";
            html += "<li><a href='#" + me.pre + "tracktab4'>Custom</a></li>";
            html += "<li><a href='#" + me.pre + "tracktab5'>Current Selection</a></li>";
            html += "</ul>";
            html += me.htmlCls.divStr + "tracktab1'>";
            html += "NCBI gi/Accession: " + me.htmlCls.inputTextStr + "id='" + me.pre + "track_gi' placeholder='gi' size=16> <br><br>";
            html += me.htmlCls.buttonStr + "addtrack_button1'>Add Track</button>";
            html += "</div>";
            html += me.htmlCls.divStr + "tracktab2'>";
            html += "FASTA Title: " + me.htmlCls.inputTextStr + "id='" + me.pre + "fasta_title' placeholder='track title' size=16> <br><br>";
            html += "FASTA sequence: <br><textarea id='" + me.pre + "track_fasta' rows='5' style='width: 100%; height: " +(2*me.htmlCls.LOG_HEIGHT) + "px; padding: 0px; border: 0px;'></textarea><br><br>";
            html += me.htmlCls.buttonStr + "addtrack_button2'>Add Track</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "tracktab2b'>";
            // html += "<div style='width:600px'>The full protein sequences with gaps are listed one by one. The sequence of the structure is listed at the top. If there are non-gap residues(e.g., from RefSeq) outside of the sequence of the structure, please remove them. Each sequence has a title line starting with \">\".</div><br>";
            html += "<div style='width:600px'>Note: The full protein sequences with gaps in MSA are listed one by one. The sequence of the structure is listed at the top. Each sequence has a title line starting with \">\".</div><br>";

            html += "<b>Precalculated Multiple Sequence Alignment (MSA)</b>:<br>";
            html += "<textarea id='" + me.pre + "track_fastaalign' rows='5' style='width: 100%; height: " +(2*me.htmlCls.LOG_HEIGHT) + "px; padding: 0px; border: 0px;'></textarea><br><br>";

            // html += "<b>Opion 1. Precalculated Multiple Sequence Alignment (MSA)</b>:<br>";
            // html += "<textarea id='" + me.pre + "track_fastaalign' rows='5' style='width: 100%; height: " +(2*me.htmlCls.LOG_HEIGHT) + "px; padding: 0px; border: 0px;'></textarea><br><br>";
            // html += "<b>Opion 2. NCBI Protein Accessions</b>: "+ me.htmlCls.inputTextStr + "id='" + me.pre + "track_acclist' size=60> <br><br>";
            html += "<b>Position of the first residue in Sequences & Annotations window</b>: " + me.htmlCls.inputTextStr + "id='" + me.pre + "fasta_startpos' value='1' size=2> <br><br>";

            html += "Color Sequence by: <select id='" + me.pre + "colorseqby'>";
            html += me.htmlCls.optionStr + "'identity' selected>Identity</option>";
            html += me.htmlCls.optionStr + "'conservation'>Conservation</option>";
            html += "</select> <br><br>";

            html += me.htmlCls.buttonStr + "addtrack_button2b'>Add Track(s)</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "tracktab2c'>";
            html += "<div style='width:500px'>Note: Show exons for all isoforms of the protein in the same gene as specified below.</div><br>";

            html += "<b><a href='https://www.ncbi.nlm.nih.gov/gene' target='_blank'>NCBI Gene</a> ID</b>: "+ me.htmlCls.inputTextStr + "id='" + me.pre + "track_geneid' size=20>" + me.htmlCls.space3 + me.htmlCls.buttonStr + "exons_table'>Exons & Introns in Gene Table</button><br><br>";

            html += "<b>Position of the first residue in Sequences & Annotations window</b>: " + me.htmlCls.inputTextStr + "id='" + me.pre + "fasta_startpos2' value='1' size=2> <br><br>";

            // html += "Color Sequence by: <select id='" + me.pre + "colorseqby2'>";
            // html += me.htmlCls.optionStr + "'identity' selected>Identity</option>";
            // html += me.htmlCls.optionStr + "'conservation'>Conservation</option>";
            // html += "</select> <br><br>";

            html += me.htmlCls.buttonStr + "addtrack_button2c'>Show Isoforms & Exons</button>";
            html += "</div>";


            html += me.htmlCls.divStr + "tracktab3'>";
            html += "BED file: " + me.htmlCls.inputFileStr + "id='" + me.pre + "track_bed' size=16> <br><br>";
            html += me.htmlCls.buttonStr + "addtrack_button3'>Add Track</button>";
            html += "</div>";
            html += me.htmlCls.divStr + "tracktab4'>";
            html += "Track Title: " + me.htmlCls.inputTextStr + "id='" + me.pre + "track_title' placeholder='track title' size=16> <br><br>";
            html += "Track Text (e.g., \"2 G, 5-6 RR\" defines a character \"G\" at the position 2 and two continuous characters \"RR\" at positions from 5 to 6. The starting position is 1): <br>";
            html += "<textarea id='" + me.pre + "track_text' rows='5' style='width: 100%; height: " +(2*me.htmlCls.MENU_HEIGHT) + "px; padding: 0px; border: 0px;'></textarea><br><br>";
            html += me.htmlCls.buttonStr + "addtrack_button4'>Add Track</button>";
            html += "</div>";
            html += me.htmlCls.divStr + "tracktab5'>";
            html += "Track Title: " + me.htmlCls.inputTextStr + "id='" + me.pre + "track_selection' placeholder='track title' size=16> <br><br>";
            html += me.htmlCls.buttonStr + "addtrack_button5'>Add Track</button>";
            html += "</div>";

            html += "</div>";

            html += "</div>";

            html += me.htmlCls.divStr + "dl_saveselection' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_saveselection', 'Save Selection');
            let index =(ic && ic.defNames2Atoms) ? Object.keys(ic.defNames2Atoms).length : 1;
            let suffix = '';
            html += "Name: " + me.htmlCls.inputTextStr + "id='" + me.pre + "seq_command_name" + suffix + "' value='seq_" + index + "' size='5'> <br>";
            //html += "Description: " + me.htmlCls.inputTextStr + "id='" + me.pre + "seq_command_desc" + suffix + "' value='seq_desc_" + index + "' size='10'> <br>";
            html += "<button style='white-space:nowrap;' id='" + me.pre + "seq_saveselection" + suffix + "'>Save</button> <button style='white-space:nowrap; margin-left:20px;' id='" + me.pre + "seq_clearselection" + suffix + "'>Clear</button><br/><br/>";
            html += "</div>";


            html += me.htmlCls.divStr + "dl_copyurl' style='width:520px;' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_copyurl', 'Share Link');
            html += "<br>";
            html += "1. <b>URLs Used in Browsers</b><br><br>";

            html += "Please copy one of the URLs below. They show the same result.<br>(To add a title to share link, click \"Windows > Your Note\" and click \"File > Share Link\" again.)<br><br>";
            html += "Original URL with commands: <br><textarea id='" + me.pre + "ori_url' rows='4' style='width:100%'></textarea><br><br>";
            if(!me.cfg.notebook) {
                html += "Lifelong Short URL:(To replace this URL, send a pull request to update share.html at <a href='https://github.com/ncbi/icn3d' target='_blank'>iCn3D GitHub</a>)<br>" + me.htmlCls.inputTextStr + "id='" + me.pre + "short_url' value='' style='width:100%'><br><br>";
                html += "Lifelong Short URL + Window Title:(To update the window title, click \"Analysis > Your Note/Window Title\".)<br>" + me.htmlCls.inputTextStr + "id='" + me.pre + "short_url_title' value='' style='width:100%'><br><br>";
            }

            html += "2. <b>Commands Used in Jupyter Noteboook</b><br><br>";
            html += "Please copy the following commands into a cell in Jupyter Notebook to show the same result. <br>More details are at https://github.com/ncbi/icn3d/tree/master/jupyternotebook.<br><br>";

            html += '<textarea id="' + me.pre + 'jn_commands" rows="4" style="width:100%"></textarea><br>';

            html += buttonStrTmp + me.pre + 'jn_copy">Copy Commands</button><br>';

            html += "</div>";

            html += me.htmlCls.divStr + "dl_selectannotations' class='" + dialogClass + " icn3d-annotation' style='background-color:white;'>";
            html += this.addNotebookTitle('dl_selectannotations', 'Sequences & Annotations');

            html += me.htmlCls.divStr + "dl_annotations_tabs'>";

            html += me.htmlCls.divStr + "dl_anno_view_tabs' style='border:0px; height:33px;'>";
            html += "<ul>";
            html += "<li><a href='#" + me.pre + "anno_tmp1' id='" + me.pre + "anno_summary'>Summary</a></li>";
            html += "<li><a href='#" + me.pre + "anno_tmp2' id='" + me.pre + "anno_details'>Details</a></li>";
            html += "</ul>";
            html += me.htmlCls.divStr + "anno_tmp1'>";
            html += "</div>";
            html += me.htmlCls.divStr + "anno_tmp2'>";
            html += "</div>";
            html += "</div>";

            html += this.getAnnoHeader();

            html += "<button style='white-space:nowrap; margin-left:5px;' id='" + me.pre + "showallchains'>Show All Chains</button><br>";

            html += me.htmlCls.divStr + "seqguide_wrapper' style='display:none'><br>" + me.htmlCls.setHtmlCls.setSequenceGuide("2") + "</div>";

            html += "</div><br/><hr><br>";

            html += me.htmlCls.divStr + "dl_annotations'>";
            html += "</div>";

            html += "</div>";

            html += me.htmlCls.divStr + "dl_graph' style='background-color:white;' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_graph', 'Interactions');
            me.svgid = me.pre + 'icn3d_viz';
            html += '<style>';
            html += '#' + me.svgid + ' svg { border: 1px solid; font: 13px sans-serif; text-anchor: end; }';
            html += '#' + me.svgid + ' .node { stroke: #eee; stroke-width: 1.5px; }';
            html += '.node .selected { stroke: ' + me.htmlCls.ORANGE + '; }';
            html += '.link { stroke: #999; stroke-opacity: 0.6; }';

            html += '</style>';

            html += me.htmlCls.divNowrapStr + '<b>Zoom</b>: mouse wheel; ' + me.htmlCls.space3 + ' <b>Move</b>: left button; ' + me.htmlCls.space3 + ' <b>Select Multiple Nodes</b>: Ctrl Key and drag an Area' + me.htmlCls.space3;
            html += '<div id="' + me.pre + 'interactionDesc" style="width:20px; margin-top:6px; display:inline-block;"><span id="'
              + me.pre + 'dl_svgcolor_expand" class="ui-icon ui-icon-plus icn3d-expand icn3d-link" style="width:15px;" title="Expand"></span><span id="'
              + me.pre + 'dl_svgcolor_shrink" class="ui-icon ui-icon-minus icn3d-shrink icn3d-link" style="display:none; width:15px;" title="Shrink"></span></div></div>';
            html += me.htmlCls.divStr + "dl_svgcolor' style='display:none;'>";
            html += me.htmlCls.divNowrapStr + '<span style="margin-left:33px">Click "View > H-Bonds & Interactions" to adjust parameters and relaunch the graph</span></div>';
            html += me.htmlCls.divNowrapStr + '<span style="margin-left:33px; color:#00FF00; font-weight:bold">Green</span>: H-Bonds; ';
            html += '<span style="color:#00FFFF; font-weight:bold">Cyan</span>: Salt Bridge/Ionic; ';
            html += '<span style="font-weight:bold">Grey</span>: contacts; ';
            html += '<span style="color:' + me.htmlCls.ORANGE + '; font-weight:bold">Orange</span>: disulfide bonds</div>';
            html += me.htmlCls.divNowrapStr + '<span style="margin-left:33px; color:#FF00FF; font-weight:bold">Magenta</span>: Halogen Bonds; ';
            html += '<span style="color:#FF0000; font-weight:bold">Red</span>: &pi;-Cation; ';
            html += '<span style="color:#0000FF; font-weight:bold">Blue</span>: &pi;-Stacking</div>';
            html += "</div>";

            html += me.htmlCls.divNowrapStr + buttonStrTmp + me.svgid + '_svg">SVG</button>' + me.htmlCls.space2;
            html += buttonStrTmp + me.svgid + '_png">PNG</button>' + me.htmlCls.space2;
            html += buttonStrTmp + me.svgid + '_json">JSON</button>';
            html += me.htmlCls.space3 + "<div id='" + me.pre + "force' style='display:inline-block;'><b>Force on Nodes</b>: <select id='" + me.svgid + "_force'>";
            html += me.htmlCls.optionStr + "'0'>No</option>";
            html += me.htmlCls.optionStr + "'1'>X-axis</option>";
            html += me.htmlCls.optionStr + "'2'>Y-axis</option>";
            html += me.htmlCls.optionStr + "'3'>Circle</option>";
            html += me.htmlCls.optionStr + "'4' selected>Random</option>";
            html += "</select></div>";
            html += me.htmlCls.space3 + "<b>Label Size</b>: <select id='" + me.svgid + "_label'>";
            tmpStr = 'icn3d-node-text';
            html += me.htmlCls.optionStr + "'" + tmpStr + "0'>No</option>";
            html += me.htmlCls.optionStr + "'" + tmpStr + "4'>4px</option>";
            html += me.htmlCls.optionStr + "'" + tmpStr + "8' selected>8px</option>";
            html += me.htmlCls.optionStr + "'" + tmpStr + "12'>12px</option>";
            html += me.htmlCls.optionStr + "'" + tmpStr + "16'>16px</option>";
            html += me.htmlCls.optionStr + "'" + tmpStr + "24'>24px</option>";
            html += me.htmlCls.optionStr + "'" + tmpStr + "32'>32px</option>";
            html += "</select>";
            html += me.htmlCls.space3 + "<div id='" + me.pre + "internalEdges' style='display:inline-block;'><b>Internal Edges</b>: <select id='" + me.svgid + "_hideedges'>";
            html += me.htmlCls.optionStr + "'1' selected>Hide</option>";
            html += me.htmlCls.optionStr + "'0'>Show</option>";
            html += "</select></div>";
            html += "</div>";

            html += '<svg id="' + me.svgid + '" style="margin-top:6px;"></svg>';
            html += "</div>";

            html += me.htmlCls.divStr + "dl_area' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_area', 'Surface Area');
            html += "Solvent Accessible Surface Area(SASA) calculated using the <a href='https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0008140' target='_blank'>EDTSurf algorithm</a>: <br>";
            html += '(0-20% out is considered "in". 50-100% out is considered "out".)<br><br>';
            html += "<b>Toal</b>: " + me.htmlCls.inputTextStr + "id='" + me.pre + "areavalue' value='' size='10'> &#8491;<sup>2</sup><br><br>";
            html += "<div id='" + me.pre + "areatable' style='max-height:400px; overflow:auto'></div>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_colorbyarea' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_colorbyarea', 'Color by surface area');
            html += "<div style='width:500px'>Color each residue based on the percentage of solvent accessilbe surface area. The color ranges from blue, to white, to red for a percentage of 0, 35(variable), and 100, respectively.</div><br>";
            html += "<b>Middle Percentage(White)</b>: " + me.htmlCls.inputTextStr + "id='" + me.pre + "midpercent' value='35' size='10'>% <br><br>";
            html += "<button style='white-space:nowrap;' id='" + me.pre + "applycolorbyarea'>Color</button><br/><br/>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_rmsd' class='" + dialogClass + "' style='max-width:300px'>";
            html += this.addNotebookTitle('dl_rmsd', 'RMSD', true);
            
            html += "</div>";

            html += me.htmlCls.divStr + "dl_buriedarea' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_buriedarea', 'Buried surface area', true);
            html += "</div>";

            html += me.htmlCls.divStr + "dl_propbypercentout' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_propbypercentout', 'Select residues basen on solvent accessilbe surface area');
            html += "<div style='width:400px'>Select residue based on the percentage of solvent accessilbe surface area. The values are in the range of 0-100.</div><br>";
            html += "<b>Min Percentage</b>: " + me.htmlCls.inputTextStr + "id='" + me.pre + "minpercentout' value='0' size='10'>% <br>";
            html += "<b>Max Percentage</b>: " + me.htmlCls.inputTextStr + "id='" + me.pre + "maxpercentout' value='100' size='10'>% <br>";
            html += "<button style='white-space:nowrap;' id='" + me.pre + "applypropbypercentout'>Apply</button><br/><br/>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_propbybfactor' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_propbybfactor', 'Select residues basen on B-factor/pLDDT');
            html += "<div style='width:400px'>Select residue based on B-factor/pLDDT. The values are in the range of 0-100.</div><br>";
            html += "<b>Min B-factor/pLDDT</b>: " + me.htmlCls.inputTextStr + "id='" + me.pre + "minbfactor' value='0' size='10'>% <br>";
            html += "<b>Max B-factor/pLDDT</b>: " + me.htmlCls.inputTextStr + "id='" + me.pre + "maxbfactor' value='100' size='10'>% <br>";
            html += "<button style='white-space:nowrap;' id='" + me.pre + "applypropbybfactor'>Apply</button><br/><br/>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_legend' class='" + dialogClass + "' style='max-width:500px; background-color:white'>";
            html += this.addNotebookTitle('dl_legend', 'Legend', true);
            html += "</div>";

            html += me.htmlCls.divStr + "dl_disttable' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_disttable', 'Distance Table', true);
            html += "</div>";

            
            html += me.htmlCls.divStr + "dl_angletable' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_angletable', 'Angle Table', true);
            html += "</div>";

            html += me.htmlCls.divStr + "dl_translate' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_translate', 'Translate the X,Y,Z coordinates of the structure');
            html += "X: " + me.htmlCls.inputTextStr + "id='" + me.pre + "translateX' value='' size=4> ";
            html += "Y: " + me.htmlCls.inputTextStr + "id='" + me.pre + "translateY' value='' size=4> ";
            html += "Z: " + me.htmlCls.inputTextStr + "id='" + me.pre + "translateZ' value='' size=4> ";
            html += me.htmlCls.buttonStr + "translate_pdb'>Translate</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_angle' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_angle', 'Measure the angle between two vectors');
            html += "<b>Vector 1</b>, X: " + me.htmlCls.inputTextStr + "id='" + me.pre + "v1X' value='' size=6> ";
            html += "Y: " + me.htmlCls.inputTextStr + "id='" + me.pre + "v1Y' value='' size=6> ";
            html += "Z: " + me.htmlCls.inputTextStr + "id='" + me.pre + "v1Z' value='' size=6><br>";
            html += "<b>Vector 2</b>, X: " + me.htmlCls.inputTextStr + "id='" + me.pre + "v2X' value='' size=6> ";
            html += "Y: " + me.htmlCls.inputTextStr + "id='" + me.pre + "v2Y' value='' size=6> ";
            html += "Z: " + me.htmlCls.inputTextStr + "id='" + me.pre + "v2Z' value='' size=6><br>";
            html += "<br>";
            
            html += me.htmlCls.buttonStr + "measure_angle'>Measure Angle</button><br><br>";
            html += "The angle is: " + me.htmlCls.inputTextStr + "id='" + me.pre + "angle_value' value='' size=6> degree.<br><br>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_matrix' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_matrix', 'Apply matrix to the X,Y,Z coordinates of the structure');
            html += "0: " + me.htmlCls.inputTextStr + "id='" + me.pre + "matrix0' value='1' size=2> ";
            html += "4: " + me.htmlCls.inputTextStr + "id='" + me.pre + "matrix4' value='0' size=2> ";
            html += "8: " + me.htmlCls.inputTextStr + "id='" + me.pre + "matrix8' value='0' size=2> ";
            html += "12: " + me.htmlCls.inputTextStr + "id='" + me.pre + "matrix12' value='0' size=2><br>";

            html += "1: " + me.htmlCls.inputTextStr + "id='" + me.pre + "matrix1' value='0' size=2> ";
            html += "5: " + me.htmlCls.inputTextStr + "id='" + me.pre + "matrix5' value='1' size=2> ";
            html += "9: " + me.htmlCls.inputTextStr + "id='" + me.pre + "matrix9' value='0' size=2> ";
            html += "13: " + me.htmlCls.inputTextStr + "id='" + me.pre + "matrix13' value='0' size=2><br>";

            html += "2: " + me.htmlCls.inputTextStr + "id='" + me.pre + "matrix2' value='0' size=2> ";
            html += "6: " + me.htmlCls.inputTextStr + "id='" + me.pre + "matrix6' value='0' size=2> ";
            html += "10: " + me.htmlCls.inputTextStr + "id='" + me.pre + "matrix10' value='1' size=2> ";
            html += "14: " + me.htmlCls.inputTextStr + "id='" + me.pre + "matrix14' value='0' size=2><br>";

            html += "3: " + me.htmlCls.inputTextStr + "id='" + me.pre + "matrix3' value='0' size=2> ";
            html += "7: " + me.htmlCls.inputTextStr + "id='" + me.pre + "matrix7' value='0' size=2> ";
            html += "11: " + me.htmlCls.inputTextStr + "id='" + me.pre + "matrix11' value='0' size=2> ";
            html += "15: " + me.htmlCls.inputTextStr + "id='" + me.pre + "matrix15' value='1' size=2><br>";

            html += me.htmlCls.buttonStr + "matrix_pdb'>Rotate with Matrix</button>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_igrefTpl' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_igrefTpl', 'Choose an Ig template');
            html += "<span style='white-space:nowrap;font-weight:bold;'>Choose an Ig template for selected residues:</span> <br><br><select id='" + me.pre + "refTpl'>";
            html += this.setTemplateMenu();
            html += "</select><br><br><span style='white-space:nowrap;'>" + me.htmlCls.buttonStr + "mn6_igrefTpl_apply'>Show Ig Ref. Number</button></span>";
            html += "</div>";

            html += me.htmlCls.divStr + "dl_alignrefTpl' class='" + dialogClass + "'>";
            html += this.addNotebookTitle('dl_alignrefTpl', 'Align with an Ig template');
            html += "<span style='white-space:nowrap;font-weight:bold;'>Choose an Ig template to align with selected residues:</span> <br><br><select id='" + me.pre + "refTpl2'>";
            html += this.setTemplateMenu();
            html += "</select><br><br><span style='white-space:nowrap;'>" + me.htmlCls.buttonStr + "mn6_alignrefTpl_apply'>Align Template with Selection</button></span>";
            html += "</div>";

            html += "</div>";
            html += "<!--/form-->";

            return html;
        }

        setTemplateMenu()  { let me = this.icn3dui; me.icn3d;
            let group2tpl = {};
            group2tpl['IgV'] = ['CD28_1yjdC_human_V', 'CD2_1hnfA_human_V-n1', 'CD8a_1cd8A_human_V', 'FAB-HEAVY_5esv_V-n1', 'FAB-LIGHT_5esv_V-n1', 'ICOS_6x4gA_human_V', 'LAG3_7tzgD_human_V-n1', 'PD1_4zqkB_human_V', 'PDL1_4z18B_human_V-n1', 'TCRa_6jxrm_human_V-n1', 'VISTA_6oilA_human_V', 'VNAR_1t6vN_shark_V'];
            group2tpl['IgC1'] = ['B2Microglobulin_7phrL_human_C1', 'CD3d_6jxrd_human_C1', 'CD3e_6jxrf_human_C1', 'FAB-LIGHT_5esv_C1-n2', 'FAB-HEAVY_5esv_C1-n2', 'GHR_1axiB_human_C1-n1', 'LAG3_7tzgD_human_C1-n2', 'MHCIa_7phrH_human_C1', 'Siglec3_5j0bB_human_C1-n2', 'TCRa_6jxrm_human_C1-n2', 'VTCN1_Q7Z7D3_human_C1-n2'];
            group2tpl['IgC2'] = ['CD2_1hnfA_human_C2-n2', 'CD3g_6jxrg_human_C2'];
            group2tpl['IgI'] = ['BTLA_2aw2A_human_Iset', 'Contactin1_3s97C_human_Iset-n2', 'JAM1_1nbqA_human_Iset-n2', 'Palladin_2dm3A_human_Iset-n1', 'Titin_4uowM_human_Iset-n152'];
            group2tpl['IgE'] = ['CoAtomerGamma1_1r4xA_human', 'Endo-1,4-BetaXylanase10A_1i8aA_bacteria_n4', 'IsdA_2iteA_bacteria', 'NaKATPaseTransporterBeta_2zxeB_spurdogshark', 'TP34_2o6cA_bacteria', 'TP47_1o75A_bacteria'];

            group2tpl['IgFN3'] = ['Contactin1_2ee2A_human_FN3-n9', 'IL6Rb_1bquB_human_FN3-n2', 'IL6Rb_1bquB_human_FN3-n3', 'InsulinR_8guyE_human_FN3-n1', 'InsulinR_8guyE_human_FN3-n2', 'Sidekick2_1wf5A_human_FN3-n7'];

            group2tpl['IgFN3-like'] = ['ASF1A_2iijA_human', 'BArrestin1_4jqiA_rat_n1', 'C3_2qkiD_human_n1', 'MPT63_1lmiA_bacteria', 'NaCaExchanger_2fwuA_dog_n2', 'RBPJ_6py8C_human_Unk-n1', 'RBPJ_6py8C_human_Unk-n2', 'TEAD1_3kysC_human'];

            group2tpl['Other Ig'] = ['CD19_6al5A_human-n1', 'CuZnSuperoxideDismutase_1hl5C_human', 'ECadherin_4zt1A_human_n2', 'LaminAC_1ifrA_human', 'ORF7a_1xakA_virus'];  

            let tpl2strandsig = {};
            tpl2strandsig['ASF1A_2iijA_human']                          = "A A' B C C' E F G G+";
            tpl2strandsig['B2Microglobulin_7phrL_human_C1']             = "A B C C' D E F G";
            tpl2strandsig['BArrestin1_4jqiA_rat_n1']                    = "A- A A' B C C' E F G";
            tpl2strandsig['BTLA_2aw2A_human_Iset']                      = "A A' B C C' D E F G";
            tpl2strandsig['C3_2qkiD_human_n1']                          = "A A' B C C' E F G";
            tpl2strandsig['CD19_6al5A_human-n1']                  = "A' B C C' D E F G";
            tpl2strandsig['CD28_1yjdC_human_V']                         = "A A' B C C' C'' D E F G";
            tpl2strandsig['CD2_1hnfA_human_C2-n2']                      = "A B C C' E F G";
            tpl2strandsig['CD2_1hnfA_human_V-n1']                       = "A' B C C' C'' D E F G";
            tpl2strandsig['CD3d_6jxrd_human_C1']                      = "A B C D E F G";
            tpl2strandsig['CD3e_6jxrf_human_C1']                      = "A B C C' D E F G";
            tpl2strandsig['CD3g_6jxrg_human_C2']                      = "A B C C' E F G G+";
            tpl2strandsig['CD8a_1cd8A_human_V']                         = "A A' B C C' C'' D E F G";
            tpl2strandsig['CoAtomerGamma1_1r4xA_human']                 = "A- A B C D E F G";
            tpl2strandsig['Contactin1_2ee2A_human_FN3-n9']              = "A A' B C C' E F G";
            tpl2strandsig['Contactin1_3s97C_human_Iset-n2']               = "A A' B C D E F G";
            tpl2strandsig['CuZnSuperoxideDismutase_1hl5C_human']        = "A- A B C C' E F G";
            tpl2strandsig['ECadherin_4zt1A_human_n2']                   = "A' B C D E F G";
            tpl2strandsig['Endo-1,4-BetaXylanase10A_1i8aA_bacteria_n4'] = "A--- A-- A- A B C C' C'' D E F G";
            tpl2strandsig['FAB-HEAVY_5esv_C1-n2']                       = "A B C D E F G";
            tpl2strandsig['FAB-HEAVY_5esv_V-n1']                        = "A B C C' C'' D E F G";
            tpl2strandsig['FAB-LIGHT_5esv_C1-n2']                       = "A B C C' D E F G";
            tpl2strandsig['FAB-LIGHT_5esv_V-n1']                        = "A A' B C C' C'' D E F G";
            tpl2strandsig['GHR_1axiB_human_C1-n1']                     = "A B C C' D E F G";
            tpl2strandsig['ICOS_6x4gA_human_V']                         = "A B C C' C'' D E F G";
            tpl2strandsig['IL6Rb_1bquB_human_FN3-n2']                   = "A B C C' E F G";
            tpl2strandsig['IL6Rb_1bquB_human_FN3-n3']                   = "A B C C' E F G";
            tpl2strandsig['InsulinR_8guyE_human_FN3-n1']                = "A B C C' E F G";
            tpl2strandsig['InsulinR_8guyE_human_FN3-n2']                = "A B C C' E F G";
            tpl2strandsig['IsdA_2iteA_bacteria']                        = "A- A B C C' D E F G";
            tpl2strandsig['JAM1_1nbqA_human_Iset-n2']                = "A A' B C C' D E F G";
            tpl2strandsig['LAG3_7tzgD_human_C1-n2']                     = "A A' B C C' D E F G";
            tpl2strandsig['LAG3_7tzgD_human_V-n1']                      = "A' B C C' D E F G";
            tpl2strandsig['LaminAC_1ifrA_human']                        = "A- A B C C' E E+ F G";
            tpl2strandsig['MHCIa_7phrH_human_C1']                       = "A B C C' D E F G";
            tpl2strandsig['MPT63_1lmiA_bacteria']                       = "A-- A- A BC C' E F G";
            tpl2strandsig['NaCaExchanger_2fwuA_dog_n2']                 = "A A' B C C' E F G";
            tpl2strandsig['NaKATPaseTransporterBeta_2zxeB_spurdogshark']= "A A' B C D E F G";
            tpl2strandsig['ORF7a_1xakA_virus']                          = "A' B C D E F G";
            tpl2strandsig['PD1_4zqkB_human_V']                          = "A A' B C C' D E F G";
            tpl2strandsig['PDL1_4z18B_human_V-n1']                      = "A A' B C C' C'' D E F G";
            tpl2strandsig['Palladin_2dm3A_human_Iset-n1']               = "A A' B C C' D E F G";
            tpl2strandsig['RBPJ_6py8C_human_Unk-n1']                    = "A A' B C C' E F G";
            tpl2strandsig['RBPJ_6py8C_human_Unk-n2']                    = "A B C D E F G";
            tpl2strandsig['Sidekick2_1wf5A_human_FN3-n7']               = "A B C C' E F G";
            tpl2strandsig['Siglec3_5j0bB_human_C1-n2']                  = "A A' B C D E F G";
            tpl2strandsig['TCRa_6jxrm_human_C1-n2']                     = "A B C D E F G";
            tpl2strandsig['TCRa_6jxrm_human_V-n1']                      = "A A' B C C' C'' D E F G";
            tpl2strandsig['TEAD1_3kysC_human']                          = "A A+ A' B C C' E F G G+";
            tpl2strandsig['TP34_2o6cA_bacteria']                        = "A- A B C C' D E F G";
            tpl2strandsig['TP47_1o75A_bacteria']                        = "A B C C' D E F G";
            tpl2strandsig['Titin_4uowM_human_Iset-n152']                 = "A A' B C C' D E F G";
            tpl2strandsig['VISTA_6oilA_human_V']                        = "A A' B C C' C'' D E F G G+";
            tpl2strandsig['VNAR_1t6vN_shark_V']                         = "A A' B C C' D E F G";
            tpl2strandsig['VTCN1_Q7Z7D3_human_C1-n2']                    = "A B C C' D E F G G+";

            let html = '';
            for(let group in group2tpl) {
                html += "<optgroup label='" + group + "'>";
                for(let i = 0, il = group2tpl[group].length; i < il; ++i) {
                    let template = group2tpl[group][i];
                    html += me.htmlCls.optionStr + "'" + template + "'>" + template  + ", Strands: " + tpl2strandsig[template] + "</option>";
                }
                html += "</optgroup>";
            }

            return html;
        }

        getAnnoHeader() { let me = this.icn3dui; me.icn3d;
            let html = '';

            html += "<div id='" + me.pre + "annoHeaderSection' class='icn3d-box' style='width:520px;'><b>Annotations:&nbsp;</b><br>";
            html += "<div id='" + me.pre + "annoHeader'><table border=0><tr>";
            let tmpStr1 = "<td style='min-width:110px;'><span style='white-space:nowrap'>";
            let tmpStr2 = "<td style='min-width:130px;'><span style='white-space:nowrap'>";

            html += tmpStr1 + me.htmlCls.inputCheckStr + "id='" + me.pre + "anno_all'>All" + me.htmlCls.space2 + "</span></td>";
            html += tmpStr2 + me.htmlCls.inputCheckStr + "id='" + me.pre + "anno_cdd' checked>Conserved Domains" + me.htmlCls.space2 + "</span></td>";
            html += tmpStr1 + me.htmlCls.inputCheckStr + "id='" + me.pre + "anno_clinvar'>ClinVar" + me.htmlCls.space2 + "</span></td>";
            html += tmpStr1 + me.htmlCls.inputCheckStr + "id='" + me.pre + "anno_binding'>Functional Sites" + me.htmlCls.space2 + "</span></td>";
            html += "</tr><tr>";
            html += tmpStr1 + me.htmlCls.inputCheckStr + "id='" + me.pre + "anno_custom'>Custom" + me.htmlCls.space2 + "</span></td>";
            html += tmpStr2 + me.htmlCls.inputCheckStr + "id='" + me.pre + "anno_3dd'>3D Domains" + me.htmlCls.space2 + "</span></td>";
            html += tmpStr1 + me.htmlCls.inputCheckStr + "id='" + me.pre + "anno_snp'>SNPs" + me.htmlCls.space2 + "</span></td>";
            
            // if(me.cfg.mmdbid != undefined || me.cfg.pdbid != undefined || me.cfg.mmtfid != undefined || me.cfg.mmcifid != undefined) { // PDB
            //     html += tmpStr1 + me.htmlCls.inputCheckStr + "id='" + me.pre + "anno_ptm' disabled>PTM (UniProt)" + me.htmlCls.space2 + "</span></td>";
            // }
            // else {
                html += tmpStr1 + me.htmlCls.inputCheckStr + "id='" + me.pre + "anno_ptm'>PTM (UniProt)" + me.htmlCls.space2 + "</span></td>";
            // }
            html += "<td></td>";
            html += "</tr><tr>";
            html += tmpStr1 + me.htmlCls.inputCheckStr + "id='" + me.pre + "anno_ssbond'>Disulfide Bonds" + me.htmlCls.space2 + "</span></td>";
            html += tmpStr1 + me.htmlCls.inputCheckStr + "id='" + me.pre + "anno_interact'>Interactions" + me.htmlCls.space2 + "</span></td>";
            html += tmpStr1 + me.htmlCls.inputCheckStr + "id='" + me.pre + "anno_crosslink'>Cross-Linkages" + me.htmlCls.space2 + "</span></td>";
            html += tmpStr1 + me.htmlCls.inputCheckStr + "id='" + me.pre + "anno_transmem'>Transmembrane" + me.htmlCls.space2 + "</span></td>";

            html += "<td></td>";
            html += "</tr><tr>";
            html += tmpStr1 + me.htmlCls.inputCheckStr + "id='" + me.pre + "anno_ig'>Ig Domains" + me.htmlCls.space2 + "</span></td>";

            html += "<td></td>";
            html += "</tr></table></div></div>";

            return html;
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Events {
        constructor(icn3dui) {
            this.icn3dui = icn3dui;
        }

        // simplify setLogCmd from clickMenuCls
        setLogCmd(str, bSetCommand, bAddLogs) {var me = this.icn3dui; me.icn3d;
            me.htmlCls.clickMenuCls.setLogCmd(str, bSetCommand, bAddLogs);
        }

        // ====== events start ===============
        fullScreenChange() { let me = this.icn3dui, ic = me.icn3d, thisClass = this; // event handler uses ".bind(inputAsThis)" to define "this"
            if(me.bNode) return;

            let fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement
              || document.mozFullscreenElement || document.msFullscreenElement;
            if(!fullscreenElement) {
                thisClass.setLogCmd("exit full screen", false);
                ic.bFullscreen = false;
                me.utilsCls.setViewerWidthHeight(me, true);
                ic.applyCenterCls.setWidthHeight(me.htmlCls.WIDTH, me.htmlCls.HEIGHT);
                ic.drawCls.draw();
            }
        }

        convertUniProtInChains(alignment) { let me = this.icn3dui; me.icn3d;
            let idArray = alignment.split(',');
            let alignment_final = '';
            for(let i = 0, il = idArray.length; i < il; ++i) {
                alignment_final += (idArray[i].indexOf('_') != -1) ? idArray[i] : idArray[i] + '_A'; // AlphaFold ID
                if(i < il - 1) alignment_final += ',';
            }

            return alignment_final;
        }

        async searchSeq() { let me = this.icn3dui, ic = me.icn3d, thisClass = this;
           let select = $("#" + me.pre + "search_seq").val();
           if(isNaN(select) && select.indexOf('$') == -1 && select.indexOf('.') == -1 && select.indexOf(':') == -1 
           && select.indexOf('@') == -1) {
               select = ':' + select;
           }
           let commandname = select.replace(/\s+/g, '_');
           let commanddesc = commandname;
           await ic.selByCommCls.selectByCommand(select, commandname, commanddesc);
           thisClass.setLogCmd('select ' + select + ' | name ' + commandname, true);
        }

        async setRealign(alignType, bMsa) { let me = this.icn3dui, ic = me.icn3d, thisClass = this;
            let nameArray = $("#" + me.pre + "atomsCustomRealignByStruct").val();
            if(nameArray.length > 0) {
                ic.hAtoms = ic.definedSetsCls.getAtomsFromNameArray(nameArray);
            }

            me.cfg.aligntool = alignType;

            let alignStr = (alignType == 'vast') ? 'structure align' : 'tmalign';
            alignStr += (bMsa) ? ' msa' : '';

            if(nameArray.length > 0) {
                thisClass.setLogCmd("realign on " + alignStr + " | " + nameArray, true);
            }
            else {
                thisClass.setLogCmd("realign on " + alignStr, true);
            }

            if(bMsa) {
                // choose the first chain for each structure
                if(nameArray.length == 0) {
                    nameArray = [];
                    let structureHash = {};
                    
                    for(let chainid in ic.chains) {
                        let atom = ic.firstAtomObjCls.getFirstAtomObj(ic.chains[chainid]);
                        if(!structureHash.hasOwnProperty(atom.structure) && (ic.proteins.hasOwnProperty(atom.serial) || ic.nucleotides.hasOwnProperty(atom.serial))) {
                            nameArray.push(chainid);
                            structureHash[atom.structure] = 1;
                        }
                    }
                }

                await ic.realignParserCls.realignOnStructAlignMsa(nameArray);
            }
            else {
                await ic.realignParserCls.realignOnStructAlign();
            }
        }

        async readFile(bAppend, files, index, dataStrAll, bmmCIF, bPng) { let me = this.icn3dui, ic = me.icn3d, thisClass = this;
            let file = files[index];
            let commandName = (bAppend) ? 'append': 'load';
            commandName += (bmmCIF) ? ' mmcif file ' : (bPng) ? ' png file ' : ' pdb file ';
            
            /*
                 reader.onload = async function(e) {
                   let imageStr = e.target.result; // or = reader.result;
                   await thisClass.loadPng(dataStr);
                 }
                 */

            let reader = new FileReader();
            reader.onload = async function(e) {
                let dataStr = e.target.result; // or = reader.result;
                thisClass.setLogCmd(commandName + file.name, false);

                if(!bAppend) {
                    ic.init();
                }
                else {
                    ic.resetConfig();
                    //ic.hAtoms = {};
                    //ic.dAtoms = {};
                    ic.bResetAnno = true;
                    ic.bResetSets = true;
                }

                ic.bInputfile = true;
                ic.InputfileType = (bmmCIF) ? 'mmcif' : (bPng) ? 'png' : 'pdb';
                if(bPng) {
                    let result = await me.htmlCls.setHtmlCls.loadPng(dataStr);
                    dataStr = result.pdb;

                    if(!dataStr) return; // old iCn3D PNG with sharable link

                    if(!ic.statefileArray) ic.statefileArray = [];
                    ic.statefileArray.push(result.statefile);
                }

                ic.InputfileData = (ic.InputfileData) ? ic.InputfileData + '\nENDMDL\n' + dataStr : dataStr;

                dataStrAll = (index > 0) ? dataStrAll + '\nENDMDL\n' + dataStr : dataStr;

                if(Object.keys(files).length == index + 1) {
                    if(bAppend) {
                        ic.hAtoms = {};
                        ic.dAtoms = {};
                    }
                    if(bmmCIF) {
                        await ic.mmcifParserCls.loadMultipleMmcifData(dataStrAll, undefined, bAppend); 
                    }
                    else {
                    	await ic.pdbParserCls.loadPdbData(dataStrAll, undefined, undefined, bAppend);
                    }

                    //ic.InputfileType = undefined; // reset
                }
                else {
                    await thisClass.readFile(bAppend, files, index + 1, dataStrAll, bmmCIF, bPng);
                }

                if(bAppend) {
                    if(ic.bSetChainsAdvancedMenu) ic.definedSetsCls.showSets();

                    ic.bResetAnno = true;

                    if(ic.bAnnoShown) {
                        await ic.showAnnoCls.showAnnotations();

                        ic.annotationCls.resetAnnoTabAll();
                    }
                }
            };

            if (typeof file === "object") {
                reader.readAsText(file);
            }
        }

        async loadPdbFile(bAppend, fileId, bmmCIF) { let me = this.icn3dui, ic = me.icn3d, thisClass = this;
           //me = ic.setIcn3dui(this.id);
           ic.bInitial = true;
           thisClass.iniFileLoad();
           let files = $("#" + me.pre + fileId)[0].files;
           if(!files[0]) {
             alert("Please select a file before clicking 'Load'");
           }
           else {
                me.htmlCls.setHtmlCls.fileSupport();
                ic.molTitle = "";

                //ic.fileCnt = Object.keys(files).length;
                //ic.loadedFileCnt = 0;

                ic.dataStrAll = '';

                await this.readFile(bAppend, files, 0, '', bmmCIF);
           }
        }

        saveHtml(id) { let me = this.icn3dui, ic = me.icn3d;
            let html = '';
            html += '<link rel="stylesheet" href="https://www.ncbi.nlm.nih.gov/Structure/icn3d/lib/jquery-ui-1.13.2.min.css">\n';
            html += '<link rel="stylesheet" href="https://www.ncbi.nlm.nih.gov/Structure/icn3d/icn3d_full_ui.css">\n';
            html += $("#" + id).html();
            let idArray = id.split('_');
            let idStr =(idArray.length > 2) ? idArray[2] : id;
            let structureStr = Object.keys(ic.structures)[0];
            if(Object.keys(ic.structures).length > 1) structureStr += '-' + Object.keys(ic.structures)[1];
            ic.saveFileCls.saveFile(structureStr + '-' + idStr + '.html', 'html', encodeURIComponent(html));
        }

        setPredefinedMenu(id) { let me = this.icn3dui, ic = me.icn3d;
            if(Object.keys(ic.chains).length < 2) {
                alert("At least two chains are required for alignment...");
                return;
            }
            me.htmlCls.clickMenuCls.SetChainsAdvancedMenu();
            let definedAtomsHtml = ic.definedSetsCls.setAtomMenu(['protein']);
            if($("#" + me.pre + id).length) {
                $("#" + me.pre + id).html(definedAtomsHtml);
            }
            
            $("#" + me.pre + id).resizable();
        }

        exportMsa(type) { let me = this.icn3dui, ic = me.icn3d;
            let text = ic.msa[type].join('\n\n');
            let fileType = (type == 'fasta') ? '.fasta' : (type == 'clustalw') ? '.aln' : '.txt';

            ic.saveFileCls.saveFile(ic.inputid + '_align' + fileType, 'text', [text]);
        }

        iniFileLoad() { let me = this.icn3dui, ic = me.icn3d;
            if(!me.cfg.notebook) dialog.dialog( "close" );
            //close all dialog
            if(!me.cfg.notebook) {
                $(".ui-dialog-content").dialog("close");
            }
            else {
                ic.resizeCanvasCls.closeDialogs();
            }
        }

        async launchMmdb(ids, bBiounit, hostUrl, bAppend) { let me = this.icn3dui, ic = me.icn3d, thisClass = this;
            if(!me.cfg.notebook) dialog.dialog( "close" );
            
            let flag = bBiounit ? 1 : 0;

            // remove space
            ids = ids.replace(/,/g, ' ').replace(/\s+/g, ',').trim();

            if(!ids) {
                alert("Please enter a list of PDB IDs or AlphaFold UniProt IDs...");
                return;
            }

            let idArray = ids.split(',');

            if(!bAppend) {
                if(idArray.length == 1 && (idArray[0].length == 4 || !isNaN(idArray[0])) ) {
                    thisClass.setLogCmd("load mmdb" + flag + " " + ids, false);
                    let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                    window.open(hostUrl + '?mmdbid=' + ids + '&bu=' + flag, urlTarget);
                }
                else {
                    thisClass.setLogCmd("load mmdbaf" + flag + " " + ids, false);
                    let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                    window.open(hostUrl + '?mmdbafid=' + ids + '&bu=' + flag, urlTarget);
                }
            }
            else {
                // single MMDB ID could show memebranes
                if(!ic.structures && idArray.length == 1 && (idArray[0].length == 4 || !isNaN(idArray[0])) ) {
                    thisClass.setLogCmd("load mmdb" + flag + " " + ids, false);
                    let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                    window.open(hostUrl + '?mmdbid=' + ids + '&bu=' + flag, urlTarget);
                }
                else {
                    me.cfg.mmdbafid = ids;
                    me.cfg.bu = flag;

                    ic.bMmdbafid = true;
                    ic.inputid = (ic.inputid) ? ic.inputid + me.cfg.mmdbafid : me.cfg.mmdbafid;
                    if(me.cfg.bu == 1) {
                        ic.loadCmd = 'load mmdbaf1 ' + me.cfg.mmdbafid;
                    }
                    else {
                        ic.loadCmd = 'load mmdbaf0 ' + me.cfg.mmdbafid;
                    }
                    me.htmlCls.clickMenuCls.setLogCmd(ic.loadCmd, true);  

                    let bStructures = (ic.structures && Object.keys(ic.structures).length > 0) ? true : false;

                    await ic.chainalignParserCls.downloadMmdbAf(me.cfg.mmdbafid);   

                    if(bStructures) {
                        if(ic.bSetChainsAdvancedMenu) ic.definedSetsCls.showSets();
                        if(ic.bAnnoShown) {
                            await ic.showAnnoCls.showAnnotations();
                            ic.annotationCls.resetAnnoTabAll();
                        }
                    }
                }
            }
        }

        //Hold all functions related to click events.
        allEventFunctions() { let me = this.icn3dui, ic = me.icn3d;
            let thisClass = this;

            if(me.bNode) return;

            let hostUrl = document.URL;
            let pos = hostUrl.indexOf("?");
            hostUrl = (pos == -1) ? hostUrl : hostUrl.substr(0, pos);

            // some URLs from VAST search are like https://www.ncbi.nlm.nih.gov/Structure/vast/icn3d/
            if(hostUrl.indexOf('/vast/icn3d/')) {
                hostUrl = hostUrl.replace(/\/vast\/icn3d\//g, '/icn3d/');
            }

            ic.definedSetsCls.clickCustomAtoms();
            ic.definedSetsCls.clickCommand_apply();
            ic.definedSetsCls.clickModeswitch();

            ic.selectionCls.clickShow_selected();
            ic.selectionCls.clickHide_selected();

            ic.diagram2dCls.click2Ddgm();
            ic.cartoon2dCls.click2Dcartoon();
            ic.ligplotCls.clickLigplot();
            ic.addTrackCls.clickAddTrackButton();
            ic.resizeCanvasCls.windowResize();
            ic.annotationCls.setTabs();
            ic.resid2specCls.switchHighlightLevel();

            if(! me.utilsCls.isMobile()) {
                ic.hlSeqCls.selectSequenceNonMobile();
            }
            else {
                ic.hlSeqCls.selectSequenceMobile();
                ic.hlSeqCls.selectChainMobile();
            }

            me.htmlCls.clickMenuCls.clickMenu1();
            me.htmlCls.clickMenuCls.clickMenu2();
            me.htmlCls.clickMenuCls.clickMenu3();
            me.htmlCls.clickMenuCls.clickMenu4();
            me.htmlCls.clickMenuCls.clickMenu5();
            me.htmlCls.clickMenuCls.clickMenu6();

            me.myEventCls.onIds("#" + me.pre + "menumode", "change", async function(e) { me.icn3d;
                e.preventDefault();
                let mode = $("#" + me.pre + "menumode").val();

                me.htmlCls.setHtmlCls.setCookie('menumode', mode);
                me.htmlCls.setMenuCls.resetMenu(mode);
            });

            // back and forward arrows
            me.myEventCls.onIds(["#" + me.pre + "back", "#" + me.pre + "mn6_back"], "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();
               thisClass.setLogCmd("back", false);
               await ic.resizeCanvasCls.back();
            });

            me.myEventCls.onIds(["#" + me.pre + "forward", "#" + me.pre + "mn6_forward"], "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();
               thisClass.setLogCmd("forward", false);
               await ic.resizeCanvasCls.forward();
            });

            me.myEventCls.onIds(["#" + me.pre + "fullscreen", "#" + me.pre + "mn6_fullscreen"], "click", function(e) { let ic = me.icn3d; // from expand icon for mobilemenu
               e.preventDefault();
               //me = ic.setIcn3dui($(this).attr('id'));
               thisClass.setLogCmd("enter full screen", false);
               ic.bFullscreen = true;
               me.htmlCls.WIDTH = $( window ).width();
               me.htmlCls.HEIGHT = $( window ).height();
               ic.applyCenterCls.setWidthHeight(me.htmlCls.WIDTH, me.htmlCls.HEIGHT);
               ic.drawCls.draw();

               ic.resizeCanvasCls.openFullscreen($("#" + me.pre + "canvas")[0]);
            });

            document.addEventListener('fullscreenchange', this.fullScreenChange.bind(this));
            document.addEventListener('webkitfullscreenchange', this.fullScreenChange.bind(this));
            document.addEventListener('mozfullscreenchange', this.fullScreenChange.bind(this));
            document.addEventListener('msfullscreenchange', this.fullScreenChange.bind(this));


            me.myEventCls.onIds(["#" + me.pre + "toggle", "#" + me.pre + "mn2_toggle"], "click", function(e) { let ic = me.icn3d;
               //thisClass.setLogCmd("toggle selection", true);
               ic.selectionCls.toggleSelection();
               thisClass.setLogCmd("toggle selection", true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_hl_clrYellow", "click", function(e) { let ic = me.icn3d;
               thisClass.setLogCmd("set highlight color yellow", true);
               ic.hColor = me.parasCls.thr(0xFFFF00);
               ic.matShader = ic.setColorCls.setOutlineColor('yellow');
               ic.drawCls.draw(); // required to make it work properly
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_hl_clrGreen", "click", function(e) { let ic = me.icn3d;
               thisClass.setLogCmd("set highlight color green", true);
               ic.hColor = me.parasCls.thr(0x00FF00);
               ic.matShader = ic.setColorCls.setOutlineColor('green');
               ic.drawCls.draw(); // required to make it work properly
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_hl_clrRed", "click", function(e) { let ic = me.icn3d;
               thisClass.setLogCmd("set highlight color red", true);
               ic.hColor = me.parasCls.thr(0xFF0000);
               ic.matShader = ic.setColorCls.setOutlineColor('red');
               ic.drawCls.draw(); // required to make it work properly
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_hl_styleOutline", "click", function(e) { let ic = me.icn3d;
               thisClass.setLogCmd("set highlight style outline", true);
               ic.bHighlight = 1;
               ic.hlUpdateCls.showHighlight();
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_hl_styleObject", "click", function(e) { let ic = me.icn3d;
               thisClass.setLogCmd("set highlight style 3d", true);
               ic.bHighlight = 2;
               ic.hlUpdateCls.showHighlight();
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_hl_styleNone", "click", function(e) { let ic = me.icn3d;
                e.stopImmediatePropagation();
                ic.hlUpdateCls.clearHighlight();
                thisClass.setLogCmd("clear selection", true);
            });

            me.myEventCls.onIds(["#" + me.pre + "alternate", "#" + me.pre + "mn2_alternate", "#" + me.pre + "alternate2"], "click", async function(e) { let ic = me.icn3d;
               ic.bAlternate = true;
               await ic.alternateCls.alternateStructures();
               ic.bAlternate = false;

               thisClass.setLogCmd("alternate structures", false);
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_realignresbyres", "click", function(e) { me.icn3d;
                me.htmlCls.dialogCls.openDlg('dl_realignresbyres', 'Align multiple chains residue by residue');
            });

            me.myEventCls.onIds("#" + me.pre + "realignSelection", "click", function(e) { let ic = me.icn3d;
                if(Object.keys(ic.chains).length < 2) {
                    alert("At least two chains are required for alignment...");
                    return;
                }
                
               ic.realignParserCls.realign();
               thisClass.setLogCmd("realign", true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_realignonseqalign", "click", function(e) { let ic = me.icn3d;
                if(ic.bRender) me.htmlCls.dialogCls.openDlg('dl_realign', 'Please select chains to realign');

                thisClass.setPredefinedMenu('atomsCustomRealign');
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_realignonstruct", "click", function(e) { let ic = me.icn3d;
                if(ic.bRender) me.htmlCls.dialogCls.openDlg('dl_realignbystruct', 'Please select chains to realign');

                thisClass.setPredefinedMenu('atomsCustomRealignByStruct');
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_realigntwostru", "click", function(e) { let ic = me.icn3d;
                if(ic.bRender) me.htmlCls.dialogCls.openDlg('dl_realigntwostru', 'Please select structures to realign');

                thisClass.setPredefinedMenu('atomsCustomRealignByStruct2');
            });


            me.myEventCls.onIds("#" + me.pre + "applyRealign", "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               let nameArray = $("#" + me.pre + "atomsCustomRealign").val();
               if(nameArray.length > 0) {
                   ic.hAtoms = ic.definedSetsCls.getAtomsFromNameArray(nameArray);
               }

               await ic.realignParserCls.realignOnSeqAlign();

               if(nameArray.length > 0) {
                   thisClass.setLogCmd("realign on seq align | " + nameArray, true);
               }
               else {
                   thisClass.setLogCmd("realign on seq align", true);
               }
            });

            me.myEventCls.onIds("#" + me.pre + "applyRealignByStruct", "click", async function(e) { me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );

                await thisClass.setRealign('vast', false);
             });

             me.myEventCls.onIds("#" + me.pre + "applyRealignByStruct_tmalign", "click", async function(e) { me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );

                await thisClass.setRealign('tmalign', false);
             });

             me.myEventCls.onIds("#" + me.pre + "applyRealignByStructMsa", "click", async function(e) { me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );

                await thisClass.setRealign('vast', true);
             });

             me.myEventCls.onIds("#" + me.pre + "applyRealignByStructMsa_tmalign", "click", async function(e) { me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );

                await thisClass.setRealign('tmalign', true);
             });

             me.myEventCls.onIds("#" + me.pre + "applyRealignByStruct_vastplus", "click", async function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                let nameArray = $("#" + me.pre + "atomsCustomRealignByStruct2").val();
                if(nameArray.length > 0) {
                    ic.hAtoms = ic.definedSetsCls.getAtomsFromNameArray(nameArray);
                }

                //me.cfg.aligntool = 'tmalign';

                await ic.vastplusCls.realignOnVastplus();

                if(nameArray.length > 0) {
                    thisClass.setLogCmd("realign on vastplus | " + nameArray, true);
                }
                else {
                    thisClass.setLogCmd("realign on vastplus", true);
                }
             });


            me.myEventCls.onIds("#" + me.pre + "applyColorSpectrumAcrossSets", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                let nameArray = $("#" + me.pre + "atomsCustomColorSpectrumAcross").val();
                if(nameArray.length == 0) {
                    alert("Please select some sets");
                    return;
                }

                let bSpectrum = true;
                ic.setColorCls.setColorAcrossSets(nameArray, bSpectrum);

                thisClass.setLogCmd("set color spectrum | " + nameArray, true);
            });

            me.myEventCls.onIds("#" + me.pre + "applyColorSpectrumBySets", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                let nameArray = $("#" + me.pre + "atomsCustomColorSpectrum").val();
                if(nameArray.length == 0) {
                    alert("Please select some sets");
                    return;
                }

                let bSpectrum = true;
                ic.setColorCls.setColorBySets(nameArray, bSpectrum);

                thisClass.setLogCmd("set residues color spectrum | " + nameArray, true);
            });

            me.myEventCls.onIds("#" + me.pre + "applyColorRainbowAcrossSets", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                let nameArray = $("#" + me.pre + "atomsCustomColorRainbowAcross").val();
                if(nameArray.length == 0) {
                    alert("Please select some sets");
                    return;
                }

                let bSpectrum = false;
                ic.setColorCls.setColorAcrossSets(nameArray, bSpectrum);

                thisClass.setLogCmd("set color rainbow | " + nameArray, true);
            });

            me.myEventCls.onIds("#" + me.pre + "applyColorRainbowBySets", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                let nameArray = $("#" + me.pre + "atomsCustomColorRainbow").val();
                if(nameArray.length == 0) {
                    alert("Please select some sets");
                    return;
                }

                let bSpectrum = false;
                ic.setColorCls.setColorBySets(nameArray, bSpectrum);

                thisClass.setLogCmd("set residues color rainbow | " + nameArray, true);
            });

            // other
            me.myEventCls.onIds("#" + me.pre + "anno_summary", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                ic.annotationCls.setAnnoViewAndDisplay('overview');
                thisClass.setLogCmd("set view overview", true);
            });
            me.myEventCls.onIds("#" + me.pre + "anno_details", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                ic.annotationCls.setAnnoViewAndDisplay('detailed view');
                thisClass.setLogCmd("set view detailed view", true);
            });

            me.myEventCls.onIds("#" + me.pre + "show_annotations", "click", async function(e) { let ic = me.icn3d;
                await ic.showAnnoCls.showAnnotations();
                thisClass.setLogCmd("view annotations", true);
            });

            me.myEventCls.onIds("#" + me.pre + "showallchains", "click", function(e) { let ic = me.icn3d;
               ic.annotationCls.showAnnoAllChains();
               thisClass.setLogCmd("show annotations all chains", true);
            });

            me.myEventCls.onIds("#" + me.pre + "show_alignsequences", "click", function(e) { me.icn3d;
                 me.htmlCls.dialogCls.openDlg('dl_alignment', 'Select residues in aligned sequences');
            });

            me.myEventCls.onIds(["#" + me.pre + "show_2ddgm", "#" + me.pre + "mn2_2ddgm"], "click", async function(e) { let ic = me.icn3d;
                 me.htmlCls.dialogCls.openDlg('dl_2ddgm', '2D Diagram');
                 await ic.viewInterPairsCls.retrieveInteractionData();
                 thisClass.setLogCmd("view interactions", true);
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_2ddepiction", "click", async function(e) { let ic = me.icn3d;
                await ic.ligplotCls.drawLigplot(ic.atoms, true);
                thisClass.setLogCmd("view 2d depiction", true);
           });

            me.myEventCls.onIds("#" + me.pre + "search_seq_button", "click", async function(e) { me.icn3d;
               e.stopImmediatePropagation();
               await thisClass.searchSeq();
            });

            me.myEventCls.onIds("#" + me.pre + "search_seq", "keyup", async function(e) { me.icn3d;
               if (e.keyCode === 13) {
                   e.preventDefault();
                   await thisClass.searchSeq();
               }
            });


            me.myEventCls.onIds("#" + me.pre + "reload_vastplus", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                thisClass.setLogCmd("vast+ search " + $("#" + me.pre + "vastpluspdbid").val(), false);
                let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                window.open('https://www.ncbi.nlm.nih.gov/Structure/vastplus/vastplus.cgi?uid=' + $("#" + me.pre + "vastpluspdbid").val(), urlTarget);
             });

            me.myEventCls.onIds("#" + me.pre + "reload_vast", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                thisClass.setLogCmd("vast search " + $("#" + me.pre + "vastpdbid").val() + "_" + $("#" + me.pre + "vastchainid").val(), false);
                let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                window.open('https://www.ncbi.nlm.nih.gov/Structure/vast/vastsrv.cgi?pdbid=' + $("#" + me.pre + "vastpdbid").val() + '&chain=' + $("#" + me.pre + "vastchainid").val(), urlTarget);
             });

            me.myEventCls.onIds("#" + me.pre + "reload_foldseek", "click", function(e) { me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );

                let alignment = $("#" + me.pre + "foldseekchainids").val();
                let alignment_final = thisClass.convertUniProtInChains(alignment);

                thisClass.setLogCmd("load chainalignment " + alignment_final, true);
                window.open(hostUrl + '?chainalign=' + alignment_final + '&aligntool=tmalign&showalignseq=1&bu=0', '_self');
             });

            me.myEventCls.onIds("#" + me.pre + "reload_mmtf", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               thisClass.setLogCmd("load bcif " + $("#" + me.pre + "mmtfid").val(), false);
               let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
               window.open(hostUrl + '?bcifid=' + $("#" + me.pre + "mmtfid").val(), urlTarget);
            });

            me.myEventCls.onIds("#" + me.pre + "mmtfid", "keyup", function(e) { let ic = me.icn3d;
               if (e.keyCode === 13) {
                   e.preventDefault();
                   if(!me.cfg.notebook) dialog.dialog( "close" );
                   thisClass.setLogCmd("load mmtf " + $("#" + me.pre + "mmtfid").val(), false);
                   let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                   window.open(hostUrl + '?mmtfid=' + $("#" + me.pre + "mmtfid").val(), urlTarget);
               }
            });


            me.myEventCls.onIds("#" + me.pre + "reload_pdb", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               thisClass.setLogCmd("load pdb " + $("#" + me.pre + "pdbid").val(), false);
               let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
               window.open(hostUrl + '?pdbid=' + $("#" + me.pre + "pdbid").val(), urlTarget);
            });

            me.myEventCls.onIds("#" + me.pre + "translate_pdb", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                let dx = $("#" + me.pre + "translateX").val();
                let dy = $("#" + me.pre + "translateY").val();
                let dz = $("#" + me.pre + "translateZ").val();

                ic.transformCls.translateCoord(ic.hAtoms, parseFloat(dx), parseFloat(dy), parseFloat(dz));
                ic.drawCls.draw();

                thisClass.setLogCmd("translate pdb " + dx + " " + dy + " "  + dz, true);
            });

            me.myEventCls.onIds("#" + me.pre + "measure_angle", "click", function(e) { me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                let v1X = $("#" + me.pre + "v1X").val();
                let v1Y = $("#" + me.pre + "v1Y").val();
                let v1Z= $("#" + me.pre + "v1Z").val();

                let v2X = $("#" + me.pre + "v2X").val();
                let v2Y = $("#" + me.pre + "v2Y").val();
                let v2Z = $("#" + me.pre + "v2Z").val();

                let angleRad = new THREE.Vector3(parseFloat(v1X), parseFloat(v1Y), parseFloat(v1Z)).angleTo(new THREE.Vector3(parseFloat(v2X), parseFloat(v2Y), parseFloat(v2Z)));
                let angle = angleRad / 3.1416 * 180;
                angle = Math.abs(angle).toFixed(0);
                if(angle > 180) angle -= 180;
                if(angle > 90) angle = 180 - angle;

                thisClass.setLogCmd("The angle is " + angle + " degree", false);
                $("#" + me.pre + "angle_value").val(angle);
            });

            me.myEventCls.onIds("#" + me.pre + "matrix_pdb", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                let mArray = [];
                for(let i = 0; i< 16; ++i) {
                    mArray.push(parseFloat($("#" + me.pre + "matrix" + i).val()));
                }

                ic.transformCls.rotateCoord(ic.hAtoms, mArray);
                ic.drawCls.draw();

                thisClass.setLogCmd("rotate pdb " + mArray, true);
            });

            me.myEventCls.onIds("#" + me.pre + "pdbid", "keyup", function(e) { let ic = me.icn3d;
               if (e.keyCode === 13) {
                   e.preventDefault();
                   if(!me.cfg.notebook) dialog.dialog( "close" );
                   thisClass.setLogCmd("load pdb " + $("#" + me.pre + "pdbid").val(), false);
                   let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                   window.open(hostUrl + '?pdbid=' + $("#" + me.pre + "pdbid").val(), urlTarget);
               }
            });

            me.myEventCls.onIds("#" + me.pre + "reload_af", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               thisClass.setLogCmd("load af " + $("#" + me.pre + "afid").val(), false);
               let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
               window.open(hostUrl + '?afid=' + $("#" + me.pre + "afid").val(), urlTarget);
            });

            me.myEventCls.onIds("#" + me.pre + "reload_afmap", "click", async function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                let afid = me.cfg.afid ? me.cfg.afid : $("#" + me.pre + "afid").val();

                thisClass.setLogCmd("set half pae map " + afid, true);
                
                await ic.contactMapCls.afErrorMap(afid);
            });
            me.myEventCls.onIds("#" + me.pre + "reload_afmapfull", "click", async function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                let afid = me.cfg.afid ? me.cfg.afid : $("#" + me.pre + "afid").val();

                thisClass.setLogCmd("set full pae map " + afid, true);
                
                await ic.contactMapCls.afErrorMap(afid, true);
            });

            me.myEventCls.onIds("#" + me.pre + "afid", "keyup", function(e) { let ic = me.icn3d;
               if (e.keyCode === 13) {
                   e.preventDefault();
                   if(!me.cfg.notebook) dialog.dialog( "close" );
                   thisClass.setLogCmd("load af " + $("#" + me.pre + "afid").val(), false);
                   let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                   window.open(hostUrl + '?afid=' + $("#" + me.pre + "afid").val(), urlTarget);
               }
            });

            me.myEventCls.onIds("#" + me.pre + "reload_opm", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               thisClass.setLogCmd("load opm " + $("#" + me.pre + "opmid").val(), false);
               let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
               window.open(hostUrl + '?opmid=' + $("#" + me.pre + "opmid").val(), urlTarget);
            });

            me.myEventCls.onIds("#" + me.pre + "opmid", "keyup", function(e) { let ic = me.icn3d;
               if (e.keyCode === 13) {
                   e.preventDefault();
                   if(!me.cfg.notebook) dialog.dialog( "close" );
                   thisClass.setLogCmd("load opm " + $("#" + me.pre + "opmid").val(), false);
                   let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                   window.open(hostUrl + '?opmid=' + $("#" + me.pre + "opmid").val(), urlTarget);
               }
            });

            me.myEventCls.onIds("#" + me.pre + "reload_align_refined", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                let alignment = $("#" + me.pre + "alignid1").val() + "," + $("#" + me.pre + "alignid2").val();
                thisClass.setLogCmd("load alignment " + alignment + ' | parameters &atype=1&bu=1', false);
                let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                window.open(hostUrl + '?align=' + alignment + '&showalignseq=1&atype=1&bu=1', urlTarget);
             });

            me.myEventCls.onIds("#" + me.pre + "reload_align_ori", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                let alignment = $("#" + me.pre + "alignid1").val() + "," + $("#" + me.pre + "alignid2").val();
                thisClass.setLogCmd("load alignment " + alignment + ' | parameters &atype=0&bu=1', false);
                let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                window.open(hostUrl + '?align=' + alignment + '&showalignseq=1&atype=0&bu=1', urlTarget);
             });

            me.myEventCls.onIds("#" + me.pre + "reload_align_tmalign", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                let alignment = $("#" + me.pre + "alignid1").val() + "," + $("#" + me.pre + "alignid2").val();
                thisClass.setLogCmd("load alignment " + alignment + ' | parameters &atype=2&bu=1', false);
                let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                window.open(hostUrl + '?align=' + alignment + '&showalignseq=1&atype=2&bu=1', urlTarget);
             });

            me.myEventCls.onIds("#" + me.pre + "reload_alignaf", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                let alignment = $("#" + me.pre + "alignafid1").val() + "_A," + $("#" + me.pre + "alignafid2").val() + "_A";
                thisClass.setLogCmd("load chains " + alignment + " | residues | resdef ", false);
                let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                window.open(hostUrl + '?chainalign=' + alignment + '&resnum=&resdef=&showalignseq=1', urlTarget);
              });

            me.myEventCls.onIds("#" + me.pre + "reload_alignaf_tmalign", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                let alignment = $("#" + me.pre + "alignafid1").val() + "_A," + $("#" + me.pre + "alignafid2").val() + "_A";
                thisClass.setLogCmd("load chains " + alignment + " | residues | resdef | align tmalign", false);
                let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                window.open(hostUrl + '?chainalign=' + alignment + '&aligntool=tmalign&resnum=&resdef=&showalignseq=1', urlTarget);
              });


            me.myEventCls.onIds("#" + me.pre + "reload_chainalign_asym", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );

               let alignment = $("#" + me.pre + "chainalignids").val();
               let alignment_final = thisClass.convertUniProtInChains(alignment);

               thisClass.setLogCmd("load chains " + alignment_final + " on asymmetric unit | residues | resdef ", false);
               let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
               window.open(hostUrl + '?chainalign=' + alignment_final + '&resnum=&resdef=&showalignseq=1&bu=0', urlTarget);
            });

            me.myEventCls.onIds("#" + me.pre + "reload_chainalign_asym2", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
     
                let alignment = $("#" + me.pre + "chainalignids2").val();
                let alignment_final = thisClass.convertUniProtInChains(alignment);
                let resalign = $("#" + me.pre + "resalignids").val();
     
                thisClass.setLogCmd("load chains " + alignment_final + " on asymmetric unit | residues " + resalign + " | resdef ", false);
                let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                window.open(hostUrl + '?chainalign=' + alignment_final + '&resnum=' + resalign + '&resdef=&showalignseq=1&bu=0', urlTarget);
             });

             me.myEventCls.onIds("#" + me.pre + "reload_chainalign_asym3", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
     
                let alignment = $("#" + me.pre + "chainalignids3").val();
                let alignment_final = thisClass.convertUniProtInChains(alignment);

                let predefinedres = $("#" + me.pre + "predefinedres").val().trim().replace(/\n/g, ': ');
                if(predefinedres && alignment_final.split(',').length - 1 != predefinedres.split(': ').length) {
                    alert("Please make sure the number of chains and the lines of predefined residues are the same...");
                    return;
                }
     
                thisClass.setLogCmd("load chains " + alignment_final + " on asymmetric unit | residues | resdef " + predefinedres, false);
                let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                window.open(hostUrl + '?chainalign=' + alignment_final + '&resnum=&resdef=' + predefinedres + '&showalignseq=1&bu=0', urlTarget);
             });

             me.myEventCls.onIds("#" + me.pre + "reload_chainalign_asym4", "click", async function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
     
                let alignment = $("#" + me.pre + "chainalignids4").val();
                let alignment_final = thisClass.convertUniProtInChains(alignment);

                let predefinedres = $("#" + me.pre + "predefinedres2").val().trim().replace(/\n/g, ': ');
                if(predefinedres && alignment_final.split(',').length - 1 != predefinedres.split(': ').length) {
                    alert("Please make sure the number of chains and the lines of predefined residues are the same...");
                    return;
                }

                me.cfg.resdef = predefinedres.replace(/:/gi, ';');

                let bRealign = true, bPredefined = true;
                let chainidArray = alignment_final.split(',');
                await ic.realignParserCls.realignChainOnSeqAlign(undefined, chainidArray, bRealign, bPredefined);
     
                thisClass.setLogCmd("realign predefined " + alignment_final + " " + predefinedres, true);
             });

            me.myEventCls.onIds("#" + me.pre + "reload_chainalign_tmalign", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );

                let alignment = $("#" + me.pre + "chainalignids").val();
                let alignment_final = thisClass.convertUniProtInChains(alignment);
     
                thisClass.setLogCmd("load chains " + alignment_final + " on asymmetric unit | residues | resdef | align tmalign", false);
                let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                window.open(hostUrl + '?chainalign=' + alignment_final + '&aligntool=tmalign&resnum=&resdef=&showalignseq=1&bu=0', urlTarget);
             });

            me.myEventCls.onIds("#" + me.pre + "reload_mutation_3d", "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               let mutationids = $("#" + me.pre + "mutationids").val();
               //let idsource = $("#" + me.pre + "idsource").val();
               let idsource, pdbsource;
               if($("#" + me.pre + "type_mmdbid").is(":checked")) {
                    idsource = 'mmdbid';
               }
               else {
                    idsource = 'afid';
               }
               if($("#" + me.pre + "showin_currentpage").is(":checked")) {
                    pdbsource = 'currentpage';
                }
                else {
                    pdbsource = 'newpage';
                }

               if(pdbsource == 'currentpage') {
                    let snp = mutationids;

                    await ic.scapCls.retrieveScap(snp);
                    thisClass.setLogCmd('scap 3d ' + snp, true);
                    thisClass.setLogCmd("select displayed set", true);
               }
               else {
                    let mmdbid = mutationids.substr(0, mutationids.indexOf('_'));           
                    thisClass.setLogCmd("3d of mutation " + mutationids, false);
                    let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                    window.open(hostUrl + '?' + idsource + '=' + mmdbid + '&command=scap 3d ' + mutationids + '; select displayed set', urlTarget);
               }
            });

            me.myEventCls.onIds("#" + me.pre + "reload_mutation_pdb", "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               let mutationids = $("#" + me.pre + "mutationids").val();
               //let idsource = $("#" + me.pre + "idsource").val();
               let idsource, pdbsource;
               if($("#" + me.pre + "type_mmdbid").is(":checked")) {
                    idsource = 'mmdbid';
               }
               else {
                    idsource = 'afid';
               }
               if($("#" + me.pre + "showin_currentpage").is(":checked")) {
                    pdbsource = 'currentpage';
                }
                else {
                    pdbsource = 'newpage';
                }

               if(pdbsource == 'currentpage') {
                    let snp = mutationids;

                    let bPdb = true;
                    await ic.scapCls.retrieveScap(snp, undefined, bPdb);
                    thisClass.setLogCmd('scap pdb ' + snp, true);
               }
               else {
                    let mmdbid = mutationids.substr(0, mutationids.indexOf('_'));
                    thisClass.setLogCmd("pdb of mutation " + mutationids, false);
                    let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                    window.open(hostUrl + '?' + idsource + '=' + mmdbid + '&command=scap pdb ' + mutationids + '; select displayed set', urlTarget);
               }
            });

            me.myEventCls.onIds("#" + me.pre + "reload_mutation_inter", "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               let mutationids = $("#" + me.pre + "mutationids").val();
               //let idsource = $("#" + me.pre + "idsource").val();
               let idsource, pdbsource;
               if($("#" + me.pre + "type_mmdbid").is(":checked")) {
                    idsource = 'mmdbid';
               }
               else {
                    idsource = 'afid';
               }
               if($("#" + me.pre + "showin_currentpage").is(":checked")) {
                    pdbsource = 'currentpage';
                }
                else {
                    pdbsource = 'newpage';
                }

               if(pdbsource == 'currentpage') {
                    let snp = mutationids;

                    let bInteraction = true;
                    await ic.scapCls.retrieveScap(snp, bInteraction);
                    thisClass.setLogCmd('scap interaction ' + snp, true);

                    let idArray = snp.split('_'); //stru_chain_resi_snp
                    let select = '.' + idArray[1] + ':' + idArray[2];
                    let name = 'snp_' + idArray[1] + '_' + idArray[2];
                    thisClass.setLogCmd("select " + select + " | name " + name, true);
                    thisClass.setLogCmd("line graph interaction pairs | selected non-selected | hbonds,salt bridge,interactions,halogen,pi-cation,pi-stacking | false | threshold 3.8 6 4 3.8 6 5.5", true);
                    thisClass.setLogCmd("adjust dialog dl_linegraph", true);
                    thisClass.setLogCmd("select displayed set", true);
               }
               else {
                    let mutationArray = mutationids.split(',');
                    let residArray = [];
                    for(let i = 0, il = mutationArray.length; i < il; ++i) {
                        let pos = mutationArray[i].lastIndexOf('_');
                        let resid = mutationArray[i].substr(0, pos);
                        residArray.push(resid);
                    }

                    let mmdbid = mutationids.substr(0, mutationids.indexOf('_'));

                    // if no structures are loaded yet
                    if(!ic.structures) {
                        ic.structures = {};
                        ic.structures[mmdbid] = 1;
                    }
                    ic.resid2specCls.residueids2spec(residArray);

                    thisClass.setLogCmd("interaction change of mutation " + mutationids, false);
                    let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                    window.open(hostUrl + '?' + idsource + '=' + mmdbid + '&command=scap interaction ' + mutationids, urlTarget);
               }
            });

            me.myEventCls.onIds("#" + me.pre + "reload_mmcif", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               thisClass.setLogCmd("load mmcif " + $("#" + me.pre + "mmcifid").val(), false);
               let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
               window.open(hostUrl + '?mmcifid=' + $("#" + me.pre + "mmcifid").val(), urlTarget);
            });

            me.myEventCls.onIds("#" + me.pre + "mmcifid", "keyup", function(e) { let ic = me.icn3d;
               if (e.keyCode === 13) {
                   e.preventDefault();
                   if(!me.cfg.notebook) dialog.dialog( "close" );
                   thisClass.setLogCmd("load mmcif " + $("#" + me.pre + "mmcifid").val(), false);
                   let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                   window.open(hostUrl + '?mmcifid=' + $("#" + me.pre + "mmcifid").val(), urlTarget);
               }
            });


            me.myEventCls.onIds("#" + me.pre + "reload_mmdb", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               
               thisClass.setLogCmd("load mmdb1 " + $("#" + me.pre + "mmdbid").val(), false);
               let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
               window.open(hostUrl + '?mmdbid=' + $("#" + me.pre + "mmdbid").val() + '&bu=1', urlTarget);
            });

            me.myEventCls.onIds("#" + me.pre + "reload_mmdb_asym", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                
                thisClass.setLogCmd("load mmdb0 " + $("#" + me.pre + "mmdbid").val(), false);
                let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                window.open(hostUrl + '?mmdbid=' + $("#" + me.pre + "mmdbid").val() + '&bu=0', urlTarget);
            });

             me.myEventCls.onIds("#" + me.pre + "reload_mmdbaf", "click", function(e) { me.icn3d;
                e.preventDefault();
                let ids = $("#" + me.pre + "mmdbafid").val();
                thisClass.launchMmdb(ids, 1, hostUrl);
            });
     
             me.myEventCls.onIds("#" + me.pre + "reload_mmdbaf_asym", "click", function(e) { me.icn3d;
                e.preventDefault();
                let ids = $("#" + me.pre + "mmdbafid").val();
                thisClass.launchMmdb(ids, 0, hostUrl);
            });

            me.myEventCls.onIds("#" + me.pre + "reload_mmdbaf_append", "click", function(e) { me.icn3d;
                e.preventDefault();
                let ids = $("#" + me.pre + "mmdbafid").val();
                thisClass.launchMmdb(ids, 1, hostUrl, true);
            });
     
             me.myEventCls.onIds("#" + me.pre + "reload_mmdbaf_asym_append", "click", function(e) { me.icn3d;
                e.preventDefault();
                let ids = $("#" + me.pre + "mmdbafid").val();
                thisClass.launchMmdb(ids, 0, hostUrl, true);
            });

            me.myEventCls.onIds("#" + me.pre + "mmdbid", "keyup", function(e) { let ic = me.icn3d;
               if (e.keyCode === 13) {
                   e.preventDefault();
                   
                   thisClass.setLogCmd("load mmdb1 " + $("#" + me.pre + "mmdbid").val(), false);
                   let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                   window.open(hostUrl + '?mmdbid=' + $("#" + me.pre + "mmdbid").val() + '&bu=1', urlTarget);
                  }
            });

            me.myEventCls.onIds("#" + me.pre + "mmdbafid", "keyup", function(e) { me.icn3d;
                if (e.keyCode === 13) {
                    e.preventDefault();
                    
                    let ids = $("#" + me.pre + "mmdbafid").val();
                    thisClass.launchMmdb(ids, 1, hostUrl);
                   }
             });


            me.myEventCls.onIds("#" + me.pre + "reload_blast_rep_id", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               let query_id = $("#" + me.pre + "query_id").val().trim();
               if(query_id.substr(1, 2) == 'M_') { // e.g., NM_..., XM_...
                    alert("You are inputting a nucleotide accession " + query_id + ". Please use a protein accession instead.");
                    return;
               }
               let query_fasta = encodeURIComponent($("#" + me.pre + "query_fasta").val());
               let blast_rep_id = $("#" + me.pre + "blast_rep_id").val();
               thisClass.setLogCmd("load seq_struct_ids " + query_id + "," + blast_rep_id, false);
               query_id =(query_id !== '' && query_id !== undefined) ? query_id : query_fasta;
               let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
               window.open(hostUrl + '?from=icn3d&alg=blast&blast_rep_id=' + blast_rep_id
                 + '&query_id=' + query_id
                 + '&command=view annotations; set annotation cdd; set annotation site; set view detailed view; select chain '
                 + blast_rep_id + '; show selection', urlTarget);
            });

            me.myEventCls.onIds("#" + me.pre + "run_esmfold", "click", async function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );

                if($('#' + me.pre + 'dl_mmdbafid').hasClass('ui-dialog-content')) {
                    $('#' + me.pre + 'dl_mmdbafid').dialog( 'close' );
                }

                let esmfold_fasta = $("#" + me.pre + "esmfold_fasta").val();
                let pdbid = 'stru--';

                if(esmfold_fasta.indexOf('>') != -1) { //FASTA with header
                    let pos = esmfold_fasta.indexOf('\n');
                    ic.esmTitle = esmfold_fasta.substr(1, pos - 1).trim();
                    if(ic.esmTitle.indexOf('|') != -1) { // uniprot
                        let idArray = ic.esmTitle.split('|');
                        pdbid = (idArray.length > 2) ? idArray[1] : ic.esmTitle;
                    }
                    else { // NCBI
                        pdbid = (ic.esmTitle.indexOf(' ') != -1) ? ic.esmTitle.substr(0, ic.esmTitle.indexOf(' ')) : ic.esmTitle;
                    }

                    if(pdbid.length < 6) pdbid = pdbid.padEnd(6, '-');

                    esmfold_fasta = esmfold_fasta.substr(pos + 1);
                }

                // remove new lines
                esmfold_fasta = esmfold_fasta.replace(/\s/g, '');

                if(esmfold_fasta.length > 400) {
                    alert("Your sequence is larger than 400 characters. Please consider to split it as described at https://github.com/facebookresearch/esm/issues/21.");
                    return;
                }

                let esmUrl = "https://api.esmatlas.com/foldSequence/v1/pdb/";
                let alertMess = 'Problem in returning PDB from ESMFold server...';
                thisClass.setLogCmd("Run ESMFold with the sequence " + esmfold_fasta, false);

                let esmData = await me.getAjaxPostPromise(esmUrl, esmfold_fasta, true, alertMess, undefined, true, 'text');
                
                ic.bResetAnno = true;
                
                ic.bInputfile = true;
                ic.InputfileType = 'pdb';
                ic.InputfileData = (ic.InputfileData) ? ic.InputfileData + '\nENDMDL\n' + esmData : esmData;

                ic.bEsmfold = true;
                let bAppend = true;
                await ic.pdbParserCls.loadPdbData(esmData, pdbid, undefined, bAppend, undefined, undefined, undefined, ic.bEsmfold);
             });

            me.myEventCls.onIds("#" + me.pre + "reload_alignsw", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                let query_id = $("#" + me.pre + "query_id").val().trim();
                if(query_id.substr(1, 2) == 'M_') { // e.g., NM_..., XM_...
                    alert("You are inputting a nucleotide accession " + query_id + ". Please use a protein accession instead.");
                    return;
                }
                let query_fasta = encodeURIComponent($("#" + me.pre + "query_fasta").val());
                let blast_rep_id = $("#" + me.pre + "blast_rep_id").val();
                thisClass.setLogCmd("load seq_struct_ids_smithwm " + query_id + "," + blast_rep_id, false);
                query_id =(query_id !== '' && query_id !== undefined) ? query_id : query_fasta;
                
                let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                window.open(hostUrl + '?from=icn3d&alg=smithwm&blast_rep_id=' + blast_rep_id
                  + '&query_id=' + query_id
                  + '&command=view annotations; set annotation cdd; set annotation site; set view detailed view; select chain '
                  + blast_rep_id + '; show selection', urlTarget);
             });

             me.myEventCls.onIds("#" + me.pre + "reload_alignswlocal", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                let query_id = $("#" + me.pre + "query_id").val().trim();
                if(query_id.substr(1, 2) == 'M_') { // e.g., NM_..., XM_...
                    alert("You are inputting a nucleotide accession " + query_id + ". Please use a protein accession instead.");
                    return;
                }
                let query_fasta = encodeURIComponent($("#" + me.pre + "query_fasta").val());
                let blast_rep_id = $("#" + me.pre + "blast_rep_id").val();
                thisClass.setLogCmd("load seq_struct_ids_local_smithwm " + query_id + "," + blast_rep_id, false);
                query_id =(query_id !== '' && query_id !== undefined) ? query_id : query_fasta;
                
                let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                window.open(hostUrl + '?from=icn3d&alg=local_smithwm&blast_rep_id=' + blast_rep_id
                  + '&query_id=' + query_id
                  + '&command=view annotations; set annotation cdd; set annotation site; set view detailed view; select chain '
                  + blast_rep_id + '; show selection', urlTarget);
             });


            me.myEventCls.onIds("#" + me.pre + "reload_proteinname", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               thisClass.setLogCmd("load protein " + $("#" + me.pre + "proteinname").val(), false);
               let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
               window.open(hostUrl + '?protein=' + $("#" + me.pre + "proteinname").val(), urlTarget);
            });

            me.myEventCls.onIds("#" + me.pre + "reload_refseq", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                thisClass.setLogCmd("load refseq " + $("#" + me.pre + "refseqid").val(), false);
                let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                window.open(hostUrl + '?refseqid=' + $("#" + me.pre + "refseqid").val(), urlTarget);
             });

            me.myEventCls.onIds("#" + me.pre + "gi", "keyup", function(e) { let ic = me.icn3d;
               if (e.keyCode === 13) {
                   e.preventDefault();
                   if(!me.cfg.notebook) dialog.dialog( "close" );
                   thisClass.setLogCmd("load gi " + $("#" + me.pre + "gi").val(), false);
                   let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                   window.open(hostUrl + '?gi=' + $("#" + me.pre + "gi").val(), urlTarget);
               }
            });

            me.myEventCls.onIds("#" + me.pre + "reload_uniprotid", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               thisClass.setLogCmd("load uniprotid " + $("#" + me.pre + "uniprotid").val(), false);
               let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
               window.open(hostUrl + '?uniprotid=' + $("#" + me.pre + "uniprotid").val(), urlTarget);
            });

            me.myEventCls.onIds("#" + me.pre + "uniprotid", "keyup", function(e) { let ic = me.icn3d;
               if (e.keyCode === 13) {
                   e.preventDefault();
                   if(!me.cfg.notebook) dialog.dialog( "close" );
                   thisClass.setLogCmd("load uniprotid " + $("#" + me.pre + "uniprotid").val(), false);
                   let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                   window.open(hostUrl + '?uniprotid=' + $("#" + me.pre + "uniprotid").val(), urlTarget);
               }
            });


            me.myEventCls.onIds("#" + me.pre + "reload_cid", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               thisClass.setLogCmd("load cid " + $("#" + me.pre + "cid").val(), false);
               let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
               window.open(hostUrl + '?cid=' + $("#" + me.pre + "cid").val(), urlTarget);
            });

            me.myEventCls.onIds("#" + me.pre + "reload_smiles", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                // thisClass.setLogCmd("load smiles " + $("#" + me.pre + "smiles").val(), false);
                let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';

                urlTarget = '_blank';

                window.open(hostUrl + '?smiles=' + encodeURIComponent($("#" + me.pre + "smiles").val()), urlTarget);
            });

            me.myEventCls.onIds("#" + me.pre + "cid", "keyup", function(e) { let ic = me.icn3d;
               if (e.keyCode === 13) {
                   e.preventDefault();
                   if(!me.cfg.notebook) dialog.dialog( "close" );
                   thisClass.setLogCmd("load cid " + $("#" + me.pre + "cid").val(), false);
                   let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
                   window.open(hostUrl + '?cid=' + $("#" + me.pre + "cid").val(), urlTarget);
               }
            });


            me.htmlCls.setHtmlCls.clickReload_pngimage();

            me.myEventCls.onIds("#" + me.pre + "video_start", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();

                const canvas = document.getElementById(ic.pre + "canvas");
                ic.videoRecorder = new MediaRecorder(canvas.captureStream());
                const recordedChunks = [];

                // Collect data chunks
                ic.videoRecorder.ondataavailable = event => {
                    recordedChunks.push(event.data);
                };

                ic.videoRecorder.onstop = event => {
                    // Code to save the recordedChunks as a video file
                    const blob = new Blob(recordedChunks, {type: ic.videoRecorder.mimeType});
                    let fileName = ic.inputid + '_video';
                    saveAs(blob, fileName);
                };

                // Start recording
                ic.videoRecorder.start();
                thisClass.setLogCmd('Video revording started', false);
            });
     
            me.myEventCls.onIds("#" + me.pre + "video_end", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();

                ic.videoRecorder.stop();
                thisClass.setLogCmd('Video revording ended', false);
            });

            me.myEventCls.onIds("#" + me.pre + "reload_state", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               thisClass.iniFileLoad();
               // initialize icn3dui
               //Do NOT clear data if iCn3D loads a pdb or other data file and then load a state file
               if(!ic.bInputfile) {
                   //ic.initUI();
                   ic.init();
               }
               let file = $("#" + me.pre + "state")[0].files[0];
               if(!file) {
                 alert("Please select a file before clicking 'Load'");
               }
               else {
                 me.htmlCls.setHtmlCls.fileSupport();
                 let reader = new FileReader();
                 reader.onload = async function(e) {
                   ic.bStatefile = true;

                   let dataStr = e.target.result; // or = reader.result;
                   thisClass.setLogCmd('load state file ' + $("#" + me.pre + "state").val(), false);
                   ic.commands = [];
                   ic.optsHistory = [];
                   await ic.loadScriptCls.loadScript(dataStr, true);
                 };
                 reader.readAsText(file);
               }
            });

            me.myEventCls.onIds("#" + me.pre + "reload_selectionfile", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               let file = $("#" + me.pre + "selectionfile")[0].files[0];
               if(!file) {
                 alert("Please select a file before clicking 'Load'");
               }
               else {
                 me.htmlCls.setHtmlCls.fileSupport();
                 let reader = new FileReader();
                 reader.onload = async function(e) {
                   let dataStr = e.target.result; // or = reader.result;
                   await ic.selectionCls.loadSelection(dataStr);
                   thisClass.setLogCmd('load selection file ' + $("#" + me.pre + "selectionfile").val(), false);
                 };
                 reader.readAsText(file);
               }
            });

            me.myEventCls.onIds("#" + me.pre + "reload_collectionfile", "click", function (e) { let ic = me.icn3d;
                e.preventDefault();
                let file = $("#" + me.pre + "collectionfile")[0].files[0];
                if (!file) {
                    alert("Please select a file before clicking 'Load'");
                } else {
                thisClass.iniFileLoad();
                    
                ic.dAtoms = me.hashUtilsCls.cloneHash(ic.atoms);
                ic.hAtoms = me.hashUtilsCls.cloneHash(ic.atoms);
                me.htmlCls.setHtmlCls.fileSupport();

                let fileName = file.name;
                let fileExtension = fileName.split('.').pop().toLowerCase();
                let collection = {};
                
                $("#" + ic.pre + "collections_menu").empty();
                $("#" + ic.pre + "collections_menu").off("change");
                    
                if (dl_collectionAppendStructureNone.checked || ic.allData === undefined) {
                    ic.bInputfile = false;
                    ic.pdbCollection = {};
                    ic.allData = {};
                    ic.allData['all'] = {
                        'atoms': {},
                        'proteins': {},
                        'nucleotides': {},
                        'chemicals': {},
                        'ions': {},
                        'water': {},
                        'structures': {}, // getSSExpandedAtoms
                        'ssbondpnts': {},
                        'residues': {}, // getSSExpandedAtoms
                        'chains': {},
                        'chainsSeq': {}, //Sequences and Annotation
                        'defNames2Atoms': {},
                        'defNames2Residues': {}
                    };
                    ic.allData['prev'] = {};
                    ic.selectCollectionsCls.reset();

                } else {
                    if (ic.collections) {
                        collection = ic.collections;
                    }
                }

                function parseJsonCollection(data) {
                    let dataStr = JSON.parse(data);
                    let parsedCollection = {};

                    dataStr["structures"].map(({ id, title, description, commands }) => {
                        if (id && id.includes('.pdb')) {
                            id = id.split('.pdb')[0];
                        }
                        parsedCollection[id] = [id, title, description, commands, false];
                    });

                    return parsedCollection;
                }
                
                function parsePdbCollection(data, description = '', commands = []) {         
                    let dataStr = data;
                    let lines = dataStr.split('\n');
                    let sections = [];
                    let currentSection = [];
                    
                    lines.forEach(line => {
                        if (line.startsWith('HEADER')) {
                        currentSection = [];
                        sections.push(currentSection);
                        }
                        currentSection.push(line);
                    });
            
                    
                    let parsedCollection = {};
                    
                    sections.forEach((section) => {
                        let headerLine = section[0].replace(/[\n\r]/g, '').trim();
                        let header = headerLine.split(' ').filter(Boolean);
                        let id = header[header.length - 1];
                        let title = section[1].startsWith('TITLE') ? section[1].split('TITLE').pop().trim() : id;

                        parsedCollection[id] = [id, title, description, commands, true];

                        const sanitizedSection = section.map(line => line.trim());
                        ic.pdbCollection[id] = sanitizedSection;
                    });

                    return parsedCollection;
                }

                if (fileExtension === 'json' || fileExtension === 'pdb') {
                    let reader = new FileReader();
                    reader.onload = async function (e) {
                        if (fileExtension === 'json') {
                            let jsonCollection = parseJsonCollection(e.target.result);
                            collection = { ...collection, ...jsonCollection };
                        } else if (fileExtension === 'pdb') {
                            ic.bInputfile = true;
                            let pdbCollection = parsePdbCollection(e.target.result);
                            collection = { ...collection, ...pdbCollection };
                        }

                        let collectionHtml = await ic.selectCollectionsCls.setAtomMenu(collection);

                        ic.collections = collection;

                        $("#" + ic.pre + "collections_menu").html(collectionHtml);
                        await ic.selectCollectionsCls.clickStructure(collection);
                        $("#" + ic.pre + "collections_menu").trigger("change");     

                        me.htmlCls.clickMenuCls.setLogCmd(
                            "load collection file " +
                            $("#" + me.pre + "collectionfile").val(),
                            false
                        );
                    };

                    reader.readAsText(file);
                } else if (fileExtension === 'zip' || fileExtension === 'gz') {
                    ic.bInputfile = true;
                    let reader2 = new FileReader();
                    reader2.onload = async function (e) {
                        if (fileExtension === 'zip') {
                            let url = './script/jszip.min.js';
                            await me.getAjaxPromise(url, 'script');

                            let jszip = new JSZip();
                            try {
                                let data = await jszip.loadAsync(e.target.result);

                                let hasJson = false;
                                let hasPdb = false;
                                let hasGz = false;
                                let jsonFiles = [];
                                let pdbFiles = [];
                                let gzFiles = [];

                                for (let fileName in data.files) {
                                    let file = data.files[fileName];
                                    if (!file.dir) {
                                        if (fileName.endsWith('.json')) {
                                            hasJson = true;
                                            jsonFiles.push(file);
                                        } else if (fileName.endsWith('.pdb')) {
                                            hasPdb = true;
                                            pdbFiles.push(file);
                                        } else if (fileName.endsWith('.gz')) {
                                            hasGz = true;
                                            gzFiles.push(file);
                                        }
                                    }
                                }

                                if (hasJson && hasPdb) {
                                    let jsonCollection = [];
                                    for (const file of jsonFiles) {
                                        let fileData = await file.async('text');
                                        let parsedJson = Object.values(parseJsonCollection(fileData));
                                        parsedJson.forEach(element => {
                                            jsonCollection.push(element);
                                        });
                                    }

                                    // For each JSON object, check if a corresponding PDB file exists
                                    for (const [id, title, description, commands, _] of jsonCollection) {
                                        let matchingPdbFile = pdbFiles.find(file => file.name.toLowerCase().includes(id.toLowerCase()));
                                        if (matchingPdbFile) {
                                            let pdbFileData = await matchingPdbFile.async('text');
                                            let parsedPdb = Object.values(parsePdbCollection(pdbFileData, description, commands));
                                            parsedPdb.forEach(element => {
                                                collection[id] = element;
                                            });
                                        }
                                    }

                                } else if (hasJson) {
                                    // Do something if only JSON files are present
                                    jsonFiles.forEach(async file => {
                                        let fileData = await file.async('text');
                                        const parsedJson = Object.values(parseJsonCollection(fileData));
                                        parsedJson.forEach(element => {
                                            collection[element[0]] = element;
                                        });
                                    });
                                } else if (hasPdb) {
                                    // Do something if only PDB files are present
                                    pdbFiles.forEach(async file => {
                                        let fileData = await file.async('text');
                                        const parsedPdb = Object.values(parsedPdbCollection(fileData));
                                        parsedPdb.forEach(element => {
                                            collection[element[0]] = element;
                                        });
                                    });
                                } else if (hasGz) {
                                    let url = './script/pako.min.js';
                                    await me.getAjaxPromise(url, 'script');
                                    try {
                                        for (const file of gzFiles) {
                                            let compressed = await file.async('uint8array');
                                            let decompressed = pako.inflate(compressed, { to: 'string' });
                                            const parsedPdb = Object.values(parsePdbCollection(decompressed));
                                            parsedPdb.forEach(element => {
                                                collection[element[0]] = element;
                                            });
                                        }
                                    } catch (error) {
                                        console.error('Error loading GZ file', error);
                                    }
                                }
                            } catch (error) {
                                console.error('Error loading ZIP file', error);
                            }
                        } else if (fileExtension === 'gz') {
                            let url = './script/pako.min.js';
                            await me.getAjaxPromise(url, 'script');
                            
                            try {
                                const compressed = new Uint8Array(e.target.result);
                                const decompressed = pako.inflate(compressed, { to: 'string' });
                                collection = parsePdbCollection(decompressed);
                            } catch (error) {
                                console.error('Error loading GZ file', error);
                            }
                        }

                        let collectionHtml = await ic.selectCollectionsCls.setAtomMenu(collection);

                        $("#" + ic.pre + "collections_menu").html(collectionHtml);
                        await ic.selectCollectionsCls.clickStructure(collection);

                        ic.collections = collection;

                        $("#" + ic.pre + "collections_menu").trigger("change");

                        me.htmlCls.clickMenuCls.setLogCmd(
                            "load collection file " +
                            $("#" + me.pre + "collectionfile").val(),
                            false
                        );
                    };

                    reader2.onerror = function(error) {
                        console.error('Error reading file', error);
                    };

                    reader2.readAsArrayBuffer(file);
                } else {
                    throw new Error('Invalid file type');
                }
                
                if (ic.allData && Object.keys(ic.allData).length > 0) {
                    $("#" + me.pre + "dl_collection_file").hide();
                    $("#" + me.pre + "dl_collection_structures").show();
                    $("#" + me.pre + "dl_collection_file_expand").show();
                    $("#" + me.pre + "dl_collection_file_shrink").hide();
                    $("#" + me.pre + "dl_collection_structures_expand").hide();
                    $("#" + me.pre + "dl_collection_structures_shrink").show();

                } else {
                    $("#" + me.pre + "dl_collection_file").show();
                    $("#" + me.pre + "dl_collection_structures").hide();
                    $("#" + me.pre + "dl_collection_file_expand").hide();
                    $("#" + me.pre + "dl_collection_file_shrink").hide();
                    $("#" + me.pre + "dl_collection_structures_expand").show();
                    $("#" + me.pre + "dl_collection_structures_shrink").hide();
                }
                  
                me.htmlCls.dialogCls.openDlg("dl_selectCollections", "Select Collections");
                }
            });

            me.myEventCls.onIds("#" + me.pre + "collections_clear_commands", "click", function (e) {
                var selectedValues = $("#" + ic.pre + "collections_menu").val();
                selectedValues.forEach(function (selectedValue) {
                    if (ic.allData[selectedValue]) {
                        ic.allData[selectedValue]['commands'] = [];
                    } else {
                        console.warn("No data found for selectedValue:", selectedValue);
                    }
                });
            });

            me.myEventCls.onIds("#" + me.pre + "opendl_export_collections", "click", function (e) {
                me.htmlCls.dialogCls.openDlg("dl_export_collections", "Export Collections");
            });

            me.myEventCls.onIds("#" + me.pre + "export_collections", "click", function (e) {
                let ic = me.icn3d;

                const selectElement = document.getElementById(me.pre + 'collections_menu');
        
                // Array to store parsed results
                const structures = [];

                const dl_collectionExportSelected = document.getElementById('dl_collectionExportSelected');
                const dl_collectionExportAll = document.getElementById('dl_collectionExportAll');

                if (dl_collectionExportSelected.checked) {

                    // Iterate over each <option> element
                    Array.from(selectElement.options)
                        .filter(option => option.selected)
                        .forEach(option => {
                            const name = option.value;
                            const title = option.textContent.trim();
                            const description = option.getAttribute('data-description');

                            // Push the extracted data into the array
                            structures.push({
                                id: name,
                                title: title,
                                description: description || '',
                                commands: (ic.allData[name] && ic.allData[name].commands) ? ic.allData[name].commands : []
                            });
                        });
                } else if (dl_collectionExportAll.checked) {
                    // Iterate over each <option> element
                    Array.from(selectElement.options)
                        .forEach(option => {
                            const name = option.value;
                            const title = option.textContent.trim();
                            const description = option.getAttribute('data-description');

                            // Push the extracted data into the array
                            structures.push({
                                name: name,
                                title: title,
                                description: description || '',
                                commands: (ic.allData[name] && ic.allData[name].commands) ? ic.allData[name].commands : []
                            });
                        });
                }

                
                const now = new Date();
                const month = now.getMonth() + 1; // Months are zero-based
                const day = now.getDate();
                const year = now.getFullYear();
                const formattedDate = `${month}_${day}_${year}`;

                const collection = {
                    collectionTitle: document.getElementById('dl_collectionTitle').value,
                    collectionDescription: document.getElementById('dl_collectionDescription').value,
                    structures: structures
                };

                const filename = `${collection.collectionTitle.replace(/\s+/g, '_')}_${formattedDate}.json`;

                const jsonString = JSON.stringify(collection, null, 2);
        
                // Create a Blob with the JSON data
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                // Create a temporary link element to trigger download
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                // Revoke the object URL after download
                URL.revokeObjectURL(url);
            });

            me.myEventCls.onIds("#" + me.pre + "reload_dsn6file2fofc", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               //if(!me.cfg.notebook) dialog.dialog( "close" );
               ic.dsn6ParserCls.loadDsn6File('2fofc');
            });
            me.myEventCls.onIds("#" + me.pre + "reload_dsn6filefofc", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               //if(!me.cfg.notebook) dialog.dialog( "close" );
               ic.dsn6ParserCls.loadDsn6File('fofc');
            });

            me.myEventCls.onIds("#" + me.pre + "reload_ccp4file2fofc", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                //if(!me.cfg.notebook) dialog.dialog( "close" );
                ic.ccp4ParserCls.loadCcp4File('2fofc');
            });
            me.myEventCls.onIds("#" + me.pre + "reload_ccp4filefofc", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                //if(!me.cfg.notebook) dialog.dialog( "close" );
                ic.ccp4ParserCls.loadCcp4File('fofc');
            });

            me.myEventCls.onIds("#" + me.pre + "reload_mtzfile2fofc", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                //if(!me.cfg.notebook) dialog.dialog( "close" );
                ic.mtzParserCls.loadMtzFile('2fofc');
            });
            me.myEventCls.onIds("#" + me.pre + "reload_mtzfilefofc", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                //if(!me.cfg.notebook) dialog.dialog( "close" );
                ic.mtzParserCls.loadMtzFile('fofc');
            });

            me.myEventCls.onIds("#" + me.pre + "reload_rcsbmtzfile2fofc", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                //if(!me.cfg.notebook) dialog.dialog( "close" );
                ic.mtzParserCls.loadMtzFile('2fofc', true);
            });
            me.myEventCls.onIds("#" + me.pre + "reload_rcsbmtzfilefofc", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                //if(!me.cfg.notebook) dialog.dialog( "close" );
                ic.mtzParserCls.loadMtzFile('fofc', true);
            });

            me.myEventCls.onIds("#" + me.pre + "reload_delphifile", "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               await ic.delphiCls.loadDelphiFile('delphi');
            });
            me.myEventCls.onIds("#" + me.pre + "reload_pqrfile", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               ic.delphiCls.loadPhiFile('pqr');
            });
            me.myEventCls.onIds("#" + me.pre + "reload_phifile", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               ic.delphiCls.loadPhiFile('phi');
            });
            me.myEventCls.onIds("#" + me.pre + "reload_cubefile", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               ic.delphiCls.loadPhiFile('cube');
            });
            me.myEventCls.onIds("#" + me.pre + "reload_pqrurlfile", "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               await ic.delphiCls.loadPhiFileUrl('pqrurl');
            });
            me.myEventCls.onIds("#" + me.pre + "reload_phiurlfile", "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               await ic.delphiCls.loadPhiFileUrl('phiurl');
            });
            me.myEventCls.onIds("#" + me.pre + "reload_cubeurlfile", "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               await ic.delphiCls.loadPhiFileUrl('cubeurl');
            });

            me.myEventCls.onIds("#" + me.pre + "reload_delphifile2", "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();
               me.htmlCls.setHtmlCls.updateSurfPara('delphi');

               if(!me.cfg.notebook) dialog.dialog( "close" );

               await ic.delphiCls.loadDelphiFile('delphi2');
            });
            me.myEventCls.onIds("#" + me.pre + "reload_pqrfile2", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               me.htmlCls.setHtmlCls.updateSurfPara('phi');

               if(!me.cfg.notebook) dialog.dialog( "close" );
               ic.delphiCls.loadPhiFile('pqr2');
            });
            me.myEventCls.onIds("#" + me.pre + "reload_phifile2", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               me.htmlCls.setHtmlCls.updateSurfPara('phi');

               if(!me.cfg.notebook) dialog.dialog( "close" );
               ic.delphiCls.loadPhiFile('phi2');
            });
            me.myEventCls.onIds("#" + me.pre + "reload_cubefile2", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               me.htmlCls.setHtmlCls.updateSurfPara('phi');

               if(!me.cfg.notebook) dialog.dialog( "close" );
               ic.delphiCls.loadPhiFile('cube2');
            });
            me.myEventCls.onIds("#" + me.pre + "reload_pqrurlfile2", "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();
               me.htmlCls.setHtmlCls.updateSurfPara('phiurl');

               if(!me.cfg.notebook) dialog.dialog( "close" );
               await ic.delphiCls.loadPhiFileUrl('pqrurl2');
            });
            me.myEventCls.onIds("#" + me.pre + "reload_phiurlfile2", "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();
               me.htmlCls.setHtmlCls.updateSurfPara('phiurl');

               if(!me.cfg.notebook) dialog.dialog( "close" );
               await ic.delphiCls.loadPhiFileUrl('phiurl2');
            });
            me.myEventCls.onIds("#" + me.pre + "reload_cubeurlfile2", "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();
               me.htmlCls.setHtmlCls.updateSurfPara('phiurl');

               if(!me.cfg.notebook) dialog.dialog( "close" );
               await ic.delphiCls.loadPhiFileUrl('cubeurl2');
            });

            me.myEventCls.onIds("#" + me.pre + "reload_dsn6fileurl2fofc", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               //if(!me.cfg.notebook) dialog.dialog( "close" );
               ic.dsn6ParserCls.loadDsn6FileUrl('2fofc');
            });
            me.myEventCls.onIds("#" + me.pre + "reload_dsn6fileurlfofc", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               //if(!me.cfg.notebook) dialog.dialog( "close" );
               ic.dsn6ParserCls.loadDsn6FileUrl('fofc');
            });

            me.myEventCls.onIds("#" + me.pre + "reload_ccp4fileurl2fofc", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                //if(!me.cfg.notebook) dialog.dialog( "close" );
                ic.ccp4ParserCls.loadCcp4FileUrl('2fofc');
            });
            me.myEventCls.onIds("#" + me.pre + "reload_ccp4fileurlfofc", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                //if(!me.cfg.notebook) dialog.dialog( "close" );
                ic.ccp4ParserCls.loadCcp4FileUrl('fofc');
            });

            me.myEventCls.onIds("#" + me.pre + "reload_mtzfileurl2fofc", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                //if(!me.cfg.notebook) dialog.dialog( "close" );
                ic.mtzParserCls.loadMtzFileUrl('2fofc');
            });
            me.myEventCls.onIds("#" + me.pre + "reload_mtzfileurlfofc", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                //if(!me.cfg.notebook) dialog.dialog( "close" );
                ic.mtzParserCls.loadMtzFileUrl('fofc');
            });

            me.myEventCls.onIds("#" + me.pre + "reload_rcsbmtzfileurl2fofc", "click", async function(e) { let ic = me.icn3d;
                e.preventDefault();
                //if(!me.cfg.notebook) dialog.dialog( "close" );
                await ic.mtzParserCls.loadMtzFileUrl('2fofc', true);
            });
            me.myEventCls.onIds("#" + me.pre + "reload_rcsbmtzfileurlfofc", "click", async function(e) { let ic = me.icn3d;
                e.preventDefault();
                //if(!me.cfg.notebook) dialog.dialog( "close" );
                await ic.mtzParserCls.loadMtzFileUrl('fofc', true);
            });

            me.myEventCls.onIds("#" + me.pre + "reload_pdbfile", "click", async function(e) { me.icn3d;
               e.preventDefault();

               let bAppend = false;
               await thisClass.loadPdbFile(bAppend, 'pdbfile');
            });

            me.myEventCls.onIds("#" + me.pre + "reload_pdbfile_app", "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();

               ic.bAppend = true;
               await thisClass.loadPdbFile(ic.bAppend, 'pdbfile_app');
            });

            me.myEventCls.onIds("#" + me.pre + "reload_mol2file", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               ic.bInitial = true;
               thisClass.iniFileLoad();
               let file = $("#" + me.pre + "mol2file")[0].files[0];
               if(!file) {
                 alert("Please select a file before clicking 'Load'");
               }
               else {
                 me.htmlCls.setHtmlCls.fileSupport();
                 let reader = new FileReader();
                 reader.onload = async function(e) {
                   let dataStr = e.target.result; // or = reader.result;
                   thisClass.setLogCmd('load mol2 file ' + $("#" + me.pre + "mol2file").val(), false);
                   ic.molTitle = "";
                   ic.inputid = undefined;
                   //ic.initUI();
                   ic.init();
                   ic.bInputfile = true;
                   ic.InputfileData = (ic.InputfileData) ? ic.InputfileData + '\nENDMDL\n' + dataStr : dataStr;
                   ic.InputfileType = 'mol2';
                   await ic.mol2ParserCls.loadMol2Data(dataStr);
                 };
                 reader.readAsText(file);
               }
            });

            me.myEventCls.onIds("#" + me.pre + "reload_sdffile", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               ic.bInitial = true;
               thisClass.iniFileLoad();
               let file = $("#" + me.pre + "sdffile")[0].files[0];
               if(!file) {
                 alert("Please select a file before clicking 'Load'");
               }
               else {
                 me.htmlCls.setHtmlCls.fileSupport();
                 let reader = new FileReader();
                 reader.onload = async function(e) {
                   let dataStr = e.target.result; // or = reader.result;
                   thisClass.setLogCmd('load sdf file ' + $("#" + me.pre + "sdffile").val(), false);
                   ic.molTitle = "";
                   ic.inputid = undefined;
                   //ic.initUI();
                   ic.init();
                   ic.bInputfile = true;
                   ic.InputfileData = (ic.InputfileData) ? ic.InputfileData + '\nENDMDL\n' + dataStr : dataStr;
                   ic.InputfileType = 'sdf';
                   await ic.sdfParserCls.loadSdfData(dataStr);
                 };
                 reader.readAsText(file);
               }
            });

            me.myEventCls.onIds("#" + me.pre + "reload_xyzfile", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               ic.bInitial = true;
               thisClass.iniFileLoad();
               let file = $("#" + me.pre + "xyzfile")[0].files[0];
               if(!file) {
                 alert("Please select a file before clicking 'Load'");
               }
               else {
                 me.htmlCls.setHtmlCls.fileSupport();
                 let reader = new FileReader();
                 reader.onload = async function(e) {
                   let dataStr = e.target.result; // or = reader.result;
                   thisClass.setLogCmd('load xyz file ' + $("#" + me.pre + "xyzfile").val(), false);
                   ic.molTitle = "";
                   ic.inputid = undefined;
                   //ic.initUI();
                   ic.init();
                   ic.bInputfile = true;
                   ic.InputfileData = (ic.InputfileData) ? ic.InputfileData + '\nENDMDL\n' + dataStr : dataStr;
                   ic.InputfileType = 'xyz';
                   await ic.xyzParserCls.loadXyzData(dataStr);
                 };
                 reader.readAsText(file);
               }
            });

            me.myEventCls.onIds("#" + me.pre + "reload_clustalwfile", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                ic.bInitial = true;
                thisClass.iniFileLoad();

                let file = $("#" + me.pre + "clustalwfile")[0].files[0];
                if(!file) {
                  alert("Please select a file before clicking 'Load'");
                }
                else {
                  me.htmlCls.setHtmlCls.fileSupport();
                  let reader = new FileReader();
                  reader.onload = async function(e) {
                    let dataStr = e.target.result; // or = reader.result;
                    thisClass.setLogCmd('load CLUSTALW file ' + $("#" + me.pre + "clustalwfile").val(), false);
                    ic.molTitle = "";
                    ic.inputid = undefined;
                    //ic.initUI();
                    ic.init();
                    ic.bInputfile = false; //true;
                    ic.InputfileType = 'clustalw';
                    await ic.msaParserCls.loadMsaData(dataStr, 'clustalw');
                  };
                  reader.readAsText(file);
                }
            });

            me.myEventCls.onIds("#" + me.pre + "reload_fastafile", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                ic.bInitial = true;
                thisClass.iniFileLoad();

                let file = $("#" + me.pre + "fastafile")[0].files[0];
                if(!file) {
                  alert("Please select a file before clicking 'Load'");
                }
                else {
                  me.htmlCls.setHtmlCls.fileSupport();
                  let reader = new FileReader();
                  reader.onload = async function(e) {
                    let dataStr = e.target.result; // or = reader.result;
                    thisClass.setLogCmd('load FASTA file ' + $("#" + me.pre + "fastafile").val(), false);
                    ic.molTitle = "";
                    ic.inputid = undefined;
                    //ic.initUI();
                    ic.init();
                    ic.bInputfile = false; //true;
                    ic.InputfileType = 'fasta';
                    await ic.msaParserCls.loadMsaData(dataStr, 'fasta');
                  };
                  reader.readAsText(file);
                }
            });

            me.myEventCls.onIds("#" + me.pre + "reload_afmapfile", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                ic.bInitial = true;
                thisClass.iniFileLoad();
                let file = $("#" + me.pre + "afmapfile")[0].files[0];
                if(!file) {
                  alert("Please select a file before clicking 'Load'");
                }
                else {
                  me.htmlCls.setHtmlCls.fileSupport();
                  let reader = new FileReader();
                  reader.onload = function(e) {
                    let dataStr = e.target.result; // or = reader.result;
                    thisClass.setLogCmd('load AlphaFold PAE file ' + $("#" + me.pre + "afmapfile").val(), false);
                    
                    me.htmlCls.dialogCls.openDlg('dl_alignerrormap', 'Show Predicted Aligned Error (PAE) map');
                    ic.contactMapCls.processAfErrorMap(JSON.parse(dataStr));
                  };
                  reader.readAsText(file);
                }
             });

             me.myEventCls.onIds("#" + me.pre + "reload_afmapfilefull", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                ic.bInitial = true;
                thisClass.iniFileLoad();
                let file = $("#" + me.pre + "afmapfile")[0].files[0];
                if(!file) {
                  alert("Please select a file before clicking 'Load'");
                }
                else {
                  me.htmlCls.setHtmlCls.fileSupport();
                  let reader = new FileReader();
                  reader.onload = function(e) {
                    let dataStr = e.target.result; // or = reader.result;
                    thisClass.setLogCmd('load AlphaFold PAE file ' + $("#" + me.pre + "afmapfile").val(), false);
                    
                    me.htmlCls.dialogCls.openDlg('dl_alignerrormap', 'Show Predicted Aligned Error (PAE) map');
                    ic.contactMapCls.processAfErrorMap(JSON.parse(dataStr), true);
                  };
                  reader.readAsText(file);
                }
             });

            me.myEventCls.onIds("#" + me.pre + "reload_urlfile", "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();
               ic.bInitial = true;
               thisClass.iniFileLoad();
               let type = $("#" + me.pre + "filetype").val();
               let url = $("#" + me.pre + "urlfile").val();
               ic.inputurl = 'type=' + type + '&url=' + encodeURIComponent(url);
               //ic.initUI();
               ic.init();
               ic.bInputfile = true;
               ic.bInputUrlfile = true;
               await ic.pdbParserCls.downloadUrl(url, type);
            });

            me.myEventCls.onIds("#" + me.pre + "reload_mmciffile", "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();

               ic.bAppend = true;
               let bmmCIF = true;
               let fileId = 'mmciffile';
               await thisClass.loadPdbFile(ic.bAppend, fileId, bmmCIF);
            });

            me.myEventCls.onIds("#" + me.pre + "applycustomcolor", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               ic.setOptionCls.setOption("color", $("#" + me.pre + "colorcustom").val());
               thisClass.setLogCmd("color " + $("#" + me.pre + "colorcustom").val(), true);
            });

            me.myEventCls.onIds(["#" + me.pre + "atomsCustomSphere2", "#" + me.pre + "atomsCustomSphere", "#" + me.pre + "radius_aroundsphere"], "change", function(e) { let ic = me.icn3d;
                ic.bSphereCalc = false;
                //thisClass.setLogCmd('set calculate sphere false', true);
            });
            me.myEventCls.onIds("#" + me.pre + "applypick_aroundsphere", "click", function(e) { let ic = me.icn3d;
                //e.preventDefault();
                
                let radius = parseFloat($("#" + me.pre + "radius_aroundsphere").val());
                let nameArray = $("#" + me.pre + "atomsCustomSphere").val();
                let nameArray2 = $("#" + me.pre + "atomsCustomSphere2").val();
                if(nameArray2.length == 0) {
                    alert("Please select the first set at step #1");
                }
                else {
                    let select = "select zone cutoff " + radius + " | sets " + nameArray2 + " " + nameArray + " | " + ic.bSphereCalc;
                    if(!ic.bSphereCalc) ic.showInterCls.pickCustomSphere(radius, nameArray2, nameArray, ic.bSphereCalc);
                    ic.bSphereCalc = true;
                    //thisClass.setLogCmd('set calculate sphere true', true);
                    ic.hlUpdateCls.updateHlAll();
                    thisClass.setLogCmd(select, true);
                }
            });
            me.myEventCls.onIds("#" + me.pre + "sphereExport", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                
                let radius = parseFloat($("#" + me.pre + "radius_aroundsphere").val());
                let nameArray = $("#" + me.pre + "atomsCustomSphere").val();
                let nameArray2 = $("#" + me.pre + "atomsCustomSphere2").val();
                if(nameArray2.length == 0) {
                    alert("Please select the first set at step #1");
                }
                else {
                    ic.showInterCls.pickCustomSphere(radius, nameArray2, nameArray, ic.bSphereCalc);
                    ic.bSphereCalc = true;
                    let text = ic.viewInterPairsCls.exportSpherePairs();
                    let file_pref = Object.keys(me.utilsCls.getHlStructures()).join(',');
                    ic.saveFileCls.saveFile(file_pref + '_sphere_pairs.html', 'html', text);

                    thisClass.setLogCmd("export pairs | " + nameArray2 + " " + nameArray + " | dist " + radius, true);
                }
            });

            me.myEventCls.onIds("#" + me.pre + "apply_adjustmem", "click", function(e) { let ic = me.icn3d;
                //e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                let extra_mem_z = parseFloat($("#" + me.pre + "extra_mem_z").val());
                let intra_mem_z = parseFloat($("#" + me.pre + "intra_mem_z").val());
                ic.selectionCls.adjustMembrane(extra_mem_z, intra_mem_z);
                let select = "adjust membrane z-axis " + extra_mem_z + " " + intra_mem_z;
                thisClass.setLogCmd(select, true);
            });

            me.myEventCls.onIds("#" + me.pre + "apply_selectplane", "click", function(e) { let ic = me.icn3d;
                //e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                let large = parseFloat($("#" + me.pre + "selectplane_z1").val());
                let small = parseFloat($("#" + me.pre + "selectplane_z2").val());
                ic.selectionCls.selectBtwPlanes(large, small);
                let select = "select planes z-axis " + large + " " + small;
                thisClass.setLogCmd(select, true);
            });

            me.myEventCls.onIds(["#" + me.pre + "atomsCustomHbond2", "#" + me.pre + "atomsCustomHbond", "#" + me.pre + "analysis_hbond", "#" + me.pre + "analysis_saltbridge", "#" + me.pre + "analysis_contact", "#" + me.pre + "hbondthreshold", "#" + me.pre + "saltbridgethreshold", "#" + me.pre + "contactthreshold"], "change", function(e) { let ic = me.icn3d;
                ic.bHbondCalc = false;
                //thisClass.setLogCmd('set calculate hbond false', true);
            });
            me.myEventCls.onIds("#" + me.pre + "crossstrucinter", "change", function(e) { let ic = me.icn3d;
               e.preventDefault();
               
               ic.crossstrucinter = parseInt($("#" + me.pre + "crossstrucinter").val());
               thisClass.setLogCmd("cross structure interaction " + ic.crossstrucinter, true);
            });
            me.myEventCls.onIds("#" + me.pre + "applyhbonds", "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();
               
               await ic.showInterCls.showInteractions('3d');
            });
            me.myEventCls.onIds("#" + me.pre + "applycontactmap", "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );

               let contactdist = parseFloat($("#" + ic.pre + "contactdist").val());
               let contacttype = $("#" + ic.pre + "contacttype").val();

               await ic.contactMapCls.contactMap(contactdist, contacttype);
               thisClass.setLogCmd('contact map | dist ' + contactdist + ' | type ' + contacttype, true);
            });
            me.myEventCls.onIds("#" + me.pre + "hbondWindow", "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();
               
               await ic.showInterCls.showInteractions('view');
            });
            me.myEventCls.onIds("#" + me.pre + "areaWindow", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               
               let nameArray = $("#" + me.pre + "atomsCustomHbond").val();
               let nameArray2 = $("#" + me.pre + "atomsCustomHbond2").val();
               ic.analysisCls.calcBuriedSurface(nameArray2, nameArray);
               thisClass.setLogCmd("calc buried surface | " + nameArray2 + " " + nameArray, true);
            });
            me.myEventCls.onIds("#" + me.pre + "sortSet1", "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();
               
               await ic.showInterCls.showInteractions('save1');
            });
            $(document).on("click", "." + me.pre + "showintercntonly", function(e) { me.icn3d;
                e.stopImmediatePropagation();
                $(".icn3d-border").hide();
                thisClass.setLogCmd("table inter count only", true);
            });
            $(document).on("click", "." + me.pre + "showinterdetails", function(e) { me.icn3d;
                e.stopImmediatePropagation();
                $(".icn3d-border").show();
                thisClass.setLogCmd("table inter details", true);
            });
            me.myEventCls.onIds("#" + me.pre + "sortSet2", "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();
               
               await ic.showInterCls.showInteractions('save2');
            });
            me.myEventCls.onIds("#" + me.pre + "hbondGraph", "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();
               
               await ic.showInterCls.showInteractions('graph');
            });
            me.myEventCls.onIds("#" + me.pre + "hbondLineGraph", "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();
               
               ic.bShownRefnum = false;
               thisClass.setLogCmd("hide ref number", true);
               await ic.showInterCls.showInteractions('linegraph');
            });
            me.myEventCls.onIds("#" + me.pre + "hbondLineGraph2", "click", async function(e) { let ic = me.icn3d;
                e.preventDefault();
                
                ic.bShownRefnum = true;
                thisClass.setLogCmd("show ref number", true);
                await ic.showInterCls.showInteractions('linegraph');
            });
            me.myEventCls.onIds("#" + me.pre + "hbondScatterplot", "click", async function(e) { let ic = me.icn3d;
                e.preventDefault();
                
                ic.bShownRefnum = false;
                thisClass.setLogCmd("hide ref number", true);
                await ic.showInterCls.showInteractions('scatterplot');
            });
            me.myEventCls.onIds("#" + me.pre + "hbondScatterplot2", "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();
               
               ic.bShownRefnum = true;
               thisClass.setLogCmd("show ref number", true);
               await ic.showInterCls.showInteractions('scatterplot');
            });
            me.myEventCls.onIds("#" + me.pre + "hbondLigplot", "click", async function(e) { let ic = me.icn3d;
                e.preventDefault();
                
                ic.bShownRefnum = false;
                thisClass.setLogCmd("hide ref number", true);
                await ic.showInterCls.showInteractions('ligplot');
            });
            // select residues
            $(document).on("click", "#" + me.svgid + " circle.selected", function(e) { let ic = me.icn3d;
                e.stopImmediatePropagation();
                let id = $(this).attr('res');
                if(ic.bSelectResidue === false && !ic.bShift && !ic.bCtrl) {
                  ic.selectionCls.removeSelection();
                }
                if(id !== undefined) {
                   ic.hlSeqCls.selectResidues(id, this);
                   ic.hlObjectsCls.addHlObjects();  // render() is called
                }
            });
            me.myEventCls.onIds("#" + me.svgid + "_svg", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               
               ic.saveFileCls.saveSvg(me.svgid, ic.inputid + "_force_directed_graph.svg");
            });
            me.myEventCls.onIds("#" + me.svgid + "_png", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               
               ic.saveFileCls.savePng(me.svgid, ic.inputid + "_force_directed_graph.png");
            });
            me.myEventCls.onIds("#" + me.svgid + "_json", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                
                let graphStr2 = ic.graphStr.substr(0, ic.graphStr.lastIndexOf('}'));
                graphStr2 += me.htmlCls.setHtmlCls.getLinkColor();

                ic.saveFileCls.saveFile(ic.inputid + "_force_directed_graph.json", "text", [graphStr2]);
            });

            $(document).on("click", "#" + me.svgid_ct + "_svg", function(e) { let ic = me.icn3d;
               e.preventDefault();
               
               ic.saveFileCls.saveSvg(me.svgid_ct, ic.inputid + "_cartoon.svg");
            });
            $(document).on("click", "#" + me.svgid_ct + "_png", function(e) { let ic = me.icn3d;
               e.preventDefault();
               
               ic.saveFileCls.savePng(me.svgid_ct, ic.inputid + "_cartoon.png");
            });
            $(document).on("click", "#" + me.svgid_ct + "_json", function(e) { let ic = me.icn3d;
                e.preventDefault();
                
                //let graphStr2 = ic.graphStr.substr(0, ic.graphStr.lastIndexOf('}'));

                ic.saveFileCls.saveFile(ic.inputid + "_cartoon.json", "text", [ic.graphStr]);
            });
            $(document).on("change", "#" + me.svgid_ct + "_label", function(e) { me.icn3d;
               e.preventDefault();
               
               let className = $("#" + me.svgid_ct + "_label").val();
               $("#" + me.svgid_ct + " text").removeClass();
               $("#" + me.svgid_ct + " text").addClass(className);
               thisClass.setLogCmd("cartoon label " + className, true);
            });

            me.myEventCls.onIds("#" + me.linegraphid + "_svg", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               
               ic.saveFileCls.saveSvg(me.linegraphid, ic.inputid + "_line_graph.svg");
            });
            me.myEventCls.onIds("#" + me.linegraphid + "_png", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               
               ic.saveFileCls.savePng(me.linegraphid, ic.inputid + "_line_graph.png");
            });
            me.myEventCls.onIds("#" + me.linegraphid + "_json", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                
                let graphStr2 = ic.lineGraphStr.substr(0, ic.lineGraphStr.lastIndexOf('}'));

                graphStr2 += me.htmlCls.setHtmlCls.getLinkColor();

                ic.saveFileCls.saveFile(ic.inputid + "_line_graph.json", "text", [graphStr2]);
            });
            me.myEventCls.onIds("#" + me.linegraphid + "_scale", "change", function(e) { let ic = me.icn3d;
               e.preventDefault();
               
               let scale = $("#" + me.linegraphid + "_scale").val();
               $("#" + me.linegraphid).attr("width",(ic.linegraphWidth * parseFloat(scale)).toString() + "px");
               thisClass.setLogCmd("line graph scale " + scale, true);
            });
            me.myEventCls.onIds("#" + me.scatterplotid + "_svg", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               
               ic.saveFileCls.saveSvg(me.scatterplotid, ic.inputid + "_scatterplot.svg");
            });
            me.myEventCls.onIds("#" + me.scatterplotid + "_png", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               
               ic.saveFileCls.savePng(me.scatterplotid, ic.inputid + "_scatterplot.png");
            });
            me.myEventCls.onIds("#" + me.scatterplotid + "_json", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                
                let graphStr2 = ic.scatterplotStr.substr(0, ic.scatterplotStr.lastIndexOf('}'));

                graphStr2 += me.htmlCls.setHtmlCls.getLinkColor();

                ic.saveFileCls.saveFile(ic.inputid + "_scatterplot.json", "text", [graphStr2]);
            });
            me.myEventCls.onIds("#" + me.scatterplotid + "_scale", "change", function(e) { let ic = me.icn3d;
               e.preventDefault();
               
               let scale = $("#" + me.scatterplotid + "_scale").val();
               $("#" + me.scatterplotid).attr("width",(ic.scatterplotWidth * parseFloat(scale)).toString() + "px");
               thisClass.setLogCmd("scatterplot scale " + scale, true);
            });

            me.myEventCls.onIds("#" + me.ligplotid + "_svg", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                
                ic.saveFileCls.saveSvg(me.ligplotid, ic.inputid + "_ligplot.svg", undefined, true);
             });
             me.myEventCls.onIds("#" + me.ligplotid + "_png", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                
                ic.saveFileCls.savePng(me.ligplotid, ic.inputid + "_ligplot.png", undefined, true);
             });
            //  me.myEventCls.onIds("#" + me.ligplotid + "_json", "click", function(e) { let ic = me.icn3d;
            //      e.preventDefault();
                 
            //      let graphStr2 = ic.ligplotStr.substr(0, ic.ligplotStr.lastIndexOf('}'));
     
            //      graphStr2 += me.htmlCls.setHtmlCls.getLinkColor();
     
            //      ic.saveFileCls.saveFile(ic.inputid + "_ligplot.json", "text", [graphStr2]);
            //  });
             me.myEventCls.onIds("#" + me.ligplotid + "_scale", "change", function(e) { let ic = me.icn3d;
                e.preventDefault();
                
                let scale = $("#" + me.ligplotid + "_scale").val();
                $("#" + me.ligplotid).attr("width",(ic.ligplotWidth * parseFloat(scale)).toString() + "px");
                ic.ligplotScale = parseFloat(scale);
                thisClass.setLogCmd("ligplot scale " + scale, true);
             });

            me.myEventCls.onIds("#" + me.contactmapid + "_svg", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               
               ic.saveFileCls.saveSvg(me.contactmapid, ic.inputid + "_contactmap.svg", true);
            });
            me.myEventCls.onIds("#" + me.contactmapid + "_png", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               
               ic.saveFileCls.savePng(me.contactmapid, ic.inputid + "_contactmap.png", true);
            });
            me.myEventCls.onIds("#" + me.contactmapid + "_json", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                
                let graphStr2 = ic.contactmapStr.substr(0, ic.contactmapStr.lastIndexOf('}'));

                graphStr2 += me.htmlCls.setHtmlCls.getLinkColor();

                ic.saveFileCls.saveFile(ic.inputid + "_contactmap.json", "text", [graphStr2]);
            });
            me.myEventCls.onIds("#" + me.contactmapid + "_scale", "change", function(e) { let ic = me.icn3d;
                e.preventDefault();
                
                let scale = $("#" + me.contactmapid + "_scale").val();
                $("#" + me.contactmapid).attr("width",(ic.contactmapWidth * parseFloat(scale)).toString() + "px");
                thisClass.setLogCmd("contactmap scale " + scale, true);
             });

            me.myEventCls.onIds("#" + me.alignerrormapid + "_svg", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                
                let scale = 1;
                $("#" + me.alignerrormapid + "_scale").val(scale);
                $("#" + me.alignerrormapid).attr("width",(ic.alignerrormapWidth * parseFloat(scale)).toString() + "px");
                
                ic.saveFileCls.saveSvg(me.alignerrormapid, ic.inputid + "_alignerrormap.svg", true);
             });
             me.myEventCls.onIds("#" + me.alignerrormapid + "_png", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                
                let scale = 1;
                $("#" + me.alignerrormapid + "_scale").val(scale);
                $("#" + me.alignerrormapid).attr("width",(ic.alignerrormapWidth * parseFloat(scale)).toString() + "px");
                
                ic.saveFileCls.savePng(me.alignerrormapid, ic.inputid + "_alignerrormap.png", true);
             });
             me.myEventCls.onIds("#" + me.alignerrormapid + "_full", "click", async function(e) { let ic = me.icn3d;
                e.preventDefault();
                
                await ic.contactMapCls.afErrorMap(afid, true);
             });
             me.myEventCls.onIds("#" + me.alignerrormapid + "_json", "click", function(e) { let ic = me.icn3d;
                 e.preventDefault();
                 
                 
                 let graphStr2 = ic.alignerrormapStr.substr(0, ic.alignerrormapStr.lastIndexOf('}'));
     
                 graphStr2 += me.htmlCls.setHtmlCls.getLinkColor();
     
                 ic.saveFileCls.saveFile(ic.inputid + "_alignerrormap.json", "text", [graphStr2]);
             });

            me.myEventCls.onIds("#" + me.alignerrormapid + "_scale", "change", function(e) { let ic = me.icn3d;
               e.preventDefault();
               
               let scale = $("#" + me.alignerrormapid + "_scale").val();
               $("#" + me.alignerrormapid).attr("width",(ic.alignerrormapWidth * parseFloat(scale)).toString() + "px");
               thisClass.setLogCmd("alignerrormap scale " + scale, true);
            });

            me.myEventCls.onIds("#" + me.svgid + "_label", "change", function(e) { me.icn3d;
               e.preventDefault();
               
               let className = $("#" + me.svgid + "_label").val();
               $("#" + me.svgid + " text").removeClass();
               $("#" + me.svgid + " text").addClass(className);
               thisClass.setLogCmd("graph label " + className, true);
            });
            me.myEventCls.onIds("#" + me.svgid + "_hideedges", "change", function(e) { let ic = me.icn3d;
               e.preventDefault();
               
               me.htmlCls.hideedges = parseInt($("#" + me.svgid + "_hideedges").val());
               if(me.htmlCls.hideedges) {
                    me.htmlCls.contactInsideColor = 'FFF';
                    me.htmlCls.hbondInsideColor = 'FFF';
                    me.htmlCls.ionicInsideColor = 'FFF';
               }
               else {
                    me.htmlCls.contactInsideColor = 'DDD';
                    me.htmlCls.hbondInsideColor = 'AFA';
                    me.htmlCls.ionicInsideColor = '8FF';
               }
               if(ic.graphStr !== undefined) {
                   if(ic.bRender && me.htmlCls.force) me.drawGraph(ic.graphStr, me.pre + 'dl_graph');
                   thisClass.setLogCmd("hide edges " + me.htmlCls.hideedges, true);
               }
            });
            me.myEventCls.onIds("#" + me.svgid + "_force", "change", function(e) { let ic = me.icn3d;
               e.preventDefault();
               
               me.htmlCls.force = parseInt($("#" + me.svgid + "_force").val());
               if(ic.graphStr !== undefined) {
                   thisClass.setLogCmd("graph force " + me.htmlCls.force, true);
                   ic.getGraphCls.handleForce();
               }
            });
            me.myEventCls.onIds("#" + me.pre + "hbondReset", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               
               ic.viewInterPairsCls.resetInteractionPairs();
               thisClass.setLogCmd("reset interaction pairs", true);
            });

            me.myEventCls.onIds("#" + me.pre + "applypick_labels", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               let text = $("#" + me.pre + "labeltext" ).val();
               let size = $("#" + me.pre + "labelsize" ).val();
               let color = $("#" + me.pre + "labelcolor" ).val();
               let background = $("#" + me.pre + "labelbkgd" ).val();
               if(size === '0' || size === '' || size === 'undefined') size = 0;
               if(color === '0' || color === '' || color === 'undefined') color = 0;
               if(background === '0' || background === '' || background === 'undefined') background = 0;
               if(ic.pAtom === undefined || ic.pAtom2 === undefined) {
                 alert("Please pick another atom");
               }
               else {
                 let x =(ic.pAtom.coord.x + ic.pAtom2.coord.x) / 2;
                 let y =(ic.pAtom.coord.y + ic.pAtom2.coord.y) / 2;
                 let z =(ic.pAtom.coord.z + ic.pAtom2.coord.z) / 2;
                 ic.analysisCls.addLabel(text, x, y, z, size, color, background, 'custom');
                 ic.pickpair = false;
                 let sizeStr = '', colorStr = '', backgroundStr = '';
                 if(size != 0) sizeStr = ' | size ' + size;
                 if(color != 0) colorStr = ' | color ' + color;
                 if(background != 0) backgroundStr = ' | background ' + background;
                 thisClass.setLogCmd('add label ' + text + ' | x ' + x.toPrecision(4)  + ' y ' + y.toPrecision(4) + ' z ' + z.toPrecision(4) + sizeStr + colorStr + backgroundStr + ' | type custom', true);
                 ic.drawCls.draw();
               }
            });

            me.myEventCls.onIds("#" + me.pre + "applyselection_labels", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               let text = $("#" + me.pre + "labeltext2" ).val();
               let size = $("#" + me.pre + "labelsize2" ).val();
               let color = $("#" + me.pre + "labelcolor2" ).val();
               let background = $("#" + me.pre + "labelbkgd2" ).val();
               if(size === '0' || size === '' || size === 'undefined') size = 0;
               if(color === '0' || color === '' || color === 'undefined') color = 0;
               if(background === '0' || background === '' || background === 'undefined') background = 0;
                 let position = ic.applyCenterCls.centerAtoms(me.hashUtilsCls.hash2Atoms(ic.hAtoms, ic.atoms));
                 let x = position.center.x;
                 let y = position.center.y;
                 let z = position.center.z;
                 //thisClass.setLogCmd('add label ' + text + ' | size ' + size + ' | color ' + color + ' | background ' + background + ' | type custom', true);
                 ic.analysisCls.addLabel(text, x, y, z, size, color, background, 'custom');
                 let sizeStr = '', colorStr = '', backgroundStr = '';
                 if(size != 0) sizeStr = ' | size ' + size;
                 if(color != 0) colorStr = ' | color ' + color;
                 if(background != 0) backgroundStr = ' | background ' + background;
                 thisClass.setLogCmd('add label ' + text + ' | x ' + x.toPrecision(4)  + ' y ' + y.toPrecision(4) + ' z ' + z.toPrecision(4) + sizeStr + colorStr + backgroundStr + ' | type custom', true);
                 ic.drawCls.draw();
            });

            me.myEventCls.onIds("#" + me.pre + "applylabelcolor", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                ic.labelcolor = $("#" + me.pre + "labelcolorall" ).val();

                thisClass.setLogCmd('set label color ' + ic.labelcolor, true);
                ic.drawCls.draw();
            });

            me.myEventCls.onIds("#" + me.pre + "applypick_stabilizer", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               if(ic.pAtom === undefined || ic.pAtom2 === undefined) {
                 alert("Please pick another atom");
               }
               else {
                 ic.pickpair = false;
                 thisClass.setLogCmd('add one stabilizer | ' + ic.pAtom.serial + ' ' + ic.pAtom2.serial, true);
                 if(ic.pairArray === undefined) ic.pairArray = [];
                 ic.pairArray.push(ic.pAtom.serial);
                 ic.pairArray.push(ic.pAtom2.serial);
                 //ic.updateStabilizer();
                 ic.threeDPrintCls.setThichknessFor3Dprint();
                 ic.drawCls.draw();
               }
            });

        // https://github.com/tovic/color-picker
        // https://tovic.github.io/color-picker/color-picker.value-update.html
        //    pickColor: function() {
            let picker = new CP(document.querySelector("#" + me.pre + "colorcustom"));
            picker.on("change", function(color) {
                this.target.value = color;
            });
            me.myEventCls.onIds("#" + me.pre + "colorcustom", "input", function() {
                let color = $("#" + me.pre + "colorcustom").val();
                picker.set('#' + color).enter();
            });
            me.myEventCls.onIds("#" + me.pre + "colorcustom", "keyup", function() {
                let color = $("#" + me.pre + "colorcustom").val();
                picker.set('#' + color).enter();
            });
            me.myEventCls.onIds("#" + me.pre + "colorcustom", "paste", function() {
                let color = $("#" + me.pre + "colorcustom").val();
                picker.set('#' + color).enter();
            });
            me.myEventCls.onIds("#" + me.pre + "colorcustom", "cut", function() {
                let color = $("#" + me.pre + "colorcustom").val();
                picker.set('#' + color).enter();
            });

            let picker2 = new CP(document.querySelector("#" + me.pre + "labelcolorall"));
            picker2.on("change", function(color) {
                this.target.value = color;
            });
            me.myEventCls.onIds("#" + me.pre + "labelcolorall", "input", function() {
                let color = $("#" + me.pre + "labelcolorall").val();
                picker2.set('#' + color).enter();
            });
            me.myEventCls.onIds("#" + me.pre + "labelcolorall", "keyup", function() {
                let color = $("#" + me.pre + "labelcolorall").val();
                picker2.set('#' + color).enter();
            });
            me.myEventCls.onIds("#" + me.pre + "labelcolorall", "paste", function() {
                let color = $("#" + me.pre + "labelcolorall").val();
                picker2.set('#' + color).enter();
            });
            me.myEventCls.onIds("#" + me.pre + "labelcolorall", "cut", function() {
                let color = $("#" + me.pre + "labelcolorall").val();
                picker2.set('#' + color).enter();
            });    

            me.myEventCls.onIds("#" + me.pre + "applypick_stabilizer_rm", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               if(ic.pAtom === undefined || ic.pAtom2 === undefined) {
                 alert("Please pick another atom");
               }
               else {
                 ic.pickpair = false;
                 thisClass.setLogCmd('remove one stabilizer | ' + ic.pAtom.serial + ' ' + ic.pAtom2.serial, true);
                 let rmLineArray = [];
                 rmLineArray.push(ic.pAtom.serial);
                 rmLineArray.push(ic.pAtom2.serial);
                 ic.threeDPrintCls.removeOneStabilizer(rmLineArray);
                 //ic.updateStabilizer();
                 ic.drawCls.draw();
               }
            });

            me.myEventCls.onIds("#" + me.pre + "applypick_measuredistance", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               ic.bMeasureDistance = false;
               if(ic.pAtom === undefined || ic.pAtom2 === undefined) {
                 alert("Please pick another atom");
               }
               else {
                 let size = 0, background = 0;
                 let color = $("#" + me.pre + "linecolor" ).val();
                 let x =(ic.pAtom.coord.x + ic.pAtom2.coord.x) / 2;
                 let y =(ic.pAtom.coord.y + ic.pAtom2.coord.y) / 2;
                 let z =(ic.pAtom.coord.z + ic.pAtom2.coord.z) / 2;
                 ic.analysisCls.addLineFromPicking('distance');
                 let distance = parseInt(ic.pAtom.coord.distanceTo(ic.pAtom2.coord) * 10) / 10;
                 let text = distance.toString() + " A";
                 ic.analysisCls.addLabel(text, x, y, z, size, color, background, 'distance');
                 let sizeStr = '', colorStr = '', backgroundStr = '';
                 if(color != 0) colorStr = ' | color ' + color;
                 thisClass.setLogCmd('add label ' + text + ' | x ' + x.toPrecision(4)  + ' y ' + y.toPrecision(4) + ' z ' + z.toPrecision(4) + sizeStr + colorStr + backgroundStr + ' | type distance', true);
                 ic.drawCls.draw();
                 ic.pk = 2;
               }
            });


            me.myEventCls.onIds("#" + me.pre + "applydist2", "click", function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               ic.bMeasureDistance = false;

               let nameArray = $("#" + me.pre + "atomsCustomDist").val();
               let nameArray2 = $("#" + me.pre + "atomsCustomDist2").val();

               ic.analysisCls.measureDistTwoSets(nameArray, nameArray2);
               thisClass.setLogCmd("dist | " + nameArray2 + " " + nameArray, true);
            });

            $(document).on("click", ".icn3d-distance", function(e) { let ic = me.icn3d;
                e.preventDefault();
                ic.bMeasureDistance = false;

                ic.distPnts = [];
                ic.labels['distance'] = [];
                ic.lines['distance'] = [];

                let sets = $(this).attr('sets').split('|');
     
                let nameArray = [sets[0]];
                let nameArray2 = [sets[1]];
     
                ic.analysisCls.measureDistTwoSets(nameArray, nameArray2);
                thisClass.setLogCmd("dist | " + nameArray2 + " " + nameArray, true);
             });

            me.myEventCls.onIds("#" + me.pre + "applydisttable", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                ic.bMeasureDistance = false;
     
                let nameArray = $("#" + me.pre + "atomsCustomDistTable").val();
                let nameArray2 = $("#" + me.pre + "atomsCustomDistTable2").val();
     
                ic.analysisCls.measureDistManySets(nameArray, nameArray2);
                me.htmlCls.dialogCls.openDlg('dl_disttable', 'Distance among the sets');

                thisClass.setLogCmd("disttable | " + nameArray2 + " " + nameArray, true);
            });

            me.myEventCls.onIds("#" + me.pre + "applyangletable", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                ic.bMeasureAngle = false;
     
                let nameArray = $("#" + me.pre + "atomsCustomAngleTable").val();
                let nameArray2 = $("#" + me.pre + "atomsCustomAngleTable2").val();
     
                ic.analysisCls.measureAngleManySets(nameArray, nameArray2);
                me.htmlCls.dialogCls.openDlg('dl_angletable', 'Angles among the sets');

                thisClass.setLogCmd("angletable | " + nameArray2 + " " + nameArray, true);
            });

            me.myEventCls.onIds("#" + me.pre + "applylinebtwsets", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                
                ic.bLinebtwsets = false;
     
                let nameArray = $("#" + me.pre + "linebtwsets").val();
                let nameArray2 = $("#" + me.pre + "linebtwsets2").val();
     
                let atomSet1 = ic.definedSetsCls.getAtomsFromNameArray(nameArray);
                let atomSet2 = ic.definedSetsCls.getAtomsFromNameArray(nameArray2);

                let posArray1 = ic.contactCls.getExtent(atomSet1);
                let posArray2 = ic.contactCls.getExtent(atomSet2);

                let pos1 = new THREE.Vector3(posArray1[2][0], posArray1[2][1], posArray1[2][2]);
                let pos2 = new THREE.Vector3(posArray2[2][0], posArray2[2][1], posArray2[2][2]);

                let radius = $("#" + me.pre + "linebtwsets_radius").val(); 
                let color = $("#" + me.pre + "linebtwsets_customcolor").val(); 
                let opacity = $("#" + me.pre + "linebtwsets_opacity").val();
                let dashed = ($("#" + me.pre + "linebtwsets_style").val() == 'Solid') ? false : true;
                let type = 'cylinder';

                let command = 'add line | x1 ' + pos1.x.toPrecision(4)  + ' y1 ' + pos1.y.toPrecision(4) + ' z1 ' + pos1.z.toPrecision(4) + ' | x2 ' + pos2.x.toPrecision(4)  + ' y2 ' + pos2.y.toPrecision(4) + ' z2 ' + pos2.z.toPrecision(4) + ' | color ' + color + ' | dashed ' + dashed + ' | type ' + type + ' | radius ' + radius + ' | opacity ' + opacity;

                thisClass.setLogCmd(command, true);

                ic.analysisCls.addLine(pos1.x, pos1.y, pos1.z, pos2.x, pos2.y, pos2.z, color, dashed, type, radius, opacity);
                ic.drawCls.draw();
            });

            me.myEventCls.onIds("#" + me.pre + "applycartoonshape", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                
                ic.bCartoonshape = false;
     
                let nameArray = $("#" + me.pre + "cartoonshape").val();
                let atomSet1 = ic.definedSetsCls.getAtomsFromNameArray(nameArray);
                let posArray1 = ic.contactCls.getExtent(atomSet1);
                let pos1 = new THREE.Vector3(posArray1[2][0], posArray1[2][1], posArray1[2][2]);

                let shape = $("#" + me.pre + "cartoonshape_shape").val(); // Sphere or Cube
                let radius = $("#" + me.pre + "cartoonshape_radius").val(); 
                let colorStr = $("#" + me.pre + "cartoonshape_customcolor").val(); 
                let opacity = $("#" + me.pre + "cartoonshape_opacity").val();

                colorStr = '#' + colorStr.replace(/\#/g, '');
                let color = me.parasCls.thr(colorStr);
             
                // draw the shape
                let command;
                if(shape == 'Sphere') {
                    ic.sphereCls.createSphereBase(pos1, color, radius, undefined, undefined, undefined, opacity);
                    // command = 'add sphere | x1 ' + pos1.x.toPrecision(4)  + ' y1 ' + pos1.y.toPrecision(4) + ' z1 ' + pos1.z.toPrecision(4) + ' | color ' + colorStr + ' | opacity ' + opacity + ' | radius ' + radius;
                    command = 'add sphere | ' + nameArray + ' | color ' + colorStr + ' | opacity ' + opacity + ' | radius ' + radius;
                }
                else {
                    ic.boxCls.createBox_base(pos1, radius, color, undefined, undefined, undefined, opacity);
                    // command = 'add cube | x1 ' + pos1.x.toPrecision(4)  + ' y1 ' + pos1.y.toPrecision(4) + ' z1 ' + pos1.z.toPrecision(4) + ' | color ' + colorStr + ' | opacity ' + opacity + ' | radius ' + radius;
                    command = 'add cube | ' + nameArray + ' | color ' + colorStr + ' | opacity ' + opacity + ' | radius ' + radius;
                }

                thisClass.setLogCmd(command, true);
                ic.shapeCmdHash[command] = 1;

                ic.drawCls.draw();
            });

            me.myEventCls.onIds("#" + me.pre + "clearlinebtwsets", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                

                ic.lines['cylinder'] = [];
                thisClass.setLogCmd('clear line between sets', true);

                ic.drawCls.draw();
            });

            me.myEventCls.onIds("#" + me.pre + "clearcartoonshape", "click", function(e) { let ic = me.icn3d;
                e.preventDefault();
                

                ic.shapeCmdHash = {};
                thisClass.setLogCmd('clear shape', true);

                ic.drawCls.draw();
            });

            me.myEventCls.onIds("#" + me.pre + "apply_thickness_3dprint", "click", function(e) { me.icn3d;
                e.preventDefault();

                me.htmlCls.setHtmlCls.setLineThickness("3dprint");
            });
            me.myEventCls.onIds("#" + me.pre + "apply_thickness_style", "click", function(e) { me.icn3d;
                e.preventDefault();

                me.htmlCls.setHtmlCls.setLineThickness("style");
                me.htmlCls.setMenuCls.setLogWindow(true);
            });

            me.myEventCls.onIds("#" + me.pre + "reset_thickness_3dprint", "click", function(e) { me.icn3d;
                e.preventDefault();

                me.htmlCls.setHtmlCls.setLineThickness("3dprint", true);
            });
            me.myEventCls.onIds("#" + me.pre + "reset_thickness_style", "click", function(e) { me.icn3d;
                e.preventDefault();

                me.htmlCls.setHtmlCls.setLineThickness("style", true);
                me.htmlCls.setMenuCls.setLogWindow(true);
            });


            me.myEventCls.onIds("#" + me.pre + "reset", "click", function(e) { let ic = me.icn3d;
                ic.selectionCls.resetAll();

                // need to render
                if(ic.bRender) ic.drawCls.draw(); //ic.drawCls.render();
            });

            me.myEventCls.onIds(["#" + me.pre + "toggleHighlight", "#" + me.pre + "toggleHighlight2"], "click", function(e) { let ic = me.icn3d;
                e.stopImmediatePropagation();
                ic.hlUpdateCls.toggleHighlight();
                thisClass.setLogCmd("toggle highlight", true);
            });
            me.myEventCls.onIds("#" + me.pre + "seq_clearselection", "click", function(e) { let ic = me.icn3d;
                e.stopImmediatePropagation();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                ic.hlUpdateCls.clearHighlight();
                thisClass.setLogCmd("clear selection", true);
            });
            me.myEventCls.onIds("#" + me.pre + "seq_clearselection2", "click", function(e) { let ic = me.icn3d;
                e.stopImmediatePropagation();
                e.preventDefault();
                ic.hlUpdateCls.clearHighlight();
                thisClass.setLogCmd("clear selection", true);
            });
            me.myEventCls.onIds("#" + me.pre + "alignseq_clearselection", "click", function(e) { let ic = me.icn3d;
                e.stopImmediatePropagation();
                ic.hlUpdateCls.clearHighlight();
                thisClass.setLogCmd("clear selection", true);
            });

            me.myEventCls.onIds("#" + me.pre + "replay", "click", async function(e) { let ic = me.icn3d;
                 e.stopImmediatePropagation();
                 ic.CURRENTNUMBER++;
                 let currentNumber =(me.cfg.replay) ? ic.STATENUMBER : ic.STATENUMBER - 1;

                 if(ic.CURRENTNUMBER == currentNumber) {
                      ic.bReplay = 0;
                      $("#" + me.pre + "replay").hide();
                 }
                 else if(ic.commands.length > 0 && ic.commands[ic.CURRENTNUMBER]) {         
                      await ic.loadScriptCls.execCommandsBase(ic.CURRENTNUMBER, ic.CURRENTNUMBER, ic.STATENUMBER);
                      let pos = ic.commands[ic.CURRENTNUMBER].indexOf('|||');
                      let cmdStrOri =(pos != -1) ? ic.commands[ic.CURRENTNUMBER].substr(0, pos) : ic.commands[ic.CURRENTNUMBER];
                      let maxLen = 30;
                      let cmdStr =(cmdStrOri.length > maxLen) ? cmdStrOri.substr(0, maxLen) + '...' : cmdStrOri;
                      let menuStr = ic.applyCommandCls.getMenuFromCmd(cmdStr);
                      $("#" + me.pre + "replay_cmd").html('Cmd: ' + cmdStr);
                      $("#" + me.pre + "replay_menu").html('Menu: ' + menuStr);

                      thisClass.setLogCmd(cmdStrOri, true);

                      ic.drawCls.draw();
                 }
            });


            ic.loadScriptCls.pressCommandtext();

            me.myEventCls.onIds("#" + me.pre + "seq_saveselection", "click", function(e) { let ic = me.icn3d;
               e.stopImmediatePropagation();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               ic.selectionCls.saveSelectionPrep();
               let name = $("#" + me.pre + "seq_command_name").val().replace(/\s+/g, '_');
               //var description = $("#" + me.pre + "seq_command_desc").val();
               ic.selectionCls.saveSelection(name, name);
            });
            me.myEventCls.onIds("#" + me.pre + "seq_saveselection2", "click", function(e) { let ic = me.icn3d;
               e.stopImmediatePropagation();
               ic.selectionCls.saveSelectionPrep();
               let name = $("#" + me.pre + "seq_command_name2").val().replace(/\s+/g, '_');
               //var description = $("#" + me.pre + "seq_command_desc2").val();
               ic.selectionCls.saveSelection(name, name);
            });

            me.myEventCls.onIds("#" + me.pre + "mn2_saveresidue", "click", function(e) { let ic = me.icn3d;
                e.stopImmediatePropagation();
                if(!me.cfg.notebook) dialog.dialog( "close" );
                
                ic.selectionCls.saveEachResiInSel();

                thisClass.setLogCmd('select each residue', true);
             });


            me.myEventCls.onIds("#" + me.pre + "alignseq_saveselection", "click", function(e) { let ic = me.icn3d;
               e.stopImmediatePropagation();
               ic.selectionCls.saveSelectionPrep();
               let name = $("#" + me.pre + "alignseq_command_name").val().replace(/\s+/g, '_');
               //var description = $("#" + me.pre + "alignseq_command_desc").val();
               ic.selectionCls.saveSelection(name, name);
            });

            me.myEventCls.onIds("#" + me.pre + "saveFasta", "click", function(e) { me.icn3d;
                e.stopImmediatePropagation();
                thisClass.exportMsa('fasta');
                thisClass.setLogCmd('Save alignment in FASTA format', false);
             });

            me.myEventCls.onIds("#" + me.pre + "saveClustal", "click", function(e) { me.icn3d;
                e.stopImmediatePropagation();
                thisClass.exportMsa('clustalw');
                thisClass.setLogCmd('Save alignment in CLUSTALWW format', false);
            });

            me.myEventCls.onIds("#" + me.pre + "saveResbyres", "click", function(e) { me.icn3d;
                e.stopImmediatePropagation();
                thisClass.exportMsa('resbyres');
                thisClass.setLogCmd('Save alignment in Residue by Residue format to be used in File > Align (or Realign) > Multiple Chain > Residue by Residue', false);
            });

            $(document).on("click", "." + me.pre + "outputselection", function(e) { let ic = me.icn3d;
                  e.stopImmediatePropagation();
                ic.bSelectResidue = false;
                ic.bSelectAlignResidue = false;
                thisClass.setLogCmd('output selection', true);
                ic.threeDPrintCls.outputSelection();
            });

            $(document).on("click", ".icn3d-saveicon", function(e) { me.icn3d;
               e.stopImmediatePropagation();
               let id = $(this).attr('pid');

               thisClass.saveHtml(id);
               thisClass.setLogCmd("save html " + id, true);
            });

            $(document).on("click", ".icn3d-hideicon", function(e) { let ic = me.icn3d;
               e.stopImmediatePropagation();
               let id = $(this).attr('pid');
               if(!me.cfg.notebook) {
                   if(ic.dialogHashHideDone === undefined) ic.dialogHashHideDone = {};
                   if(ic.dialogHashPosToRight === undefined) ic.dialogHashPosToRight = {};
                   if(!ic.dialogHashHideDone.hasOwnProperty(id)) {
                       ic.dialogHashHideDone[id] = {"width": $("#" + id).dialog( "option", "width"), "height": $("#" + id).dialog( "option", "height"), "position": $("#" + id).dialog( "option", "position")};
                       let dialogWidth = 160;
                       let dialogHeight = 80;
                       $("#" + id).dialog( "option", "width", dialogWidth );
                       $("#" + id).dialog( "option", "height", dialogHeight );
                       let posToRight;
                       if(ic.dialogHashPosToRight.hasOwnProperty(id)) {
                           posToRight = ic.dialogHashPosToRight[id];
                       }
                       else {
                           posToRight = Object.keys(ic.dialogHashPosToRight).length *(dialogWidth + 10);
                           ic.dialogHashPosToRight[id] = posToRight;
                       }
                       let position ={ my: "right bottom", at: "right-" + posToRight + " bottom+60", of: "#" + ic.divid, collision: "none" };
                       $("#" + id).dialog( "option", "position", position );
                   }
                   else {
                       let width = ic.dialogHashHideDone[id].width;
                       let height = ic.dialogHashHideDone[id].height;
                       let position = ic.dialogHashHideDone[id].position;
                       $("#" + id).dialog( "option", "width", width );
                       $("#" + id).dialog( "option", "height", height );
                       $("#" + id).dialog( "option", "position", position );
                       delete ic.dialogHashHideDone[id];
                   }
               }
            });

            // highlight a pair residues
            $(document).on("click", "." + me.pre + "selres", function(e) { let ic = me.icn3d;
                  e.stopImmediatePropagation();
                  ic.bSelOneRes = false;
                  let elems = $( "." + me.pre + "seloneres" );
                  for(let i = 0, il = elems.length; i < il;  ++i) {
                      elems[i].checked = false;
                  }
                  let idArray = $(this).attr('resid').split('|');
                  ic.hAtoms = {};
                  ic.selectedResidues = {};
                  let cmd = 'select ';
                  for(let i = 0, il = idArray.length; i < il; ++i) {
                      let idStr = idArray[i]; // TYR $1KQ2.B:56@OH, or ASP $1KQ2.B:40
                      if(i > 0) cmd += ' or ';
                      cmd += ic.selectionCls.selectOneResid(idStr);
                  }
                  ic.hlUpdateCls.updateHlAll();
                  thisClass.setLogCmd(cmd, true);
            });
            // highlight a residue
            $(document).on("click", "." + me.pre + "seloneres", function(e) { let ic = me.icn3d;
                  e.stopImmediatePropagation();
                  if(!ic.bSelOneRes) {
                      ic.hAtoms = {};
                      ic.selectedResidues = {};
                      ic.bSelOneRes = true;
                  }
                  let resid = $(this).attr('resid');
                  let id = $(this).attr('id');
                  if($("#" + id).length && $("#" + id)[0].checked) { // checked
                      ic.selectionCls.selectOneResid(resid);
                  }
                  else if($("#" + id).length && !$("#" + id)[0].checked) { // unchecked
                      ic.selectionCls.selectOneResid(resid, true);
                  }
                  ic.hlUpdateCls.updateHlAll();
            });
            // highlight a set of residues
            $(document).on("click", "." + me.pre + "selset", async function(e) { let ic = me.icn3d;
                  e.stopImmediatePropagation();
                  ic.bSelOneRes = false;
                  let elems = $( "." + me.pre + "seloneres" );
                  for(let i = 0, il = elems.length; i < il;  ++i) {
                      elems[i].checked = false;
                  }
                  let cmd = $(this).attr('cmd');
                  await ic.selByCommCls.selectByCommand(cmd, '', '');
                  ic.hlObjectsCls.removeHlObjects();  // render() is called
                  ic.hlObjectsCls.addHlObjects();  // render() is called
                  thisClass.setLogCmd(cmd, true);
            });


            $(document).on("click", ".icn3d-addtrack", function(e) { let ic = me.icn3d;
              e.stopImmediatePropagation();
              $("#" + me.pre + "anno_custom")[0].checked = true;
              $("[id^=" + me.pre + "custom]").show();
              //e.preventDefault();
              let chainid = $(this).attr('chainid');
              let geneid = ic.chainsGene[chainid].geneId;
              $("#" + me.pre + "track_chainid").val(chainid);
              $("#" + me.pre + "track_geneid").val(geneid);
              me.htmlCls.dialogCls.openDlg('dl_addtrack', 'Add track for Chain: ' + chainid);
              $( "#" + me.pre + "track_gi" ).focus();
            });

            $(document).on("click", ".icn3d-customcolor", function(e) { me.icn3d;
              e.stopImmediatePropagation();
              //e.preventDefault();
              let chainid = $(this).attr('chainid');
              $("#" + me.pre + "customcolor_chainid").val(chainid);
              me.htmlCls.dialogCls.openDlg('dl_customcolor', 'Apply custom color or tube for Chain: ' + chainid);
            });

            $(document).on("click", ".icn3d-helixsets", function(e) { let ic = me.icn3d;
              e.stopImmediatePropagation();
              //e.preventDefault();
              let chainid = $(this).attr('chainid');
              ic.addTrackCls.defineSecondary(chainid, 'helix');
              thisClass.setLogCmd('define helix sets | chain ' + chainid, true);
            });

            $(document).on("click", ".icn3d-sheetsets", function(e) { let ic = me.icn3d;
              e.stopImmediatePropagation();
              //e.preventDefault();
              let chainid = $(this).attr('chainid');
              ic.addTrackCls.defineSecondary(chainid, 'sheet');
              thisClass.setLogCmd('define sheet sets | chain ' + chainid, true);
            });

            $(document).on("click", ".icn3d-coilsets", function(e) { let ic = me.icn3d;
              e.stopImmediatePropagation();
              //e.preventDefault();
              let chainid = $(this).attr('chainid');
              ic.addTrackCls.defineSecondary(chainid, 'coil');
              thisClass.setLogCmd('define coil sets | chain ' + chainid, true);
            });

            $(document).on("click", ".icn3d-iganchorsets", function(e) { let ic = me.icn3d;
                e.stopImmediatePropagation();
                //e.preventDefault();
                let chainid = $(this).attr('chainid');
                ic.addTrackCls.defineIgstrand(chainid, 'iganchor');
                thisClass.setLogCmd('define iganchor sets | chain ' + chainid, true);
            });

            $(document).on("click", ".icn3d-igstrandsets", function(e) { let ic = me.icn3d;
                e.stopImmediatePropagation();
                //e.preventDefault();
                let chainid = $(this).attr('chainid');
                ic.addTrackCls.defineIgstrand(chainid, 'igstrand');
                thisClass.setLogCmd('define igstrand sets | chain ' + chainid, true);
            });

            $(document).on("click", ".icn3d-igloopsets", function(e) { let ic = me.icn3d;
                e.stopImmediatePropagation();
                //e.preventDefault();
                let chainid = $(this).attr('chainid');
                ic.addTrackCls.defineIgstrand(chainid, 'igloop');
                thisClass.setLogCmd('define igloop sets | chain ' + chainid, true);
            });

            $(document).on("click", ".icn3d-igdomainsets", function(e) { let ic = me.icn3d;
                e.stopImmediatePropagation();
                //e.preventDefault();
                let chainid = $(this).attr('chainid');
                ic.addTrackCls.defineIgstrand(chainid, 'igdomain');
                thisClass.setLogCmd('define igdomain sets | chain ' + chainid, true);
            });

            me.myEventCls.onIds("#" + me.pre + "deletesets", "click", function(e) { let ic = me.icn3d;
                 ic.definedSetsCls.deleteSelectedSets();
                 thisClass.setLogCmd("delete selected sets", true);
            });

            $(document).on('mouseup touchend', "accordion", function(e) { let ic = me.icn3d;
              if(ic.bControlGl && !me.bNode) {
                  if(window.controls) {
                    window.controls.noRotate = false;
                    window.controls.noZoom = false;
                    window.controls.noPan = false;
                  }
              }
              else {
                  if(ic.controls) {
                    ic.controls.noRotate = false;
                    ic.controls.noZoom = false;
                    ic.controls.noPan = false;
                  }
              }
            });

           $(document).on('mousedown touchstart', "accordion", function(e) { let ic = me.icn3d;
              if(ic.bControlGl && !me.bNode) {
                  if(window.controls) {
                    window.controls.noRotate = true;
                    window.controls.noZoom = true;
                    window.controls.noPan = true;
                  }
              }
              else {
                  if(ic.controls) {
                    ic.controls.noRotate = true;
                    ic.controls.noZoom = true;
                    ic.controls.noPan = true;
                  }
              }
            });

            //$("[id$=_cddseq_expand]").on('click', '.ui-icon-plus', function(e) { let ic = me.icn3d;
            $(document).on("click", ".icn3d-expand", function(e) { me.icn3d;
                e.stopImmediatePropagation();
                let oriId = $(this).attr('id');
                let pos = oriId.lastIndexOf('_');
                let id = oriId.substr(0, pos);
                $("#" + id).show();
                $("#" + id + "_expand").hide();
                $("#" + id + "_shrink").show();
            });
            //$("[id$=_cddseq_shrink]").on('click', '.ui-icon-minus', function(e) { let ic = me.icn3d;
            $(document).on("click", ".icn3d-shrink", function(e) { me.icn3d;
                e.stopImmediatePropagation();
                let oriId = $(this).attr('id');
                let pos = oriId.lastIndexOf('_');
                let id = oriId.substr(0, pos);
                $("#" + id).hide();
                $("#" + id + "_expand").show();
                $("#" + id + "_shrink").hide();
            });

            window.onscroll = function(e) { let ic = me.icn3d;
                if(ic.view == 'detailed view' && $(window).scrollTop() == 0 && $(window).scrollTop() == 0 && $("#" + me.pre + "dl_selectannotations").scrollTop() == 0) {
                    // show fixed titles
                    ic.annotationCls.showFixedTitle();
                }
                else {
                    // remove fixed titles
                    ic.annotationCls.hideFixedTitle();
                }
            } ;
            me.myEventCls.onIds( "#" + me.pre + "dl_selectannotations", "scroll", function() {
                if(ic.view == 'detailed view' && $(window).scrollTop() == 0 && $(window).scrollTop() == 0 && $("#" + me.pre + "dl_selectannotations").scrollTop() == 0) {
                    // show fixed titles
                    ic.annotationCls.showFixedTitle();
                }
                else {
                    // remove fixed titles
                    ic.annotationCls.hideFixedTitle();
                }
            });


            me.myEventCls.onIds("#" + me.pre + "mn6_themeBlue", "click", function(e) { me.icn3d;
               me.htmlCls.setMenuCls.setTheme('blue');
               thisClass.setLogCmd("set theme blue", true);
            });
            me.myEventCls.onIds("#" + me.pre + "mn6_themeOrange", "click", function(e) { me.icn3d;
               me.htmlCls.setMenuCls.setTheme('orange');
               thisClass.setLogCmd("set theme orange", true);
            });
            me.myEventCls.onIds("#" + me.pre + "mn6_themeBlack", "click", function(e) { me.icn3d;
               me.htmlCls.setMenuCls.setTheme('black');
               thisClass.setLogCmd("set theme black", true);
            });

            $(document).on("click", "." + me.pre + "snpin3d", async function(e) { let ic = me.icn3d;
                e.stopImmediatePropagation();

                let snp = $(this).attr('snp');

                await ic.scapCls.retrieveScap(snp);
                thisClass.setLogCmd('scap 3d ' + snp, true);
                thisClass.setLogCmd("select displayed set", true);
            });

            $(document).on("click", "." + me.pre + "snpinter", async function(e) { let ic = me.icn3d;
                e.stopImmediatePropagation();

                let snp = $(this).attr('snp');

                let bInteraction = true;
                await ic.scapCls.retrieveScap(snp, bInteraction);
                thisClass.setLogCmd('scap interaction ' + snp, true);

                let idArray = snp.split('_'); //stru_chain_resi_snp
                let select = '.' + idArray[1] + ':' + idArray[2];
                let name = 'snp_' + idArray[1] + '_' + idArray[2];
                thisClass.setLogCmd("select " + select + " | name " + name, true);
                thisClass.setLogCmd("line graph interaction pairs | selected non-selected | hbonds,salt bridge,interactions,halogen,pi-cation,pi-stacking | false | threshold 3.8 6 4 3.8 6 5.5", true);
                thisClass.setLogCmd("adjust dialog dl_linegraph", true);
                thisClass.setLogCmd("select displayed set", true);
            });

            $(document).on("click", "." + me.pre + "snppdb", async function(e) { let ic = me.icn3d;
                e.stopImmediatePropagation();

                let snp = $(this).attr('snp');

                let bPdb = true;
                await ic.scapCls.retrieveScap(snp, undefined, bPdb);
                thisClass.setLogCmd('scap pdb ' + snp, true);
            });

        }

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class AlignSeq {
        constructor(icn3dui) {
            this.icn3dui = icn3dui;
        }

        //Set up the sequence display with the aligned sequences. Either chains in "alignChainArray" or residues
        //in "residueArray" will be highlighted. "bUpdateHighlightAtoms" is a flag to update the highlight atoms
        //or not. "bShowHighlight" is a flag to show highlight or not.
        getAlignSequencesAnnotations(alignChainArray, bUpdateHighlightAtoms, residueArray, bShowHighlight, bOnechain, bReverse) {
            let me = this.icn3dui,
                ic = me.icn3d;
            let sequencesHtml = '';

            alignChainArray = Object.keys(ic.alnChains);

            if (bReverse) alignChainArray = alignChainArray.reverse();
            
            let maxSeqCnt = 0;

            let chainHash = {};
            if (alignChainArray !== undefined) {

                for (let i = 0, il = alignChainArray.length; i < il; ++i) {
                    let chainid = alignChainArray[i];

                    // make sure some residues are aligned
                    if(ic.alnChainsSeq[chainid] && ic.alnChainsSeq[chainid].length > 0) {
                        chainHash[chainid] = 1;
                    }
                    else {
                        return { "sequencesHtml": sequencesHtml, "maxSeqCnt": maxSeqCnt };
                    }
                }
            }

            //  let bModifyHAtoms = Object.keys(ic.hAtoms).length == Object.keys(ic.atoms).length && bHighlightChain &&(bUpdateHighlightAtoms === undefined || bUpdateHighlightAtoms);
            //  let bModifyHAtoms = Object.keys(ic.hAtoms).length == Object.keys(ic.atoms).length &&(bUpdateHighlightAtoms === undefined || bUpdateHighlightAtoms);
            let bModifyHAtoms = (bUpdateHighlightAtoms === undefined || bUpdateHighlightAtoms);

            if (bModifyHAtoms) {
                ic.hAtoms = {};
            }

            let bHighlightChain;
            let index = 0, prevResCnt2nd = 0;
            let firstChainid, oriChainid;

            //  for(let i in ic.alnChains) {
            for (let m = 0, ml = alignChainArray.length; m < ml; ++m) {
                let i = alignChainArray[m];
              
                if (index == 0) firstChainid = i;

                if (bOnechain && index > 0) {
                    oriChainid = firstChainid;
                } else {
                    oriChainid = i;
                }

                //bHighlightChain =(alignChainArray !== undefined && chainHash.hasOwnProperty(oriChainid)) ? true : false;

                //if( bHighlightChain &&(bUpdateHighlightAtoms === undefined || bUpdateHighlightAtoms) ) {
                // do not update isa subset is selected already
                if (bModifyHAtoms) {
                    ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.alnChains[i]);
                }

                let resiHtmlArray = [], seqHtml = "";
                let seqLength = (ic.alnChainsSeq[i] !== undefined) ? ic.alnChainsSeq[i].length : 0;

                if (seqLength > maxSeqCnt) maxSeqCnt = seqLength;

                let dashPos = oriChainid.indexOf('_');
                let structure = oriChainid.substr(0, dashPos);
                let chain = oriChainid.substr(dashPos + 1);

                //let startResi = (ic.alnChainsSeq[i][0] !== undefined) ? ic.alnChainsSeq[i][0].resi : '';
                let startResi, endResi;
                for (let k = 0, kl = seqLength; k < kl; ++k) {
                    if(ic.alnChainsSeq[i][k].resn != '-') {
                        startResi = ic.alnChainsSeq[i][k].resi;
                        break;
                    }
                }

                for (let k = seqLength - 1; k >= 0; --k) {
                    if(ic.alnChainsSeq[i][k].resn != '-') {
                        endResi = ic.alnChainsSeq[i][k].resi;
                        break;
                    }
                }

                seqHtml += "<span class='icn3d-residueNum' title='starting residue number'>" + startResi + "</span>";
                bHighlightChain = (alignChainArray !== undefined && chainHash.hasOwnProperty(oriChainid)) ? true : false;

                for (let k = 0, kl = seqLength; k < kl; ++k) {
                    // resiId is empty if it's gap
                    let resiId = 'N/A', resIdFull = '';
                    //if (ic.alnChainsSeq[i][k].resi !== '' && !isNaN(ic.alnChainsSeq[i][k].resi)) {
                    if (ic.alnChainsSeq[i][k].resi !== '') {
                        resiId = ic.alnChainsSeq[i][k].resi;
                        resIdFull = structure + "_" + chain + "_" + resiId;
                        ic.alnChainsSeq[i][k].color;
                    }

                    let classForAlign = "class='icn3d-residue"; // used to identify a residue when clicking a residue in sequence

                    //if((bShowHighlight === undefined || bShowHighlight) &&(bHighlightChain ||(ic.alnChainsSeq[i][k].aligned === 2 && residueArray !== undefined && resIdFull !== '' && residueArray.indexOf(resIdFull) !== -1) ) ) {
                    if ((bShowHighlight === undefined || bShowHighlight) && (bHighlightChain || (residueArray !== undefined && resIdFull !== '' && residueArray.indexOf(resIdFull) !== -1))) {
                        classForAlign = "class='icn3d-residue icn3d-highlightSeq";
                    }

                    // class for alignment: cons, ncons, nalign
                    if (resIdFull === '') {
                        classForAlign += "'";
                    } else {
                        classForAlign += " " + ic.alnChainsSeq[i][k].class + "'";
                    }

                    let colorRes;

                    if (!ic.residues.hasOwnProperty(resIdFull)) {                  
                        colorRes = '#000000;';
                    } else {
                        let firstAtom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[resIdFull]);
                        colorRes = (firstAtom.color !== undefined) ? '#' + firstAtom.color.getHexString() + ';' : '#000000;';
                    }

                    if (colorRes.toUpperCase() === '#FFFFFF;') colorRes = me.htmlCls.GREYD;

                    let bWithCoord = (resIdFull !== '') ? true : false;

                    if (bOnechain && k == 0) {
                        let letterSpace = 10;
                        let empthWidth = prevResCnt2nd * letterSpace;
                        seqHtml += "<span style='width:" + empthWidth + "px'></span>";
                    }

                    if (bWithCoord) {
                        if (ic.alnChainsSeq[i][k].resi != -1) {
                            // add "align" in front of id so that full sequence and aligned sequence will not conflict
                            seqHtml += "<span id='align_" + me.pre + resIdFull + "' " + classForAlign + " style='color:" + colorRes + "' title='" + ic.alnChainsSeq[i][k].resn + ic.alnChainsSeq[i][k].resi + "'>" + ic.alnChainsSeq[i][k].resn + "</span>";
                        } else {
                            seqHtml += "<span>" + ic.alnChainsSeq[i][k].resn + "</span>";
                        }
                    } else {
                        seqHtml += "<span title='" + ic.alnChainsSeq[i][k].resn + ic.alnChainsSeq[i][k].resi + "'>" + ic.alnChainsSeq[i][k].resn + "</span>";
                    }

                }
                //let endResi = (ic.alnChainsSeq[i][seqLength - 1] !== undefined) ? ic.alnChainsSeq[i][seqLength - 1].resi : '';
                seqHtml += "<span class='icn3d-residueNum' title='ending residue number'>" + endResi + "</span>";

                let n = alignChainArray.length;

                // the first chain stores all annotations
                // secondary: n, labels: 2, title: n, empty line: 1
                let annoLength = (ic.alnChainsAnno[i] !== undefined) ? ic.alnChainsAnno[i].length : 0;

                for (let j = 0, jl = annoLength; j < jl; ++j) {
                    resiHtmlArray[j] = "";

                    //let chainid = (j == 0 && annoLength >= 7) ? ic.alnChainsAnTtl[i][4][0] : oriChainid; // bottom secondary, j == 0: chain2,  next secondary, j == 1: chain1,
                    let chainid = (j < n) ?  alignChainArray[n - 1 - j] : oriChainid; // bottom secondary, j == 0: chain2,  next secondary, j == 1: chain1,

                    resiHtmlArray[j] += "<span class='icn3d-residueNum'></span>"; // a spot corresponding to the starting and ending residue number
                    for (let k = 0, kl = ic.alnChainsAnno[i][j].length; k < kl; ++k) {
                        let text = ic.alnChainsAnno[i][j][k];

                        if (text == 'H' || text == 'E' || text == 'c' || text == 'o') {

                            if (text == 'H') {
                                if (k % 2 == 0) {
                                    resiHtmlArray[j] += '<span class="icn3d-helix">&nbsp;</span>';
                                } else {
                                    resiHtmlArray[j] += '<span class="icn3d-helix2">&nbsp;</span>';
                                }
                            } else if (text == 'E') {
                                if (ic.alnChainsSeq[chainid][k] !== undefined) {
                                    let resiId = ic.alnChainsSeq[chainid][k].resi;
                                    let resIdFull = chainid + "_" + resiId;

                                    if (ic.residues.hasOwnProperty(resIdFull)) {
                                        let atom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[resIdFull]);

                                        if (atom.ssend) {
                                            resiHtmlArray[j] += '<span class="icn3d-sheet2">&nbsp;</span>';
                                        } else {
                                            resiHtmlArray[j] += '<span class="icn3d-sheet">&nbsp;</span>';
                                        }
                                    }
                                    else {
                                        resiHtmlArray[j] += '<span class="icn3d-sheet">&nbsp;</span>';
                                    }
                                }
                                else {
                                    resiHtmlArray[j] += '<span class="icn3d-sheet">&nbsp;</span>';
                                }
                            } else if (text == 'c') {
                                resiHtmlArray[j] += '<span class="icn3d-coil">&nbsp;</span>';
                            } else if (text == 'o') {
                                resiHtmlArray[j] += '<span class="icn3d-other">&nbsp;</span>';
                            } else {                          
                                resiHtmlArray[j] += "<span></span>";
                            }
                        } else {
                            resiHtmlArray[j] += "<span>" + text + "</span>";
                        }
                        //resiHtmlArray[j] += "<span>" + ic.alnChainsAnno[i][j][k] + "</span>";
                    }
                    resiHtmlArray[j] += "<span class='icn3d-residueNum'></span>"; // a spot corresponding to the starting and ending residue number
                }

                let chainidTmp = i,
                    title = (ic.pdbid_chain2title !== undefined) ? ic.pdbid_chain2title[oriChainid] : '';

                // add markers and residue numbers
                for (let j = annoLength - 1; j >= 0; --j) {
                    let annotitle = ic.alnChainsAnTtl[i][j][0];
                    if (annotitle == 'SS') annotitle = '';
                    //sequencesHtml += "<div class='icn3d-residueLine' style='white-space:nowrap;'><div class='icn3d-seqTitle' chain='" + i + "' anno='" + j + "'>" + annotitle + "</div>" + resiHtmlArray[j] + "<br/></div>";
                    sequencesHtml += "<div class='icn3d-residueLine' style='white-space:nowrap;'><div class='icn3d-seqTitle' anno='" + j + "'>" + annotitle + "</div>" + resiHtmlArray[j] + "<br/></div>";
                }
                
                sequencesHtml += '<div class="icn3d-seqTitle icn3d-link icn3d-blue" chain="' + i + '" anno="sequence" title="' + title + '">' + chainidTmp + ' </div><span class="icn3d-seqLine">' + seqHtml + '</span><br/>';

                if (index > 0) prevResCnt2nd += seqLength;

                ++index;
            }

            return { "sequencesHtml": sequencesHtml, "maxSeqCnt": maxSeqCnt }
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class SetHtml {
        constructor(icn3dui) {
            this.icn3dui = icn3dui;
        }

        getLink(id, text, bSimpleMenu, selType) { let me = this.icn3dui; me.icn3d;
            me.htmlCls.allMenus[id] = text;
            if(selType) me.htmlCls.allMenusSel[id] = selType;
            if(bSimpleMenu) me.htmlCls.simpleMenus[id] = 1;

            return "<li><span data-pinger id='" + me.pre + id + "' class='icn3d-link'>" + text + "</span></li>";
        }

        // a group of menus
        getMenuText(id, text, classname, bSimpleMenu, selType) { let me = this.icn3dui; me.icn3d;
            me.htmlCls.allMenus[id] = text;
            if(selType) me.htmlCls.allMenusSel[id] = selType;
            if(bSimpleMenu) me.htmlCls.simpleMenus[id] = 1;

            let styleStr = (classname == 'icn3d-menupd') ? " style='padding-left:1.5em!important;'" : "";

            // no ending "</li>"" since this is usually the start of a group of menus
            return "<li><span data-pinger id='" + me.pre + id + "'" + styleStr + ">" + text + "</span>"; 
        }

        getMenuUrl(id, url, text, bSimpleMenu, selType) { let me = this.icn3dui; me.icn3d;
            me.htmlCls.allMenus[id] = text;
            if(selType) me.htmlCls.allMenusSel[id] = selType;
            if(bSimpleMenu) me.htmlCls.simpleMenus[id] = 1;

            return "<li><a id='" + me.pre + id + "' href='" + url + "' target='_blank'>" + text + "</a></li>";
        }

        getMenuSep() { let me = this.icn3dui; me.icn3d;
            return "<li class='icn3d-menusep'>-</li>";
        }

        getLinkWrapper(id, text, wrapper, bSimpleMenu, selType, bHide) { let me = this.icn3dui; me.icn3d;
            me.htmlCls.allMenus[id] = text;
            if(selType) me.htmlCls.allMenusSel[id] = selType;
            if(bSimpleMenu) me.htmlCls.simpleMenus[id] = 1;

            let hideStr = (bHide) ? ' style="display:none"' : '';
            return "<li id='" + me.pre + wrapper + "'" + hideStr + "><span data-pinger id='" + me.pre + id + "' class='icn3d-link'>" + text + "</span></li>";
        }

        getLinkWrapper2(id, text, wrapper, bSimpleMenu, selType) { let me = this.icn3dui; me.icn3d;
            me.htmlCls.allMenus[id] = text;
            if(selType) me.htmlCls.allMenusSel[id] = selType;
            if(bSimpleMenu) me.htmlCls.simpleMenus[id] = 1;

            return "<li id='" + me.pre + wrapper + "'><span data-pinger id='" + me.pre + id + "' class='icn3d-link'>" + text + "</span>";
        }

        getRadio(radioid, id, text, bChecked, bSimpleMenu, selType) { let me = this.icn3dui; me.icn3d;
            me.htmlCls.allMenus[id] = text;
            if(selType) me.htmlCls.allMenusSel[id] = selType;
            if(bSimpleMenu) me.htmlCls.simpleMenus[id] = 1;

            let checkedStr =(bChecked) ? ' checked' : '';

            //https://stackoverflow.com/questions/17541614/use-images-instead-of-radio-buttons/17541916
            return "<li><label data-pinger id='" + me.pre + id + "' class='icn3d-rad'>" + me.htmlCls.inputRadioStr + "name='" + me.pre + radioid + "' " + "class='" + me.pre + radioid + "' " + "v='" + text + "'" + checkedStr + "><span class='ui-icon ui-icon-blank'></span> <span class='icn3d-rad-text'>" + text + "</span></label></li>";
        }

        getRadioColor(radioid, id, text, color, bChecked, bSimpleMenu, selType) { let me = this.icn3dui; me.icn3d;
            me.htmlCls.allMenus[id] = text;
            if(selType) me.htmlCls.allMenusSel[id] = selType;
            if(bSimpleMenu) me.htmlCls.simpleMenus[id] = 1;

            let checkedStr =(bChecked) ? ' checked' : '';

            //https://stackoverflow.com/questions/17541614/use-images-instead-of-radio-buttons/17541916
            return "<li><label data-pinger id='" + me.pre + id + "' class='icn3d-rad'>" + me.htmlCls.inputRadioStr + "name='" + me.pre + radioid + "'" + checkedStr + "><span class='ui-icon ui-icon-blank'></span> <span class='icn3d-color-rad-text' color='" + color + "'><span style='background-color:#" + color + "'>" + me.htmlCls.space3 + "</span> " + text + "</span></label></li>";
        }

        setAdvanced(index) { let me = this.icn3dui; me.icn3d;
            let indexStr =(index === undefined) ? '' : index;

            let dialogClass =(me.cfg.notebook) ? 'icn3d-hidden' : '';
            let html = me.htmlCls.divStr + "dl_advanced" + indexStr + "' class='" + dialogClass + "'>";

            html += "<table width='500'><tr><td valign='top'><table cellspacing='0'>";
            html += "<tr><td><b>Select:</b></td><td>" + me.htmlCls.inputTextStr + "id='" + me.pre + "command" + indexStr + "' placeholder='$[structures].[chains]:[residues]@[atoms]' size='60'></td></tr>";
            html += "<tr><td><b>Name:</b></td><td>" + me.htmlCls.inputTextStr + "id='" + me.pre + "command_name" + indexStr + "' placeholder='my_selection' size='60'></td></tr>";
            html += "<tr><td colspan='2' align='left'>" + me.htmlCls.space3 + me.htmlCls.buttonStr + "command_apply" + indexStr + "'><b>Save Selection to Defined Sets</b></button></td></tr>";
            html += "</table></td>";

            html += "</tr>";

            html += "<tr><td>";

            html += 'Specification Tips: <div style="width:20px; margin-top:6px; display:inline-block;"><span id="' + me.pre + 'specguide' + indexStr + '_expand" class="ui-icon ui-icon-plus icn3d-expand icn3d-link" style="width:15px;" title="Expand"></span><span id="' + me.pre + 'specguide' + indexStr + '_shrink" class="ui-icon ui-icon-minus icn3d-shrink icn3d-link" style="display:none; width:15px;" title="Shrink"></span></div><br>';

            html += me.htmlCls.divStr + "specguide" + indexStr + "' style='display:none; width:500px' class='icn3d-box'>";

            html += "<b>Specification:</b> In the selection \"$1HHO,4N7N.A,B,C:5-10,LV,3AlaVal,chemicals@CA,C,C*\":";
            html += "<ul><li>\"$1HHO,4N7N\" uses \"$\" to indicate structure selection.<br/>";
            html += "<li>\".A,B,C\" uses \".\" to indicate chain selection.<br/>";
            html += "<li>\":5-10,LV,3LeuVal,chemicals\" uses the colon \":\" to indicate residue selection. Residue selection could be residue number(5-10), one-letter IUPAC residue name abbreviations(LV), three-letter residue names(AlaVal, \"3\" indicates each residue name has three letters), or predefined names: \"proteins\", \"nucleotides\", \"chemicals\", \"ions\", and \"water\". IUPAC abbreviations can be written either as a contiguous string(e.g., \":LV\"), in order to find all instances of that sequence in the structure, or they can be separated by commas(e.g., \":L,V\") to select all residues of a given type in the structure(in the latter case, select all Leucine and Valine in the structure).<br/>";
            html += "<li>\"@CA,C,C*\" uses \"@\" to indicate atom name selection. \"C*\" selects any atom names starting with \"C\". <br/>";
            html += "<li>Partial definition is allowed, e.g., \":1-10\" selects all residue IDs 1-10 in all chains.<br/>";
            html += "<li>Different selections can be unioned(with \"<b>or</b>\", default), intersected(with \"<b>and</b>\"), or negated(with \"<b>not</b>\"). For example, \":1-10 or :K\" selects all residues 1-10 and all Lys residues. \":1-10 and :K\" selects all Lys residues in the range of residue number 1-10. \":1-10 or not :K\" selects all residues 1-10, which are not Lys residues.<br/>";
            html += "<li>The wild card character \"X\" or \"x\" can be used to represent any character.";
            html += "</ul>";
            html += "<b>Set Operation:</b>";
            html += "<ul><li>Users can select multiple sets in the menu \"Select > Defined Sets\".<br/>";
            html += "<li>Different sets can be unioned(with \"<b>or</b>\", default), intersected(with \"<b>and</b>\"), or negated(with \"<b>not</b>\"). For example, if the \"Defined Sets\" menu has four sets \":1-10\", \":11-20\", \":5-15\", and \":7-8\", the command \"saved atoms :1-10 or :11-20 and :5-15 not :7-8\" unions all residues 1-10 and 11-20 to get the residues 1-20, then intersects with the residues 5-15 to get the residues 5-15, then exclude the residues 7-8 to get the final residues 5-6 and 9-15.</ul>";
            html += "<b>Full commands in url or command window:</b>";
            html += "<ul><li>Select without saving the set: select $1HHO,4N7N.A,B,C:5-10,LV,chemicals@CA,C,C*<br/>";
            //html += "<li>Select and save: select $1HHO,4N7N.A,B,C:5-10,LV,chemicals@CA,C | name my_name | description my_description</ul>";
            html += "<li>Select and save: select $1HHO,4N7N.A,B,C:5-10,LV,chemicals@CA,C,C* | name my_name</ul>";

            html += "</div>";

            html += "</td></tr></table>";
            html += "</div>";

            return html;
        }

        getOptionHtml(optArray, selIndex) { let me = this.icn3dui; me.icn3d;
            let html = '';

            for(let i = 0, il = optArray.length; i < il; ++i) {
                let iStr = optArray[i];

                if(i == selIndex) {
                    html += me.htmlCls.optionStr + "'" + iStr + "' selected>" + iStr + "</option>";
                }
                else {
                    html += me.htmlCls.optionStr + "'" + iStr + "'>" + iStr + "</option>";
                }
            }

            return html;
        }

        setColorHints() { let me = this.icn3dui; me.icn3d;
            let html = '';

            html += me.htmlCls.divNowrapStr + '<span style="margin-left:33px; color:#00FF00; font-weight:bold">Green</span>: H-Bonds; ';
            html += '<span style="color:#00FFFF; font-weight:bold">Cyan</span>: Salt Bridge/Ionic; ';
            html += '<span style="font-weight:bold">Grey</span>: Contacts</div>';
            html += me.htmlCls.divNowrapStr + '<span style="margin-left:33px; color:#FF00FF; font-weight:bold">Magenta</span>: Halogen Bonds; ';
            html += '<span style="color:#FF0000; font-weight:bold">Red</span>: &pi;-Cation; ';
            html += '<span style="color:#0000FF; font-weight:bold">Blue</span>: &pi;-Stacking</div>';

            return html;
        }

        setThicknessHtml(type) { let me = this.icn3dui, ic = me.icn3d;
            let html = '';

            // type == '3dprint' or 'style'
            let linerad =(type == '3dprint') ? '1' : '0.1';
            let coilrad =(type == '3dprint') ? '1.2' : '0.3';
            let stickrad =(type == '3dprint') ? '0.8' : '0.4';
            let crosslinkrad =(type == '3dprint') ? '0.8' : '0.4';
            let tracerad =(type == '3dprint') ? '1' : '0.4';
            let ballscale =(type == '3dprint') ? '0.6' : '0.3';
            let ribbonthick =(type == '3dprint') ? '1' : '0.2';
            let prtribbonwidth =(type == '3dprint') ? '2' : '1.3';
            let nucleotideribbonwidth =(type == '3dprint') ? '1.4' : '0.8';

            let shininess = 40;
            let light1 = 0.8;
            let light2 = 0.4;
            let light3 = 0.2;
            let bGlycansCartoon = 0;
            let bMembrane = 1;
            let bCmdWindow = 0;

            // retrieve from cache
            if(type == 'style') {
                if(this.getCookie('shininess') != '') {
                    shininess = parseFloat(this.getCookie('shininess'));
                }

                if(this.getCookie('light1') != '') {
                    light1 = parseFloat(this.getCookie('light1'));
                    light2 = parseFloat(this.getCookie('light2'));
                    light3 = parseFloat(this.getCookie('light3'));
                }

                if(this.getCookie('lineRadius') != '') {
                    linerad = parseFloat(this.getCookie('lineRadius'));
                    coilrad = parseFloat(this.getCookie('coilWidth'));
                    stickrad = parseFloat(this.getCookie('cylinderRadius'));
                    let clrad = this.getCookie('crosslinkRadius');
                    crosslinkrad = (!isNaN(clrad)) ? parseFloat(clrad) : ic.crosslinkRadius;
                    tracerad = parseFloat(this.getCookie('traceRadius'));
                    ballscale = parseFloat(this.getCookie('dotSphereScale'));
                    ribbonthick = parseFloat(this.getCookie('ribbonthickness'));
                    prtribbonwidth = parseFloat(this.getCookie('helixSheetWidth'));
                    nucleotideribbonwidth = parseFloat(this.getCookie('nucleicAcidWidth'));
                }

                if(this.getCookie('glycan') != '') {
                    bGlycansCartoon = parseFloat(this.getCookie('glycan'));
                }

                if(this.getCookie('membrane') != '') {
                    bMembrane = parseFloat(this.getCookie('membrane'));
                }

                if(this.getCookie('cmdwindow') != '') {
                    bCmdWindow = parseFloat(this.getCookie('cmdwindow'));
                }

                html += "<b>Note</b>: The following parameters will be saved in cache. You just need to set them once. <br><br>";

                html += "<b>1. Shininess</b>: " + me.htmlCls.inputTextStr + "id='" + me.pre + "shininess' value='" + shininess + "' size=4>" + me.htmlCls.space3 + "(for the shininess of the 3D objects, default 40)<br/><br/>";
                html += "<b>2. Three directional lights</b>: <br>";
                html += "<b>Key Light</b>: " + me.htmlCls.inputTextStr + "id='" + me.pre + "light1' value='" + light1 + "' size=4>" + me.htmlCls.space3 + "(for the light strength of the key light, default 0.8)<br/>";
                html += "<b>Fill Light</b>: " + me.htmlCls.inputTextStr + "id='" + me.pre + "light2' value='" + light2 + "' size=4>" + me.htmlCls.space3 + "(for the light strength of the fill light, default 0.4)<br/>";
                html += "<b>Back Light</b>: " + me.htmlCls.inputTextStr + "id='" + me.pre + "light3' value='" + light3 + "' size=4>" + me.htmlCls.space3 + "(for the light strength of the back light, default 0.2)<br/><br/>";
                html += "<b>3. Thickness</b>: <br>";
            }

            html += "<b>Line Radius</b>: " + me.htmlCls.inputTextStr + "id='" + me.pre + "linerad_" + type + "' value='" + linerad + "' size=4>" + me.htmlCls.space3 + "(for stabilizers, hydrogen bonds, distance lines, default 0.1)<br/>";
            html += "<b>Coil Radius</b>: " + me.htmlCls.inputTextStr + "id='" + me.pre + "coilrad_" + type + "' value='" + coilrad + "' size=4>" + me.htmlCls.space3 + "(for coils, default 0.3)<br/>";
            html += "<b>Stick Radius</b>: " + me.htmlCls.inputTextStr + "id='" + me.pre + "stickrad_" + type + "' value='" + stickrad + "' size=4>" + me.htmlCls.space3 + "(for sticks, default 0.4)<br/>";
            html += "<b>Cross-Linkage Radius</b>: " + me.htmlCls.inputTextStr + "id='" + me.pre + "crosslinkrad_" + type + "' value='" + crosslinkrad + "' size=4>" + me.htmlCls.space3 + "(for cross-linkages, default 0.4)<br/>";
            html += "<b>Trace Radius</b>: " + me.htmlCls.inputTextStr + "id='" + me.pre + "tracerad_" + type + "' value='" + tracerad + "' size=4>" + me.htmlCls.space3 + "(for C alpha trace, O3' trace, default 0.4)<br/>";

            html += "<b>Ribbon Thickness</b>: " + me.htmlCls.inputTextStr + "id='" + me.pre + "ribbonthick_" + type + "' value='" + ribbonthick + "' size=4>" + me.htmlCls.space3 + "(for helix and sheet ribbons, nucleotide ribbons, default 0.2)<br/>";
            html += "<b>Protein Ribbon Width</b>: " + me.htmlCls.inputTextStr + "id='" + me.pre + "prtribbonwidth_" + type + "' value='" + prtribbonwidth + "' size=4>" + me.htmlCls.space3 + "(for helix and sheet ribbons, default 1.3)<br/>";
            html += "<b>Nucleotide Ribbon Width</b>: " + me.htmlCls.inputTextStr + "id='" + me.pre + "nucleotideribbonwidth_" + type + "' value='" + nucleotideribbonwidth + "' size=4>" + me.htmlCls.space3 + "(for nucleotide ribbons, default 0.8)<br/>";

            html += "<b>Ball Scale</b>: " + me.htmlCls.inputTextStr + "id='" + me.pre + "ballscale_" + type + "' value='" + ballscale + "' size=4>" + me.htmlCls.space3 + "(for styles 'Ball and Stick' and 'Dot', default 0.3)<br/>";

            if(type == 'style') {
                html += "<br><b>4. Show Glycan Cartoon</b>: " + me.htmlCls.inputTextStr + "id='" + me.pre + "glycan' value='" + bGlycansCartoon + "' size=4>" + me.htmlCls.space3 + "(0: hide, 1: show, default 0)<br/>";

                html += "<br><b>5. Show Membrane</b>: " + me.htmlCls.inputTextStr + "id='" + me.pre + "membrane' value='" + bMembrane + "' size=4>" + me.htmlCls.space3 + "(0: hide, 1: show, default 1)<br/>";

                html += "<br><b>6. Enlarge Command Window</b>: " + me.htmlCls.inputTextStr + "id='" + me.pre + "cmdwindow' value='" + bCmdWindow + "' size=4>" + me.htmlCls.space3 + "(0: Regular, 1: Large, default 0)<br/><br/>";
            }

            html += me.htmlCls.spanNowrapStr + "" + me.htmlCls.buttonStr + "apply_thickness_" + type + "'>Apply</button></span>&nbsp;&nbsp;&nbsp;";

            html += me.htmlCls.spanNowrapStr + "" + me.htmlCls.buttonStr + "reset_thickness_" + type + "'>Reset</button></span>";

            return html;
        }

        getCookie(cname) {
          let name = cname + "=";
          let decodedCookie = decodeURIComponent(document.cookie);
          let ca = decodedCookie.split(';');
          for(let i = 0; i <ca.length; i++) {
            let c = ca[i];
            while (c.charAt(0) == ' ') {
              c = c.substring(1);
            }
            if (c.indexOf(name) == 0) {
              return c.substring(name.length, c.length);
            }
          }
          return "";
        }

        setSequenceGuide(suffix, bShown) { let me = this.icn3dui, ic = me.icn3d;
          let sequencesHtml = '';

          let index =(ic && ic.defNames2Atoms) ? Object.keys(ic.defNames2Atoms).length : 1;

          if(bShown) {
             sequencesHtml += me.htmlCls.divStr + "seqguide" + suffix + "'>";
         }
         else {
             sequencesHtml += '<div style="width:20px; margin-left:3px; display:inline-block;"><span id="' + me.pre + 'seqguide' + suffix + '_expand" class="ui-icon ui-icon-plus icn3d-expand icn3d-link" style="width:15px;" title="Expand"></span><span id="' + me.pre + 'seqguide' + suffix + '_shrink" class="ui-icon ui-icon-minus icn3d-shrink icn3d-link" style="display:none; width:15px;" title="Shrink"></span></div> ';

             sequencesHtml += "<div style='min-width:200px; display:inline-block;'><b>Selection:</b> Name: " + me.htmlCls.inputTextStr + "id='" + me.pre + "seq_command_name" + suffix + "' value='seq_" + index + "' size='5'> " + me.htmlCls.space2 + "<button style='white-space:nowrap;' id='" + me.pre + "seq_saveselection" + suffix + "'>Save</button> <button style='white-space:nowrap; margin-left:20px;' id='" + me.pre + "seq_clearselection" + suffix + "'>Clear</button></div><br/>";

             sequencesHtml += me.htmlCls.divStr + "seqguide" + suffix + "' style='display:none; white-space:normal;' class='icn3d-box'>";
         }

          sequencesHtml += this.getSelectionHints();

          let resCategories = "<b>Residue labeling:</b> standard residue with coordinates: UPPER case letter; nonstandard residue with coordinates: the first UPPER case letter plus a period except that water residue uses the letter 'O'; residue missing coordinates: lower case letter.";
          let scroll =(me.utilsCls.isMac() && !me.utilsCls.isMobile()) ? "<br/><br/><b>Turn on scroll bar:</b> System preferences -> General -> show scroll bars -> check Always" : "";

          sequencesHtml += resCategories + scroll + "<br/></div>";

          return sequencesHtml;
        }

        setAlignSequenceGuide(suffix, bShown) { let me = this.icn3dui, ic = me.icn3d;
          let sequencesHtml = '';
          suffix = '';

          let index =(ic && ic.defNames2Atoms) ? Object.keys(ic.defNames2Atoms).length : 1;

          sequencesHtml += '<div style="width:20px; margin-left:3px; display:inline-block;"><span id="' + me.pre + 'alignseqguide' + suffix + '_expand" class="ui-icon ui-icon-plus icn3d-expand icn3d-link" style="width:15px;" title="Expand"></span><span id="' + me.pre + 'alignseqguide' + suffix + '_shrink" class="ui-icon ui-icon-minus icn3d-shrink icn3d-link" style="display:none; width:15px;" title="Shrink"></span></div> ';

          sequencesHtml += "<div style='min-width:200px; display:inline-block;'><b>Selection:</b> Name: " + me.htmlCls.inputTextStr + "id='" + me.pre + "alignseq_command_name' value='alseq_" + index + "' size='10'> " + me.htmlCls.space2 + "<button style='white-space:nowrap;' id='" + me.pre + "alignseq_saveselection'>Save</button> <button style='white-space:nowrap; margin-left:20px;' id='" + me.pre + "alignseq_clearselection'>Clear</button></div><br/>";

          sequencesHtml += "<div style='min-width:200px; display:inline-block; margin-top:3px'><b>Save Alignment</b>: " + "<button style='white-space:nowrap;' id='" + me.pre + "saveFasta'>FASTA</button> <button style='white-space:nowrap; margin-left:20px;' id='" + me.pre + "saveClustal'>CLUSTALW</button> <button style='white-space:nowrap; margin-left:20px;' id='" + me.pre + "saveResbyres'>Residue by Residue</button></div><br/>";

          sequencesHtml += me.htmlCls.divStr + "alignseqguide" + suffix + "' style='display:none; white-space:normal;' class='icn3d-box'>";

          sequencesHtml += this.getSelectionHints();

          let resCategories = "<b>Residue labeling:</b> aligned residue with coordinates: UPPER case letter; non-aligned residue with coordinates: lower case letter which can be highlighted; residue missing coordinates: lower case letter which can NOT be highlighted.";
          let scroll =(me.utilsCls.isMac() && !me.utilsCls.isMobile()) ? "<br/><br/><b>Turn on scroll bar:</b> System preferences -> General -> show scroll bars -> check Always" : "";

          sequencesHtml += resCategories + scroll + "<br/>";

          sequencesHtml += "</div>";

          return sequencesHtml;
        }

        getSelectionHints() { let me = this.icn3dui; me.icn3d;
          let sequencesHtml = '';

          if(!me.utilsCls.isMobile()) {
              sequencesHtml += "<b>Select on 1D sequences:</b> drag to select, drag again to deselect, multiple selection is allowed without Ctrl key, click \"Save Selection\" to save the current selection.<br/><br/>";

              sequencesHtml += "<b>Select on 2D interaction diagram:</b> click on the nodes or lines. The nodes are chains and can be united with the Ctrl key. The lines are interactions and can NOT be united. Each click on the lines selects half of the lines, i.e., select the interacting residues in one of the two chains.<br/><br/>";

              let tmpStr = me.utilsCls.isMobile() ? 'use finger to pick' : 'hold "Alt" and use mouse to pick';
              sequencesHtml += "<b>Select on 3D structures:</b> " + tmpStr + ", click the second time to deselect, hold \"Ctrl\" to union selection, hold \"Shift\" to select a range, press the up/down arrow to switch among atom/residue/strand/chain/structure, click \"Save Selection\" to save the current selection.<br/><br/>";

              sequencesHtml += "<b>Save the current selection</b>(either on 3D structure, 2D interactions, or 1D sequence): open the menu \"Select -> Save Selection\", specify the name and description for the selection, and click \"Save\".<br/><br/>";
          }
          else {
                sequencesHtml += "<b>Select Aligned Sequences:</b> touch to select, touch again to deselect, multiple selection is allowed without Ctrl key, click \"Save Selection\" to save the current selection.<br/>";
          }

          return sequencesHtml;
        }

        addGsizeSalt(name) { let me = this.icn3dui; me.icn3d;
            let html = "";

            html += "<span style='white-space:nowrap;font-weight:bold;'>Grid Size: <select id='" + me.pre + name + "gsize'>";

            let optArray1c = ['65', '97', '129'];
            html += this.getOptionHtml(optArray1c, 0);

            html += "</select></span>";

            html += "<span style='white-space:nowrap;font-weight:bold;margin-left:30px;'>Salt Concentration: <select id='" + me.pre + name + "salt'>";

            let optArray1d = ['0', '0.15'];
            html += this.getOptionHtml(optArray1d, 1);

            html += "</select> M</span><br/>";

            return html;
        }

        getFootHtml(type, tabName) { let me = this.icn3dui; me.icn3d;
            let footHtml = "<div style='width:500px;'>";

            if(type == 'delphi') {
                if(me.cfg.cid) {
                    footHtml += "<b>Note</b>: Partial charges(MMFF94) are from PubChem Compound SDF files.<br/><br/>";
                }
                else {
                    footHtml += "<b>Note</b>: Only the selected residues are used for <a href='http://honig.c2b2.columbia.edu/delphi'>DelPhi</a> potential calculation by solving linear Poisson-Boltzmann equation.";

                    footHtml += '<div style="width:20px; margin-top:6px; display:inline-block;"><span id="'
                      + me.pre + tabName + '_expand" class="ui-icon ui-icon-plus icn3d-expand icn3d-link" style="width:15px;" title="Expand"></span><span id="'
                      + me.pre + tabName + '_shrink" class="ui-icon ui-icon-minus icn3d-shrink icn3d-link" style="display:none; width:15px;" title="Shrink"></span></div><br>';
                    footHtml += me.htmlCls.divStr + tabName + "' style='display:none;'>";

                    footHtml += "<br>The hydrogens and partial charges of proteins and nucleotides are added using <a href='http://compbio.clemson.edu/pka_webserver'>DelPhiPKa</a> with the Amber charge and size files. The hydrogens of ligands are added using <a href='http://openbabel.org/wiki/Main_Page'>Open Babel</a>. The partial charges of ligands are calculated using <a href='http://ambermd.org/antechamber/ac.html'>Antechamber</a> with the Gasteiger charge method. All partial charges are calculated at pH 7.<br/><br/>";

                    footHtml += "Lipids are treated as ligands. Please use \"HETATM\" instead of \"ATOM  \" for each lipid atom in your PDB file. Each phosphate in lipids is assigned with a charge of -1. You can download PQR and modify it, or prepare your PQR file using other tools. Then load the PQR file at the menu \"Analysis > Load PQR/Potential\".<br/><br/>";

                    footHtml += "</div>";
                }
            }
            else {
                footHtml += "<b>Note</b>: Always load a PDB file before loading a PQR or DelPhi potential file.";

                footHtml += '<div style="width:20px; margin-top:6px; display:inline-block;"><span id="'
                  + me.pre + tabName + '_expand" class="ui-icon ui-icon-plus icn3d-expand icn3d-link" style="width:15px;" title="Expand"></span><span id="'
                  + me.pre + tabName + '_shrink" class="ui-icon ui-icon-minus icn3d-shrink icn3d-link" style="display:none; width:15px;" title="Shrink"></span></div><br>';
                footHtml += me.htmlCls.divStr + tabName + "' style='display:none;'>";

                footHtml += "The PDB file can be loaded in the URL with \"pdbid=\" or at \"File > Open File\". The PQR file can be prepared at the menu \"Analysis > Download PQR\" with your modification or using other tools. The DelPhi potential file can be calculated at <a href='http://compbio.clemson.edu/sapp/delphi_webserver/'>DelPhi Web Server</a> and be exported as a Cube file. ";

                if(type == 'url') footHtml += "The PQR or potential file can be accessed in a URL if it is located in the same host as iCn3D.";

                footHtml += "<br/><br/>";

                footHtml += "</div>";
            }
            footHtml += "</div>";

            return footHtml;
        }

        getPotentialHtml(type, dialogClass) { let me = this.icn3dui; me.icn3d;
            let html = '';

            let name0, name1, name2;
            let tab1, tab2;
            tab1 = 'Equipotential Map';
            tab2 = 'Surface with Potential';
            //tab3 = 'Download PQR';

            if(type == 'delphi') {
                name1 = 'delphi';
            }
            else if(type == 'local') {
                name0 = 'pqr';
                name1 = 'phi';
                name2 = 'cube';
            }
            else if(type == 'url') {
                name0 = 'pqrurl';
                name1 = 'phiurl';
                name2 = 'cubeurl';
            }

            html += me.htmlCls.divStr + "dl_" + name1 + "' class='" + dialogClass + "'>";
            html += me.htmlCls.setDialogCls.addNotebookTitle("dl_" + name1, 'DelPhi Potential');
            
            html += me.htmlCls.divStr + "dl_" + name1 + "_tabs' style='border:0px;'>";
            html += "<ul>";
            html += "<li><a href='#" + me.pre + name1 + "tab1'>" + tab1 + "</a></li>";
            html += "<li><a href='#" + me.pre + name1 + "tab2'>" + tab2 + "</a></li>";
            //html += "<li><a href='#" + me.pre + name1 + "tab3'>" + tab3 + "</a></li>";
            html += "</ul>";

            html += me.htmlCls.divStr + name1 + "tab1'>";
            if(type == 'delphi') html += this.addGsizeSalt(name1 + "1") + "<br>";

            html += "<span style='white-space:nowrap;font-weight:bold;'>Potential contour at: <select id='" + me.pre + name1 + "contour'>";

            let optArray1b = ['0.5', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10'];
            html += this.getOptionHtml(optArray1b, 2);

            html += "</select> kT/e(25.6mV at 298K)</span><br/><br/>";

            let htmlTmp;

            // tab1: equipotential map
            if(type == 'delphi') {
                html += me.htmlCls.buttonStr + "reload_" + name1 + "file' style='margin-top: 6px;'>Equipotential Map</button>";
                html += me.htmlCls.buttonStr + name1 + "mapNo' style='margin-left:30px;'>Remove Map</button><br>";
            }
            else if(type == 'local') {
                html += me.htmlCls.divStr + name1 + "tab1_tabs' style='border:0px;'>";
                html += "<ul>";
                html += "<li><a href='#" + me.pre + name1 + "tab1_" + name0 + "'>PQR</a></li>";
                html += "<li><a href='#" + me.pre + name1 + "tab1_" + name1 + "'>Phi</a></li>";
                html += "<li><a href='#" + me.pre + name1 + "tab1_" + name2 + "'>Cube</a></li>";
                html += "</ul>";

                htmlTmp = "<span style='margin-left:30px'>" + me.htmlCls.buttonStr + name1 + "mapNo'>Remove Map</button></span></div>";

                html += me.htmlCls.divStr + name1 + "tab1_" + name0 + "'>";
                html += this.addGsizeSalt(name0) + "<br>";
                html += "<b>PQR File</b>: " + me.htmlCls.inputFileStr + "id='" + me.pre + name0 + "file'> <br><br>" + me.htmlCls.buttonStr + "reload_" + name0 + "file' style='margin-top: 6px;'>Equipotential Map</button>" + htmlTmp;

                html += me.htmlCls.divStr + name1 + "tab1_" + name1 + "'>";
                html += "<b>Phi File</b>: " + me.htmlCls.inputFileStr + "id='" + me.pre + name1 + "file'> <br><br>" + me.htmlCls.buttonStr + "reload_" + name1 + "file' style='margin-top: 6px;'>Equipotential Map</button>" + htmlTmp;

                html += me.htmlCls.divStr + name1 + "tab1_" + name2 + "'>";
                html += "<b>Cube File</b>: " + me.htmlCls.inputFileStr + "id='" + me.pre + name2 + "file'> <br><br>" + me.htmlCls.buttonStr + "reload_" + name2 + "file' style='margin-top: 6px;'>Equipotential Map</button>" + htmlTmp;

                html += "</div>";
            }
            else if(type == 'url') {
                html += me.htmlCls.divStr + name1 + "tab1_tabs' style='border:0px;'>";
                html += "<ul>";
                html += "<li><a href='#" + me.pre + name1 + "tab1_" + name0 + "2'>PQR</a></li>";
                html += "<li><a href='#" + me.pre + name1 + "tab1_" + name1 + "2'>Phi</a></li>";
                html += "<li><a href='#" + me.pre + name1 + "tab1_" + name2 + "2'>Cube</a></li>";
                html += "</ul>";

                htmlTmp = "<span style='margin-left:30px'>" + me.htmlCls.buttonStr + name1 + "mapNo'>Remove Map</button></span></div>";

                html += me.htmlCls.divStr + name1 + "tab1_" + name0 + "2'>";
                html += this.addGsizeSalt(name0) + "<br>";
                html += "<b>PQR URL</b> in the same host: " + me.htmlCls.inputTextStr + "id='" + me.pre + name0 + "file'> <br><br>" + me.htmlCls.buttonStr + "reload_" + name0 + "file' style='margin-top: 6px;'>Equipotential Map</button>" + htmlTmp;

                html += me.htmlCls.divStr + name1 + "tab1_" + name1 + "2'>";
                html += "<b>Phi URL</b> in the same host: " + me.htmlCls.inputTextStr + "id='" + me.pre + name1 + "file'> <br><br>" + me.htmlCls.buttonStr + "reload_" + name1 + "file' style='margin-top: 6px;'>Equipotential Map</button>" + htmlTmp;

                html += me.htmlCls.divStr + name1 + "tab1_" + name2 + "2'>";
                html += "<b>Cube URL</b> in the same host: " + me.htmlCls.inputTextStr + "id='" + me.pre + name2 + "file'> <br><br>" + me.htmlCls.buttonStr + "reload_" + name2 + "file' style='margin-top: 6px;'>Equipotential Map</button>" + htmlTmp;

                html += "</div>";
            }

            html += "<br>" + this.getFootHtml(type, name1 + "tab1_foot");
            html += "</div>";

            html += me.htmlCls.divStr + name1 + "tab2'>";
            if(type == 'delphi') html += this.addGsizeSalt(name1 + "2") + "<br>";

            html += "<span style='white-space:nowrap;font-weight:bold;'>Surface with max potential at: <select id='" + me.pre + name1 + "contour2'>";

            let optArray1c = ['0.5', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10'];
            html += this.getOptionHtml(optArray1c, 2);

            html += "</select> kT/e(25.6mV at 298K)</span><br/><br/>";

            html += "<b>Surface</b>: <select id='" + me.pre + name1 + "surftype'>";
            html += "<option value='21'>Van der Waals</option>";
            html += "<option value='22' selected>Molecular Surface</option>";
            html += "<option value='23'>Solvent Accessible</option>";
            html += "</select>";

            html += "<span style='margin-left:20px'><b>Opacity</b>: <select id='" + me.pre + name1 + "surfop'>";
            let surfOp = ['1.0', '0.9', '0.8', '0.7', '0.6', '0.5', '0.4', '0.3', '0.2', '0.1'];
            html += this.getOptionHtml(surfOp, 0);
            html += "</select></span>";

            html += "<span style='margin-left:20px'><b>Wireframe</b>: <select id='" + me.pre + name1 + "surfwf'>";
            html += "<option value='yes'>Yes</option>";
            html += "<option value='no' selected>No</option>";
            html += "</select></span><br/>";

            html += "<br/>";

            // tab2: surface with potential
            if(type == 'delphi') {
                html += me.htmlCls.buttonStr + "reload_" + name1 + "file2' style='margin-top: 6px;'>Surface with Potential</button>";
                html += me.htmlCls.buttonStr + name1 + "mapNo2' style='margin-left:30px;'>Remove Surface</button><br>";
            }
            else if(type == 'local') {
                html += me.htmlCls.divStr + name1 + "tab2_tabs' style='border:0px;'>";
                html += "<ul>";
                html += "<li><a href='#" + me.pre + name1 + "tab2_" + name0 + "'>PQR</a></li>";
                html += "<li><a href='#" + me.pre + name1 + "tab2_" + name1 + "'>Phi</a></li>";
                html += "<li><a href='#" + me.pre + name1 + "tab2_" + name2 + "'>Cube</a></li>";
                html += "</ul>";

                htmlTmp = "<span style='margin-left:30px'>" + me.htmlCls.buttonStr + name1 + "mapNo2'>Remove Surface</button></span></div>";

                html += me.htmlCls.divStr + name1 + "tab2_" + name0 + "'>";
                html += this.addGsizeSalt(name0 + "2") + "<br>";
                html += "<b>PQR File</b>: " + me.htmlCls.inputFileStr + "id='" + me.pre + name0 + "file2'> <br><br>" + me.htmlCls.buttonStr + "reload_" + name0 + "file2' style='margin-top: 6px;'>Surface with Potential</button>" + htmlTmp;

                html += me.htmlCls.divStr + name1 + "tab2_" + name1 + "'>";
                html += "<b>Phi File</b>: " + me.htmlCls.inputFileStr + "id='" + me.pre + name1 + "file2'> <br><br>" + me.htmlCls.buttonStr + "reload_" + name1 + "file2' style='margin-top: 6px;'>Surface with Potential</button>" + htmlTmp;

                html += me.htmlCls.divStr + name1 + "tab2_" + name2 + "'>";
                html += "<b>Cube File</b>: " + me.htmlCls.inputFileStr + "id='" + me.pre + name2 + "file2'> <br><br>" + me.htmlCls.buttonStr + "reload_" + name2 + "file2' style='margin-top: 6px;'>Surface with Potential</button>" + htmlTmp;

                html += "</div>";
            }
            else if(type == 'url') {
                html += me.htmlCls.divStr + name1 + "tab2_tabs' style='border:0px;'>";
                html += "<ul>";
                html += "<li><a href='#" + me.pre + name1 + "tab2_" + name0 + "2'>PQR</a></li>";
                html += "<li><a href='#" + me.pre + name1 + "tab2_" + name1 + "2'>Phi</a></li>";
                html += "<li><a href='#" + me.pre + name1 + "tab2_" + name2 + "2'>Cube</a></li>";
                html += "</ul>";

                htmlTmp = "<span style='margin-left:30px'>" + me.htmlCls.buttonStr + name1 + "mapNo2'>Remove Surface</button></span></div>";

                html += me.htmlCls.divStr + name1 + "tab2_" + name0 + "2'>";
                html += this.addGsizeSalt(name0 + "2") + "<br>";
                html += "<b>PQR URL</b> in the same host: " + me.htmlCls.inputTextStr + "id='" + me.pre + name0 + "file2'> <br><br>" + me.htmlCls.buttonStr + "reload_" + name0 + "file2' style='margin-top: 6px;'>Surface with Potential</button>" + htmlTmp;

                html += me.htmlCls.divStr + name1 + "tab2_" + name1 + "2'>";
                html += "<b>Phi URL</b> in the same host: " + me.htmlCls.inputTextStr + "id='" + me.pre + name1 + "file2'> <br><br>" + me.htmlCls.buttonStr + "reload_" + name1 + "file2' style='margin-top: 6px;'>Surface with Potential</button>" + htmlTmp;

                html += me.htmlCls.divStr + name1 + "tab2_" + name2 + "2'>";
                html += "<b>Cube URL</b> in the same host: " + me.htmlCls.inputTextStr + "id='" + me.pre + name2 + "file2'> <br><br>" + me.htmlCls.buttonStr + "reload_" + name2 + "file2' style='margin-top: 6px;'>Surface with Potential</button>" + htmlTmp;

                html += "</div>";
            }

            html += "<br>" + this.getFootHtml(type, name1 + "tab2_foot");
            html += "</div>";

            html += "</div>";
            html += "</div>";

            return html;
        }

        async exportPqr(bPdb) { let me = this.icn3dui, ic = me.icn3d;
           let ionHash = {};
           let atomHash = {};

           let atoms = me.hashUtilsCls.intHash(ic.dAtoms, ic.hAtoms);
           for(let i in atoms) {
               ic.atoms[i];

               if(ic.ions.hasOwnProperty(i)) {
                 ionHash[i] = 1;
               }
               else {
                 atomHash[i] = 1;
               }
           }

           let fileExt = (bPdb) ? 'pdb' : 'pqr';
           if(me.cfg.cid) {
              let pqrStr = '';
              
              let bPqr = (bPdb) ? false : true;
              pqrStr += ic.saveFileCls.getAtomPDB(atomHash, bPqr) + ic.saveFileCls.getAtomPDB(ionHash, bPqr);

              let file_pref = Object.keys(me.utilsCls.getHlStructures()).join(',');
              ic.saveFileCls.saveFile(file_pref + '_icn3d.' + fileExt, 'text', [pqrStr]);
           }
           else {
                let bCalphaOnly = me.utilsCls.isCalphaPhosOnly(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms));
                if(bCalphaOnly) {
                    alert("The potential will not be shown because the side chains are missing in the structure...");
                    return;
                }

                let pdbstr = '';

                let bMergeIntoOne = true, bOneLetterChain = true;
                pdbstr +=(me.cfg.cid) ? ic.saveFileCls.getAtomPDB(atomHash, true, undefined, undefined, undefined, undefined, bMergeIntoOne, bOneLetterChain) : ic.saveFileCls.getAtomPDB(atomHash, undefined, undefined, undefined, undefined, undefined, bMergeIntoOne, bOneLetterChain);
                pdbstr += ic.saveFileCls.getAtomPDB(ionHash, true, undefined, true, undefined, undefined, bMergeIntoOne, bOneLetterChain);

                let url = me.htmlCls.baseUrl + "delphi/delphi.cgi";

                let pdbid =(me.cfg.cid) ? me.cfg.cid : Object.keys(ic.structures).toString();

                let dataObj = {'pdb2pqr': pdbstr, 'pdbid': pdbid};
                let data = await me.getAjaxPostPromise(url, dataObj, true, undefined, undefined, true, 'text');

                let pqrStr = data;

                if(bPdb) {
                let lineArray = pqrStr.split('\n');

                let pdbStr = '';
                for(let i = 0, il = lineArray.length; i < il; ++i) {
                    let line = lineArray[i];
                    if(line.substr(0, 6) == 'ATOM  ' || line.substr(0, 6) == 'HETATM') {
                        let atomName = line.substr(12, 4).trim();
                        let elem;
                        if(line.substr(0, 6) == 'ATOM  ') {
                            elem = atomName.substr(0, 1);
                        }
                        else {
                            let twochar = atomName.substr(0, 2);
                            if(me.parasCls.vdwRadii.hasOwnProperty(twochar)) {
                                elem = twochar;
                            }
                            else {
                                elem = atomName.substr(0, 1);
                            }
                        }

                        pdbStr += line.substr(0, 54) + '                      ' + elem.padStart(2, ' ') + '\n';
                    }
                    else {
                        pdbStr += line + '\n';
                    }
                }

                pqrStr = pdbStr;
                }

                let file_pref = Object.keys(me.utilsCls.getHlStructures()).join(',');
                ic.saveFileCls.saveFile(file_pref + '_icn3d_residues.' + fileExt, 'text', [pqrStr]);
            }
        }

        clickReload_pngimage() { let me = this.icn3dui; me.icn3d;
            if(me.bNode) return;

            let thisClass = this;
            me.myEventCls.onIds("#" + me.pre + "reload_pngimage", "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();
               if(!me.cfg.notebook) dialog.dialog( "close" );
               //close all dialog
               if(!me.cfg.notebook) {
                   $(".ui-dialog-content").dialog("close");
               }
               else {
                   ic.resizeCanvasCls.closeDialogs();
               }

            //    ic.init();
               let files = $("#" + me.pre + "pngimage")[0].files;
               if(!files[0]) {
                 alert("Please select a file before clicking 'Load'");
               }
               else {
                 thisClass.fileSupport();

                 let bAppend = true;
                 let bmmCIF = false;
                 let bPng = true;
                 await me.htmlCls.eventsCls.readFile(bAppend, files, 0, '', bmmCIF, bPng);
               }
            });
        }

        async loadPng(imageStr, command, bRender) { let me = this.icn3dui, ic = me.icn3d;
        // async loadPng(imageStr) { let me = this.icn3dui, ic = me.icn3d;
           let matchedStr = 'Share Link: ';
           let pos = imageStr.indexOf(matchedStr);
           let matchedStrState = "Start of state file======\n";
           let posState = imageStr.indexOf(matchedStrState);

           let data = '', statefile = '';

           if(pos == -1 && posState == -1) {
               alert('Please load a PNG image saved by clicking the menu "File > Save File > iCn3D PNG Image"...');
           }
           else if(pos != -1) {
               let url = imageStr.substr(pos + matchedStr.length);
               me.htmlCls.clickMenuCls.setLogCmd('load iCn3D PNG image ' + $("#" + me.pre + "pngimage").val(), false);
               window.open(url, '_self');
           }
           else if(posState != -1) {
               let matchedStrData = "Start of data file======\n";
               let posData = imageStr.indexOf(matchedStrData);
               ic.bInputfile =(posData == -1) ? false : true;
               ic.bInputPNGWithData = ic.bInputfile;
               let commandStr = (command) ? command.replace(/;/g, "\n") : '';
            //    let commandStr = '';

            //    let statefile;
            //    if(ic.bInputfile) {
                   let posDataEnd = imageStr.indexOf("End of data file======\n");
                   data = imageStr.substr(posData + matchedStrData.length, posDataEnd - posData - matchedStrData.length);
                //    ic.InputfileData = (ic.InputfileData) ? ic.InputfileData + '\nENDMDL\n' + data : data;

                   let matchedStrType = "Start of type file======\n";
                   let posType = imageStr.indexOf(matchedStrType);
                   let posTypeEnd = imageStr.indexOf("End of type file======\n");
                   let type = imageStr.substr(posType + matchedStrType.length, posTypeEnd - posType - matchedStrType.length - 1); // remove the new line char
                   ic.InputfileType = type;

                   //var matchedStrState = "Start of state file======\n";
                   //var posState = imageStr.indexOf(matchedStrState);
                   let posStateEnd = imageStr.indexOf("End of state file======\n");
                   statefile = imageStr.substr(posState + matchedStrState.length, posStateEnd - posState- matchedStrState.length);
                   //statefile = decodeURIComponent(statefile);
                   statefile = decodeURIComponent(statefile + "\n" + commandStr);

                   if(bRender) {
                        if(type === 'pdb') {
                            await ic.pdbParserCls.loadPdbData(data);

                            ic.commands = [];
                            ic.optsHistory = [];
                            //await ic.loadScriptCls.loadScript(statefile, true);
                        }
                        else {
                            if(type === 'mol2') {
                                await ic.mol2ParserCls.loadMol2Data(data);
                            }
                            else if(type === 'sdf') {
                                await ic.sdfParserCls.loadSdfData(data);
                            }
                            else if(type === 'xyz') {
                                await ic.xyzParserCls.loadXyzData(data);
                            }
                            else if(type === 'mmcif') {
                                await ic.mmcifParserCls.loadMmcifData(data);
                            }
                            ic.commands = [];
                            ic.optsHistory = [];
                            //await ic.loadScriptCls.loadScript(statefile, true);
                        }

                        await ic.loadScriptCls.loadScript(statefile, true);

                        // me.htmlCls.clickMenuCls.setLogCmd('load iCn3D PNG image ' + $("#" + me.pre + "pngimage").val(), false);
                    }
    /*                   
               }
               else { // url length > 4000
                   //var matchedStrState = "Start of state file======\n";
                   //var posState = imageStr.indexOf(matchedStrState);
                   let posStateEnd = imageStr.indexOf("End of state file======\n");
                   statefile = imageStr.substr(posState + matchedStrState.length, posStateEnd - posState- matchedStrState.length);
                   //statefile = decodeURIComponent(statefile);
                   statefile = decodeURIComponent(statefile + "\n" + commandStr);

                   ic.commands = [];
                   ic.optsHistory = [];
                   //await  ic.loadScriptCls.loadScript(statefile, true);
               }

                await ic.loadScriptCls.loadScript(statefile, true);

               me.htmlCls.clickMenuCls.setLogCmd('load iCn3D PNG image ' + $("#" + me.pre + "pngimage").val(), false);
    */
           }

           return {'pdb': data, 'statefile': statefile};
        }

        fileSupport() {
             if(!window.File || !window.FileReader || !window.FileList || !window.Blob) {
                alert('The File APIs are not fully supported in this browser.');
             }
        }

        getLinkColor() {
            let graphStr2 = '';
            graphStr2 += ', linkmap: {\n';
            graphStr2 += '3: {"type": "peptidebond", "c":""},\n';
            graphStr2 += '4: {"type": "ssbond", "c":"FFA500"},\n';
            graphStr2 += '5: {"type": "ionic", "c":"0FF"},\n';
            graphStr2 += '6: {"type": "ionicInside", "c":"FFF"},\n';
            graphStr2 += '11: {"type": "contact", "c":"888"},\n';
            graphStr2 += '12: {"type": "contactInside", "c":"FFF"},\n';
            graphStr2 += '13: {"type": "hbond", "c":"0F0"},\n';
            graphStr2 += '14: {"type": "hbondInside", "c":"FFF"},\n';
            graphStr2 += '15: {"type": "clbond", "c":"006400"},\n';
            graphStr2 += '17: {"type": "halogen", "c":"F0F"},\n';
            graphStr2 += '18: {"type": "halogenInside", "c":"FFF"},\n';
            graphStr2 += '19: {"type": "pication", "c":"F00"},\n';
            graphStr2 += '20: {"type": "picationInside", "c":"FFF"},\n';
            graphStr2 += '21: {"type": "pistacking", "c":"00F"},\n';
            graphStr2 += '22: {"type": "pistackingInside", "c":"FFF"}\n';
            graphStr2 += '}}\n';

            return graphStr2;
        }

        setCookieForThickness() { let me = this.icn3dui, ic = me.icn3d;
            if(!me.bNode) { // && postfix == 'style') {
                let exdays = 3650; // 10 years

                this.setCookie('lineRadius', ic.lineRadius, exdays);
                this.setCookie('coilWidth', ic.coilWidth, exdays);
                this.setCookie('cylinderRadius', ic.cylinderRadius, exdays);
                this.setCookie('crosslinkRadius', ic.crosslinkRadius, exdays);
                this.setCookie('traceRadius', ic.traceRadius, exdays);
                this.setCookie('dotSphereScale', ic.dotSphereScale, exdays);
                this.setCookie('ribbonthickness', ic.ribbonthickness, exdays);
                this.setCookie('helixSheetWidth', ic.helixSheetWidth, exdays);
                this.setCookie('nucleicAcidWidth', ic.nucleicAcidWidth, exdays);
            }
        }

        setLineThickness(postfix, bReset) { let me = this.icn3dui, ic = me.icn3d;
            ic.bSetThickness = true;

            if(postfix == 'style') {
                if(bReset) {
                    $("#" + me.pre + "shininess").val('40');
                    $("#" + me.pre + "light1").val('0.8');
                    $("#" + me.pre + "light2").val('0.4');
                    $("#" + me.pre + "light3").val('0.2');
                    $("#" + me.pre + "glycan").val('0');
                    $("#" + me.pre + "membrane").val('1');
                    $("#" + me.pre + "cmdwindow").val('0');
                }

                ic.shininess = parseFloat($("#" + me.pre + "shininess").val()); //40;
                ic.light1 = parseFloat($("#" + me.pre + "light1").val()); //0.6;
                ic.light2 = parseFloat($("#" + me.pre + "light2").val()); //0.4;
                ic.light3 = parseFloat($("#" + me.pre + "light3").val()); //0.2;
                ic.bGlycansCartoon = parseInt($("#" + me.pre + "glycan").val()); //0;
                ic.bMembrane = parseInt($("#" + me.pre + "membrane").val()); //1;
                ic.bCmdWindow = parseInt($("#" + me.pre + "cmdwindow").val()); //0;
            }

            if(bReset) {
                $("#" + me.pre + "linerad_" + postfix ).val(0.1); //0.1; // hbonds, distance lines
                $("#" + me.pre + "coilrad_" + postfix ).val(0.3); //0.3; // style cartoon-coil
                $("#" + me.pre + "stickrad_" + postfix ).val(0.4); //0.4; // style stick
                $("#" + me.pre + "crosslinkrad_" + postfix ).val(0.4); //0.4; // cross-linkage
                $("#" + me.pre + "tracerad_" + postfix ).val(0.4); //0.4; // style c alpha trace, nucleotide stick
                $("#" + me.pre + "ballscale_" + postfix ).val(0.3); //0.3; // style ball and stick, dot
                $("#" + me.pre + "ribbonthick_" + postfix ).val(0.2); //0.2; // style ribbon, nucleotide cartoon, stand thickness
                $("#" + me.pre + "prtribbonwidth_" + postfix ).val(1.3); //1.3; // style ribbon, stand thickness
                $("#" + me.pre + "nucleotideribbonwidth_" + postfix ).val(0.8); //0.8; // nucleotide cartoon
            }

            ic.lineRadius = parseFloat($("#" + me.pre + "linerad_" + postfix ).val()); //0.1; // hbonds, distance lines
            ic.coilWidth = parseFloat($("#" + me.pre + "coilrad_" + postfix ).val()); //0.4; // style cartoon-coil
            ic.cylinderRadius = parseFloat($("#" + me.pre + "stickrad_" + postfix ).val()); //0.4; // style stick
            ic.crosslinkRadius = parseFloat($("#" + me.pre + "crosslinkrad_" + postfix ).val()); //0.4; // cross-linkage
            ic.traceRadius = parseFloat($("#" + me.pre + "tracerad_" + postfix ).val()); //0.4; // style c alpha trace, nucleotide stick
            ic.dotSphereScale = parseFloat($("#" + me.pre + "ballscale_" + postfix ).val()); //0.3; // style ball and stick, dot
            ic.ribbonthickness = parseFloat($("#" + me.pre + "ribbonthick_" + postfix ).val()); //0.4; // style ribbon, nucleotide cartoon, stand thickness
            ic.helixSheetWidth = parseFloat($("#" + me.pre + "prtribbonwidth_" + postfix ).val()); //1.3; // style ribbon, stand thickness
            ic.nucleicAcidWidth = parseFloat($("#" + me.pre + "nucleotideribbonwidth_" + postfix ).val()); //0.8; // nucleotide cartoon

            // save to cache
            if(!me.bNode) { // && postfix == 'style') {
                let exdays = 3650; // 10 years
                this.setCookie('shininess', ic.shininess, exdays);
                this.setCookie('light1', ic.light1, exdays);
                this.setCookie('light2', ic.light2, exdays);
                this.setCookie('light3', ic.light3, exdays);
                this.setCookie('glycan', ic.bGlycansCartoon, exdays);
                this.setCookie('membrane', ic.bMembrane, exdays);
                this.setCookie('cmdwindow', ic.bCmdWindow, exdays);
            }

            this.setCookieForThickness();

            if(postfix = bReset) {
               let select = "reset thickness";
               me.htmlCls.clickMenuCls.setLogCmd(select, true);
               ic.bSetThickness = false;
               ic.threeDPrintCls.resetAfter3Dprint();
            }
            else {
                me.htmlCls.clickMenuCls.setLogCmd('set thickness | linerad ' + ic.lineRadius + ' | coilrad ' + ic.coilWidth + ' | stickrad ' + ic.cylinderRadius + ' | crosslinkrad ' + ic.crosslinkRadius + ' | tracerad ' + ic.traceRadius + ' | ribbonthick ' + ic.ribbonthickness + ' | proteinwidth ' + ic.helixSheetWidth + ' | nucleotidewidth ' + ic.nucleicAcidWidth  + ' | ballscale ' + ic.dotSphereScale, true);

                me.htmlCls.clickMenuCls.setLogCmd('set glycan ' + ic.bGlycansCartoon, true);
                me.htmlCls.clickMenuCls.setLogCmd('set membrane ' + ic.bMembrane, true);
                me.htmlCls.clickMenuCls.setLogCmd('set cmdwindow ' + ic.bCmdWindow, true);
            }

            ic.drawCls.draw();
        }

        setCookie(cname, cvalue, exdays) {
          let d = new Date();
          d.setTime(d.getTime() + (exdays*24*60*60*1000));
          let expires = "expires="+ d.toUTCString();
          document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
        }

        updateSurfPara(type) { let me = this.icn3dui, ic = me.icn3d;
           ic.phisurftype = $("#" + me.pre + type + "surftype").val();
           ic.phisurfop = $("#" + me.pre + type + "surfop").val();
           ic.phisurfwf = $("#" + me.pre + type + "surfwf").val();
        }

        exportPdb() { let me = this.icn3dui, ic = me.icn3d;
            let pdbStr = '';
        ///       pdbStr += ic.saveFileCls.getPDBHeader();
            let atoms = me.hashUtilsCls.intHash(ic.dAtoms, ic.hAtoms);
            pdbStr += ic.saveFileCls.getAtomPDB(atoms);

            if(!me.bNode) {
                let file_pref = Object.keys(me.utilsCls.getHlStructures()).join(',');
                ic.saveFileCls.saveFile(file_pref + '_icn3d.pdb', 'text', [pdbStr]);
            }
            
            return pdbStr;
        }

        exportSecondary() { let me = this.icn3dui, ic = me.icn3d;
            let secondaryStr = '';
            let atoms = me.hashUtilsCls.intHash(ic.dAtoms, ic.hAtoms);
            secondaryStr += ic.saveFileCls.getSecondary(atoms);

            if(!me.bNode) {
                let file_pref = Object.keys(me.utilsCls.getHlStructures()).join(',');
                ic.saveFileCls.saveFile(file_pref + '_icn3d_ss.txt', 'text', [secondaryStr]);
            }
            
            return secondaryStr;
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Html {
      constructor(icn3dui) { let me = icn3dui;
        this.icn3dui = icn3dui;

        this.cfg = this.icn3dui.cfg;

        this.opts = {};
        this.opts['background']         = 'black';        //transparent, black, grey, white

        this.allMenus = {};
        this.allMenusSel= {}; // Selectable menus
        this.simpleMenus = {};
        this.shownMenus = {};

        this.WIDTH = 400; // total width of view area
        this.HEIGHT = 400; // total height of view area
        this.RESIDUE_WIDTH = 10;  // sequences
        if(me.utilsCls.isMobile() || this.cfg.mobilemenu) {
            this.MENU_HEIGHT = 0;
        }
        else {
            this.MENU_HEIGHT = 40;
        }
        this.LOG_HEIGHT = 65; //65;

        // used to set the position for the log/command textarea
        this.MENU_WIDTH = 750;
        //The width (in px) that was left empty by the 3D viewer. The default is 20px.
        this.LESSWIDTH = 20;
        this.LESSWIDTH_RESIZE = 30; //20;
        //The height (in px) that was left empty by the 3D viewer. The default is 20px.
        this.LESSHEIGHT = 60; //20; // NCBI log is 40px high

        // size of 2D cartoons
        this.width2d = 200;

        this.CMD_HEIGHT = 0.8*this.LOG_HEIGHT;
        //this.EXTRAHEIGHT = 2*this.MENU_HEIGHT + this.CMD_HEIGHT;
        this.EXTRAHEIGHT = this.MENU_HEIGHT + this.CMD_HEIGHT;
        if(this.cfg.showmenu != undefined && this.cfg.showmenu == false) {
            //this.EXTRAHEIGHT -= 2*this.MENU_HEIGHT;
            this.EXTRAHEIGHT -= this.MENU_HEIGHT;
        }
        if(this.cfg.showcommand != undefined && this.cfg.showcommand == false) {
            this.EXTRAHEIGHT -= this.CMD_HEIGHT;
        }

        this.GREY8 = "#AAAAAA"; //"#888888"; // style protein grey
        this.GREYB = "#CCCCCC"; //"#BBBBBB";
        this.GREYC = "#DDDDDD"; //"#CCCCCC"; // grey background
        this.GREYD = "#EEEEEE"; //"#DDDDDD";
        this.ORANGE = "#FFA500";

        this.themecolor = 'blue';

        // used in graph
        this.defaultValue = 1;
        this.ssValue = 3;
        this.coilValue = 3;
        this.contactValue = 11;
        this.contactInsideValue = 12;
        this.hbondValue = 13;
        this.hbondInsideValue = 14;
        this.ssbondValue = 4;
        this.ionicValue = 5;
        this.ionicInsideValue = 6;
        this.clbondValue = 15;
        this.halogenValue = 17;
        this.halogenInsideValue = 18;
        this.picationValue = 19;
        this.picationInsideValue = 20;
        this.pistackingValue = 21;
        this.pistackingInsideValue = 22;
        this.contactColor = '888';
        this.contactInsideColor = 'FFF'; //'DDD';
        this.hbondColor = '0F0';
        this.hbondInsideColor = 'FFF'; //'AFA';
        this.ssbondColor = 'FFA500';
        this.ionicColor = '0FF';
        this.ionicInsideColor = 'FFF'; //'8FF';
        this.clbondColor = '006400';
        this.halogenColor = 'F0F';
        this.halogenInsideColor = 'FFF';
        this.picationColor = 'F00';
        this.picationInsideColor = 'FFF';
        this.pistackingColor = '00F';
        this.pistackingInsideColor = 'FFF';
        this.hideedges = 1;
        //this.pushcenter = 0;
        this.force = 4;
        this.simulation = undefined;

        //this.baseUrl = "https://www.ncbi.nlm.nih.gov/Structure/";
        this.baseUrl = (window && window.location && window.location.hostname == 'structure.ncbi.nlm.nih.gov') 
            ? "https://structure.ncbi.nlm.nih.gov/Structure/" : "https://www.ncbi.nlm.nih.gov/Structure/";

        this.tmalignUrl = this.baseUrl + "tmalign/tmalign.cgi";
        
        this.divStr = "<div id='" + this.icn3dui.pre;
        this.divNowrapStr = "<div style='white-space:nowrap'>";
        this.spanNowrapStr = "<span style='white-space:nowrap'>";
        this.inputTextStr = "<input type='text' ";
        this.inputFileStr = "<input type='file' ";
        this.inputRadioStr = "<input type='radio' ";
        this.inputCheckStr = "<input type='checkbox' ";
        this.optionStr = "<option value=";
        this.buttonStr = "<button id='" + this.icn3dui.pre;
        this.postfix = "2"; // add postfix for the structure of the query protein when align two chains in one protein
        this.space2 = "&nbsp;&nbsp;";
        this.space3 = this.space2 + "&nbsp;";
        this.space4 = this.space2 + this.space2;
        //this.wifiStr = '<i class="icn3d-wifi" title="requires internet">&nbsp;</i>';
        this.wifiStr = '';
        //this.licenseStr = '<i class="icn3d-license" title="requires license">&nbsp;</i>';
        this.licenseStr = '';
        this.closeAc = {collapsible: true, active: false}; // close accordion

        this.clickMenuCls = new ClickMenu(this.icn3dui);
        this.setMenuCls = new SetMenu(this.icn3dui);
        this.dialogCls = new Dialog(this.icn3dui);
        this.setDialogCls = new SetDialog(this.icn3dui);
        this.eventsCls = new Events(this.icn3dui);
        this.alignSeqCls = new AlignSeq(this.icn3dui);
        this.setHtmlCls = new SetHtml(this.icn3dui);
      }
    }

    /*
    import {
        AnimationClip,
        Bone,
        Box3,
        BufferAttribute,
        BufferGeometry,
        ClampToEdgeWrapping,
        Color,
        DirectionalLight,
        DoubleSide,
        FileLoader,
        FrontSide,
        Group,
        ImageBitmapLoader,
        InterleavedBuffer,
        InterleavedBufferAttribute,
        Interpolant,
        InterpolateDiscrete,
        InterpolateLinear,
        Line,
        LineBasicMaterial,
        LineLoop,
        LineSegments,
        LinearFilter,
        LinearMipmapLinearFilter,
        LinearMipmapNearestFilter,
        Loader,
        THREE.LoaderUtils,
        Material,
        MathUtils,
        Matrix4,
        Mesh,
        MeshBasicMaterial,
        MeshPhysicalMaterial,
        MeshStandardMaterial,
        MirroredRepeatWrapping,
        NearestFilter,
        NearestMipmapLinearFilter,
        NearestMipmapNearestFilter,
        NumberKeyframeTrack,
        Object3D,
        OrthographicCamera,
        PerspectiveCamera,
        PointLight,
        Points,
        PointsMaterial,
        PropertyBinding,
        Quaternion,
        QuaternionKeyframeTrack,
        RepeatWrapping,
        Skeleton,
        SkinnedMesh,
        Sphere,
        SpotLight,
        TangentSpaceNormalMap,
        Texture,
        TextureLoader,
        TriangleFanDrawMode,
        TriangleStripDrawMode,
        Vector2,
        Vector3,
        VectorKeyframeTrack,
        sRGBEncoding
    } from 'three';
    */

    class GLTFLoader extends THREE.Loader {

        constructor( manager ) {

            super( manager );

            this.dracoLoader = null;
            this.ktx2Loader = null;
            this.meshoptDecoder = null;

            this.pluginCallbacks = [];

            this.register( function ( parser ) {

                return new GLTFMaterialsClearcoatExtension( parser );

            } );

            this.register( function ( parser ) {

                return new GLTFTextureBasisUExtension( parser );

            } );

            this.register( function ( parser ) {

                return new GLTFTextureWebPExtension( parser );

            } );

            this.register( function ( parser ) {

                return new GLTFMaterialsSheenExtension( parser );

            } );

            this.register( function ( parser ) {

                return new GLTFMaterialsTransmissionExtension( parser );

            } );

            this.register( function ( parser ) {

                return new GLTFMaterialsVolumeExtension( parser );

            } );

            this.register( function ( parser ) {

                return new GLTFMaterialsIorExtension( parser );

            } );

            this.register( function ( parser ) {

                return new GLTFMaterialsSpecularExtension( parser );

            } );

            this.register( function ( parser ) {

                return new GLTFLightsExtension( parser );

            } );

            this.register( function ( parser ) {

                return new GLTFMeshoptCompression( parser );

            } );

        }

        load( url, onLoad, onProgress, onError ) {

            const scope = this;

            let resourcePath;

            if ( this.resourcePath !== '' ) {

                resourcePath = this.resourcePath;

            } else if ( this.path !== '' ) {

                resourcePath = this.path;

            } else {

                resourcePath = THREE.LoaderUtils.extractUrlBase( url );

            }

            // Tells the LoadingManager to track an extra item, which resolves after
            // the model is fully loaded. This means the count of items loaded will
            // be incorrect, but ensures manager.onLoad() does not fire early.
            this.manager.itemStart( url );

            const _onError = function ( e ) {

                if ( onError ) {

                    onError( e );

                } else {

                    console.error( e );

                }

                scope.manager.itemError( url );
                scope.manager.itemEnd( url );

            };

            const loader = new THREE.FileLoader( this.manager );

            loader.setPath( this.path );
            loader.setResponseType( 'arraybuffer' );
            loader.setRequestHeader( this.requestHeader );
            loader.setWithCredentials( this.withCredentials );

            loader.load( url, function ( data ) {

                try {

                    scope.parse( data, resourcePath, function ( gltf ) {

                        onLoad( gltf );

                        scope.manager.itemEnd( url );

                    }, _onError );

                } catch ( e ) {

                    _onError( e );

                }

            }, onProgress, _onError );

        }

        setDRACOLoader( dracoLoader ) {

            this.dracoLoader = dracoLoader;
            return this;

        }

        setDDSLoader() {

            throw new Error(

                'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'

            );

        }

        setKTX2Loader( ktx2Loader ) {

            this.ktx2Loader = ktx2Loader;
            return this;

        }

        setMeshoptDecoder( meshoptDecoder ) {

            this.meshoptDecoder = meshoptDecoder;
            return this;

        }

        register( callback ) {

            if ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {

                this.pluginCallbacks.push( callback );

            }

            return this;

        }

        unregister( callback ) {

            if ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {

                this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );

            }

            return this;

        }

        parse( data, path, onLoad, onError ) {

            let content;
            const extensions = {};
            const plugins = {};

            if ( typeof data === 'string' ) {

                content = data;

            } else {

                const magic = THREE.LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );

                if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {

                    try {

                        extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );

                    } catch ( error ) {

                        if ( onError ) onError( error );
                        return;

                    }

                    content = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;

                } else {

                    content = THREE.LoaderUtils.decodeText( new Uint8Array( data ) );

                }

            }

            const json = JSON.parse( content );

            if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {

                if ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );
                return;

            }

            const parser = new GLTFParser( json, {

                path: path || this.resourcePath || '',
                crossOrigin: this.crossOrigin,
                requestHeader: this.requestHeader,
                manager: this.manager,
                ktx2Loader: this.ktx2Loader,
                meshoptDecoder: this.meshoptDecoder

            } );

            parser.fileLoader.setRequestHeader( this.requestHeader );

            for ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {

                const plugin = this.pluginCallbacks[ i ]( parser );
                plugins[ plugin.name ] = plugin;

                // Workaround to avoid determining as unknown extension
                // in addUnknownExtensionsToUserData().
                // Remove this workaround if we move all the existing
                // extension handlers to plugin system
                extensions[ plugin.name ] = true;

            }

            if ( json.extensionsUsed ) {

                for ( let i = 0; i < json.extensionsUsed.length; ++ i ) {

                    const extensionName = json.extensionsUsed[ i ];
                    const extensionsRequired = json.extensionsRequired || [];

                    switch ( extensionName ) {

                        case EXTENSIONS.KHR_MATERIALS_UNLIT:
                            extensions[ extensionName ] = new GLTFMaterialsUnlitExtension();
                            break;

                        case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                            extensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();
                            break;

                        case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
                            extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );
                            break;

                        case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
                            extensions[ extensionName ] = new GLTFTextureTransformExtension();
                            break;

                        case EXTENSIONS.KHR_MESH_QUANTIZATION:
                            extensions[ extensionName ] = new GLTFMeshQuantizationExtension();
                            break;

                        default:

                            if ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {

                                console.warn( 'THREE.GLTFLoader: Unknown extension "' + extensionName + '".' );

                            }

                    }

                }

            }

            parser.setExtensions( extensions );
            parser.setPlugins( plugins );
            parser.parse( onLoad, onError );

        }

        parseAsync( data, path ) {

            const scope = this;

            return new Promise( function ( resolve, reject ) {

                scope.parse( data, path, resolve, reject );

            } );

        }

    }

    /* GLTFREGISTRY */

    function GLTFRegistry() {

        let objects = {};

        return  {

            get: function ( key ) {

                return objects[ key ];

            },

            add: function ( key, object ) {

                objects[ key ] = object;

            },

            remove: function ( key ) {

                delete objects[ key ];

            },

            removeAll: function () {

                objects = {};

            }

        };

    }

    /*********************************/
    /********** EXTENSIONS ***********/
    /*********************************/

    const EXTENSIONS = {
        KHR_BINARY_GLTF: 'KHR_binary_glTF',
        KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
        KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
        KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
        KHR_MATERIALS_IOR: 'KHR_materials_ior',
        KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
        KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
        KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
        KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
        KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
        KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
        KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
        KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
        KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
        EXT_TEXTURE_WEBP: 'EXT_texture_webp',
        EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'
    };

    /**
     * Punctual Lights Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
     */
    class GLTFLightsExtension {

        constructor( parser ) {

            this.parser = parser;
            this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;

            // Object3D instance caches
            this.cache = { refs: {}, uses: {} };

        }

        _markDefs() {

            const parser = this.parser;
            const nodeDefs = this.parser.json.nodes || [];

            for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

                const nodeDef = nodeDefs[ nodeIndex ];

                if ( nodeDef.extensions
                        && nodeDef.extensions[ this.name ]
                        && nodeDef.extensions[ this.name ].light !== undefined ) {

                    parser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );

                }

            }

        }

        _loadLight( lightIndex ) {

            const parser = this.parser;
            const cacheKey = 'light:' + lightIndex;
            let dependency = parser.cache.get( cacheKey );

            if ( dependency ) return dependency;

            const json = parser.json;
            const extensions = ( json.extensions && json.extensions[ this.name ] ) || {};
            const lightDefs = extensions.lights || [];
            const lightDef = lightDefs[ lightIndex ];
            let lightNode;

            const color = new Color( 0xffffff );

            if ( lightDef.color !== undefined ) color.fromArray( lightDef.color );

            const range = lightDef.range !== undefined ? lightDef.range : 0;

            switch ( lightDef.type ) {

                case 'directional':
                    lightNode = new DirectionalLight( color );
                    lightNode.target.position.set( 0, 0, - 1 );
                    lightNode.add( lightNode.target );
                    break;

                case 'point':
                    lightNode = new PointLight( color );
                    lightNode.distance = range;
                    break;

                case 'spot':
                    lightNode = new SpotLight( color );
                    lightNode.distance = range;
                    // Handle spotlight properties.
                    lightDef.spot = lightDef.spot || {};
                    lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
                    lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
                    lightNode.angle = lightDef.spot.outerConeAngle;
                    lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
                    lightNode.target.position.set( 0, 0, - 1 );
                    lightNode.add( lightNode.target );
                    break;

                default:
                    throw new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );

            }

            // Some lights (e.g. spot) default to a position other than the origin. Reset the position
            // here, because node-level parsing will only override position if explicitly specified.
            lightNode.position.set( 0, 0, 0 );

            lightNode.decay = 2;

            if ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;

            lightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );

            dependency = Promise.resolve( lightNode );

            parser.cache.add( cacheKey, dependency );

            return dependency;

        }

        createNodeAttachment( nodeIndex ) {

            const self = this;
            const parser = this.parser;
            const json = parser.json;
            const nodeDef = json.nodes[ nodeIndex ];
            const lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};
            const lightIndex = lightDef.light;

            if ( lightIndex === undefined ) return null;

            return this._loadLight( lightIndex ).then( function ( light ) {

                return parser._getNodeRef( self.cache, lightIndex, light );

            } );

        }

    }

    /**
     * Unlit Materials Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
     */
    class GLTFMaterialsUnlitExtension {

        constructor() {

            this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;

        }

        getMaterialType() {

            return MeshBasicMaterial;

        }

        extendParams( materialParams, materialDef, parser ) {

            const pending = [];

            materialParams.color = new Color( 1.0, 1.0, 1.0 );
            materialParams.opacity = 1.0;

            const metallicRoughness = materialDef.pbrMetallicRoughness;

            if ( metallicRoughness ) {

                if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

                    const array = metallicRoughness.baseColorFactor;

                    materialParams.color.fromArray( array );
                    materialParams.opacity = array[ 3 ];

                }

                if ( metallicRoughness.baseColorTexture !== undefined ) {

                    pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, sRGBEncoding ) );

                }

            }

            return Promise.all( pending );

        }

    }

    /**
     * Clearcoat Materials Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
     */
    class GLTFMaterialsClearcoatExtension {

        constructor( parser ) {

            this.parser = parser;
            this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;

        }

        getMaterialType( materialIndex ) {

            const parser = this.parser;
            const materialDef = parser.json.materials[ materialIndex ];

            if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

            return MeshPhysicalMaterial;

        }

        extendMaterialParams( materialIndex, materialParams ) {

            const parser = this.parser;
            const materialDef = parser.json.materials[ materialIndex ];

            if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

                return Promise.resolve();

            }

            const pending = [];

            const extension = materialDef.extensions[ this.name ];

            if ( extension.clearcoatFactor !== undefined ) {

                materialParams.clearcoat = extension.clearcoatFactor;

            }

            if ( extension.clearcoatTexture !== undefined ) {

                pending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );

            }

            if ( extension.clearcoatRoughnessFactor !== undefined ) {

                materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;

            }

            if ( extension.clearcoatRoughnessTexture !== undefined ) {

                pending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );

            }

            if ( extension.clearcoatNormalTexture !== undefined ) {

                pending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );

                if ( extension.clearcoatNormalTexture.scale !== undefined ) {

                    const scale = extension.clearcoatNormalTexture.scale;

                    materialParams.clearcoatNormalScale = new Vector2( scale, scale );

                }

            }

            return Promise.all( pending );

        }

    }

    /**
     * Sheen Materials Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen
     */
    class GLTFMaterialsSheenExtension {

        constructor( parser ) {

            this.parser = parser;
            this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;

        }

        getMaterialType( materialIndex ) {

            const parser = this.parser;
            const materialDef = parser.json.materials[ materialIndex ];

            if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

            return MeshPhysicalMaterial;

        }

        extendMaterialParams( materialIndex, materialParams ) {

            const parser = this.parser;
            const materialDef = parser.json.materials[ materialIndex ];

            if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

                return Promise.resolve();

            }

            const pending = [];

            materialParams.sheenColor = new Color( 0, 0, 0 );
            materialParams.sheenRoughness = 0;
            materialParams.sheen = 1;

            const extension = materialDef.extensions[ this.name ];

            if ( extension.sheenColorFactor !== undefined ) {

                materialParams.sheenColor.fromArray( extension.sheenColorFactor );

            }

            if ( extension.sheenRoughnessFactor !== undefined ) {

                materialParams.sheenRoughness = extension.sheenRoughnessFactor;

            }

            if ( extension.sheenColorTexture !== undefined ) {

                pending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture, sRGBEncoding ) );

            }

            if ( extension.sheenRoughnessTexture !== undefined ) {

                pending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );

            }

            return Promise.all( pending );

        }

    }

    /**
     * Transmission Materials Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
     * Draft: https://github.com/KhronosGroup/glTF/pull/1698
     */
    class GLTFMaterialsTransmissionExtension {

        constructor( parser ) {

            this.parser = parser;
            this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;

        }

        getMaterialType( materialIndex ) {

            const parser = this.parser;
            const materialDef = parser.json.materials[ materialIndex ];

            if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

            return MeshPhysicalMaterial;

        }

        extendMaterialParams( materialIndex, materialParams ) {

            const parser = this.parser;
            const materialDef = parser.json.materials[ materialIndex ];

            if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

                return Promise.resolve();

            }

            const pending = [];

            const extension = materialDef.extensions[ this.name ];

            if ( extension.transmissionFactor !== undefined ) {

                materialParams.transmission = extension.transmissionFactor;

            }

            if ( extension.transmissionTexture !== undefined ) {

                pending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );

            }

            return Promise.all( pending );

        }

    }

    /**
     * Materials Volume Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
     */
    class GLTFMaterialsVolumeExtension {

        constructor( parser ) {

            this.parser = parser;
            this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;

        }

        getMaterialType( materialIndex ) {

            const parser = this.parser;
            const materialDef = parser.json.materials[ materialIndex ];

            if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

            return MeshPhysicalMaterial;

        }

        extendMaterialParams( materialIndex, materialParams ) {

            const parser = this.parser;
            const materialDef = parser.json.materials[ materialIndex ];

            if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

                return Promise.resolve();

            }

            const pending = [];

            const extension = materialDef.extensions[ this.name ];

            materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;

            if ( extension.thicknessTexture !== undefined ) {

                pending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );

            }

            materialParams.attenuationDistance = extension.attenuationDistance || 0;

            const colorArray = extension.attenuationColor || [ 1, 1, 1 ];
            materialParams.attenuationColor = new Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );

            return Promise.all( pending );

        }

    }

    /**
     * Materials ior Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior
     */
    class GLTFMaterialsIorExtension {

        constructor( parser ) {

            this.parser = parser;
            this.name = EXTENSIONS.KHR_MATERIALS_IOR;

        }

        getMaterialType( materialIndex ) {

            const parser = this.parser;
            const materialDef = parser.json.materials[ materialIndex ];

            if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

            return MeshPhysicalMaterial;

        }

        extendMaterialParams( materialIndex, materialParams ) {

            const parser = this.parser;
            const materialDef = parser.json.materials[ materialIndex ];

            if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

                return Promise.resolve();

            }

            const extension = materialDef.extensions[ this.name ];

            materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;

            return Promise.resolve();

        }

    }

    /**
     * Materials specular Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular
     */
    class GLTFMaterialsSpecularExtension {

        constructor( parser ) {

            this.parser = parser;
            this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;

        }

        getMaterialType( materialIndex ) {

            const parser = this.parser;
            const materialDef = parser.json.materials[ materialIndex ];

            if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

            return MeshPhysicalMaterial;

        }

        extendMaterialParams( materialIndex, materialParams ) {

            const parser = this.parser;
            const materialDef = parser.json.materials[ materialIndex ];

            if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

                return Promise.resolve();

            }

            const pending = [];

            const extension = materialDef.extensions[ this.name ];

            materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;

            if ( extension.specularTexture !== undefined ) {

                pending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );

            }

            const colorArray = extension.specularColorFactor || [ 1, 1, 1 ];
            materialParams.specularColor = new Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );

            if ( extension.specularColorTexture !== undefined ) {

                pending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture, sRGBEncoding ) );

            }

            return Promise.all( pending );

        }

    }

    /**
     * BasisU Texture Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
     */
    class GLTFTextureBasisUExtension {

        constructor( parser ) {

            this.parser = parser;
            this.name = EXTENSIONS.KHR_TEXTURE_BASISU;

        }

        loadTexture( textureIndex ) {

            const parser = this.parser;
            const json = parser.json;

            const textureDef = json.textures[ textureIndex ];

            if ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {

                return null;

            }

            const extension = textureDef.extensions[ this.name ];
            const loader = parser.options.ktx2Loader;

            if ( ! loader ) {

                if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

                    throw new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );

                } else {

                    // Assumes that the extension is optional and that a fallback texture is present
                    return null;

                }

            }

            return parser.loadTextureImage( textureIndex, extension.source, loader );

        }

    }

    /**
     * WebP Texture Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
     */
    class GLTFTextureWebPExtension {

        constructor( parser ) {

            this.parser = parser;
            this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
            this.isSupported = null;

        }

        loadTexture( textureIndex ) {

            const name = this.name;
            const parser = this.parser;
            const json = parser.json;

            const textureDef = json.textures[ textureIndex ];

            if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {

                return null;

            }

            const extension = textureDef.extensions[ name ];
            const source = json.images[ extension.source ];

            let loader = parser.textureLoader;
            if ( source.uri ) {

                const handler = parser.options.manager.getHandler( source.uri );
                if ( handler !== null ) loader = handler;

            }

            return this.detectSupport().then( function ( isSupported ) {

                if ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );

                if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {

                    throw new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );

                }

                // Fall back to PNG or JPEG.
                return parser.loadTexture( textureIndex );

            } );

        }

        detectSupport() {

            if ( ! this.isSupported ) {

                this.isSupported = new Promise( function ( resolve ) {

                    const image = new Image();

                    // Lossy test image. Support for lossy images doesn't guarantee support for all
                    // WebP images, unfortunately.
                    image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';

                    image.onload = image.onerror = function () {

                        resolve( image.height === 1 );

                    };

                } );

            }

            return this.isSupported;

        }

    }

    /**
     * meshopt BufferView Compression Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
     */
    class GLTFMeshoptCompression {

        constructor( parser ) {

            this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
            this.parser = parser;

        }

        loadBufferView( index ) {

            const json = this.parser.json;
            const bufferView = json.bufferViews[ index ];

            if ( bufferView.extensions && bufferView.extensions[ this.name ] ) {

                const extensionDef = bufferView.extensions[ this.name ];

                const buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );
                const decoder = this.parser.options.meshoptDecoder;

                if ( ! decoder || ! decoder.supported ) {

                    if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

                        throw new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );

                    } else {

                        // Assumes that the extension is optional and that fallback buffer data is present
                        return null;

                    }

                }

                return Promise.all( [ buffer, decoder.ready ] ).then( function ( res ) {

                    const byteOffset = extensionDef.byteOffset || 0;
                    const byteLength = extensionDef.byteLength || 0;

                    const count = extensionDef.count;
                    const stride = extensionDef.byteStride;

                    const result = new ArrayBuffer( count * stride );
                    const source = new Uint8Array( res[ 0 ], byteOffset, byteLength );

                    decoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );
                    return result;

                } );

            } else {

                return null;

            }

        }

    }

    /* BINARY EXTENSION */
    const BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
    const BINARY_EXTENSION_HEADER_LENGTH = 12;
    const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };

    class GLTFBinaryExtension {

        constructor( data ) {

            this.name = EXTENSIONS.KHR_BINARY_GLTF;
            this.content = null;
            this.body = null;

            const headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );

            this.header = {
                magic: THREE.LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),
                version: headerView.getUint32( 4, true ),
                length: headerView.getUint32( 8, true )
            };

            if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {

                throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );

            } else if ( this.header.version < 2.0 ) {

                throw new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );

            }

            const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
            const chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );
            let chunkIndex = 0;

            while ( chunkIndex < chunkContentsLength ) {

                const chunkLength = chunkView.getUint32( chunkIndex, true );
                chunkIndex += 4;

                const chunkType = chunkView.getUint32( chunkIndex, true );
                chunkIndex += 4;

                if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {

                    const contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );
                    this.content = THREE.LoaderUtils.decodeText( contentArray );

                } else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {

                    const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
                    this.body = data.slice( byteOffset, byteOffset + chunkLength );

                }

                // Clients must ignore chunks with unknown types.

                chunkIndex += chunkLength;

            }

            if ( this.content === null ) {

                throw new Error( 'THREE.GLTFLoader: JSON content not found.' );

            }

        }

    }

    /**
     * DRACO Mesh Compression Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
     */
    class GLTFDracoMeshCompressionExtension {

        constructor( json, dracoLoader ) {

            if ( ! dracoLoader ) {

                throw new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );

            }

            this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
            this.json = json;
            this.dracoLoader = dracoLoader;
            this.dracoLoader.preload();

        }

        decodePrimitive( primitive, parser ) {

            const json = this.json;
            const dracoLoader = this.dracoLoader;
            const bufferViewIndex = primitive.extensions[ this.name ].bufferView;
            const gltfAttributeMap = primitive.extensions[ this.name ].attributes;
            const threeAttributeMap = {};
            const attributeNormalizedMap = {};
            const attributeTypeMap = {};

            for ( const attributeName in gltfAttributeMap ) {

                const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

                threeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];

            }

            for ( const attributeName in primitive.attributes ) {

                const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

                if ( gltfAttributeMap[ attributeName ] !== undefined ) {

                    const accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];
                    const componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

                    attributeTypeMap[ threeAttributeName ] = componentType;
                    attributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;

                }

            }

            return parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {

                return new Promise( function ( resolve ) {

                    dracoLoader.decodeDracoFile( bufferView, function ( geometry ) {

                        for ( const attributeName in geometry.attributes ) {

                            const attribute = geometry.attributes[ attributeName ];
                            const normalized = attributeNormalizedMap[ attributeName ];

                            if ( normalized !== undefined ) attribute.normalized = normalized;

                        }

                        resolve( geometry );

                    }, threeAttributeMap, attributeTypeMap );

                } );

            } );

        }

    }

    /**
     * Texture Transform Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
     */
    class GLTFTextureTransformExtension {

        constructor() {

            this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;

        }

        extendTexture( texture, transform ) {

            if ( transform.texCoord !== undefined ) {

                console.warn( 'THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.' );

            }

            if ( transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined ) {

                // See https://github.com/mrdoob/three.js/issues/21819.
                return texture;

            }

            texture = texture.clone();

            if ( transform.offset !== undefined ) {

                texture.offset.fromArray( transform.offset );

            }

            if ( transform.rotation !== undefined ) {

                texture.rotation = transform.rotation;

            }

            if ( transform.scale !== undefined ) {

                texture.repeat.fromArray( transform.scale );

            }

            texture.needsUpdate = true;

            return texture;

        }

    }

    /**
     * Specular-Glossiness Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness
     */

    /**
     * A sub class of StandardMaterial with some of the functionality
     * changed via the `onBeforeCompile` callback
     * @pailhead
     */
    class GLTFMeshStandardSGMaterial extends THREE.MeshStandardMaterial {

        constructor( params ) {

            super();

            this.isGLTFSpecularGlossinessMaterial = true;

            //various chunks that need replacing
            const specularMapParsFragmentChunk = [
                '#ifdef USE_SPECULARMAP',
                '   uniform sampler2D specularMap;',
                '#endif'
            ].join( '\n' );

            const glossinessMapParsFragmentChunk = [
                '#ifdef USE_GLOSSINESSMAP',
                '   uniform sampler2D glossinessMap;',
                '#endif'
            ].join( '\n' );

            const specularMapFragmentChunk = [
                'vec3 specularFactor = specular;',
                '#ifdef USE_SPECULARMAP',
                '   vec4 texelSpecular = texture2D( specularMap, vUv );',
                '   // reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
                '   specularFactor *= texelSpecular.rgb;',
                '#endif'
            ].join( '\n' );

            const glossinessMapFragmentChunk = [
                'float glossinessFactor = glossiness;',
                '#ifdef USE_GLOSSINESSMAP',
                '   vec4 texelGlossiness = texture2D( glossinessMap, vUv );',
                '   // reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
                '   glossinessFactor *= texelGlossiness.a;',
                '#endif'
            ].join( '\n' );

            const lightPhysicalFragmentChunk = [
                'PhysicalMaterial material;',
                'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',
                'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',
                'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',
                'material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',
                'material.roughness += geometryRoughness;',
                'material.roughness = min( material.roughness, 1.0 );',
                'material.specularColor = specularFactor;',
            ].join( '\n' );

            const uniforms = {
                specular: { value: new Color().setHex( 0xffffff ) },
                glossiness: { value: 1 },
                specularMap: { value: null },
                glossinessMap: { value: null }
            };

            this._extraUniforms = uniforms;

            this.onBeforeCompile = function ( shader ) {

                for ( const uniformName in uniforms ) {

                    shader.uniforms[ uniformName ] = uniforms[ uniformName ];

                }

                shader.fragmentShader = shader.fragmentShader
                    .replace( 'uniform float roughness;', 'uniform vec3 specular;' )
                    .replace( 'uniform float metalness;', 'uniform float glossiness;' )
                    .replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk )
                    .replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk )
                    .replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk )
                    .replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk )
                    .replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );

            };

            Object.defineProperties( this, {

                specular: {
                    get: function () {

                        return uniforms.specular.value;

                    },
                    set: function ( v ) {

                        uniforms.specular.value = v;

                    }
                },

                specularMap: {
                    get: function () {

                        return uniforms.specularMap.value;

                    },
                    set: function ( v ) {

                        uniforms.specularMap.value = v;

                        if ( v ) {

                            this.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps

                        } else {

                            delete this.defines.USE_SPECULARMAP;

                        }

                    }
                },

                glossiness: {
                    get: function () {

                        return uniforms.glossiness.value;

                    },
                    set: function ( v ) {

                        uniforms.glossiness.value = v;

                    }
                },

                glossinessMap: {
                    get: function () {

                        return uniforms.glossinessMap.value;

                    },
                    set: function ( v ) {

                        uniforms.glossinessMap.value = v;

                        if ( v ) {

                            this.defines.USE_GLOSSINESSMAP = '';
                            this.defines.USE_UV = '';

                        } else {

                            delete this.defines.USE_GLOSSINESSMAP;
                            delete this.defines.USE_UV;

                        }

                    }
                }

            } );

            delete this.metalness;
            delete this.roughness;
            delete this.metalnessMap;
            delete this.roughnessMap;

            this.setValues( params );

        }

        copy( source ) {

            super.copy( source );

            this.specularMap = source.specularMap;
            this.specular.copy( source.specular );
            this.glossinessMap = source.glossinessMap;
            this.glossiness = source.glossiness;
            delete this.metalness;
            delete this.roughness;
            delete this.metalnessMap;
            delete this.roughnessMap;
            return this;

        }

    }


    class GLTFMaterialsPbrSpecularGlossinessExtension {

        constructor() {

            this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;

            this.specularGlossinessParams = [
                'color',
                'map',
                'lightMap',
                'lightMapIntensity',
                'aoMap',
                'aoMapIntensity',
                'emissive',
                'emissiveIntensity',
                'emissiveMap',
                'bumpMap',
                'bumpScale',
                'normalMap',
                'normalMapType',
                'displacementMap',
                'displacementScale',
                'displacementBias',
                'specularMap',
                'specular',
                'glossinessMap',
                'glossiness',
                'alphaMap',
                'envMap',
                'envMapIntensity'
            ];

        }

        getMaterialType() {

            return GLTFMeshStandardSGMaterial;

        }

        extendParams( materialParams, materialDef, parser ) {

            const pbrSpecularGlossiness = materialDef.extensions[ this.name ];

            materialParams.color = new Color( 1.0, 1.0, 1.0 );
            materialParams.opacity = 1.0;

            const pending = [];

            if ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {

                const array = pbrSpecularGlossiness.diffuseFactor;

                materialParams.color.fromArray( array );
                materialParams.opacity = array[ 3 ];

            }

            if ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {

                pending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture, sRGBEncoding ) );

            }

            materialParams.emissive = new Color( 0.0, 0.0, 0.0 );
            materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
            materialParams.specular = new Color( 1.0, 1.0, 1.0 );

            if ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {

                materialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );

            }

            if ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {

                const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
                pending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );
                pending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef, sRGBEncoding ) );

            }

            return Promise.all( pending );

        }

        createMaterial( materialParams ) {

            const material = new GLTFMeshStandardSGMaterial( materialParams );
            material.fog = true;

            material.color = materialParams.color;

            material.map = materialParams.map === undefined ? null : materialParams.map;

            material.lightMap = null;
            material.lightMapIntensity = 1.0;

            material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;
            material.aoMapIntensity = 1.0;

            material.emissive = materialParams.emissive;
            material.emissiveIntensity = 1.0;
            material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;

            material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;
            material.bumpScale = 1;

            material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;
            material.normalMapType = TangentSpaceNormalMap;

            if ( materialParams.normalScale ) material.normalScale = materialParams.normalScale;

            material.displacementMap = null;
            material.displacementScale = 1;
            material.displacementBias = 0;

            material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;
            material.specular = materialParams.specular;

            material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;
            material.glossiness = materialParams.glossiness;

            material.alphaMap = null;

            material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;
            material.envMapIntensity = 1.0;

            return material;

        }

    }

    /**
     * Mesh Quantization Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
     */
    class GLTFMeshQuantizationExtension {

        constructor() {

            this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;

        }

    }

    /*********************************/
    /********** INTERPOLATION ********/
    /*********************************/

    // Spline Interpolation
    // Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
    class GLTFCubicSplineInterpolant extends THREE.Interpolant {

        constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

            super( parameterPositions, sampleValues, sampleSize, resultBuffer );

        }

        copySampleValue_( index ) {

            // Copies a sample value to the result buffer. See description of glTF
            // CUBICSPLINE values layout in interpolate_() function below.

            const result = this.resultBuffer,
                values = this.sampleValues,
                valueSize = this.valueSize,
                offset = index * valueSize * 3 + valueSize;

            for ( let i = 0; i !== valueSize; i ++ ) {

                result[ i ] = values[ offset + i ];

            }

            return result;

        }

    }

    GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

    GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

    GLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {

        const result = this.resultBuffer;
        const values = this.sampleValues;
        const stride = this.valueSize;

        const stride2 = stride * 2;
        const stride3 = stride * 3;

        const td = t1 - t0;

        const p = ( t - t0 ) / td;
        const pp = p * p;
        const ppp = pp * p;

        const offset1 = i1 * stride3;
        const offset0 = offset1 - stride3;

        const s2 = - 2 * ppp + 3 * pp;
        const s3 = ppp - pp;
        const s0 = 1 - s2;
        const s1 = s3 - pp + p;

        // Layout of keyframe output values for CUBICSPLINE animations:
        //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
        for ( let i = 0; i !== stride; i ++ ) {

            const p0 = values[ offset0 + i + stride ]; // splineVertex_k
            const m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)
            const p1 = values[ offset1 + i + stride ]; // splineVertex_k+1
            const m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)

            result[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;

        }

        return result;

    };

    const _q = new THREE.Quaternion();

    class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {

        interpolate_( i1, t0, t, t1 ) {

            const result = super.interpolate_( i1, t0, t, t1 );

            _q.fromArray( result ).normalize().toArray( result );

            return result;

        }

    }


    /*********************************/
    /********** INTERNALS ************/
    /*********************************/

    /* CONSTANTS */

    const WEBGL_CONSTANTS = {
        FLOAT: 5126,
        //FLOAT_MAT2: 35674,
        FLOAT_MAT3: 35675,
        FLOAT_MAT4: 35676,
        FLOAT_VEC2: 35664,
        FLOAT_VEC3: 35665,
        FLOAT_VEC4: 35666,
        LINEAR: 9729,
        REPEAT: 10497,
        SAMPLER_2D: 35678,
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6,
        UNSIGNED_BYTE: 5121,
        UNSIGNED_SHORT: 5123
    };

    const WEBGL_COMPONENT_TYPES = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
    };

    const WEBGL_FILTERS = {
        9728: THREE.NearestFilter,
        9729: THREE.LinearFilter,
        9984: THREE.NearestMipmapNearestFilter,
        9985: THREE.LinearMipmapNearestFilter,
        9986: THREE.NearestMipmapLinearFilter,
        9987: THREE.LinearMipmapLinearFilter
    };

    const WEBGL_WRAPPINGS = {
        33071: THREE.ClampToEdgeWrapping,
        33648: THREE.MirroredRepeatWrapping,
        10497: THREE.RepeatWrapping
    };

    const WEBGL_TYPE_SIZES = {
        'SCALAR': 1,
        'VEC2': 2,
        'VEC3': 3,
        'VEC4': 4,
        'MAT2': 4,
        'MAT3': 9,
        'MAT4': 16
    };

    const ATTRIBUTES = {
        POSITION: 'position',
        NORMAL: 'normal',
        TANGENT: 'tangent',
        TEXCOORD_0: 'uv',
        TEXCOORD_1: 'uv2',
        COLOR_0: 'color',
        WEIGHTS_0: 'skinWeight',
        JOINTS_0: 'skinIndex',
    };

    const PATH_PROPERTIES = {
        scale: 'scale',
        translation: 'position',
        rotation: 'quaternion',
        weights: 'morphTargetInfluences'
    };

    const INTERPOLATION = {
        CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
                                    // keyframe track will be initialized with a default interpolation type, then modified.
        LINEAR: THREE.InterpolateLinear,
        STEP: THREE.InterpolateDiscrete
    };

    const ALPHA_MODES = {
        OPAQUE: 'OPAQUE',
        MASK: 'MASK',
        BLEND: 'BLEND'
    };

    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
     */
    function createDefaultMaterial( cache ) {

        if ( cache[ 'DefaultMaterial' ] === undefined ) {

            cache[ 'DefaultMaterial' ] = new MeshStandardMaterial( {
                color: 0xFFFFFF,
                emissive: 0x000000,
                metalness: 1,
                roughness: 1,
                transparent: false,
                depthTest: true,
                side: FrontSide,
                //needsUpdate: true 
            } );

        }

        return cache[ 'DefaultMaterial' ];

    }

    function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {

        // Add unknown glTF extensions to an object's userData.

        for ( const name in objectDef.extensions ) {

            if ( knownExtensions[ name ] === undefined ) {

                object.userData.gltfExtensions = object.userData.gltfExtensions || {};
                object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];

            }

        }

    }

    /**
     * @param {Object3D|Material|BufferGeometry} object
     * @param {GLTF.definition} gltfDef
     */
    function assignExtrasToUserData( object, gltfDef ) {

        if ( gltfDef.extras !== undefined ) {

            if ( typeof gltfDef.extras === 'object' ) {

                Object.assign( object.userData, gltfDef.extras );

            } else {

                console.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );

            }

        }

    }

    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
     *
     * @param {BufferGeometry} geometry
     * @param {Array<GLTF.Target>} targets
     * @param {GLTFParser} parser
     * @return {Promise<BufferGeometry>}
     */
    function addMorphTargets( geometry, targets, parser ) {

        let hasMorphPosition = false;
        let hasMorphNormal = false;
        let hasMorphColor = false;

        for ( let i = 0, il = targets.length; i < il; i ++ ) {

            const target = targets[ i ];

            if ( target.POSITION !== undefined ) hasMorphPosition = true;
            if ( target.NORMAL !== undefined ) hasMorphNormal = true;
            if ( target.COLOR_0 !== undefined ) hasMorphColor = true;

            if ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;

        }

        if ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry );

        const pendingPositionAccessors = [];
        const pendingNormalAccessors = [];
        const pendingColorAccessors = [];

        for ( let i = 0, il = targets.length; i < il; i ++ ) {

            const target = targets[ i ];

            if ( hasMorphPosition ) {

                const pendingAccessor = target.POSITION !== undefined
                    ? parser.getDependency( 'accessor', target.POSITION )
                    : geometry.attributes.position;

                pendingPositionAccessors.push( pendingAccessor );

            }

            if ( hasMorphNormal ) {

                const pendingAccessor = target.NORMAL !== undefined
                    ? parser.getDependency( 'accessor', target.NORMAL )
                    : geometry.attributes.normal;

                pendingNormalAccessors.push( pendingAccessor );

            }

            if ( hasMorphColor ) {

                const pendingAccessor = target.COLOR_0 !== undefined
                    ? parser.getDependency( 'accessor', target.COLOR_0 )
                    : geometry.attributes.color;

                pendingColorAccessors.push( pendingAccessor );

            }

        }

        return Promise.all( [
            Promise.all( pendingPositionAccessors ),
            Promise.all( pendingNormalAccessors ),
            Promise.all( pendingColorAccessors )
        ] ).then( function ( accessors ) {

            const morphPositions = accessors[ 0 ];
            const morphNormals = accessors[ 1 ];
            const morphColors = accessors[ 2 ];

            if ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;
            if ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;
            if ( hasMorphColor ) geometry.morphAttributes.color = morphColors;
            geometry.morphTargetsRelative = true;

            return geometry;

        } );

    }

    /**
     * @param {Mesh} mesh
     * @param {GLTF.Mesh} meshDef
     */
    function updateMorphTargets( mesh, meshDef ) {

        mesh.updateMorphTargets();

        if ( meshDef.weights !== undefined ) {

            for ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {

                mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];

            }

        }

        // .extras has user-defined data, so check that .extras.targetNames is an array.
        if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {

            const targetNames = meshDef.extras.targetNames;

            if ( mesh.morphTargetInfluences.length === targetNames.length ) {

                mesh.morphTargetDictionary = {};

                for ( let i = 0, il = targetNames.length; i < il; i ++ ) {

                    mesh.morphTargetDictionary[ targetNames[ i ] ] = i;

                }

            } else {

                console.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );

            }

        }

    }

    function createPrimitiveKey( primitiveDef ) {

        const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];
        let geometryKey;

        if ( dracoExtension ) {

            geometryKey = 'draco:' + dracoExtension.bufferView
                    + ':' + dracoExtension.indices
                    + ':' + createAttributesKey( dracoExtension.attributes );

        } else {

            geometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;

        }

        return geometryKey;

    }

    function createAttributesKey( attributes ) {

        let attributesKey = '';

        const keys = Object.keys( attributes ).sort();

        for ( let i = 0, il = keys.length; i < il; i ++ ) {

            attributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';

        }

        return attributesKey;

    }

    function getNormalizedComponentScale( constructor ) {

        // Reference:
        // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data

        switch ( constructor ) {

            case Int8Array:
                return 1 / 127;

            case Uint8Array:
                return 1 / 255;

            case Int16Array:
                return 1 / 32767;

            case Uint16Array:
                return 1 / 65535;

            default:
                throw new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );

        }

    }

    function getImageURIMimeType( uri ) {

        if ( uri.search( /\.jpe?g($|\?)/i ) > 0 || uri.search( /^data\:image\/jpeg/ ) === 0 ) return 'image/jpeg';
        if ( uri.search( /\.webp($|\?)/i ) > 0 || uri.search( /^data\:image\/webp/ ) === 0 ) return 'image/webp';

        return 'image/png';

    }

    /* GLTF PARSER */

    class GLTFParser {

        constructor( json = {}, options = {} ) {

            this.json = json;
            this.extensions = {};
            this.plugins = {};
            this.options = options;

            // loader object cache
            this.cache = new GLTFRegistry();

            // associations between Three.js objects and glTF elements
            this.associations = new Map();

            // BufferGeometry caching
            this.primitiveCache = {};

            // Object3D instance caches
            this.meshCache = { refs: {}, uses: {} };
            this.cameraCache = { refs: {}, uses: {} };
            this.lightCache = { refs: {}, uses: {} };

            this.sourceCache = {};
            this.textureCache = {};

            // Track node names, to ensure no duplicates
            this.nodeNamesUsed = {};

            // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
            // expensive work of uploading a texture to the GPU off the main thread.
            if ( typeof createImageBitmap !== 'undefined' && /^((?!chrome|android).)*safari/i.test( navigator.userAgent ) === false ) {

                this.textureLoader = new ImageBitmapLoader( this.options.manager );

            } else {

                this.textureLoader = new TextureLoader( this.options.manager );

            }

            this.textureLoader.setCrossOrigin( this.options.crossOrigin );
            this.textureLoader.setRequestHeader( this.options.requestHeader );

            this.fileLoader = new THREE.FileLoader( this.options.manager );
            this.fileLoader.setResponseType( 'arraybuffer' );

            if ( this.options.crossOrigin === 'use-credentials' ) {

                this.fileLoader.setWithCredentials( true );

            }

        }

        setExtensions( extensions ) {

            this.extensions = extensions;

        }

        setPlugins( plugins ) {

            this.plugins = plugins;

        }

        parse( onLoad, onError ) {

            const parser = this;
            const json = this.json;
            const extensions = this.extensions;

            // Clear the loader cache
            this.cache.removeAll();

            // Mark the special nodes/meshes in json for efficient parse
            this._invokeAll( function ( ext ) {

                return ext._markDefs && ext._markDefs();

            } );

            Promise.all( this._invokeAll( function ( ext ) {

                return ext.beforeRoot && ext.beforeRoot();

            } ) ).then( function () {

                return Promise.all( [

                    parser.getDependencies( 'scene' ),
                    parser.getDependencies( 'animation' ),
                    parser.getDependencies( 'camera' ),

                ] );

            } ).then( function ( dependencies ) {

                const result = {
                    scene: dependencies[ 0 ][ json.scene || 0 ],
                    scenes: dependencies[ 0 ],
                    animations: dependencies[ 1 ],
                    cameras: dependencies[ 2 ],
                    asset: json.asset,
                    parser: parser,
                    userData: {}
                };

                addUnknownExtensionsToUserData( extensions, result, json );

                assignExtrasToUserData( result, json );

                Promise.all( parser._invokeAll( function ( ext ) {

                    return ext.afterRoot && ext.afterRoot( result );

                } ) ).then( function () {

                    onLoad( result );

                } );

            } ).catch( onError );

        }

        /**
         * Marks the special nodes/meshes in json for efficient parse.
         */
        _markDefs() {

            const nodeDefs = this.json.nodes || [];
            const skinDefs = this.json.skins || [];
            const meshDefs = this.json.meshes || [];

            // Nothing in the node definition indicates whether it is a Bone or an
            // Object3D. Use the skins' joint references to mark bones.
            for ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {

                const joints = skinDefs[ skinIndex ].joints;

                for ( let i = 0, il = joints.length; i < il; i ++ ) {

                    nodeDefs[ joints[ i ] ].isBone = true;

                }

            }

            // Iterate over all nodes, marking references to shared resources,
            // as well as skeleton joints.
            for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

                const nodeDef = nodeDefs[ nodeIndex ];

                if ( nodeDef.mesh !== undefined ) {

                    this._addNodeRef( this.meshCache, nodeDef.mesh );

                    // Nothing in the mesh definition indicates whether it is
                    // a SkinnedMesh or Mesh. Use the node's mesh reference
                    // to mark SkinnedMesh if node has skin.
                    if ( nodeDef.skin !== undefined ) {

                        meshDefs[ nodeDef.mesh ].isSkinnedMesh = true;

                    }

                }

                if ( nodeDef.camera !== undefined ) {

                    this._addNodeRef( this.cameraCache, nodeDef.camera );

                }

            }

        }

        /**
         * Counts references to shared node / Object3D resources. These resources
         * can be reused, or "instantiated", at multiple nodes in the scene
         * hierarchy. Mesh, Camera, and Light instances are instantiated and must
         * be marked. Non-scenegraph resources (like Materials, Geometries, and
         * Textures) can be reused directly and are not marked here.
         *
         * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
         */
        _addNodeRef( cache, index ) {

            if ( index === undefined ) return;

            if ( cache.refs[ index ] === undefined ) {

                cache.refs[ index ] = cache.uses[ index ] = 0;

            }

            cache.refs[ index ] ++;

        }

        /** Returns a reference to a shared resource, cloning it if necessary. */
        _getNodeRef( cache, index, object ) {

            if ( cache.refs[ index ] <= 1 ) return object;

            const ref = object.clone();

            // Propagates mappings to the cloned object, prevents mappings on the
            // original object from being lost.
            const updateMappings = ( original, clone ) => {

                const mappings = this.associations.get( original );
                if ( mappings != null ) {

                    this.associations.set( clone, mappings );

                }

                for ( const [ i, child ] of original.children.entries() ) {

                    updateMappings( child, clone.children[ i ] );

                }

            };

            updateMappings( object, ref );

            ref.name += '_instance_' + ( cache.uses[ index ] ++ );

            return ref;

        }

        _invokeOne( func ) {

            const extensions = Object.values( this.plugins );
            extensions.push( this );

            for ( let i = 0; i < extensions.length; i ++ ) {

                const result = func( extensions[ i ] );

                if ( result ) return result;

            }

            return null;

        }

        _invokeAll( func ) {

            const extensions = Object.values( this.plugins );
            extensions.unshift( this );

            const pending = [];

            for ( let i = 0; i < extensions.length; i ++ ) {

                const result = func( extensions[ i ] );

                if ( result ) pending.push( result );

            }

            return pending;

        }

        /**
         * Requests the specified dependency asynchronously, with caching.
         * @param {string} type
         * @param {number} index
         * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
         */
        getDependency( type, index ) {

            const cacheKey = type + ':' + index;
            let dependency = this.cache.get( cacheKey );

            if ( ! dependency ) {

                switch ( type ) {

                    case 'scene':
                        dependency = this.loadScene( index );
                        break;

                    case 'node':
                        dependency = this.loadNode( index );
                        break;

                    case 'mesh':
                        dependency = this._invokeOne( function ( ext ) {

                            return ext.loadMesh && ext.loadMesh( index );

                        } );
                        break;

                    case 'accessor':
                        dependency = this.loadAccessor( index );
                        break;

                    case 'bufferView':
                        dependency = this._invokeOne( function ( ext ) {

                            return ext.loadBufferView && ext.loadBufferView( index );

                        } );
                        break;

                    case 'buffer':
                        dependency = this.loadBuffer( index );
                        break;

                    case 'material':
                        dependency = this._invokeOne( function ( ext ) {

                            return ext.loadMaterial && ext.loadMaterial( index );

                        } );
                        break;

                    case 'texture':
                        dependency = this._invokeOne( function ( ext ) {

                            return ext.loadTexture && ext.loadTexture( index );

                        } );
                        break;

                    case 'skin':
                        dependency = this.loadSkin( index );
                        break;

                    case 'animation':
                        dependency = this.loadAnimation( index );
                        break;

                    case 'camera':
                        dependency = this.loadCamera( index );
                        break;

                    default:
                        throw new Error( 'Unknown type: ' + type );

                }

                this.cache.add( cacheKey, dependency );

            }

            return dependency;

        }

        /**
         * Requests all dependencies of the specified type asynchronously, with caching.
         * @param {string} type
         * @return {Promise<Array<Object>>}
         */
        getDependencies( type ) {

            let dependencies = this.cache.get( type );

            if ( ! dependencies ) {

                const parser = this;
                const defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];

                dependencies = Promise.all( defs.map( function ( def, index ) {

                    return parser.getDependency( type, index );

                } ) );

                this.cache.add( type, dependencies );

            }

            return dependencies;

        }

        /**
         * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
         * @param {number} bufferIndex
         * @return {Promise<ArrayBuffer>}
         */
        loadBuffer( bufferIndex ) {

            const bufferDef = this.json.buffers[ bufferIndex ];
            const loader = this.fileLoader;

            if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {

                throw new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );

            }

            // If present, GLB container is required to be the first buffer.
            if ( bufferDef.uri === undefined && bufferIndex === 0 ) {

                return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );

            }

            const options = this.options;

            return new Promise( function ( resolve, reject ) {

                loader.load( THREE.LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {

                    reject( new Error( 'THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".' ) );

                } );

            } );

        }

        /**
         * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
         * @param {number} bufferViewIndex
         * @return {Promise<ArrayBuffer>}
         */
        loadBufferView( bufferViewIndex ) {

            const bufferViewDef = this.json.bufferViews[ bufferViewIndex ];

            return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {

                const byteLength = bufferViewDef.byteLength || 0;
                const byteOffset = bufferViewDef.byteOffset || 0;
                return buffer.slice( byteOffset, byteOffset + byteLength );

            } );

        }

        /**
         * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
         * @param {number} accessorIndex
         * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
         */
        loadAccessor( accessorIndex ) {

            const parser = this;
            const json = this.json;

            const accessorDef = this.json.accessors[ accessorIndex ];

            if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {

                // Ignore empty accessors, which may be used to declare runtime
                // information about attributes coming from another source (e.g. Draco
                // compression extension).
                return Promise.resolve( null );

            }

            const pendingBufferViews = [];

            if ( accessorDef.bufferView !== undefined ) {

                pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );

            } else {

                pendingBufferViews.push( null );

            }

            if ( accessorDef.sparse !== undefined ) {

                pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );
                pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );

            }

            return Promise.all( pendingBufferViews ).then( function ( bufferViews ) {

                const bufferView = bufferViews[ 0 ];

                const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
                const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

                // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
                const elementBytes = TypedArray.BYTES_PER_ELEMENT;
                const itemBytes = elementBytes * itemSize;
                const byteOffset = accessorDef.byteOffset || 0;
                const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;
                const normalized = accessorDef.normalized === true;
                let array, bufferAttribute;

                // The buffer is not interleaved if the stride is the item size in bytes.
                if ( byteStride && byteStride !== itemBytes ) {

                    // Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
                    // This makes sure that IBA.count reflects accessor.count properly
                    const ibSlice = Math.floor( byteOffset / byteStride );
                    const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
                    let ib = parser.cache.get( ibCacheKey );

                    if ( ! ib ) {

                        array = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );

                        // Integer parameters to IB/IBA are in array elements, not bytes.
                        ib = new InterleavedBuffer( array, byteStride / elementBytes );

                        parser.cache.add( ibCacheKey, ib );

                    }

                    bufferAttribute = new InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );

                } else {

                    if ( bufferView === null ) {

                        array = new TypedArray( accessorDef.count * itemSize );

                    } else {

                        array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );

                    }

                    bufferAttribute = new BufferAttribute( array, itemSize, normalized );

                }

                // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
                if ( accessorDef.sparse !== undefined ) {

                    const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
                    const TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];

                    const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
                    const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;

                    const sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );
                    const sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );

                    if ( bufferView !== null ) {

                        // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
                        bufferAttribute = new BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );

                    }

                    for ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {

                        const index = sparseIndices[ i ];

                        bufferAttribute.setX( index, sparseValues[ i * itemSize ] );
                        if ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );
                        if ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );
                        if ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );
                        if ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );

                    }

                }

                return bufferAttribute;

            } );

        }

        /**
         * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
         * @param {number} textureIndex
         * @return {Promise<THREE.Texture>}
         */
        loadTexture( textureIndex ) {

            const json = this.json;
            const options = this.options;
            const textureDef = json.textures[ textureIndex ];
            const sourceIndex = textureDef.source;
            const sourceDef = json.images[ sourceIndex ];

            let loader = this.textureLoader;

            if ( sourceDef.uri ) {

                const handler = options.manager.getHandler( sourceDef.uri );
                if ( handler !== null ) loader = handler;

            }

            return this.loadTextureImage( textureIndex, sourceIndex, loader );

        }

        loadTextureImage( textureIndex, sourceIndex, loader ) {

            const parser = this;
            const json = this.json;

            const textureDef = json.textures[ textureIndex ];
            const sourceDef = json.images[ sourceIndex ];

            const cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;

            if ( this.textureCache[ cacheKey ] ) {

                // See https://github.com/mrdoob/three.js/issues/21559.
                return this.textureCache[ cacheKey ];

            }

            const promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) {

                texture.flipY = false;

                if ( textureDef.name ) texture.name = textureDef.name;

                const samplers = json.samplers || {};
                const sampler = samplers[ textureDef.sampler ] || {};

                texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;
                texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipmapLinearFilter;
                texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;
                texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;

                parser.associations.set( texture, { textures: textureIndex } );

                return texture;

            } ).catch( function () {

                return null;

            } );

            this.textureCache[ cacheKey ] = promise;

            return promise;

        }

        loadImageSource( sourceIndex, loader ) {

            const parser = this;
            const json = this.json;
            const options = this.options;

            if ( this.sourceCache[ sourceIndex ] !== undefined ) {

                return this.sourceCache[ sourceIndex ].then( ( texture ) => texture.clone() );

            }

            const sourceDef = json.images[ sourceIndex ];

            const URL = self.URL || self.webkitURL;

            let sourceURI = sourceDef.uri || '';
            let isObjectURL = false;

            if ( sourceDef.bufferView !== undefined ) {

                // Load binary image data from bufferView, if provided.

                sourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) {

                    isObjectURL = true;
                    const blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } );
                    sourceURI = URL.createObjectURL( blob );
                    return sourceURI;

                } );

            } else if ( sourceDef.uri === undefined ) {

                throw new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );

            }

            const promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {

                return new Promise( function ( resolve, reject ) {

                    let onLoad = resolve;

                    if ( loader.isImageBitmapLoader === true ) {

                        onLoad = function ( imageBitmap ) {

                            const texture = new Texture( imageBitmap );
                            texture.needsUpdate = true;

                            resolve( texture );

                        };

                    }

                    loader.load( THREE.LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );

                } );

            } ).then( function ( texture ) {

                // Clean up resources and configure Texture.

                if ( isObjectURL === true ) {

                    URL.revokeObjectURL( sourceURI );

                }

                texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri );

                return texture;

            } ).catch( function ( error ) {

                console.error( 'THREE.GLTFLoader: Couldn\'t load texture', sourceURI );
                throw error;

            } );

            this.sourceCache[ sourceIndex ] = promise;
            return promise;

        }

        /**
         * Asynchronously assigns a texture to the given material parameters.
         * @param {Object} materialParams
         * @param {string} mapName
         * @param {Object} mapDef
         * @return {Promise<Texture>}
         */
        assignTexture( materialParams, mapName, mapDef, encoding ) {

            const parser = this;

            return this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {

                // Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured
                // However, we will copy UV set 0 to UV set 1 on demand for aoMap
                if ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && ! ( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {

                    console.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );

                }

                if ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {

                    const transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;

                    if ( transform ) {

                        const gltfReference = parser.associations.get( texture );
                        texture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );
                        parser.associations.set( texture, gltfReference );

                    }

                }

                if ( encoding !== undefined ) {

                    texture.encoding = encoding;

                }

                materialParams[ mapName ] = texture;

                return texture;

            } );

        }

        /**
         * Assigns final material to a Mesh, Line, or Points instance. The instance
         * already has a material (generated from the glTF material options alone)
         * but reuse of the same glTF material may require multiple threejs materials
         * to accommodate different primitive types, defines, etc. New materials will
         * be created if necessary, and reused from a cache.
         * @param  {Object3D} mesh Mesh, Line, or Points instance.
         */
        assignFinalMaterial( mesh ) {

            const geometry = mesh.geometry;
            let material = mesh.material;

            const useDerivativeTangents = geometry.attributes.tangent === undefined;
            const useVertexColors = geometry.attributes.color !== undefined;
            const useFlatShading = geometry.attributes.normal === undefined;

            if ( mesh.isPoints ) {

                const cacheKey = 'PointsMaterial:' + material.uuid;

                let pointsMaterial = this.cache.get( cacheKey );

                if ( ! pointsMaterial ) {

                    pointsMaterial = new PointsMaterial();
                    Material.prototype.copy.call( pointsMaterial, material );
                    pointsMaterial.color.copy( material.color );
                    pointsMaterial.map = material.map;
                    pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

                    this.cache.add( cacheKey, pointsMaterial );

                }

                material = pointsMaterial;

            } else if ( mesh.isLine ) {

                const cacheKey = 'LineBasicMaterial:' + material.uuid;

                let lineMaterial = this.cache.get( cacheKey );

                if ( ! lineMaterial ) {

                    lineMaterial = new LineBasicMaterial();
                    Material.prototype.copy.call( lineMaterial, material );
                    lineMaterial.color.copy( material.color );

                    this.cache.add( cacheKey, lineMaterial );

                }

                material = lineMaterial;

            }

            // Clone the material if it will be modified
            if ( useDerivativeTangents || useVertexColors || useFlatShading ) {

                let cacheKey = 'ClonedMaterial:' + material.uuid + ':';

                if ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:';
                if ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';
                if ( useVertexColors ) cacheKey += 'vertex-colors:';
                if ( useFlatShading ) cacheKey += 'flat-shading:';

                let cachedMaterial = this.cache.get( cacheKey );

                if ( ! cachedMaterial ) {

                    cachedMaterial = material.clone();

                    if ( useVertexColors ) cachedMaterial.vertexColors = true;
                    if ( useFlatShading ) cachedMaterial.flatShading = true;

                    if ( useDerivativeTangents ) {

                        // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
                        if ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;
                        if ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;

                    }

                    this.cache.add( cacheKey, cachedMaterial );

                    this.associations.set( cachedMaterial, this.associations.get( material ) );

                }

                material = cachedMaterial;

            }

            // workarounds for mesh and geometry

            if ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {

                geometry.setAttribute( 'uv2', geometry.attributes.uv );

            }

            mesh.material = material;

        }

        getMaterialType( /* materialIndex */ ) {

            return MeshStandardMaterial;

        }

        /**
         * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
         * @param {number} materialIndex
         * @return {Promise<Material>}
         */
        loadMaterial( materialIndex ) {

            const parser = this;
            const json = this.json;
            const extensions = this.extensions;
            const materialDef = json.materials[ materialIndex ];

            let materialType;
            const materialParams = {};
            const materialExtensions = materialDef.extensions || {};

            const pending = [];

            if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {

                const sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];
                materialType = sgExtension.getMaterialType();
                pending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );

            } else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {

                const kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];
                materialType = kmuExtension.getMaterialType();
                pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );

            } else {

                // Specification:
                // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

                const metallicRoughness = materialDef.pbrMetallicRoughness || {};

                materialParams.color = new Color( 1.0, 1.0, 1.0 );
                materialParams.opacity = 1.0;

                if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

                    const array = metallicRoughness.baseColorFactor;

                    materialParams.color.fromArray( array );
                    materialParams.opacity = array[ 3 ];

                }

                if ( metallicRoughness.baseColorTexture !== undefined ) {

                    pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, sRGBEncoding ) );

                }

                materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
                materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

                if ( metallicRoughness.metallicRoughnessTexture !== undefined ) {

                    pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );
                    pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );

                }

                materialType = this._invokeOne( function ( ext ) {

                    return ext.getMaterialType && ext.getMaterialType( materialIndex );

                } );

                pending.push( Promise.all( this._invokeAll( function ( ext ) {

                    return ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );

                } ) ) );

            }

            if ( materialDef.doubleSided === true ) {

                materialParams.side = DoubleSide;

            }

            const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

            if ( alphaMode === ALPHA_MODES.BLEND ) {

                materialParams.transparent = true;

                // See: https://github.com/mrdoob/three.js/issues/17706
                materialParams.depthWrite = false;

            } else {

                materialParams.transparent = false;

                if ( alphaMode === ALPHA_MODES.MASK ) {

                    materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;

                }

            }

            if ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {

                pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );

                materialParams.normalScale = new Vector2( 1, 1 );

                if ( materialDef.normalTexture.scale !== undefined ) {

                    const scale = materialDef.normalTexture.scale;

                    materialParams.normalScale.set( scale, scale );

                }

            }

            if ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {

                pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );

                if ( materialDef.occlusionTexture.strength !== undefined ) {

                    materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;

                }

            }

            if ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {

                materialParams.emissive = new Color().fromArray( materialDef.emissiveFactor );

            }

            if ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {

                pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture, sRGBEncoding ) );

            }

            return Promise.all( pending ).then( function () {

                let material;

                if ( materialType === GLTFMeshStandardSGMaterial ) {

                    material = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );

                } else {

                    material = new materialType( materialParams );

                }

                if ( materialDef.name ) material.name = materialDef.name;

                assignExtrasToUserData( material, materialDef );

                parser.associations.set( material, { materials: materialIndex } );

                if ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );

                return material;

            } );

        }

        /** When Object3D instances are targeted by animation, they need unique names. */
        createUniqueName( originalName ) {

            const sanitizedName = PropertyBinding.sanitizeNodeName( originalName || '' );

            let name = sanitizedName;

            for ( let i = 1; this.nodeNamesUsed[ name ]; ++ i ) {

                name = sanitizedName + '_' + i;

            }

            this.nodeNamesUsed[ name ] = true;

            return name;

        }

        /**
         * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
         *
         * Creates BufferGeometries from primitives.
         *
         * @param {Array<GLTF.Primitive>} primitives
         * @return {Promise<Array<BufferGeometry>>}
         */
        loadGeometries( primitives ) {

            const parser = this;
            const extensions = this.extensions;
            const cache = this.primitiveCache;

            function createDracoPrimitive( primitive ) {

                return extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]
                    .decodePrimitive( primitive, parser )
                    .then( function ( geometry ) {

                        return addPrimitiveAttributes( geometry, primitive, parser );

                    } );

            }

            const pending = [];

            for ( let i = 0, il = primitives.length; i < il; i ++ ) {

                const primitive = primitives[ i ];
                const cacheKey = createPrimitiveKey( primitive );

                // See if we've already created this geometry
                const cached = cache[ cacheKey ];

                if ( cached ) {

                    // Use the cached geometry if it exists
                    pending.push( cached.promise );

                } else {

                    let geometryPromise;

                    if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {

                        // Use DRACO geometry if available
                        geometryPromise = createDracoPrimitive( primitive );

                    } else {

                        // Otherwise create a new geometry
                        geometryPromise = addPrimitiveAttributes( new BufferGeometry(), primitive, parser );

                    }

                    // Cache this geometry
                    cache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };

                    pending.push( geometryPromise );

                }

            }

            return Promise.all( pending );

        }

        /**
         * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
         * @param {number} meshIndex
         * @return {Promise<Group|Mesh|SkinnedMesh>}
         */
        loadMesh( meshIndex ) {

            const parser = this;
            const json = this.json;
            const extensions = this.extensions;

            const meshDef = json.meshes[ meshIndex ];
            const primitives = meshDef.primitives;

            const pending = [];

            for ( let i = 0, il = primitives.length; i < il; i ++ ) {

                const material = primitives[ i ].material === undefined
                    ? createDefaultMaterial( this.cache )
                    : this.getDependency( 'material', primitives[ i ].material );

                pending.push( material );

            }

            pending.push( parser.loadGeometries( primitives ) );

            return Promise.all( pending ).then( function ( results ) {

                const materials = results.slice( 0, results.length - 1 );
                const geometries = results[ results.length - 1 ];

                const meshes = [];

                for ( let i = 0, il = geometries.length; i < il; i ++ ) {

                    const geometry = geometries[ i ];
                    const primitive = primitives[ i ];

                    // 1. create Mesh

                    let mesh;

                    const material = materials[ i ];

                    if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||
                            primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||
                            primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||
                            primitive.mode === undefined ) {

                        // .isSkinnedMesh isn't in glTF spec. See ._markDefs()
                        mesh = meshDef.isSkinnedMesh === true
                            ? new SkinnedMesh( geometry, material )
                            : new Mesh( geometry, material );

                        if ( mesh.isSkinnedMesh === true && ! mesh.geometry.attributes.skinWeight.normalized ) {

                            // we normalize floating point skin weight array to fix malformed assets (see #15319)
                            // it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
                            mesh.normalizeSkinWeights();

                        }

                        if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {

                            mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode );

                        } else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {

                            mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode );

                        }

                    } else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {

                        mesh = new LineSegments( geometry, material );

                    } else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {

                        mesh = new Line( geometry, material );

                    } else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {

                        mesh = new LineLoop( geometry, material );

                    } else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {

                        mesh = new Points( geometry, material );

                    } else {

                        throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );

                    }

                    if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {

                        updateMorphTargets( mesh, meshDef );

                    }

                    mesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );

                    assignExtrasToUserData( mesh, meshDef );

                    if ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );

                    parser.assignFinalMaterial( mesh );

                    meshes.push( mesh );

                }

                for ( let i = 0, il = meshes.length; i < il; i ++ ) {

                    parser.associations.set( meshes[ i ], {
                        meshes: meshIndex,
                        primitives: i
                    } );

                }

                if ( meshes.length === 1 ) {

                    return meshes[ 0 ];

                }

                const group = new Group();

                parser.associations.set( group, { meshes: meshIndex } );

                for ( let i = 0, il = meshes.length; i < il; i ++ ) {

                    group.add( meshes[ i ] );

                }

                return group;

            } );

        }

        /**
         * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
         * @param {number} cameraIndex
         * @return {Promise<THREE.Camera>}
         */
        loadCamera( cameraIndex ) {

            let camera;
            const cameraDef = this.json.cameras[ cameraIndex ];
            const params = cameraDef[ cameraDef.type ];

            if ( ! params ) {

                console.warn( 'THREE.GLTFLoader: Missing camera parameters.' );
                return;

            }

            if ( cameraDef.type === 'perspective' ) {

                camera = new PerspectiveCamera( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );

            } else if ( cameraDef.type === 'orthographic' ) {

                camera = new OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );

            }

            if ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );

            assignExtrasToUserData( camera, cameraDef );

            return Promise.resolve( camera );

        }

        /**
         * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
         * @param {number} skinIndex
         * @return {Promise<Object>}
         */
        loadSkin( skinIndex ) {

            const skinDef = this.json.skins[ skinIndex ];

            const skinEntry = { joints: skinDef.joints };

            if ( skinDef.inverseBindMatrices === undefined ) {

                return Promise.resolve( skinEntry );

            }

            return this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {

                skinEntry.inverseBindMatrices = accessor;

                return skinEntry;

            } );

        }

        /**
         * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
         * @param {number} animationIndex
         * @return {Promise<AnimationClip>}
         */
        loadAnimation( animationIndex ) {

            const json = this.json;

            const animationDef = json.animations[ animationIndex ];

            const pendingNodes = [];
            const pendingInputAccessors = [];
            const pendingOutputAccessors = [];
            const pendingSamplers = [];
            const pendingTargets = [];

            for ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {

                const channel = animationDef.channels[ i ];
                const sampler = animationDef.samplers[ channel.sampler ];
                const target = channel.target;
                const name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.
                const input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;
                const output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;

                pendingNodes.push( this.getDependency( 'node', name ) );
                pendingInputAccessors.push( this.getDependency( 'accessor', input ) );
                pendingOutputAccessors.push( this.getDependency( 'accessor', output ) );
                pendingSamplers.push( sampler );
                pendingTargets.push( target );

            }

            return Promise.all( [

                Promise.all( pendingNodes ),
                Promise.all( pendingInputAccessors ),
                Promise.all( pendingOutputAccessors ),
                Promise.all( pendingSamplers ),
                Promise.all( pendingTargets )

            ] ).then( function ( dependencies ) {

                const nodes = dependencies[ 0 ];
                const inputAccessors = dependencies[ 1 ];
                const outputAccessors = dependencies[ 2 ];
                const samplers = dependencies[ 3 ];
                const targets = dependencies[ 4 ];

                const tracks = [];

                for ( let i = 0, il = nodes.length; i < il; i ++ ) {

                    const node = nodes[ i ];
                    const inputAccessor = inputAccessors[ i ];
                    const outputAccessor = outputAccessors[ i ];
                    const sampler = samplers[ i ];
                    const target = targets[ i ];

                    if ( node === undefined ) continue;

                    node.updateMatrix();
                    node.matrixAutoUpdate = true;

                    let TypedKeyframeTrack;

                    switch ( PATH_PROPERTIES[ target.path ] ) {

                        case PATH_PROPERTIES.weights:

                            TypedKeyframeTrack = NumberKeyframeTrack;
                            break;

                        case PATH_PROPERTIES.rotation:

                            TypedKeyframeTrack = QuaternionKeyframeTrack;
                            break;

                        case PATH_PROPERTIES.position:
                        case PATH_PROPERTIES.scale:
                        default:

                            TypedKeyframeTrack = VectorKeyframeTrack;
                            break;

                    }

                    const targetName = node.name ? node.name : node.uuid;

                    const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;

                    const targetNames = [];

                    if ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {

                        node.traverse( function ( object ) {

                            if ( object.morphTargetInfluences ) {

                                targetNames.push( object.name ? object.name : object.uuid );

                            }

                        } );

                    } else {

                        targetNames.push( targetName );

                    }

                    let outputArray = outputAccessor.array;

                    if ( outputAccessor.normalized ) {

                        const scale = getNormalizedComponentScale( outputArray.constructor );
                        const scaled = new Float32Array( outputArray.length );

                        for ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {

                            scaled[ j ] = outputArray[ j ] * scale;

                        }

                        outputArray = scaled;

                    }

                    for ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {

                        const track = new TypedKeyframeTrack(
                            targetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],
                            inputAccessor.array,
                            outputArray,
                            interpolation
                        );

                        // Override interpolation with custom factory method.
                        if ( sampler.interpolation === 'CUBICSPLINE' ) {

                            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {

                                // A CUBICSPLINE keyframe in glTF has three output values for each input value,
                                // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
                                // must be divided by three to get the interpolant's sampleSize argument.

                                const interpolantType = ( this instanceof QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;

                                return new interpolantType( this.times, this.values, this.getValueSize() / 3, result );

                            };

                            // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
                            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;

                        }

                        tracks.push( track );

                    }

                }

                const name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;

                return new AnimationClip( name, undefined, tracks );

            } );

        }

        createNodeMesh( nodeIndex ) {

            const json = this.json;
            const parser = this;
            const nodeDef = json.nodes[ nodeIndex ];

            if ( nodeDef.mesh === undefined ) return null;

            return parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {

                const node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );

                // if weights are provided on the node, override weights on the mesh.
                if ( nodeDef.weights !== undefined ) {

                    node.traverse( function ( o ) {

                        if ( ! o.isMesh ) return;

                        for ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {

                            o.morphTargetInfluences[ i ] = nodeDef.weights[ i ];

                        }

                    } );

                }

                return node;

            } );

        }

        /**
         * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
         * @param {number} nodeIndex
         * @return {Promise<Object3D>}
         */
        loadNode( nodeIndex ) {

            const json = this.json;
            const extensions = this.extensions;
            const parser = this;

            const nodeDef = json.nodes[ nodeIndex ];

            // reserve node's name before its dependencies, so the root has the intended name.
            const nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';

            return ( function () {

                const pending = [];

                const meshPromise = parser._invokeOne( function ( ext ) {

                    return ext.createNodeMesh && ext.createNodeMesh( nodeIndex );

                } );

                if ( meshPromise ) {

                    pending.push( meshPromise );

                }

                if ( nodeDef.camera !== undefined ) {

                    pending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {

                        return parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );

                    } ) );

                }

                parser._invokeAll( function ( ext ) {

                    return ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );

                } ).forEach( function ( promise ) {

                    pending.push( promise );

                } );

                return Promise.all( pending );

            }() ).then( function ( objects ) {

                let node;

                // .isBone isn't in glTF spec. See ._markDefs
                if ( nodeDef.isBone === true ) {

                    node = new Bone();

                } else if ( objects.length > 1 ) {

                    node = new Group();

                } else if ( objects.length === 1 ) {

                    node = objects[ 0 ];

                } else {

                    node = new Object3D();

                }

                if ( node !== objects[ 0 ] ) {

                    for ( let i = 0, il = objects.length; i < il; i ++ ) {

                        node.add( objects[ i ] );

                    }

                }

                if ( nodeDef.name ) {

                    node.userData.name = nodeDef.name;
                    node.name = nodeName;

                }

                assignExtrasToUserData( node, nodeDef );

                if ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );

                if ( nodeDef.matrix !== undefined ) {

                    const matrix = new Matrix4();
                    matrix.fromArray( nodeDef.matrix );
                    node.applyMatrix4( matrix );

                } else {

                    if ( nodeDef.translation !== undefined ) {

                        node.position.fromArray( nodeDef.translation );

                    }

                    if ( nodeDef.rotation !== undefined ) {

                        node.quaternion.fromArray( nodeDef.rotation );

                    }

                    if ( nodeDef.scale !== undefined ) {

                        node.scale.fromArray( nodeDef.scale );

                    }

                }

                if ( ! parser.associations.has( node ) ) {

                    parser.associations.set( node, {} );

                }

                parser.associations.get( node ).nodes = nodeIndex;

                return node;

            } );

        }

        /**
         * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
         * @param {number} sceneIndex
         * @return {Promise<Group>}
         */
        loadScene( sceneIndex ) {

            const json = this.json;
            const extensions = this.extensions;
            const sceneDef = this.json.scenes[ sceneIndex ];
            const parser = this;

            // Loader returns Group, not Scene.
            // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172
            const scene = new Group();
            if ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );

            assignExtrasToUserData( scene, sceneDef );

            if ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );

            const nodeIds = sceneDef.nodes || [];

            const pending = [];

            for ( let i = 0, il = nodeIds.length; i < il; i ++ ) {

                pending.push( buildNodeHierarchy( nodeIds[ i ], scene, json, parser ) );

            }

            return Promise.all( pending ).then( function () {

                // Removes dangling associations, associations that reference a node that
                // didn't make it into the scene.
                const reduceAssociations = ( node ) => {

                    const reducedAssociations = new Map();

                    for ( const [ key, value ] of parser.associations ) {

                        if ( key instanceof Material || key instanceof Texture ) {

                            reducedAssociations.set( key, value );

                        }

                    }

                    node.traverse( ( node ) => {

                        const mappings = parser.associations.get( node );

                        if ( mappings != null ) {

                            reducedAssociations.set( node, mappings );

                        }

                    } );

                    return reducedAssociations;

                };

                parser.associations = reduceAssociations( scene );

                return scene;

            } );

        }

    }

    function buildNodeHierarchy( nodeId, parentObject, json, parser ) {

        const nodeDef = json.nodes[ nodeId ];

        return parser.getDependency( 'node', nodeId ).then( function ( node ) {

            if ( nodeDef.skin === undefined ) return node;

            // build skeleton here as well

            let skinEntry;

            return parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {

                skinEntry = skin;

                const pendingJoints = [];

                for ( let i = 0, il = skinEntry.joints.length; i < il; i ++ ) {

                    pendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );

                }

                return Promise.all( pendingJoints );

            } ).then( function ( jointNodes ) {

                node.traverse( function ( mesh ) {

                    if ( ! mesh.isMesh ) return;

                    const bones = [];
                    const boneInverses = [];

                    for ( let j = 0, jl = jointNodes.length; j < jl; j ++ ) {

                        const jointNode = jointNodes[ j ];

                        if ( jointNode ) {

                            bones.push( jointNode );

                            const mat = new Matrix4();

                            if ( skinEntry.inverseBindMatrices !== undefined ) {

                                mat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );

                            }

                            boneInverses.push( mat );

                        } else {

                            console.warn( 'THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[ j ] );

                        }

                    }

                    mesh.bind( new Skeleton( bones, boneInverses ), mesh.matrixWorld );

                } );

                return node;

            } );

        } ).then( function ( node ) {

            // build node hierarchy

            parentObject.add( node );

            const pending = [];

            if ( nodeDef.children ) {

                const children = nodeDef.children;

                for ( let i = 0, il = children.length; i < il; i ++ ) {

                    const child = children[ i ];
                    pending.push( buildNodeHierarchy( child, node, json, parser ) );

                }

            }

            return Promise.all( pending );

        } );

    }

    /**
     * @param {BufferGeometry} geometry
     * @param {GLTF.Primitive} primitiveDef
     * @param {GLTFParser} parser
     */
    function computeBounds( geometry, primitiveDef, parser ) {

        const attributes = primitiveDef.attributes;

        const box = new Box3();

        if ( attributes.POSITION !== undefined ) {

            const accessor = parser.json.accessors[ attributes.POSITION ];

            const min = accessor.min;
            const max = accessor.max;

            // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

            if ( min !== undefined && max !== undefined ) {

                box.set(
                    new Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),
                    new Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )
                );

                if ( accessor.normalized ) {

                    const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
                    box.min.multiplyScalar( boxScale );
                    box.max.multiplyScalar( boxScale );

                }

            } else {

                console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

                return;

            }

        } else {

            return;

        }

        const targets = primitiveDef.targets;

        if ( targets !== undefined ) {

            const maxDisplacement = new Vector3();
            const vector = new Vector3();

            for ( let i = 0, il = targets.length; i < il; i ++ ) {

                const target = targets[ i ];

                if ( target.POSITION !== undefined ) {

                    const accessor = parser.json.accessors[ target.POSITION ];
                    const min = accessor.min;
                    const max = accessor.max;

                    // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

                    if ( min !== undefined && max !== undefined ) {

                        // we need to get max of absolute components because target weight is [-1,1]
                        vector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );
                        vector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );
                        vector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );


                        if ( accessor.normalized ) {

                            const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
                            vector.multiplyScalar( boxScale );

                        }

                        // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
                        // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
                        // are used to implement key-frame animations and as such only two are active at a time - this results in very large
                        // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
                        maxDisplacement.max( vector );

                    } else {

                        console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

                    }

                }

            }

            // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
            box.expandByVector( maxDisplacement );

        }

        geometry.boundingBox = box;

        const sphere = new Sphere();

        box.getCenter( sphere.center );
        sphere.radius = box.min.distanceTo( box.max ) / 2;

        geometry.boundingSphere = sphere;

    }

    /**
     * @param {BufferGeometry} geometry
     * @param {GLTF.Primitive} primitiveDef
     * @param {GLTFParser} parser
     * @return {Promise<BufferGeometry>}
     */
    function addPrimitiveAttributes( geometry, primitiveDef, parser ) {

        const attributes = primitiveDef.attributes;

        const pending = [];

        function assignAttributeAccessor( accessorIndex, attributeName ) {

            return parser.getDependency( 'accessor', accessorIndex )
                .then( function ( accessor ) {

                    geometry.setAttribute( attributeName, accessor );

                } );

        }

        for ( const gltfAttributeName in attributes ) {

            const threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();

            // Skip attributes already provided by e.g. Draco extension.
            if ( threeAttributeName in geometry.attributes ) continue;

            pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );

        }

        if ( primitiveDef.indices !== undefined && ! geometry.index ) {

            const accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {

                geometry.setIndex( accessor );

            } );

            pending.push( accessor );

        }

        assignExtrasToUserData( geometry, primitiveDef );

        computeBounds( geometry, primitiveDef, parser );

        return Promise.all( pending ).then( function () {

            return primitiveDef.targets !== undefined
                ? addMorphTargets( geometry, primitiveDef.targets, parser )
                : geometry;

        } );

    }

    /**
     * @param {BufferGeometry} geometry
     * @param {Number} drawMode
     * @return {BufferGeometry}
     */
    function toTrianglesDrawMode( geometry, drawMode ) {

        let index = geometry.getIndex();

        // generate index if not present

        if ( index === null ) {

            const indices = [];

            const position = geometry.getAttribute( 'position' );

            if ( position !== undefined ) {

                for ( let i = 0; i < position.count; i ++ ) {

                    indices.push( i );

                }

                geometry.setIndex( indices );
                index = geometry.getIndex();

            } else {

                console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );
                return geometry;

            }

        }

        //

        const numberOfTriangles = index.count - 2;
        const newIndices = [];

        if ( drawMode === TriangleFanDrawMode ) {

            // gl.TRIANGLE_FAN

            for ( let i = 1; i <= numberOfTriangles; i ++ ) {

                newIndices.push( index.getX( 0 ) );
                newIndices.push( index.getX( i ) );
                newIndices.push( index.getX( i + 1 ) );

            }

        } else {

            // gl.TRIANGLE_STRIP

            for ( let i = 0; i < numberOfTriangles; i ++ ) {

                if ( i % 2 === 0 ) {

                    newIndices.push( index.getX( i ) );
                    newIndices.push( index.getX( i + 1 ) );
                    newIndices.push( index.getX( i + 2 ) );


                } else {

                    newIndices.push( index.getX( i + 2 ) );
                    newIndices.push( index.getX( i + 1 ) );
                    newIndices.push( index.getX( i ) );

                }

            }

        }

        if ( ( newIndices.length / 3 ) !== numberOfTriangles ) {

            console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );

        }

        // build final geometry

        const newGeometry = geometry.clone();
        newGeometry.setIndex( newIndices );

        return newGeometry;

    }

    /**
     * @webxr-input-profiles/motion-controllers 1.0.0 https://github.com/immersive-web/webxr-input-profiles
     */

    const Constants = {
      Handedness: Object.freeze({
        NONE: 'none',
        LEFT: 'left',
        RIGHT: 'right'
      }),

      ComponentState: Object.freeze({
        DEFAULT: 'default',
        TOUCHED: 'touched',
        PRESSED: 'pressed'
      }),

      ComponentProperty: Object.freeze({
        BUTTON: 'button',
        X_AXIS: 'xAxis',
        Y_AXIS: 'yAxis',
        STATE: 'state'
      }),

      ComponentType: Object.freeze({
        TRIGGER: 'trigger',
        SQUEEZE: 'squeeze',
        TOUCHPAD: 'touchpad',
        THUMBSTICK: 'thumbstick',
        BUTTON: 'button'
      }),

      ButtonTouchThreshold: 0.05,

      AxisTouchThreshold: 0.1,

      VisualResponseProperty: Object.freeze({
        TRANSFORM: 'transform',
        VISIBILITY: 'visibility'
      })
    };

    /**
     * @description Static helper function to fetch a JSON file and turn it into a JS object
     * @param {string} path - Path to JSON file to be fetched
     */
    async function fetchJsonFile(path) {
      const response = await fetch(path);
      if (!response.ok) {
        throw new Error(response.statusText);
      } else {
        return response.json();
      }
    }

    async function fetchProfilesList(basePath) {
      if (!basePath) {
        throw new Error('No basePath supplied');
      }

      const profileListFileName = 'profilesList.json';
      const profilesList = await fetchJsonFile(`${basePath}/${profileListFileName}`);
      return profilesList;
    }

    async function fetchProfile(xrInputSource, basePath, defaultProfile = null, getAssetPath = true) {
      if (!xrInputSource) {
        throw new Error('No xrInputSource supplied');
      }

      if (!basePath) {
        throw new Error('No basePath supplied');
      }

      // Get the list of profiles
      const supportedProfilesList = await fetchProfilesList(basePath);

      // Find the relative path to the first requested profile that is recognized
      let match;
      xrInputSource.profiles.some((profileId) => {
        const supportedProfile = supportedProfilesList[profileId];
        if (supportedProfile) {
          match = {
            profileId,
            profilePath: `${basePath}/${supportedProfile.path}`,
            deprecated: !!supportedProfile.deprecated
          };
        }
        return !!match;
      });

      if (!match) {
        if (!defaultProfile) {
          throw new Error('No matching profile name found');
        }

        const supportedProfile = supportedProfilesList[defaultProfile];
        if (!supportedProfile) {
          throw new Error(`No matching profile name found and default profile "${defaultProfile}" missing.`);
        }

        match = {
          profileId: defaultProfile,
          profilePath: `${basePath}/${supportedProfile.path}`,
          deprecated: !!supportedProfile.deprecated
        };
      }

      const profile = await fetchJsonFile(match.profilePath);

      let assetPath;
      if (getAssetPath) {
        let layout;
        if (xrInputSource.handedness === 'any') {
          layout = profile.layouts[Object.keys(profile.layouts)[0]];
        } else {
          layout = profile.layouts[xrInputSource.handedness];
        }
        if (!layout) {
          throw new Error(
            `No matching handedness, ${xrInputSource.handedness}, in profile ${match.profileId}`
          );
        }

        if (layout.assetPath) {
          assetPath = match.profilePath.replace('profile.json', layout.assetPath);
        }
      }

      return { profile, assetPath };
    }

    /** @constant {Object} */
    const defaultComponentValues = {
      xAxis: 0,
      yAxis: 0,
      button: 0,
      state: Constants.ComponentState.DEFAULT
    };

    /**
     * @description Converts an X, Y coordinate from the range -1 to 1 (as reported by the Gamepad
     * API) to the range 0 to 1 (for interpolation). Also caps the X, Y values to be bounded within
     * a circle. This ensures that thumbsticks are not animated outside the bounds of their physical
     * range of motion and touchpads do not report touch locations off their physical bounds.
     * @param {number} x The original x coordinate in the range -1 to 1
     * @param {number} y The original y coordinate in the range -1 to 1
     */
    function normalizeAxes(x = 0, y = 0) {
      let xAxis = x;
      let yAxis = y;

      // Determine if the point is outside the bounds of the circle
      // and, if so, place it on the edge of the circle
      const hypotenuse = Math.sqrt((x * x) + (y * y));
      if (hypotenuse > 1) {
        const theta = Math.atan2(y, x);
        xAxis = Math.cos(theta);
        yAxis = Math.sin(theta);
      }

      // Scale and move the circle so values are in the interpolation range.  The circle's origin moves
      // from (0, 0) to (0.5, 0.5). The circle's radius scales from 1 to be 0.5.
      const result = {
        normalizedXAxis: (xAxis * 0.5) + 0.5,
        normalizedYAxis: (yAxis * 0.5) + 0.5
      };
      return result;
    }

    /**
     * Contains the description of how the 3D model should visually respond to a specific user input.
     * This is accomplished by initializing the object with the name of a node in the 3D model and
     * property that need to be modified in response to user input, the name of the nodes representing
     * the allowable range of motion, and the name of the input which triggers the change. In response
     * to the named input changing, this object computes the appropriate weighting to use for
     * interpolating between the range of motion nodes.
     */
    class VisualResponse {
      constructor(visualResponseDescription) {
        this.componentProperty = visualResponseDescription.componentProperty;
        this.states = visualResponseDescription.states;
        this.valueNodeName = visualResponseDescription.valueNodeName;
        this.valueNodeProperty = visualResponseDescription.valueNodeProperty;

        if (this.valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM) {
          this.minNodeName = visualResponseDescription.minNodeName;
          this.maxNodeName = visualResponseDescription.maxNodeName;
        }

        // Initializes the response's current value based on default data
        this.value = 0;
        this.updateFromComponent(defaultComponentValues);
      }

      /**
       * Computes the visual response's interpolation weight based on component state
       * @param {Object} componentValues - The component from which to update
       * @param {number} xAxis - The reported X axis value of the component
       * @param {number} yAxis - The reported Y axis value of the component
       * @param {number} button - The reported value of the component's button
       * @param {string} state - The component's active state
       */
      updateFromComponent({
        xAxis, yAxis, button, state
      }) {
        const { normalizedXAxis, normalizedYAxis } = normalizeAxes(xAxis, yAxis);
        switch (this.componentProperty) {
          case Constants.ComponentProperty.X_AXIS:
            this.value = (this.states.includes(state)) ? normalizedXAxis : 0.5;
            break;
          case Constants.ComponentProperty.Y_AXIS:
            this.value = (this.states.includes(state)) ? normalizedYAxis : 0.5;
            break;
          case Constants.ComponentProperty.BUTTON:
            this.value = (this.states.includes(state)) ? button : 0;
            break;
          case Constants.ComponentProperty.STATE:
            if (this.valueNodeProperty === Constants.VisualResponseProperty.VISIBILITY) {
              this.value = (this.states.includes(state));
            } else {
              this.value = this.states.includes(state) ? 1.0 : 0.0;
            }
            break;
          default:
            throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);
        }
      }
    }

    class Component {
      /**
       * @param {Object} componentId - Id of the component
       * @param {Object} componentDescription - Description of the component to be created
       */
      constructor(componentId, componentDescription) {
        if (!componentId
         || !componentDescription
         || !componentDescription.visualResponses
         || !componentDescription.gamepadIndices
         || Object.keys(componentDescription.gamepadIndices).length === 0) {
          throw new Error('Invalid arguments supplied');
        }

        this.id = componentId;
        this.type = componentDescription.type;
        this.rootNodeName = componentDescription.rootNodeName;
        this.touchPointNodeName = componentDescription.touchPointNodeName;

        // Build all the visual responses for this component
        this.visualResponses = {};
        Object.keys(componentDescription.visualResponses).forEach((responseName) => {
          const visualResponse = new VisualResponse(componentDescription.visualResponses[responseName]);
          this.visualResponses[responseName] = visualResponse;
        });

        // Set default values
        this.gamepadIndices = Object.assign({}, componentDescription.gamepadIndices);

        this.values = {
          state: Constants.ComponentState.DEFAULT,
          button: (this.gamepadIndices.button !== undefined) ? 0 : undefined,
          xAxis: (this.gamepadIndices.xAxis !== undefined) ? 0 : undefined,
          yAxis: (this.gamepadIndices.yAxis !== undefined) ? 0 : undefined
        };
      }

      get data() {
        const data = { id: this.id, ...this.values };
        return data;
      }

      /**
       * @description Poll for updated data based on current gamepad state
       * @param {Object} gamepad - The gamepad object from which the component data should be polled
       */
      updateFromGamepad(gamepad) {
        // Set the state to default before processing other data sources
        this.values.state = Constants.ComponentState.DEFAULT;

        // Get and normalize button
        if (this.gamepadIndices.button !== undefined
            && gamepad.buttons.length > this.gamepadIndices.button) {
          const gamepadButton = gamepad.buttons[this.gamepadIndices.button];
          this.values.button = gamepadButton.value;
          this.values.button = (this.values.button < 0) ? 0 : this.values.button;
          this.values.button = (this.values.button > 1) ? 1 : this.values.button;

          // Set the state based on the button
          if (gamepadButton.pressed || this.values.button === 1) {
            this.values.state = Constants.ComponentState.PRESSED;
          } else if (gamepadButton.touched || this.values.button > Constants.ButtonTouchThreshold) {
            this.values.state = Constants.ComponentState.TOUCHED;
          }
        }

        // Get and normalize x axis value
        if (this.gamepadIndices.xAxis !== undefined
            && gamepad.axes.length > this.gamepadIndices.xAxis) {
          this.values.xAxis = gamepad.axes[this.gamepadIndices.xAxis];
          this.values.xAxis = (this.values.xAxis < -1) ? -1 : this.values.xAxis;
          this.values.xAxis = (this.values.xAxis > 1) ? 1 : this.values.xAxis;

          // If the state is still default, check if the xAxis makes it touched
          if (this.values.state === Constants.ComponentState.DEFAULT
            && Math.abs(this.values.xAxis) > Constants.AxisTouchThreshold) {
            this.values.state = Constants.ComponentState.TOUCHED;
          }
        }

        // Get and normalize Y axis value
        if (this.gamepadIndices.yAxis !== undefined
            && gamepad.axes.length > this.gamepadIndices.yAxis) {
          this.values.yAxis = gamepad.axes[this.gamepadIndices.yAxis];
          this.values.yAxis = (this.values.yAxis < -1) ? -1 : this.values.yAxis;
          this.values.yAxis = (this.values.yAxis > 1) ? 1 : this.values.yAxis;

          // If the state is still default, check if the yAxis makes it touched
          if (this.values.state === Constants.ComponentState.DEFAULT
            && Math.abs(this.values.yAxis) > Constants.AxisTouchThreshold) {
            this.values.state = Constants.ComponentState.TOUCHED;
          }
        }

        // Update the visual response weights based on the current component data
        Object.values(this.visualResponses).forEach((visualResponse) => {
          visualResponse.updateFromComponent(this.values);
        });
      }
    }

    /**
      * @description Builds a motion controller with components and visual responses based on the
      * supplied profile description. Data is polled from the xrInputSource's gamepad.
      * @author Nell Waliczek / https://github.com/NellWaliczek
    */
    class MotionController {
      /**
       * @param {Object} xrInputSource - The XRInputSource to build the MotionController around
       * @param {Object} profile - The best matched profile description for the supplied xrInputSource
       * @param {Object} assetUrl
       */
      constructor(xrInputSource, profile, assetUrl) {
        if (!xrInputSource) {
          throw new Error('No xrInputSource supplied');
        }

        if (!profile) {
          throw new Error('No profile supplied');
        }

        this.xrInputSource = xrInputSource;
        this.assetUrl = assetUrl;
        this.id = profile.profileId;

        // Build child components as described in the profile description
        this.layoutDescription = profile.layouts[xrInputSource.handedness];
        this.components = {};
        Object.keys(this.layoutDescription.components).forEach((componentId) => {
          const componentDescription = this.layoutDescription.components[componentId];
          this.components[componentId] = new Component(componentId, componentDescription);
        });

        // Initialize components based on current gamepad state
        this.updateFromGamepad();
      }

      get gripSpace() {
        return this.xrInputSource.gripSpace;
      }

      get targetRaySpace() {
        return this.xrInputSource.targetRaySpace;
      }

      /**
       * @description Returns a subset of component data for simplified debugging
       */
      get data() {
        const data = [];
        Object.values(this.components).forEach((component) => {
          data.push(component.data);
        });
        return data;
      }

      /**
       * @description Poll for updated data based on current gamepad state
       */
      updateFromGamepad() {
        Object.values(this.components).forEach((component) => {
          component.updateFromGamepad(this.xrInputSource.gamepad);
        });
      }
    }

    /*
    import {
        Mesh,
        MeshBasicMaterial,
        Object3D,
        SphereGeometry,
    } from 'three';
    */

    const DEFAULT_PROFILES_PATH = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles';
    const DEFAULT_PROFILE = 'generic-trigger';

    class XRControllerModel extends THREE.Object3D {

        constructor() {

            super();

            this.motionController = null;
            this.envMap = null;

        }

        setEnvironmentMap( envMap ) {

            if ( this.envMap == envMap ) {

                return this;

            }

            this.envMap = envMap;
            this.traverse( ( child ) => {

                if ( child.isMesh ) {

                    child.material.envMap = this.envMap;
                    child.material.needsUpdate = true;

                }

            } );

            return this;

        }

        /**
         * Polls data from the XRInputSource and updates the model's components to match
         * the real world data
         */
        updateMatrixWorld( force ) {

            super.updateMatrixWorld( force );

            if ( ! this.motionController ) return;

            // Cause the MotionController to poll the Gamepad for data
            this.motionController.updateFromGamepad();

            // Update the 3D model to reflect the button, thumbstick, and touchpad state
            Object.values( this.motionController.components ).forEach( ( component ) => {

                // Update node data based on the visual responses' current states
                Object.values( component.visualResponses ).forEach( ( visualResponse ) => {

                    const { valueNode, minNode, maxNode, value, valueNodeProperty } = visualResponse;

                    // Skip if the visual response node is not found. No error is needed,
                    // because it will have been reported at load time.
                    if ( ! valueNode ) return;

                    // Calculate the new properties based on the weight supplied
                    if ( valueNodeProperty === Constants.VisualResponseProperty.VISIBILITY ) {

                        valueNode.visible = value;

                    } else if ( valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM ) {

                        valueNode.quaternion.slerpQuaternions(
                            minNode.quaternion,
                            maxNode.quaternion,
                            value
                        );

                        valueNode.position.lerpVectors(
                            minNode.position,
                            maxNode.position,
                            value
                        );

                    }

                } );

            } );

        }

    }

    /**
     * Walks the model's tree to find the nodes needed to animate the components and
     * saves them to the motionContoller components for use in the frame loop. When
     * touchpads are found, attaches a touch dot to them.
     */
    function findNodes( motionController, scene ) {

        // Loop through the components and find the nodes needed for each components' visual responses
        Object.values( motionController.components ).forEach( ( component ) => {

            const { type, touchPointNodeName, visualResponses } = component;

            if ( type === Constants.ComponentType.TOUCHPAD ) {

                component.touchPointNode = scene.getObjectByName( touchPointNodeName );
                if ( component.touchPointNode ) {

                    // Attach a touch dot to the touchpad.
                    const sphereGeometry = new SphereGeometry( 0.001 );
                    const material = new MeshBasicMaterial( {color: 0x0000FF } );
                    const sphere = new Mesh( sphereGeometry, material );
                    component.touchPointNode.add( sphere );

                } else {

                    console.warn( `Could not find touch dot, ${component.touchPointNodeName}, in touchpad component ${component.id}` );

                }

            }

            // Loop through all the visual responses to be applied to this component
            Object.values( visualResponses ).forEach( ( visualResponse ) => {

                const { valueNodeName, minNodeName, maxNodeName, valueNodeProperty } = visualResponse;

                // If animating a transform, find the two nodes to be interpolated between.
                if ( valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM ) {

                    visualResponse.minNode = scene.getObjectByName( minNodeName );
                    visualResponse.maxNode = scene.getObjectByName( maxNodeName );

                    // If the extents cannot be found, skip this animation
                    if ( ! visualResponse.minNode ) {

                        console.warn( `Could not find ${minNodeName} in the model` );
                        return;

                    }

                    if ( ! visualResponse.maxNode ) {

                        console.warn( `Could not find ${maxNodeName} in the model` );
                        return;

                    }

                }

                // If the target node cannot be found, skip this animation
                visualResponse.valueNode = scene.getObjectByName( valueNodeName );
                if ( ! visualResponse.valueNode ) {

                    console.warn( `Could not find ${valueNodeName} in the model` );

                }

            } );

        } );

    }

    function addAssetSceneToControllerModel( controllerModel, scene ) {

        // Find the nodes needed for animation and cache them on the motionController.
        findNodes( controllerModel.motionController, scene );

        // Apply any environment map that the mesh already has set.
        if ( controllerModel.envMap ) {

            scene.traverse( ( child ) => {

                if ( child.isMesh ) {

                    child.material.envMap = controllerModel.envMap;
                    child.material.needsUpdate = true;

                }

            } );

        }

        // Add the glTF scene to the controllerModel.
        controllerModel.add( scene );

    }

    class XRControllerModelFactory {

        constructor( gltfLoader = null ) {

            this.gltfLoader = gltfLoader;
            this.path = DEFAULT_PROFILES_PATH;
            this._assetCache = {};

            // If a GLTFLoader wasn't supplied to the constructor create a new one.
            if ( ! this.gltfLoader ) {

                this.gltfLoader = new GLTFLoader();

            }

        }

        createControllerModel( controller ) {

            const controllerModel = new XRControllerModel();
            let scene = null;

            controller.addEventListener( 'connected', ( event ) => {

                const xrInputSource = event.data;

                if ( xrInputSource.targetRayMode !== 'tracked-pointer' || ! xrInputSource.gamepad ) return;

                fetchProfile( xrInputSource, this.path, DEFAULT_PROFILE ).then( ( { profile, assetPath } ) => {

                    controllerModel.motionController = new MotionController(
                        xrInputSource,
                        profile,
                        assetPath
                    );

                    const cachedAsset = this._assetCache[ controllerModel.motionController.assetUrl ];
                    if ( cachedAsset ) {

                        scene = cachedAsset.scene.clone();

                        addAssetSceneToControllerModel( controllerModel, scene );

                    } else {

                        if ( ! this.gltfLoader ) {

                            throw new Error( 'GLTFLoader not set.' );

                        }

                        this.gltfLoader.setPath( '' );
                        this.gltfLoader.load( controllerModel.motionController.assetUrl, ( asset ) => {

                            this._assetCache[ controllerModel.motionController.assetUrl ] = asset;

                            scene = asset.scene.clone();

                            addAssetSceneToControllerModel( controllerModel, scene );

                        },
                        null,
                        () => {

                            throw new Error( `Asset ${controllerModel.motionController.assetUrl} missing or malformed.` );

                        } );

                    }

                } ).catch( ( err ) => {

                    console.warn( err );

                } );

            } );

            controller.addEventListener( 'disconnected', () => {

                controllerModel.motionController = null;
                controllerModel.remove( scene );
                scene = null;

            } );

            return controllerModel;

        }

    }

    //import * as THREE from './three/three.module.js';

    // copied from https://github.com/NikLever/Learn-WebXR/blob/master/libs/ControllerGestures.js
    // created by Nik Lever

    class ControllerGestures extends THREE.EventDispatcher{
        constructor( renderer ){
            super();
            
            if (renderer === undefined){
                console.error('ControllerGestures must be passed a renderer');
                return;
            }
            
            const clock = new THREE.Clock();
            
            this.controller1 = renderer.xr.getController(0);
            this.controller1.userData.gestures = { index: 0 };
            this.controller1.userData.selectPressed = false;
            this.controller1.addEventListener( 'selectstart', onSelectStart );
            this.controller1.addEventListener( 'selectend', onSelectEnd );
            
            this.controller2 = renderer.xr.getController(1);
            this.controller2.userData.gestures = { index: 1 };
            this.controller2.userData.selectPressed = false;
            this.controller2.addEventListener( 'selectstart', onSelectStart );
            this.controller2.addEventListener( 'selectend', onSelectEnd );
            
            this.doubleClickLimit = 0.2;
            this.pressMinimum = 0.4;
            this.right = new THREE.Vector3(1,0,0);
            this.up = new THREE.Vector3(0,1,0);
            
            this.type = 'unknown';
            //this.touchCount = 0;

            this.prevTap = 'none';
            
            this.clock = clock;
            
            const self = this;
            
            function onSelectStart( ){
                const data = this.userData.gestures;
                
                data.startPosition = undefined;
                data.startTime = clock.getElapsedTime();
                
                if ( self.type.indexOf('tap') == -1) data.taps = 0;
                
                self.type = 'unknown';
                this.userData.selectPressed = true;
                
                //self.touchCount++;
                
                //console.log( `onSelectStart touchCount: ${ self.touchCount }` );
            }
            
            function onSelectEnd( ){
                const data = this.userData.gestures;
                
                data.endTime = clock.getElapsedTime();
                const startToEnd = data.endTime - data.startTime;
                
                //console.log(`ControllerGestures.onSelectEnd: startToEnd:${startToEnd.toFixed(2)} taps:${data.taps}`);
    /*             
                if (self.type === 'swipe'){
                    const direction = ( self.controller1.position.y < data.startPosition.y) ? "DOWN" : "UP";
                    self.dispatchEvent( { type:'swipe', direction } );
                    self.type = 'unknown';
                }else 
              
                if (self.type !== "pinch" && self.type !== "rotate" && self.type !== 'pan'){
                    // if ( startToEnd < self.doubleClickLimit ){
                        self.type = "tap";
                        //data.taps++;
                    // }
                    // else if ( startToEnd > self.pressMinimum ){
                    //     self.dispatchEvent( { type: 'press', position: self.controller1.position, matrixWorld: self.controller1.matrixWorld }   );
                    //     self.type = 'unknown';
                    // }
                }else{
                    self.type = 'unknown';
                }
    */

                if ( startToEnd < self.doubleClickLimit ){
                    data.taps++;
                }
                self.type = 'tap';

                this.userData.selectPressed = false;
                data.startPosition = undefined;
                
                //self.touchCount--;
            }
        }
        
        get multiTouch(){
            let result;
            if ( this.controller1 === undefined || this.controller2 === undefined ){   
                result = false;
            }else {
                result = this.controller1.userData.selectPressed && this.controller2.userData.selectPressed;
            }
            //console.log( `ControllerGestures multiTouch: ${result} touchCount:${self.touchCount}`);
            return result;
        }
        
        get touch(){
            let result;
            if ( this.controller1 === undefined || this.controller2 === undefined ){   
                result = false;
            }else {
                result = this.controller1.userData.selectPressed || this.controller2.userData.selectPressed;
            }
            //console.log( `ControllerGestures touch: ${result}`);
            return result;
        }
        
        get debugMsg(){
            return this.type;
        }
        
        update(){
            const data1 = this.controller1.userData.gestures;
            const data2 = this.controller2.userData.gestures;
            const currentTime = this.clock.getElapsedTime();
            
            let elapsedTime;
            
            if (this.controller1.userData.selectPressed && data1.startPosition === undefined){
                elapsedTime = currentTime - data1.startTime;
                if (elapsedTime > 0.05 ) data1.startPosition = this.controller1.position.clone();
            }
            
            if (this.controller2.userData.selectPressed && data2.startPosition === undefined){
                elapsedTime = currentTime - data2.startTime;
                if (elapsedTime > 0.05 ) data2.startPosition = this.controller2.position.clone();
            }
           
            if (!this.controller1.userData.selectPressed && this.type === 'tap' ){
                //Only dispatch event after double click limit is passed
                elapsedTime = this.clock.getElapsedTime() - data1.endTime;
                if (elapsedTime > this.doubleClickLimit){
                    //console.log( `ControllerGestures.update dispatchEvent taps:${data1.taps}` );
                    switch( data1.taps ){
                        case 1:
                            //this.dispatchEvent( { type: 'tap', position: this.controller1.position, matrixWorld: this.controller1.matrixWorld } );
                            self.prevTap = 'tap';
                            break;
                        case 2:
                            this.dispatchEvent( { type: 'doubletap', position: this.controller1.position, matrixWorld: this.controller1.matrixWorld } );
                            self.prevTap = 'doubletap';
                            break;
                    }
                    this.type = "unknown";
                    data1.taps = 0;
                }
            }

            if (this.type === 'unknown' && this.touch){
                //if (data1.startPosition !== undefined){
                    //if (this.multiTouch){

                    if(self.prevTap == 'doubletap') {
                        //if (data2.startPosition !== undefined){
                            //startPosition is undefined for 1/20 sec
                            //test for pinch or rotate

                            // const startDistance = data1.startPosition.distanceTo( data2.startPosition );
                            // const currentDistance = this.controller1.position.distanceTo( this.controller2.position );
                            // const delta = currentDistance - startDistance;

                            // if ( Math.abs(delta) > 0.01 ){
                                this.type = 'pinch';
                                this.startDistance = this.controller1.position.distanceTo( this.controller2.position );
                                //this.dispatchEvent( { type: 'pinch', delta: 0, scale: 1, initialise: true } );
                                this.dispatchEvent( { type: 'pinch', delta: new THREE.Vector3(0,0,0), scale: 1, initialise: true } );
                            // }else{
                            //     const v1 = data2.startPosition.clone().sub( data1.startPosition ).normalize();
                            //     const v2 = this.controller2.position.clone().sub( this.controller1.position ).normalize();
                            //     const theta = v1.angleTo( v2 );
                            //     if (Math.abs(theta) > 0.2){
                            //         this.type = 'rotate';
                            //         this.startVector = v2.clone();
                            //         this.dispatchEvent( { type: 'rotate', theta: 0, initialise: true } );
                            //     }
                            // }
                        //}
                    }else { //if(self.prevTap == 'tap') {
                        //test for swipe or pan
                        // let dist = data1.startPosition.distanceTo( this.controller1.position );
                        // elapsedTime = this.clock.getElapsedTime() - data1.startTime;
                        // const velocity = dist/elapsedTime;

                        //console.log(`dist:${dist.toFixed(3)} velocity:${velocity.toFixed(3)}`);
                        // if ( dist > 0.01 && velocity > 0.1 ){
                        //     const v = this.controller1.position.clone().sub( data1.startPosition );
                        //     let maxY = (Math.abs(v.y) > Math.abs(v.x)) && (Math.abs(v.y) > Math.abs(v.z));
                        //     if ( maxY )this.type = "swipe";
                        // }else if (dist > 0.006 && velocity < 0.03){
                            this.type = "pan";
                            this.startPosition = this.controller1.position.clone();
                            this.dispatchEvent( { type: 'pan', delta: new THREE.Vector3(0,0,0), initialise: true } );
                        // }
                    }
                //}
            }else if (this.type === 'pinch' || this.type === 'pan'){
                //if (this.type === 'pinch'){
                //if (this.multiTouch){

                if(self.prevTap == 'doubletap') {
                    if (this.controller2.position) {
                        const currentDistance = this.controller1.position.distanceTo( this.controller2.position );
                        // const delta = currentDistance - this.startDistance;
                        const scale = currentDistance/this.startDistance;

                        const delta = this.controller1.position.clone().sub( this.startPosition );
                        this.dispatchEvent( { type: 'pinch', delta, scale });
                    }

                // }else if (this.type === 'rotate'){
                //     const v = this.controller2.position.clone().sub( this.controller1.position ).normalize();
                //     let theta = this.startVector.angleTo( v );
                //     const cross = this.startVector.clone().cross( v );
                //     if (this.up.dot(cross) > 0) theta = -theta;
                //     this.dispatchEvent( { type: 'rotate', theta } );
    /*
                //}else if (this.type === 'pan'){
                } else { //if(self.prevTap == 'tap') {
                    // const delta = this.controller1.position.clone().sub( this.startPosition );
                    // this.dispatchEvent( { type: 'pan', delta } );

                    const position = this.controller1.position.clone();
                    this.dispatchEvent( { type: 'pan', position } );
    */
                }
            }
        }
    }

    // from https://github.com/NikLever/Learn-WebXR/tree/master/libs, by Nik Lever

    /*An element is defined by 
    type: text | button | image | shape
    hover: hex
    active: hex
    position: x, y, left, right, top, bottom
    width: pixels, will inherit from body if missing
    height: pixels, will inherit from body if missing
    overflow: fit | scroll | hidden
    textAlign: center | left | right
    fontSize: pixels
    fontColor: hex
    fontFamily: string
    padding: pixels
    backgroundColor: hex
    borderRadius: pixels
    clipPath: svg path
    border: width color style
    */
    class CanvasUI{
    	constructor(content, config){
            const defaultconfig = {
                panelSize: { width: 1, height: 1},
                width: 512,
                height: 512,
                opacity: 0.7,
                body:{
                    fontFamily:'Arial', 
                    fontSize:30, 
                    padding:2, //20, 
                    backgroundColor: '#000', 
                    fontColor:'#fff', 
                    borderRadius: 6
                }
            };
    		this.config = (config===undefined) ? defaultconfig : config;
            
            if (this.config.width === undefined) this.config.width = 512;
            if (this.config.height === undefined) this.config.height = 512;
            if (this.config.body === undefined) this.config.body = {
                fontFamily:'Arial', 
                size:30, 
                padding:2, //20, 
                backgroundColor: '#000', 
                fontColor:'#fff', 
                borderRadius: 6};
            
            const body = this.config.body;
            if (body.borderRadius === undefined) body.borderRadius = 6;
            if (body.fontFamily === undefined) body.fontFamily = "Arial";
            if (body.padding === undefined) body.padding = 2; //20;
            if (body.fontSize === undefined) body.fontSize = 30;
            if (body.backgroundColor === undefined) body.backgroundColor = '#000';
            if (body.fontColor === undefined) body.fontColor = '#fff';
            
            Object.entries( this.config ).forEach( ( [ name, value]) => {
                if ( typeof(value) === 'object' && name !== 'panelSize' && !(value instanceof THREE.WebGLRenderer) && !(value instanceof THREE.Scene) ){
                    const pos = (value.position!==undefined) ? value.position : { x: 0, y: 0 };
                    
                    if (pos.left !== undefined && pos.x === undefined ) pos.x = pos.left;
                    if (pos.top !== undefined && pos.y === undefined ) pos.y = pos.top;

                    const width = (value.width!==undefined) ? value.width : this.config.width;
                    const height = (value.height!==undefined) ? value.height : this.config.height;

                    if (pos.right !== undefined && pos.x === undefined ) pos.x = this.config.width - pos.right - width;
                    if (pos.bottom !== undefined && pos.y === undefined ) pos.y = this.config.height - pos.bottom - height;
                    
                    if (pos.x === undefined) pos.x = 0;
                    if (pos.y === undefined) pos.y = 0;
                    
                    value.position = pos;
                    
                    if (value.type === undefined) value.type = 'text';
                }
            });
            
            
            const canvas = this.createOffscreenCanvas(this.config.width, this.config.height);
            this.context = canvas.getContext('2d');
            this.context.save();
            
            const opacity = ( this.config.opacity !== undefined ) ? this.config.opacity : 0.7;
    		
            const planeMaterial = new THREE.MeshBasicMaterial({ transparent: true, opacity });
            this.panelSize = ( this.config.panelSize !== undefined) ? this.config.panelSize : { width:1, height:1 };
    		const planeGeometry = new THREE.PlaneGeometry(this.panelSize.width, this.panelSize.height);
    		
    		this.mesh = new THREE.Mesh(planeGeometry, planeMaterial);
            
            this.texture = new THREE.CanvasTexture(canvas);
            this.mesh.material.map = this.texture;
            
            this.scene = this.config.scene;
            
            const inputs = Object.values( this.config ).filter( ( value )=>{
                return  value.type === "input-text";
            });
            if ( inputs.length > 0 ){
                this.keyboard = new CanvasKeyboard(this.panelSize.width, this.config.renderer );
                const mesh = this.keyboard.mesh;
                mesh.position.set( 0, -0.3, 0.2 );
                this.mesh.add( this.keyboard.mesh );
            }
            
            if (content === undefined){
                this.content = { body: "" };
                this.config.body.type = "text";
            }else {
                this.content = content;
                const btns = Object.values(config).filter( (value) => { return value.type === "button" || value.overflow === "scroll" || value.type === "input-text" });
                if (btns.length>0){
                    if ( config === undefined || config.renderer === undefined ){
                        console.warn("CanvasUI: button, scroll or input-text in the config but no renderer");
                    }else {
                        this.renderer = config.renderer;
                        this.initControllers();
                    }
                }
            }
            
            this.selectedElements = [ undefined, undefined ];
            this.selectPressed = [ false, false ];
            this.scrollData = [ undefined, undefined ];
            this.intersects = [ undefined, undefined ];
            
            this.needsUpdate = true;
            
            this.update();
    	}
    	
        getIntersectY( index ){
            const height = this.config.height || 512;
            const intersect = this.intersects[index];
            if (intersect === undefined ) return 0;
            if ( intersect.uv === undefined ) return 0;
            return (1 - intersect.uv.y) * height;
        }
        
        initControllers(){
            this.vec3 = new THREE.Vector3();
            this.mat4 = new THREE.Matrix4();
            this.raycaster = new THREE.Raycaster();
            
            const self = this;
            
            function onSelect( event ) {     
                const index = (event.target === self.controller) ? 0 : 1;
                const elm = self.selectedElements[index];
                if ( elm !== undefined ){
                    if ( elm.type == "button"){
                        self.select( index );
                    }else if ( elm.type == "input-text"){
                        if ( self.keyboard ){
                            if ( self.keyboard.visible ){
                                self.keyboard.linkedUI = undefined;
                                self.keyboard.linkedText = undefined;
                                self.keyboard.linkedElement = undefined;
                                self.keyboard.visible = false;
                            }else {
                                self.keyboard.linkedUI = self;
                                let name;
                                Object.entries( self.config ).forEach( ([prop, value]) => {
                                    if ( value == elm ) name = prop;
                                });
                                const y = (0.5-((elm.position.y + elm.height + self.config.body.padding )/self.config.height)) * self.panelSize.height;
                                const h = Math.max( self.panelSize.width, self.panelSize.height )/2;
                                self.keyboard.position.set( 0, -h/1.5 - y, 0.1 );
                                self.keyboard.linkedText = self.content[ name ];
                                self.keyboard.linkedName = name;
                                self.keyboard.linkedElement = elm;
                                self.keyboard.visible = true;
                            }
                        }
                    }
                }
            }
            
            function onSelectStart( event ){
                const index = (event.target === self.controller) ? 0 : 1;
                self.selectPressed[index] = true;
                if ( self.selectedElements[index] !== undefined && self.selectedElements[index].overflow == "scroll"){
                    const elm = self.selectedElements[index];
                    self.scrollData[index] = { scrollY: elm.scrollY, rayY: self.getIntersectY(index) };
                }
            }
            
            function onSelectEnd( event ){
                const index = (event.target === self.controller) ? 0 : 1;
                self.selectPressed[index] = false;
                if ( self.selectedElements[index] !== undefined && self.selectedElements[index].overflow == "scroll"){
                    self.scrollData[index] = undefined;
                }
            }
            
            this.controller = this.renderer.xr.getController( 0 );
            this.controller.addEventListener( 'select', onSelect );
            this.controller.addEventListener( 'selectstart', onSelectStart );
            this.controller.addEventListener( 'selectend', onSelectEnd );
            this.controller1 = this.renderer.xr.getController( 1 );
            this.controller1.addEventListener( 'select', onSelect );
            this.controller1.addEventListener( 'selectstart', onSelectStart );
            this.controller1.addEventListener( 'selectend', onSelectEnd );
              
            if ( this.scene ){
                const radius = 0.015;
                const geometry = new THREE.IcosahedronBufferGeometry( radius );
                const material = new THREE.MeshBasicMaterial( {color: 0x0000aa } );

                const mesh1 = new THREE.Mesh( geometry, material );
                mesh1.visible = false;
                this.scene.add( mesh1 );
                const mesh2 = new THREE.Mesh( geometry, material );
                mesh2.visible = false;
                this.scene.add( mesh2 );

                this.intersectMesh = [ mesh1, mesh2 ];
            }
            
        }
        
        setClip( elm ){
            const context = this.context;
            
            context.restore();
            context.save();
            
            if (elm.clipPath !== undefined){
                const path = new Path2D( elm.clipPath );
                context.clip( path );
            }else {
                const pos = (elm.position!==undefined) ? elm.position : { x:0, y: 0 };
                const borderRadius = elm.borderRadius || 0;
                const width = elm.width || this.config.width;
                const height = elm.height || this.config.height;
               
                context.beginPath();
                
                if (borderRadius !== 0){
                    const angle = Math.PI/2;
                    //start top left
                    context.moveTo(pos.x + borderRadius, pos.y );
                    context.arc( pos.x + borderRadius, pos.y + borderRadius, borderRadius, angle, angle*2, true);
                    context.lineTo( pos.x, pos.y + height - borderRadius );
                    context.arc( pos.x + borderRadius, pos.y + height - borderRadius, borderRadius, 0, angle, true);
                    context.lineTo( pos.x + width - borderRadius, pos.y + height);
                    context.arc( pos.x + width - borderRadius, pos.y + height - borderRadius, borderRadius, angle*3, angle*4, true);
                    context.lineTo( pos.x + width, pos.y + borderRadius );
                    context.arc( pos.x + width - borderRadius, pos.y + borderRadius, borderRadius, angle*2, angle*3, true);
                    context.closePath();
                    context.clip();
                }else {
                    context.rect( pos.x, pos.y, width, height );
                    context.clip();
                }
                
                
            }
            
        }

        setPosition(x, y, z){
            if (this.mesh === undefined) return;
            this.mesh.position.set(x, y, z);
        }

        setRotation(x, y, z){
            if (this.mesh === undefined) return;
            this.mesh.rotation.set(x, y, z);
        }

        updateElement( name, content ){
            let elm = this.content[name];
            
            if (elm===undefined){
                console.warn( `CanvasGUI.updateElement: No ${name} found`);
                return;
            }
            
            if (typeof elm === 'object'){
                elm.content = content;
            }else {
                elm = content;
            }
            
            this.content[name] = elm;
            
            this.needsUpdate = true;
        }
        
        get panel(){
            return this.mesh;
        }

        getElementAtLocation( x, y ){
            const self = this;
            const elms = Object.entries( this.config ).filter( ([ name, elm ]) => {
                if (typeof elm === 'object' && name !== 'panelSize' && name !== 'body' && !(elm instanceof THREE.WebGLRenderer) && !(elm instanceof THREE.Scene)){
                    const pos = elm.position;
                    const width = (elm.width !== undefined) ? elm.width : self.config.width;
                    const height = (elm.height !== undefined) ? elm.height : self.config.height;
                    return (x>=pos.x && x<(pos.x+width) && y>=pos.y && y<(pos.y + height));
                }
            });
            const elm = (elms.length==0) ? null : this.config[elms[0][0]];
            //console.log(`selected = ${elm}`);
            return elm;
        }

        updateConfig( name, property, value ){  
            let elm = this.config[name];
            
            if (elm===undefined){
                console.warn( `CanvasUI.updateconfig: No ${name} found`);
                return;
            }
            
            elm[property] = value;
            
            this.needsUpdate = true;
        }

        hover( index = 0, uv ){
            if (uv === undefined){
                if (this.selectedElements[index] !== undefined){
                    this.selectedElements[index] = undefined;
                    this.needsUpdate = true;
                }
            }else {
                const x = uv.x * (this.config.width || 512);
                const y = (1 - uv.y) * (this.config.height || 512);
                //console.log( `hover uv:${uv.x.toFixed(2)},${uv.y.toFixed(2)}>>texturePos:${x.toFixed(0)}, ${y.toFixed(0)}`);
                const elm = this.getElementAtLocation( x, y );
                if (elm===null){
                    if ( this.selectedElements[index] !== undefined ){
                        this.selectedElements[index] = undefined;
                        this.needsUpdate = true;
                    }
                }else if( this.selectedElements[index] !== elm ){
                    this.selectedElements[index] = elm;
                    this.needsUpdate = true;
                }
            }
             
        }
        
        select( index = 0 ){
            if (this.selectedElements[index] !== undefined){
                const elm = this.selectedElements[index];
                if (elm.onSelect) elm.onSelect();
                if (elm.type === 'input-text'){
                    this.keyboard.mesh.visible = true;
                }else {
                    this.selectedElements[index] = undefined;
                }
            }
        }
        
        scroll( index ){
            if ( this.selectedElements[index] === undefined ){
                if (this.intersectMesh) this.intersectMesh[index].visible = false;
                return;
            } 
            if ( this.selectedElements[index].overflow !== 'scroll') return;
            const elm = this.selectedElements[index];
            if ( this.selectPressed[index] ){ 
                const scrollData = this.scrollData[index];
                if (scrollData !== undefined){
                    if (this.intersectMesh){
                        this.intersectMesh[index].visible = true;
                        this.intersectMesh[index].position.copy( this.intersects[index].point );
                    }
                    const rayY = this.getIntersectY( index );
                    const offset = rayY - scrollData.rayY;
                    elm.scrollY = Math.min( Math.max( elm.minScrollY, scrollData.scrollY + offset), 0 );
                    this.needsUpdate = true;
                }
            }else {
                if (this.intersectMesh) this.intersectMesh[index].visible = false;
            }
        }
            
        handleController( controller, index ){
            this.mat4.identity().extractRotation( controller.matrixWorld );

            this.raycaster.ray.origin.setFromMatrixPosition( controller.matrixWorld );
            this.raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( this.mat4 );

            const intersects = this.raycaster.intersectObject( this.mesh );

            if (intersects.length>0){
                this.hover( index, intersects[0].uv );
                this.intersects[index] = intersects[0];
                this.scroll( index );
            }else {
                this.hover( index );
                this.intersects[index] = undefined;
                this.scroll( index );
            }
        }
        
    	update(){    
            if (this.mesh===undefined) return;
                
            if ( this.controller ) this.handleController( this.controller, 0 );
            if ( this.controller1 ) this.handleController( this.controller1, 1 );

            if ( this.keyboard && this.keyboard.visible ) this.keyboard.update();
            
            if ( !this.needsUpdate ) return;
    		
    		let context = this.context;
    		
    		context.clearRect(0, 0, this.config.width, this.config.height);
            
            const bgColor = ( this.config.body.backgroundColor ) ? this.config.body.backgroundColor : "#000";
            ( this.config.body.fontFamily ) ? this.config.body.fontFamily : "Arial";
            const fontColor = ( this.config.body.fontColor ) ? this.config.body.fontColor : "#fff";
            ( this.config.body.fontSize ) ? this.config.body.fontSize : 30;
            this.setClip(this.config.body);
            context.fillStyle = bgColor;
            context.fillRect( 0, 0, this.config.width, this.config.height);
            
            const self = this;
            
            Object.entries(this.content).forEach( ([name, content]) => {
                const config = (self.config[name]!==undefined) ? self.config[name] : self.config.body;
                const display = (config.display !== undefined) ? config.display : 'block';
                
                if (display !== 'none'){
                    const pos = (config.position!==undefined) ? config.position : { x: 0, y: 0 };                
                    const width = (config.width!==undefined) ? config.width : self.config.width;
                    const height = (config.height!==undefined) ? config.height : self.config.height;

                    if (config.type == "button" && !content.toLowerCase().startsWith("<path>")){
                        if ( config.borderRadius === undefined) config.borderRadius = 6;
                        if ( config.textAlign === undefined ) config.textAlign = "center";
                    }
                    
                    self.setClip( config );
                    
                    const svgPath = content.toLowerCase().startsWith("<path>");
                    const hover = ((self.selectedElements[0] !== undefined && this.selectedElements[0] === config)||(self.selectedElements[1] !== undefined && this.selectedElements[1] === config));
                    
                    if ( config.backgroundColor !== undefined){
                        if (hover && config.type== "button" && config.hover !== undefined){
                            context.fillStyle = config.hover;
                        }else {
                            context.fillStyle = config.backgroundColor;
                        }
                        context.fillRect( pos.x, pos.y, width, height );
                    }

                    if (config.type == "text" || config.type == "button" || config.type == "input-text"){
                        let stroke = false;
                        if (hover){
                            if (!svgPath && config.type == "button"){
                                context.fillStyle = (config.fontColor !== undefined) ? config.fontColor : fontColor;
                            }else {
                                context.fillStyle = (config.hover !== undefined) ? config.hover : ( config.fontColor !== undefined) ? config.fontColor : fontColor;
                            }
                            stroke = (config.hover === undefined);
                        }else {
                            context.fillStyle = (config.fontColor !== undefined) ? config.fontColor : fontColor;
                        }
                        
                        if ( svgPath ){
                            const code = content.toUpperCase().substring(6, content.length - 7);
                            context.save();
                            context.translate( pos.x, pos.y );
                            const path = new Path2D(code);
                            context.fill(path);
                            context.restore();
                        }else {
                            self.wrapText( name, content );
                        }

                        if (stroke){
                            context.beginPath();
                            context.strokeStyle = "#fff";
                            context.lineWidth = 2;
                            context.rect( pos.x, pos.y, width, height);
                            context.stroke();
                        }
                    }else if (config.type == "img"){
                        if (config.img === undefined){
                            this.loadImage(content).then(img =>{
                                console.log(`w: ${img.width} | h: ${img.height}`);
                                config.img = img;
                                self.needsUpdate = true;
                                self.update();           
                            }).catch(err => console.error(err));
                        }else {
                            const aspect = config.img.width/config.img.height;
                            const h = width/aspect;
                            context.drawImage( config.img, pos.x, pos.y, width, h );           
                        }
                    }
                }
            });
    		
            this.needsUpdate = false;
    		this.texture.needsUpdate = true;
    	}
    	
        loadImage(src) {
          return new Promise((resolve, reject) => {
            const img = new THREE.Image();
            img.addEventListener("load", () => resolve(img));
            img.addEventListener("error", err => reject(err));
            img.src = src;
          });
        }

    	createOffscreenCanvas(w, h) {
    		const canvas = document.createElement('canvas');
    		canvas.width = w;
    		canvas.height = h;
    		return canvas;
    	}
    	
        fillRoundedRect( x, y, w, h, radius ){
            const ctx = this.context;
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + w - radius, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
            ctx.lineTo(x + w, y + h - radius);
            ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
            ctx.lineTo(x + radius, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
        }
        
        lookAt( pos ){
            if ( this.mesh === undefined ) return;
            if ( !(pos instanceof Vector3) ){
                console.error( 'CanvasUI lookAt called parameter not a THREE.Vector3');
                return;
            }
            this.mesh.lookAt( pos );
        }
        
        get visible(){
            if (this.mesh === undefined ) return false;
            return this.mesh.visible;
        }
        
        set visible(value){
            if (this.mesh){
                this.mesh.visible = value;
            }
        }
        
        get position(){
            if (this.mesh === undefined) return undefined;
            return this.mesh.position;
        }
        
        set position(value){
            if (this.mesh === undefined) return;
            if (!(value instanceof Vector3) ){
                console.error( 'CanvasUI trying to set the mesh position using a parameter that is not a THREE.Vector3');
                return;
            }
            this.mesh.position.copy( value );
        }
        
        get quaternion(){
            if (this.mesh === undefined) return undefined;
            return this.mesh.quaternion;
        }
        
        set quaternion(value){
            if (this.mesh === undefined) return;
            if (!(value instanceof QUaternion) ){
                console.error( 'CanvasUI trying to set the mesh quaternion using a parameter that is not a THREE.Quaternion');
                return;
            }
            this.mesh.quaternion.copy( value );
        }
        
    	wrapText(name, txt){
            //console.log( `wrapText: ${name}:${txt}`);
    		const words = txt.split(' ');
            let line = '';
    		const lines = [];
            const config = (this.config[name]!==undefined) ? this.config[name] : this.config.body;
            const width = (config.width!==undefined) ? config.width : this.config.width;
            const height = (config.height!==undefined) ? config.height : this.config.height;
            const pos = (config.position!==undefined) ? config.position : { x:0, y:0 };
            const padding = (config.padding!==undefined) ? config.padding : (this.config.body.padding!==undefined) ? this.config.body.padding : 10;
            const paddingTop = (config.paddingTop!==undefined) ? config.paddingTop : padding;
            const paddingLeft = (config.paddingLeft!==undefined) ? config.paddingLeft : padding;
            const paddingBottom = (config.paddingBottom!==undefined) ? config.paddingBottom : padding;
            const paddingRight = (config.paddingRight!==undefined) ? config.paddingRight : padding;
            const rect = { x:pos.x+paddingLeft, y:pos.y+paddingTop, width: width - paddingLeft - paddingRight, height: height - paddingTop - paddingBottom };
            const textAlign = (config.textAlign !== undefined) ? config.textAlign : (this.config.body.textAlign !== undefined) ? this.config.body.textAlign : "left";
            const fontSize = (config.fontSize !== undefined ) ? config.fontSize : ( this.config.body.fontSize !== undefined) ? this.config.body.fontSize : 30;
            const fontFamily = (config.fontFamily!==undefined) ? config.fontFamily : (this.config.body.fontFamily!==undefined) ? this.config.body.fontFamily : 'Arial';
            const leading = (config.leading !== undefined) ? config.leading : (this.config.body.leading !== undefined) ? this.config.body.leading : 8;
    		const lineHeight = fontSize + leading;
            
            const context = this.context;
            
            context.textAlign = textAlign;
            
    		context.font = `${fontSize}px '${fontFamily}'`;
    		
            words.forEach( function(word){
    			let testLine = (words.length>1) ? `${line}${word} ` : word;
            	let metrics = context.measureText(testLine);
            	if (metrics.width > rect.width && word.length>1) {
                    if (line.length==0 && metrics.width > rect.width){
                        //word too long
                        while(metrics.width > rect.width){
                            let count = 0;
                            do{
                                count++;
                                testLine = word.substr(0, count);
                                metrics = context.measureText(testLine);
                            }while(metrics.width < rect.width && count < (word.length-1));
                            count--;
                            testLine = word.substr(0, count);
                            lines.push( testLine );
                            word = word.substr(count);
                            if (count<=1) break;
                            metrics = context.measureText(word);
                        }
                        if (word != "") lines.push(word);
                    }else {
    				    lines.push(line);
    				    line = `${word} `;
                    }
    			}else {
    				line = testLine;
    			}
    		});
    		
    		if (line != '') lines.push(line);
            
            const textHeight = lines.length * lineHeight;
            let scrollY = 0;
            
            if (textHeight>rect.height && config.overflow === 'scroll'){
                //Show a scroll bar
                if ( config.scrollY === undefined ) config.scrollY = 0;
                const fontColor = ( config.fontColor !== undefined ) ? config.fontColor : this.config.body.fontColor;
                context.fillStyle = "#aaa";
                this.fillRoundedRect( pos.x + width - 12, pos.y, 12, height, 6 );
                context.fillStyle = "#666";
                const scale = rect.height / textHeight;
                const thumbHeight = scale * height;
                const thumbY = -config.scrollY * scale;
                this.fillRoundedRect( pos.x + width - 12, pos.y + thumbY, 12, thumbHeight, 6);
                context.fillStyle = fontColor;
                scrollY = config.scrollY;
                config.minScrollY = rect.height - textHeight;
            }
    		
    		let y = scrollY + rect.y + fontSize/2;
    		let x;
            
            switch( textAlign ){
                case "center":
                    x = rect.x + rect.width/2;
                    break;
                case "right":
                    x = rect.x + rect.width;
                    break;
                default:
                    x = rect.x;
                    break;
            }
            
    		lines.forEach( (line) => {
                if ((y + lineHeight) > 0) context.fillText(line, x, y);
    			y += lineHeight;
    		});
    	}
    }

    // from https://github.com/NikLever/Learn-WebXR/tree/master/libs, by Nik Lever

    class CanvasKeyboard{
        constructor( width, renderer, lang = "EN" ){
            const config = this.getConfig( lang );
            config.panelSize = { width, height: width * 0.5 };
            config.height = 256;
            config.body = { backgroundColor: "#555" };
            config.renderer = renderer;
            const content = this.getContent( lang );
            this.keyboard = new CanvasUI( content, config );
            this.keyboard.mesh.visible = false;
            this.shift = false;
        }
        
        get mesh(){
            return this.keyboard.mesh;
        }
        
        getConfig( lang ){
            //EN
            //keys
            //qwertyuiop - 10 square - btn0-btn9
            //asdfghjkl@ - 10 square buttons - btn10-btn19
            //^zxcvbnm< - 1.5 shift,7 square,1.5 backspace - btn20-btn28
            //[?123],space.[Enter] - 2,1,4,1,2 - btn30-btn34
            //keys shifted
            //QWERTYUIOP - 10 square 
            //ASDFGHJKL@ - 10 square buttons
            //^ZXCVBNM< - 1.5 shift,7 square,1.5 backspace
            //[?123],space.[Enter] - 2,1,4,1,2
            //numbers
            //1234567890 - 10 square
            //@#%&*/-+() - 10 sq
            //^?!"'\:;< - 1.5 shift,7 square,1.5 backspace
            //[ABC],space.[Enter] - 2,1,4,1,2
            //numbers shifted
            //1234567890 - 10 square
            //$^=|{}[] - 10 sq
            //^<>_`~:;< - 1.5 shift,7 square,1.5 backspace
            //[ABC],space.[Enter] - 2,1,4,1,2
            const config = {};
            let padding = 10;
            const paddingTop = 20;
            const width = ((512 - 2 * padding) / 10) - padding;
            const height = (( 256 - 2 * padding) / 4) - padding;
            const hover = "#333";
            const backgroundColor = "#000";
            //Top row
            let y = padding;
            let x = padding;
            for (let i=0; i<10; i++){
                const btn = { type: "button", position: { x, y }, width, height, padding, paddingTop, backgroundColor, borderRadius:6, hover, onSelect: this.onSelect.bind( this, i ) };
                config[`btn${i}`] = btn;
                x += (width + padding);
            }
            //2nd row
            y += (height + padding);
            x = padding;
            for (let i=0; i<10; i++){
                const btn = { type: "button", position: { x, y }, width, height, padding, paddingTop, backgroundColor, borderRadius:6, hover, onSelect: this.onSelect.bind( this, i + 10 ) };
                config[`btn${i+10}`] = btn;
                x += (width + padding);
            }
            //3rd row
            y += (height + padding);
            x = padding;
            for (let i=0; i<9; i++){
                const w = (i==0 || i==8) ? (width * 1.5 + padding * 0.5) : width;
                const btn = { type: "button", position: { x, y }, width: w, height, padding, paddingTop, backgroundColor, borderRadius:6, hover, onSelect: this.onSelect.bind( this, i + 20 ) };
                config[`btn${i+20}`] = btn;
                x += ( w + padding );
            }
            //4th row
            y += (height + padding);
            x = padding;
            for (let i=0; i<5; i++){
                const w = (i==0 || i==4) ? (width * 2 + padding) : (i==2) ? (width * 4 + 3 * padding) : width;
                const btn = { type: "button", position: { x, y }, width: w, height, padding, paddingTop, backgroundColor, borderRadius:6, hover, onSelect: this.onSelect.bind( this, i + 30 ) };
                if (i==0) btn.fontSize = 20;
                config[`btn${i+30}`] = btn;
                x += ( w + padding );
            }
            return config;
        }
        
        getContent( lang, layoutIndex=0 ){
            let content = {};
            let keys;
            
            this.language = lang;
            this.keyboardIndex = layoutIndex;
            
            switch(layoutIndex){
                case 0:
                    //EN
                    //keys
                    //qwertyuiop - 10 square - btn0-btn9
                    //asdfghjkl@ - 10 square buttons - btn10-btn19
                    //^zxcvbnm< - 1.5 shift,7 square,1.5 backspace - btn20-btn28
                    //[?123],space.[Enter] - 1.5,1,4,1,1.5 - btn30-btn34
                    keys = [ 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', 
                             'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', '@',
                             '', 'z', 'x', 'c', 'v', 'b', 'n', 'm', '', '',
                             '?123', ',', '   ', '.', ''];
                    for(let i=0; i<keys.length; i++){
                        const key = keys[i];
                        if (key!=='') content[`btn${i}`] = key;
                    }
                    break;
                case 1:
                    //keys shifted
                    //QWERTYUIOP - 10 square 
                    //ASDFGHJKL@ - 10 square buttons
                    //^ZXCVBNM< - 1.5 shift,7 square,1.5 backspace
                    //[?123],space.[Enter] - 1.5,1,4,1,1.5
                    keys = [ 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', 
                             'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', '@',
                             '', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', '', '',
                             '?123', ',', '   ', '.', ''];
                    for(let i=0; i<keys.length; i++){
                        const key = keys[i];
                        if (key!=='') content[`btn${i}`] = key;
                    }
                    break;
                case 2:
                    //numbers
                    //1234567890 - 10 square
                    //@#%&*/-+() - 10 sq
                    //^?!"'\:;< - 1.5 shift,7 square,1.5 backspace
                    //[ABC],space.[Enter] - 1.5,1,4,1,1.5
                    keys = [ '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 
                             '@', '#', '%', '&', '*', '/', '-', '+', '(', ')',
                             '', '?', '!', '"', '\'', '\\', ':', ';', '', '',
                             'abc', ',', '   ', '.', ''];
                    for(let i=0; i<keys.length; i++){
                        const key = keys[i];
                        if (key!=='') content[`btn${i}`] = key;
                    }
                    break;
                case 3:
                    //numbers shifted
                    //1234567890 - 10 square
                    //$^=|{}[] - 10 sq
                    //^<>_`~:;< - 1.5 shift,7 square,1.5 backspace
                    //[ABC],space.[Enter] - 1.5,1,5,1,1.5
                    keys = [ '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 
                             '', '', '$', '^', '=', '|', '{', '}', '[', '}',
                             '', '<', '>', '_', '`', '~', ':', ';', '', '',
                             'abc', ',', '   ', '.', ''];
                    for(let i=0; i<keys.length; i++){
                        const key = keys[i];
                        if (key!=='') content[`btn${i}`] = key;
                    }
                    break;
            }
            
            return content;
        }
        
        get position(){
            return this.keyboard.mesh.position;    
        }
        
        get visible(){
            return this.keyboard.mesh.visible;
        }
        
        set visible( value ){
            this.keyboard.mesh.visible = value;    
        }
        
        setKeyboard( index ){
            this.keyboard.content = this.getContent( this.language, index );
            this.keyboard.needsUpdate = true;
        }
        
        onSelect( index ){
            if ( !this.visible ) return
            
            //console.log( `CanvasKeyboard onSelect: key index ${index}`);
            let change = false;
            
            switch(index){
                case 34://Enter
                    this.visible = false;
                    if ( this.linkedElement.onEnter ) this.linkedElement.onEnter( this.linkedText );
                    break;
                case 32://space
                    this.linkedText += ' ';
                    change = true;
                    break;
                case 30://switch keyboard
                    this.shift = false;
                    if (this.keyboardIndex<2){
                        this.setKeyboard( 2 );
                    }else {
                        this.setKeyboard( 0 );
                    }
                    this.keyboard.needsUpdate = true;
                    break;
                case 28://backspace
                    this.linkedText = this.linkedText.substring( 0, this.linkedText.length-1 );
                    change = true;
                    break;
                case 20://shift
                    this.shift = !this.shift;
                    if (this.keyboardIndex==0){
                        this.setKeyboard( 1 );
                    }else if (this.keyboardIndex==1){
                        this.setKeyboard( 0 );
                    }else if (this.keyboardIndex==2){
                        this.setKeyboard( 3 );
                    }else if (this.keyboardIndex==3){
                        this.setKeyboard( 2 );
                    }
                    break;
                default:
                    const txt = this.keyboard.content[`btn${index}`];
                    this.linkedText += txt;
                    change = true;
                    if (this.keyboardIndex==1) this.setKeyboard( 0 );
                    break;
            }
            
            if ( change ){
                this.linkedUI.updateElement( this.linkedName, this.linkedText );
                if ( this.linkedElement.onChanged) this.linkedElement.onChanged( this.linkedText );
            }
        }
        
        update(){
            if (this.keyboard){
                this.keyboard.update();
            }
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Scene {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //This core function sets up the scene and display the structure according to the input
        //options (shown above), which is a hash containing values for different keys.
        rebuildScene(options) { let ic = this.icn3d, me = ic.icn3dui;
            if(options === undefined) options = ic.opts;

            this.rebuildSceneBase(options);

            ic.fogCls.setFog();

            // if(!ic.bVr && !ic.bAr) { // first time
                ic.cameraCls.setCamera();
            // }

            // if(!ic.bSetVrArButtons) { // call once
            if(!me.cfg.imageonly) this.setVrArButtons();
            // }

            // if((ic.bVr || ic.bAr) && !ic.bSetVrAr) { // call once
                this.setVrAr();
            // }

            if(ic.bSkipChemicalbinding === undefined || !ic.bSkipChemicalbinding) {
                ic.applyOtherCls.applyChemicalbindingOptions();
            }

            ic.bSkipChemicalbinding = true;

            if (options.chemicalbinding === 'show') {
                ic.opts["hbonds"] = "yes";
            }

            // show disulfide bonds, set side chains
            ic.applySsbondsCls.applySsbondsOptions();

            // show cross-linkages, set side chains
            ic.applyClbondsCls.applyClbondsOptions();

            // add dashed lines for missing residues
            ic.applyMissingResCls.applyMissingResOptions();

            ic.applyDisplayCls.applyDisplayOptions(ic.opts, ic.dAtoms);

            ic.applyOtherCls.applyOtherOptions();

            //ic.setFog();

            //ic.setCamera();

            //https://stackoverflow.com/questions/15726560/three-js-raycaster-intersection-empty-when-objects-not-part-of-scene
            ic.scene_ghost.updateMatrixWorld(true);
        }

        rebuildSceneBase(options) { let ic = this.icn3d, me = ic.icn3dui;
            $.extend(ic.opts, options);

            ic.cam_z = ic.maxD * 2;
            //ic.cam_z = -ic.maxD * 2;

            if(ic.scene !== undefined) {
                for(let i = ic.scene.children.length - 1; i >= 0; i--) {
                    let obj = ic.scene.children[i];
                    // if(ic.bVr) {
                    //     if(ic.dollyId && obj.id != ic.dollyId) {
                    //         ic.scene.remove(obj);
                    //     }
                    // }
                    // else {
                        ic.scene.remove(obj);
                    // }
                }
            }
            else {
                ic.scene = new THREE.Scene();
            }

            if(ic.scene_ghost !== undefined) {
                for(let i = ic.scene_ghost.children.length - 1; i >= 0; i--) {
                     let obj = ic.scene_ghost.children[i];
                     ic.scene_ghost.remove(obj);
                }
            }
            else {
                ic.scene_ghost = new THREE.Scene();
            }

            // get parameters from cookies
            if(me.htmlCls.setHtmlCls.getCookie('shininess') != '') {
                let shininess = parseFloat(me.htmlCls.setHtmlCls.getCookie('shininess'));

                if(ic.shininess != shininess) {
                    me.htmlCls.clickMenuCls.setLogCmd('set shininess ' + shininess, true);
                }

                ic.shininess = shininess;
            }

            if(!me.bNode && me.htmlCls.setHtmlCls.getCookie('light1') != '') {
                let light1 = parseFloat(me.htmlCls.setHtmlCls.getCookie('light1'));
                let light2 = parseFloat(me.htmlCls.setHtmlCls.getCookie('light2'));
                let light3 = parseFloat(me.htmlCls.setHtmlCls.getCookie('light3'));

                if(ic.light1 != light1 || ic.light2 != light2 || ic.light3 != light3) {
                    me.htmlCls.clickMenuCls.setLogCmd('set light | light1 ' + light1 + ' | light2 ' + light2 + ' | light3 ' + light3, true);
                }

                ic.light1 = light1;
                ic.light2 = light2;
                ic.light3 = light3;
            }

            ic.directionalLight = new THREE.DirectionalLight(0xFFFFFF, ic.light1); //1.0);
            ic.directionalLight2 = new THREE.DirectionalLight(0xFFFFFF, ic.light2);
            ic.directionalLight3 = new THREE.DirectionalLight(0xFFFFFF, ic.light3);

            if(ic.cam_z > 0) {
              ic.directionalLight.position.set(-1, 1, 1); //(0, 1, 1);
              ic.directionalLight2.position.set(1, 1, 1); //(0, -1, 1);
              ic.directionalLight3.position.set(1, 1, -1); //(0, 1, -1);

              ic.lightPos = new THREE.Vector3(-1, 1, 1); //(0, 1, 1);
              ic.lightPos2 = new THREE.Vector3(1, 1, 1); //(0, -1, 1);
              ic.lightPos3 = new THREE.Vector3(1, 1, -1); //(0, 1, -1);
            }
            else {
              ic.directionalLight.position.set(-1, 1, -1); //(0, 1, -1);
              ic.directionalLight2.position.set(1, 1, -1); //(0, -1, -1);
              ic.directionalLight3.position.set(1, 1, 1); //(0, 1, 1);

              ic.lightPos = new THREE.Vector3(-1, 1, -1); //(0, 1, -1);
              ic.lightPos2 = new THREE.Vector3(1, 1, -1); //(0, -1, -1);
              ic.lightPos3 = new THREE.Vector3(1, 1, 1); //(0, 1, 1);
            }

            let ambientLight = new THREE.AmbientLight(0x404040); //(0x888888); //(0x404040);

            ic.scene.add(ic.directionalLight);
            ic.scene.add(ambientLight);

            if(ic.mdl !== undefined) {
                for(let i = ic.mdl.children.length - 1; i >= 0; i--) {
                     let obj = ic.mdl.children[i];
                     if(obj.geometry) obj.geometry.dispose();
                     if(obj.material) obj.material.dispose();
                     ic.mdl.remove(obj);
                }
            }

            if(ic.mdlImpostor !== undefined) {
                for(let i = ic.mdlImpostor.children.length - 1; i >= 0; i--) {
                     let obj = ic.mdlImpostor.children[i];
                     if(obj.geometry) obj.geometry.dispose();
                     if(obj.material) obj.material.dispose();
                     ic.mdlImpostor.remove(obj);
                }

                ic.mdlImpostor.children.length = 0;
            }

            // https://discourse.threejs.org/t/correctly-remove-mesh-from-scene-and-dispose-material-and-geometry/5448/2
            // clear memory
            if(!me.bNode) ic.renderer.renderLists.dispose();

            ic.mdl = new THREE.Object3D();  // regular display
            ic.mdlImpostor = new THREE.Object3D();  // Impostor display

            ic.scene.add(ic.mdl);
            ic.scene.add(ic.mdlImpostor);

            // highlight on impostors
            ic.mdl_ghost = new THREE.Object3D();  // Impostor display
            ic.scene_ghost.add(ic.mdl_ghost);
     
            // related to pk
            ic.objects = []; // define objects for pk, not all elements are used for pk
            ic.objects_ghost = []; // define objects for pk, not all elements are used for pk

            ic.raycaster = new THREE.Raycaster();
            ic.projector = new THREE.Projector();
            ic.mouse = new THREE.Vector2();

            let background = me.parasCls.backgroundColors[ic.opts.background.toLowerCase()];

            if(!me.bNode) {
                if(ic.opts.background.toLowerCase() === 'transparent') {
                    ic.renderer.setClearColor(background, 0);
                }
                else {
                    ic.renderer.setClearColor(background, 1);
                }
            }

            ic.perspectiveCamera = new THREE.PerspectiveCamera(20, ic.container.whratio, 0.1, 10000);
            ic.perspectiveCamera.position.set(0, 0, ic.cam_z);
            ic.perspectiveCamera.lookAt(new THREE.Vector3(0, 0, 0));

            ic.orthographicCamera = new THREE.OrthographicCamera();
            ic.orthographicCamera.position.set(0, 0, ic.cam_z);
            ic.orthographicCamera.lookAt(new THREE.Vector3(0, 0, 0));

            ic.cams = {
                perspective: ic.perspectiveCamera,
                orthographic: ic.orthographicCamera,
            };  
            
            if(!me.bNode && ic.opts['effect'] == 'stereo' && !window.icn3duiHash) {
                ic.effect = ic.effects[options.effect];
                ic.effect.setSize(ic.container.width(), ic.container.height());
            }
        };

        setVrAr() { let ic = this.icn3d; ic.icn3dui;
            let thisClass = this;

            ic.bSetVrAr = true;

            // https://github.com/NikLever/Learn-WebXR/tree/master/start
            // https://github.com/mrdoob/three.js/blob/master/examples/webxr_ar_cones.html
            // https://github.com/mrdoob/three.js/blob/master/examples/webxr_vr_cubes.html



            //if(ic.bVr && !ic.dolly) {       
            if(ic.bVr) {      
                ic.canvasUI = this.createUI();

                // ic.canvasUILog = this.createUILog();
                // ic.cam.add( ic.canvasUILog.mesh );

                ic.raycasterVR = new THREE.Raycaster();
                ic.workingMatrix = new THREE.Matrix4();
                ic.workingVector = new THREE.Vector3();
                ic.origin = new THREE.Vector3();
                //let geometry = new THREE.IcosahedronBufferGeometry( radius, 2 );

                // modified from https://github.com/NikLever/Learn-WebXR/blob/master/complete/lecture3_7/app.js
                // add dolly to move camera
                ic.dolly = new THREE.Object3D();
                
                ic.dolly.position.z = 5;
                ic.dolly.add(ic.cam);
                ic.scene.add(ic.dolly);

                ic.dollyId = ic.dolly.id;

                //ic.cameraVector = new THREE.Vector3(); // create once and reuse it!

                ic.dummyCam = new THREE.Object3D();
                ic.cam.add(ic.dummyCam);

                ic.clock = new THREE.Clock();

                //controllers
                ic.controllers = this.getControllers();

                ic.controllers.forEach( (controller) => {
                    controller.addEventListener( 'connected', function ( event ) {
                        try {
                            //https://github.com/NikLever/Learn-WebXR/blob/master/complete/lecture3_6/app.js
                            const info = {};

                            const DEFAULT_PROFILES_PATH = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles';
                            const DEFAULT_PROFILE = 'generic-trigger';

                            fetchProfile( event.data, DEFAULT_PROFILES_PATH, DEFAULT_PROFILE ).then( ( { profile, assetPath } ) => {
                                //console.log( JSON.stringify(profile));
                                //ic.canvasUILog.updateElement( "info", "profile " + JSON.stringify(profile) );

                                info.name = profile.profileId;
                                info.targetRayMode = event.data.targetRayMode;
                    
                                Object.entries( profile.layouts ).forEach( ( [key, layout] ) => {
                                    const components = {};
                                    Object.values( layout.components ).forEach( ( component ) => {
                                        components[component.rootNodeName] = component.gamepadIndices;
                                    });
                                    info[key] = components;
                                });
                    
                                //self.createButtonStates( info.right );
                                
                                //console.log( JSON.stringify(info) );
                    
                                thisClass.updateControllers( info );
                                //ic.canvasUILog.updateElement( "info", JSON.stringify(info).replace(/,/g, ', ') );
                            } );
                        }
                        catch(err) {
                            //ic.canvasUILog.updateElement("info", "ERROR: " + error);
                        }
                    } );

                    controller.addEventListener( 'disconnected', function () {
                        this.remove( this.children[ 0 ] );
                        ic.controllers.forEach( (controllerTmp) => {
                        });
                        //self.controllerGrip = null;
                    } );
                 
                });        
            }      
            else if(ic.bAr) {
                // the menu didn't work in AR
                // ic.canvasUILog = this.createUILog();
                // ic.cam.add( ic.canvasUILog.mesh );
                
                //Add gestures here
                ic.gestures = new ControllerGestures(ic.renderer);
                ic.scene.add(ic.gestures.controller1);
                ic.scene.add(ic.gestures.controller2);

                // ic.gestures.addEventListener('tap', (ev) => {
                //     // const controller = ic.gestures.controller1; 
                //     // ic.mdl.position.set( -0.03, 0, - 0.3 ).applyMatrix4( controller.matrixWorld );
                //     // ic.mdl.scale.copy(new THREE.Vector3( 0.001, 0.001, 0.001 ));  
                // });

                ic.gestures.addEventListener('doubletap', (ev) => {
                    thisClass.positionCenter();
                });
    /* 
                ic.gestures.addEventListener('pan', (ev) => { // touch across screen, move
                    if(ev.initialise !== undefined) {
                        thisClass.startPosition = ic.mdl.position.clone();
                        thisClass.startQuaternion = ic.mdl.quaternion.clone();
                    }
                    else {
                        const endPosition = ev.position;
                        let angle = Math.acos( thisClass.startPosition.dot( endPosition ) / thisClass.startPosition.length() / endPosition.length() );

                        let axis = new THREE.Vector3();
                        axis.crossVectors( thisClass.startPosition, endPosition ).normalize();

                        let rotateSpeed = 6.0;
                        angle *= rotateSpeed;

                        let quaternion = new THREE.Quaternion();
                        quaternion.setFromAxisAngle( axis, -angle );

                        ic.mdl.quaternion.copy(thisClass.startQuaternion);
                        ic.mdl.quaternion.multiplyQuaternions(quaternion, ic.mdl.quaternion);
                    }
                });
    */
                ic.gestures.addEventListener('pinch', (ev) => { // two fingers opening or closing
                    if(ev.initialise !== undefined) {
                        thisClass.startPosition = ic.mdl.position.clone();
                        thisClass.startScale = ic.mdl.scale.clone();                   
                    }
                    else {
                        let zoomSpeed = 1.0;
                        const scale = thisClass.startScale.clone().multiplyScalar(ev.scale * zoomSpeed);                  
                        ic.mdl.scale.copy(scale);
                    }
                });
    /* 
                ic.gestures.addEventListener('rotate', (ev) => { // two fingers rotating around
                    if(ev.initialise !== undefined) {
                        thisClass.startQuaternion = ic.mdl.quaternion.clone();
                    }
                    else {
                        ic.mdl.quaternion.copy(thisClass.startQuaternion);
                        ic.mdl.rotateY(ev.theta);
                    }
                });  
    */                                       
            }
        }

        positionCenter() { let ic = this.icn3d; ic.icn3dui;
            const controller = ic.gestures.controller1; 
            ic.mdl.position.set( -0.06, 0, - 0.6 ).applyMatrix4( controller.matrixWorld );
            ic.mdl.scale.copy(new THREE.Vector3( 0.005, 0.005, 0.005 )); 
        }

        setVrArButtons() { let ic = this.icn3d, me = ic.icn3dui;
            // call just once
            ic.bSetVrArButtons = true;

            if(!me.bNode) {
                $("#" + me.pre + "VRButton").remove();
                $("#" + me.pre + "viewer").get(0).appendChild( ic.VRButtonCls.createButton( ic.renderer ) );

                $("#" + me.pre + "ARButton").remove();
                $("#" + me.pre + "viewer").get(0).appendChild( ic.ARButtonCls.createButton( ic.renderer ) );
            }
        }

        //https://github.com/NikLever/Learn-WebXR/blob/master/complete/lecture3_6/app.js
        updateControllers(info){ let ic = this.icn3d; ic.icn3dui;
            this.addEventForController(info, 'right');
            this.addEventForController(info, 'left');
        }

        addEventForController(info, left_right) { let ic = this.icn3d; ic.icn3dui;

            const controller = (left_right == 'right') ? ic.renderer.xr.getController(0) : ic.renderer.xr.getController(1);
            const controllerInfo = (left_right == 'right') ? info.right : info.left;

            function onSelectStart() {
                this.userData.selectPressed = true;
            }

            function onSelectEnd() {
                this.userData.selectPressed = false;
                this.userData.selected = undefined;
            }

            function onSqueezeStart( ){
                this.userData.squeezePressed = true;

                ic.cam.add( ic.canvasUI.mesh );
            }

            function onSqueezeEnd( ){
                this.userData.squeezePressed = false;

                ic.cam.remove( ic.canvasUI.mesh );
            }

            if (controller && controllerInfo !== undefined){
                // "trigger":{"button":0},
                // "squeeze":{"button":1},
                // "thumbstick":{"button":3,"xAxis":2,"yAxis":3},   "touchpad":{"button":2,"xAxis":0,"yAxis":1},
                //======= left => right =========
                // "x_button":{"button":4},     "a_button":{"button":4}
                // "y_button":{"button":5},     "b_button":{"button":5}
                // "thumbrest":{"button":6}

                let trigger = false, squeeze = false;
                //right: 
                // let a_button = false, b_button = false, thumbrest = false;
                //left: 
                //let a_button = false, b_button = false, thumbrest = false;
                
                Object.keys( controllerInfo ).forEach( (key) => {
                    if (key.indexOf('trigger')!=-1) trigger = true;                   
                    if (key.indexOf('squeeze')!=-1) squeeze = true;     
                    if (key.indexOf('thumbstick')!=-1 || key.indexOf('touchpad')!=-1) {
                        ic.xAxisIndex = controllerInfo[key].xAxis;
                        ic.yAxisIndex = controllerInfo[key].yAxis;
                    }
                    // if (key.indexOf('a_button')!=-1) a_button = true; 
                    // if (key.indexOf('b_button')!=-1) b_button = true; 
                    // if (key.indexOf('x_button')!=-1) a_button = true; 
                    // if (key.indexOf('y_button')!=-1) b_button = true; 
                    // if (key.indexOf('thumbrest')!=-1) thumbrest = true; 
                });
                
                if (trigger){
                    controller.addEventListener( 'selectstart', onSelectStart );
                    controller.addEventListener( 'selectend', onSelectEnd );
                }

                if (squeeze){
                    controller.addEventListener( 'squeezestart', onSqueezeStart );
                    controller.addEventListener( 'squeezeend', onSqueezeEnd );
                }
            }
        }

        createUI() { let ic = this.icn3d, me = ic.icn3dui;
            let margin = 6, btnWidth = 94, btnHeight = 50, btnHeight2 = 22, svgWidth = 94, svgHeight2 = 34;
            let fontSize = 12, fontLarge = 14, fontColor = "#1c94c4", bkgdColor = "#ccc", hoverColor = "#fbcb09";
            let paddingtop = 20, paddingtop2 = 12;

            const config = {
                panelSize: { width: 2, height: 1.6 },
                height: 400,
                select: { type: "button", paddingTop: paddingtop, position:{ top: margin, left: margin }, width: btnWidth, height: btnHeight, fontColor: "#000", fontSize: fontLarge, backgroundColor: bkgdColor},
                residue: { type: "button", paddingTop: paddingtop, position:{ top: margin + (btnHeight + margin), left: margin}, width: btnWidth, height: btnHeight, fontColor: fontColor, fontSize: fontSize, backgroundColor: bkgdColor, hover: hoverColor, onSelect: function() {
                    ic.pk = 2;
                    //ic.opts['pk'] = 'residue';
                    if(!ic.pAtomNum) ic.pAtomNum = 0;

                    ic.cam.remove( ic.canvasUI.mesh );
                } },
                secondarySelect: { type: "button", paddingTop: paddingtop2, position:{ top: margin + 2*(btnHeight + margin), left: margin}, width: btnWidth, height: btnHeight, fontColor: fontColor, fontSize: fontSize, backgroundColor: bkgdColor, hover: hoverColor, onSelect: function() {
                    ic.pk = 3;
                    //ic.opts['pk'] = 'strand';
                    if(!ic.pAtomNum) ic.pAtomNum = 0;
                    ic.cam.remove( ic.canvasUI.mesh );
                } },
                chainSelect: { type: "button", paddingTop: paddingtop, position:{ top: margin + 3*(btnHeight + margin), left: margin}, width: btnWidth, height: btnHeight, fontColor: fontColor, fontSize: fontSize, backgroundColor: bkgdColor, hover: hoverColor, onSelect: function() {
                    ic.pk = 5;
                    //ic.opts['pk'] = 'chain';
                    if(!ic.pAtomNum) ic.pAtomNum = 0;
                    ic.cam.remove( ic.canvasUI.mesh );
                } },
                atom: { type: "button", paddingTop: paddingtop, position:{ top: margin + 4*(btnHeight + margin), left: margin}, width: btnWidth, height: btnHeight, fontColor: fontColor, fontSize: fontSize, backgroundColor: bkgdColor, hover: hoverColor, onSelect: function() {
                    ic.pk = 1;
                    //ic.opts['pk'] = 'atom';
                    if(!ic.pAtomNum) ic.pAtomNum = 0;
                    ic.cam.remove( ic.canvasUI.mesh );
                } },
                reset: { type: "button", paddingTop: paddingtop, position:{ top: margin + 5*(btnHeight + margin), left: margin}, width: btnWidth, height: btnHeight, fontColor: fontColor, fontSize: fontSize, backgroundColor: bkgdColor, hover: hoverColor, onSelect: function() {
                    ic.viewInterPairsCls.resetInteractionPairs();
                    ic.selectionCls.resetAll();
                    
                    ic.cam.remove( ic.canvasUI.mesh );
                } },
                togglehl: { type: "button", paddingTop: paddingtop2, position:{ top: margin + 6*(btnHeight + margin), left: margin}, width: btnWidth, height: btnHeight, fontColor: fontColor, fontSize: fontSize, backgroundColor: bkgdColor, hover: hoverColor, onSelect: function() {
                    ic.hlUpdateCls.toggleHighlight();
                    
                    ic.cam.remove( ic.canvasUI.mesh );
                } },

                style: { type: "button", paddingTop: paddingtop, position:{ top: margin, left: margin + (btnWidth + margin)}, width: btnWidth, height: btnHeight, fontColor: "#000", fontSize: fontLarge, backgroundColor: bkgdColor},
                ribbon: { type: "button", paddingTop: paddingtop, position:{ top: margin + (btnHeight + margin), left: margin + (btnWidth + margin)}, width: btnWidth, height: btnHeight, fontColor: fontColor, fontSize: fontSize, backgroundColor: bkgdColor, hover: hoverColor, onSelect: function() {
                    ic.setOptionCls.setStyle("proteins", "ribbon");
                    ic.setOptionCls.setStyle("nucleotides", "nucleotide cartoon");
                    ic.cam.remove( ic.canvasUI.mesh );
                } },
                schematic: { type: "button", paddingTop: paddingtop, position:{ top: margin + 2*(btnHeight + margin), left: margin + (btnWidth + margin)}, width: btnWidth, height: btnHeight, fontColor: fontColor, fontSize: fontSize, backgroundColor: bkgdColor, hover: hoverColor, onSelect: function() {
                    ic.setOptionCls.setStyle("proteins", "schematic");
                    ic.setOptionCls.setStyle("nucleotides", "schematic");
                    ic.cam.remove( ic.canvasUI.mesh );
                } },
                stick: { type: "button", paddingTop: paddingtop, position:{ top: margin + 3*(btnHeight + margin), left: margin + (btnWidth + margin) }, width: btnWidth, height: btnHeight, fontColor: fontColor, fontSize: fontSize, backgroundColor: bkgdColor, hover: hoverColor, onSelect: function() {
                    ic.setOptionCls.setStyle("proteins", "stick");
                    ic.setOptionCls.setStyle("nucleotides", "stick");
                    ic.cam.remove( ic.canvasUI.mesh );
                } },
                sphere: { type: "button", paddingTop: paddingtop, position:{ top: margin + 4*(btnHeight + margin), left: margin + (btnWidth + margin) }, width: btnWidth, height: btnHeight, fontColor: fontColor, fontSize: fontSize, backgroundColor: bkgdColor, hover: hoverColor, onSelect: function() {
                    ic.setOptionCls.setStyle("proteins", "sphere");
                    ic.setOptionCls.setStyle("nucleotides", "sphere");
                    ic.cam.remove( ic.canvasUI.mesh );
                } },
                surface: { type: "button", paddingTop: paddingtop, position:{ top: margin + 5*(btnHeight + margin), left: margin + (btnWidth + margin) }, width: btnWidth, height: btnHeight, fontColor: fontColor, fontSize: fontSize, backgroundColor: bkgdColor, hover: hoverColor, onSelect: function() {
                    ic.opts['surface'] = 'molecular surface';
                    ic.applyMapCls.applySurfaceOptions();

                    ic.cam.remove( ic.canvasUI.mesh );
                } },
                surfaceTrn: { type: "button", paddingTop: paddingtop2, position:{ top: margin + 6*(btnHeight + margin), left: margin + (btnWidth + margin) }, width: btnWidth, height: btnHeight, fontColor: fontColor, fontSize: fontSize, backgroundColor: bkgdColor, hover: hoverColor, onSelect: function() {
                    ic.opts['surface'] = 'molecular surface';
                    ic.opts['opacity'] = '0.2';
                    ic.applyMapCls.applySurfaceOptions();

                    ic.cam.remove( ic.canvasUI.mesh );
                } },

                color: { type: "button", paddingTop: paddingtop, position:{ top: margin, left: margin + 2*(btnWidth + margin)}, width: btnWidth, height: btnHeight, fontColor: "#000", fontSize: fontLarge, backgroundColor: bkgdColor},
                rainbow: { type: "button", paddingTop: paddingtop, position:{ top: margin + (btnHeight + margin), left: margin + 2*(btnWidth + margin)}, width: btnWidth, height: btnHeight, fontColor: fontColor, fontSize: fontSize, backgroundColor: bkgdColor, hover: hoverColor, onSelect: function() {
                    ic.setOptionCls.setOption('color', 'rainbow for chains');
                    ic.cam.remove( ic.canvasUI.mesh );
                } },
                atomColor: { type: "button", paddingTop: paddingtop, position:{ top: margin + 2*(btnHeight + margin), left: margin + 2*(btnWidth + margin)}, width: btnWidth, height: btnHeight, fontColor: fontColor, fontSize: fontSize, backgroundColor: bkgdColor, hover: hoverColor, onSelect: function() {
                    ic.setOptionCls.setOption('color', 'atom');
                    ic.cam.remove( ic.canvasUI.mesh );
                } },
                chainColor: { type: "button", paddingTop: paddingtop, position:{ top: margin + 3*(btnHeight + margin), left: margin + 2*(btnWidth + margin) }, width: btnWidth, height: btnHeight, fontColor: fontColor, fontSize: fontSize, backgroundColor: bkgdColor, hover: hoverColor, onSelect: function() {
                    ic.setOptionCls.setOption('color', 'chain');
                     ic.cam.remove( ic.canvasUI.mesh );
                } },
                secondaryColor: { type: "button", paddingTop: paddingtop2, position:{ top: margin + 4*(btnHeight + margin), left: margin + 2*(btnWidth + margin) }, width: btnWidth, height: btnHeight, fontColor: fontColor, fontSize: fontSize, backgroundColor: bkgdColor, hover: hoverColor, onSelect: function() {
                    ic.setOptionCls.setOption('color', 'secondary structure green');
                    ic.cam.remove( ic.canvasUI.mesh );
                } },
                charge: { type: "button", paddingTop: paddingtop, position:{ top: margin + 6*(btnHeight + margin), left: margin + 2*(btnWidth + margin) }, width: btnWidth, height: btnHeight, fontColor: fontColor, fontSize: fontSize, backgroundColor: bkgdColor, hover: hoverColor, onSelect: function() {
                    ic.setOptionCls.setOption('color', 'charge');
                    ic.cam.remove( ic.canvasUI.mesh );
                } },
                AlphaFold: { type: "button", paddingTop: paddingtop, position:{ top: margin + 5*(btnHeight + margin), left: margin + 2*(btnWidth + margin) }, width: btnWidth, height: btnHeight, fontColor: fontColor, fontSize: fontSize, backgroundColor: bkgdColor, hover: hoverColor, onSelect: function() {
                    ic.setOptionCls.setOption('color', 'confidence');
                     ic.cam.remove( ic.canvasUI.mesh );
                } },
                

                unicolor: { type: "button", paddingTop: paddingtop, position:{ top: margin, left: margin + 3*(btnWidth + margin)}, width: btnWidth, height: btnHeight, fontColor: "#000", fontSize: fontLarge, backgroundColor: bkgdColor},
                red: { type: "button", position:{ top: btnHeight, left: 3*(btnWidth + margin)}, width: svgWidth, height: svgHeight2, fontColor: 'red', hover: hoverColor, onSelect: function() {
                    ic.setOptionCls.setOption('color', 'red');
                    ic.cam.remove( ic.canvasUI.mesh );
                } },
                green: { type: "button", position:{ top: btnHeight + (btnHeight2 + margin), left: 3*(btnWidth + margin)}, width: svgWidth, height: svgHeight2, fontColor: 'green', hover: hoverColor, onSelect: function() {
                    ic.setOptionCls.setOption('color', 'green');
                    ic.cam.remove( ic.canvasUI.mesh );
                } },
                blue: { type: "button", position:{ top: 2*(margin + btnHeight) - margin, left: 3*(btnWidth + margin)}, width: svgWidth, height: svgHeight2, fontColor: 'blue', hover: hoverColor, onSelect: function() {
                    ic.setOptionCls.setOption('color', 'blue');
                    ic.cam.remove( ic.canvasUI.mesh );
                } },
                blueviolet: { type: "button", position:{ top: 2*(margin + btnHeight) - margin + (btnHeight2 + margin), left: 3*(btnWidth + margin)}, width: svgWidth, height: svgHeight2, fontColor: '#8A2BE2', hover: hoverColor, onSelect: function() {
                    ic.setOptionCls.setOption('color', '8A2BE2');
                    ic.cam.remove( ic.canvasUI.mesh );
                } },
                magenta: { type: "button", position:{ top: 3*(margin + btnHeight) - margin , left: 3*(btnWidth + margin)}, width: svgWidth, height: svgHeight2, fontColor: 'magenta', hover: hoverColor, onSelect: function() {
                    ic.setOptionCls.setOption('color', 'magenta');
                    ic.cam.remove( ic.canvasUI.mesh );
                } },
                yellow: { type: "button", position:{ top: 3*(margin + btnHeight) - margin + (btnHeight2 + margin), left: 3*(btnWidth + margin)}, width: svgWidth, height: svgHeight2, fontColor: 'yellow', hover: hoverColor, onSelect: function() {
                    ic.setOptionCls.setOption('color', 'yellow');
                    ic.cam.remove( ic.canvasUI.mesh );
                } },
                orange: { type: "button", position:{ top: 4*(margin + btnHeight) - margin, left: 3*(btnWidth + margin)}, width: svgWidth, height: svgHeight2, fontColor: 'orange', hover: hoverColor, onSelect: function() {
                    ic.setOptionCls.setOption('color', 'FFA500');
                     ic.cam.remove( ic.canvasUI.mesh );
                } },
                cyan: { type: "button", position:{ top: 4*(margin + btnHeight) - margin + (btnHeight2 + margin), left: 3*(btnWidth + margin)}, width: svgWidth, height: svgHeight2, fontColor: 'cyan', hover: hoverColor, onSelect: function() {
                    ic.setOptionCls.setOption('color', 'cyan');
                    ic.cam.remove( ic.canvasUI.mesh );
                } },
                gray: { type: "button", position:{ top: 5*(margin + btnHeight) - margin, left: 3*(btnWidth + margin)}, width: svgWidth, height: svgHeight2, fontColor: 'gray', hover: hoverColor, onSelect: function() {
                    ic.setOptionCls.setOption('color', '888888');
                     ic.cam.remove( ic.canvasUI.mesh );
                } },
                white: { type: "button", position:{ top: 5*(margin + btnHeight) - margin + (btnHeight2 + margin), left: 3*(btnWidth + margin)}, width: svgWidth, height: svgHeight2, fontColor: 'white', hover: hoverColor, onSelect: function() {
                    ic.setOptionCls.setOption('color', 'white');
                    ic.cam.remove( ic.canvasUI.mesh );
                } },

                analysis: { type: "button", paddingTop: paddingtop, position:{ top: margin, left: margin + 4*(btnWidth + margin) }, width: btnWidth, height: btnHeight, fontColor: "#000", fontSize: fontLarge, backgroundColor: bkgdColor},
                distance: { type: "button", paddingTop: paddingtop, position:{ top: margin + (btnHeight + margin), left: margin + 4*(btnWidth + margin)}, width: btnWidth, height: btnHeight, fontColor: fontColor, fontSize: fontSize, backgroundColor: bkgdColor, hover: hoverColor, onSelect: function() {
                    try {
                        ic.bMeasureDistance = true;

                        let atoms1 = ic.pickingCls.getPickedAtomList(ic.pk, ic.pAtom);
                        let atoms2 = ic.pickingCls.getPickedAtomList(ic.pk, ic.pAtom2);

                        let center1 = ic.applyCenterCls.centerAtoms(me.hashUtilsCls.hash2Atoms(atoms1, ic.atoms)).center;
                        let center2 = ic.applyCenterCls.centerAtoms(me.hashUtilsCls.hash2Atoms(atoms2, ic.atoms)).center;

                        let size = 0, background = 0;
                        let color = '#FFFF00';
                        let x =(center1.x + center2.x) / 2;
                        let y =(center1.y + center2.y) / 2;
                        let z =(center1.z + center2.z) / 2;

                        //ic.analysisCls.addLineFromPicking('distance');
                        let dashed = true;
                        ic.analysisCls.addLine(center1.x, center1.y, center1.z, center2.x, center2.y, center2.z, color, dashed, 'distance');
            
                        let distance = parseInt(center1.distanceTo(center2) * 10) / 10;
                        let text = distance.toString() + " A";
                        ic.analysisCls.addLabel(text, x, y, z, size, color, background, 'distance');
                        ic.drawCls.draw();

                        ic.cam.remove( ic.canvasUI.mesh );
                    }
                    catch(err) {
                        //ic.canvasUILog.updateElement( "info", "ERROR: " + err );
                    }
                } },
                interaction: { type: "button", paddingTop: paddingtop, position:{ top: margin + 2*(btnHeight + margin), left: margin + 4*(btnWidth + margin)}, width: btnWidth, height: btnHeight, fontColor: fontColor, fontSize: fontSize, backgroundColor: bkgdColor, hover: hoverColor, onSelect: function() {
                    try {
                       ic.viewInterPairsCls.viewInteractionPairs(['selected'], ['non-selected'], false, '3d', 1, 1, 1, 1, 1, 1);
                       ic.cam.remove( ic.canvasUI.mesh );
                    }
                    catch(err) {
                       //ic.canvasUILog.updateElement( "info", "ERROR: " + err );
                    }
               } },
               delphi: { type: "button", paddingTop: paddingtop, position:{ top: margin + 3*(btnHeight + margin), left: margin + 4*(btnWidth + margin)}, width: btnWidth, height: btnHeight, fontColor: fontColor, fontSize: fontSize, backgroundColor: bkgdColor, hover: hoverColor, onSelect: async function() {
                   let gsize = 65, salt = 0.15, contour = 2, bSurface = true;
                   ic.phisurftype = 22; // molecular surface
                   ic.phisurfop = 1.0; // opacity
                   ic.phisurfwf = 'no'; // wireframe
                   await ic.delphiCls.CalcPhi(gsize, salt, contour, bSurface);
                   
                   ic.cam.remove( ic.canvasUI.mesh );
               } },
                removeLabel: { type: "button", paddingTop: paddingtop, position:{ top: margin + 4*(btnHeight + margin), left: margin + 4*(btnWidth + margin) }, width: btnWidth, height: btnHeight, fontColor: fontColor, fontSize: fontSize, backgroundColor: bkgdColor, hover: hoverColor, onSelect: function() {
                    for(let name in ic.labels) {
                        //if(name === 'residue' || name === 'custom') {
                            ic.labels[name] = [];
                        //}
                    }
            
                    ic.drawCls.draw();
                    ic.cam.remove( ic.canvasUI.mesh );
                } },

                renderer: ic.renderer
            };

            const content = {
                select: "Select",
                residue: "Residue",
                secondarySelect: "Secondary Structure",
                chainSelect: "Chain",
                atom: "Atom",
                reset: "Reset",
                togglehl: "Toggle Highlight",

                style: "Style",
                ribbon: "Ribbon",
                schematic: "Schematic",
                stick: "Stick",
                sphere: "Sphere",
                surface: "Surface",
                surfaceTrn: "Transparent Surface",

                color: "Color",
                rainbow: "Rainbow",
                atomColor: "Atom",
                chainColor: "Chain",
                secondaryColor: "Secondary Structure",
                AlphaFold: "AlphaFold",
                charge: "Charge",

                unicolor: "UniColor",
                red: "<path>M 100 15 L 15 15 L 15 100 L 100 100 Z<path>",
                green: "<path>M 100 15 L 15 15 L 15 100 L 100 100 Z<path>",
                blue: "<path>M 100 15 L 15 15 L 15 100 L 100 100 Z<path>",
                blueviolet: "<path>M 100 15 L 15 15 L 15 100 L 100 100 Z<path>",
                magenta: "<path>M 100 15 L 15 15 L 15 100 L 100 100 Z<path>",
                yellow: "<path>M 100 15 L 15 15 L 15 100 L 100 100 Z<path>",
                orange: "<path>M 100 15 L 15 15 L 15 100 L 100 100 Z<path>",
                cyan: "<path>M 100 15 L 15 15 L 15 100 L 100 100 Z<path>",
                gray: "<path>M 100 15 L 15 15 L 15 100 L 100 100 Z<path>",
                white: "<path>M 100 15 L 15 15 L 15 100 L 100 100 Z<path>",

                analysis: "Analysis",
                distance: "Distance",
                interaction: "Interaction",
                delphi: "DelPhi Potential",
                removeLabel: "Remove Label"
            };

            const ui = new CanvasUI( content, config );
            
            //ui.mesh.position.set( 0, 1.5, -1.2 );
            //ui.mesh.position.set( 0, 2, -2 );
            ui.mesh.position.set( 0, 0, -3 );

            return ui;
        }

        createUILog() { let ic = this.icn3d; ic.icn3dui;
            const config = {
                panelSize: { width: 2, height: 2 },
                height: 512,
                info: { type: "text", overflow: "scroll", position:{ top: 6, left: 6 }, width: 506, height: 506, backgroundColor: "#aaa", fontColor: "#000" },
                renderer: ic.renderer
            };
            const content = {
                info: "Debug info"
            };

            const ui = new CanvasUI( content, config );

            //ui.mesh.position.set( 0, -2, -3 ); // VR
            ui.mesh.position.set( 0, -1, -2 ); // AR

            return ui;
        }

        getControllers() { let ic = this.icn3d; ic.icn3dui;
            const controllerModelFactory = new XRControllerModelFactory();
         
            // The camera is right above the headset, lower the line a bit.
            // Then the menu selection was off. So don't change it.
            const yAdjust = 0; //-1;
            const geometry = new THREE.BufferGeometry().setFromPoints( [
                new THREE.Vector3(0, yAdjust, 0),
                new THREE.Vector3(0, yAdjust,-1)
            ]);
            const line = new THREE.Line( geometry );
            line.name = 'line';
            line.scale.z = 50; //10; // extend the line 10 time

            const controllers = [];
            
            for(let i=0; i<=1; i++){
                const controller = ic.renderer.xr.getController( i );
                if(!controller) continue;

                ic.dolly.add( controller );

                controller.add( line.clone() );
                
                controller.userData.selectPressed = false;
    //            ic.scene.add(controller);
                ic.cam.add(controller);
                
                controllers.push( controller );
                
                const grip = ic.renderer.xr.getControllerGrip( i );
                grip.add( controllerModelFactory.createControllerModel( grip ));
                ic.scene.add( grip );
            }
            
            return controllers;
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Camera {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Set the camera according to the size of the structure.
        setCamera() { let ic = this.icn3d, me = ic.icn3dui;
            if(ic.bControlGl && !me.bNode) {
                window.cam = ic.cams[ic.opts.camera.toLowerCase()];

                let maxD = ic.maxD;

                if(window.cam === ic.perspectiveCamera) {
                    let bInstance = (ic.biomtMatrices !== undefined && ic.biomtMatrices.length * ic.cnt > ic.maxatomcnt) ? true : false;
                    //var factor = (ic.biomtMatrices !== undefined && ic.biomtMatrices.length * ic.cnt > 10 * ic.maxatomcnt) ? 1 : 2;
                    //var factor = (ic.biomtMatrices !== undefined && ic.biomtMatrices.length * ic.cnt > 10 * ic.maxatomcnt) ? 1 : 3;
                    if(bInstance) {
                        window.camMaxDFactor = 1;
                    }
                    else if(window.camMaxDFactorFog !== undefined) {
                        window.camMaxDFactor = window.camMaxDFactorFog; // 3
                    }
                    else {
                        window.camMaxDFactor = 3; //2;
                    }

                    if(window.cam_z > 0) {
                      window.cam.position.z = maxD * window.camMaxDFactor; // for perspective, the z position should be large enough to see the whole molecule
                    }
                    else {
                      window.cam.position.z = -maxD * window.camMaxDFactor; // for perspective, the z position should be large enough to see the whole molecule
                    }

                    if(ic.opts['slab'] === 'yes') {
                        if(bInstance) {
                            window.cam.near = 0.1;
                        }
                        else if(window.camMaxDFactorFog !== undefined) {
                            window.cam.near = maxD * window.camMaxDFactorFog - 10; // keep some surrounding residues
                        }
                        else {
                            window.cam.near = maxD * window.camMaxDFactor;
                        }
                    }
                    else {
                        window.cam.near = 0.1;
                    }
                    window.cam.far = 10000;

                    if(ic.bControlGl && !me.bNode) {
                        window.controls = new THREE.TrackballControls( window.cam, undefined, ic );
                    }
                    else {
                        if(!me.bNode) {
                            ic.controls = new THREE.TrackballControls( ic.cam, document.getElementById(ic.id), ic );
                        }
                        else {
                            ic.controls = new THREE.TrackballControls( ic.cam, document, ic );
                        }
                    }
                }
                else if (window.cam === ic.orthographicCamera){
                    if(ic.biomtMatrices !== undefined && ic.biomtMatrices.length * ic.cnt > 10 * ic.maxatomcnt) {
                        window.cam.right = ic.maxD/2 * 1.5;
                    }
                    else {
                        window.cam.right = ic.maxD/2 * 2.5;
                    }

                    window.cam.left = -window.cam.right;
                    window.cam.top = window.cam.right /ic.container.whratio;
                    window.cam.bottom = -window.cam.right /ic.container.whratio;

                      if(ic.opts['slab'] === 'yes') {
                          window.cam.near = ic.maxD * 2;
                      }
                      else {
                        window.cam.near = 0;
                      }

                      window.cam.far = 10000;

                    if(ic.bControlGl && !me.bNode) {
                        window.controls = new THREE.OrthographicTrackballControls( window.cam, undefined, ic );
                    }
                    else {
                        if(!me.bNode) {
                            ic.controls = new THREE.OrthographicTrackballControls( ic.cam, document.getElementById(ic.id), ic );
                        }
                        else {
                            ic.controls = new THREE.OrthographicTrackballControls( ic.cam, document, ic );
                        }
                    }
                }

                window.cam.updateProjectionMatrix();
            }
        //    else {
                // also set its own camera for picking purpose

                ic.cam = ic.cams[ic.opts.camera.toLowerCase()];

                let maxD = ic.maxD;

                if(ic.cam === ic.perspectiveCamera) {
                    let bInstance = (ic.biomtMatrices !== undefined && ic.biomtMatrices.length * ic.cnt > ic.maxatomcnt) ? true : false;
                    //var factor = (ic.biomtMatrices !== undefined && ic.biomtMatrices.length * ic.cnt > 10 * ic.maxatomcnt) ? 1 : 2;
                    //var factor = (ic.biomtMatrices !== undefined && ic.biomtMatrices.length * ic.cnt > 10 * ic.maxatomcnt) ? 1 : 3;
                    if(bInstance) {
                        ic.camMaxDFactor = 1;
                    }
                    else if(ic.camMaxDFactorFog !== undefined) {
                        ic.camMaxDFactor = ic.camMaxDFactorFog; // 3
                    }
                    else {
                        ic.camMaxDFactor = 3; //2;
                    }

                    if(ic.cam_z > 0) {
                      ic.cam.position.z = maxD * ic.camMaxDFactor; // forperspective, the z positionshould be large enough to see the whole molecule
                    }
                    else {
                      ic.cam.position.z = -maxD * ic.camMaxDFactor; // forperspective, the z positionshould be large enough to see the whole molecule
                    }

                    if(ic.opts['slab'] === 'yes') {
                        if(bInstance) {
                            ic.cam.near = 0.1;
                        }
                        else if(ic.camMaxDFactorFog !== undefined) {
                            ic.cam.near = maxD * ic.camMaxDFactorFog - 10; // keep some surrounding residues
                        }
                        else {
                            ic.cam.near = maxD * ic.camMaxDFactor;
                        }
                    }
                    else {
                        ic.cam.near = 0.1;
                    }
                    ic.cam.far = 10000;

                    if(ic.bControlGl && !me.bNode) {
                        window.controls = new THREE.TrackballControls( ic.cam, undefined, ic );
                    }
                    else {
                        if(!me.bNode) {
                            ic.controls = new THREE.TrackballControls( ic.cam, document.getElementById(ic.id), ic );
                        }
                        else {
                            ic.controls = new THREE.TrackballControls( ic.cam, document, ic );
                        }
                    }
                }
                else if (ic.cam === ic.orthographicCamera){
                    if(ic.biomtMatrices !== undefined && ic.biomtMatrices.length * ic.cnt > 10 * ic.maxatomcnt) {
                        ic.cam.right = ic.maxD/2 * 1.5;
                    }
                    else {
                        ic.cam.right = ic.maxD/2 * 2.5;
                    }

                    ic.cam.left = -ic.cam.right;
                    ic.cam.top = ic.cam.right /ic.container.whratio;
                    ic.cam.bottom = -ic.cam.right /ic.container.whratio;

                      if(ic.opts['slab'] === 'yes') {
                          ic.cam.near = ic.maxD * 2;
                      }
                      else {
                        ic.cam.near = 0;
                      }

                      ic.cam.far = 10000;

                    if(ic.bControlGl && !me.bNode) {
                        window.controls = new THREE.OrthographicTrackballControls( ic.cam, undefined, ic );
                    }
                    else {
                        if(!me.bNode) {
                            ic.controls = new THREE.OrthographicTrackballControls( ic.cam, document.getElementById(ic.id), ic );
                        }
                        else {
                            ic.controls = new THREE.OrthographicTrackballControls( ic.cam, document, ic );
                        }
                    }
                }

                // ic.cam.add(ic.directionalLight);

                ic.cam.updateProjectionMatrix();
        //    }
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Fog {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        setFog(bZoomin) { let ic = this.icn3d, me = ic.icn3dui;
            let background = me.parasCls.backgroundColors[ic.opts.background.toLowerCase()];

            if(bZoomin) {
                let centerAtomsResults = ic.applyCenterCls.centerAtoms(ic.hAtoms);
                ic.maxD = centerAtomsResults.maxD;
                //if (ic.maxD < 5) ic.maxD = 5;
                if (ic.maxD < 25) ic.maxD = 25;
            }

            let bInstance = (ic.biomtMatrices !== undefined && ic.biomtMatrices.length * ic.cnt > ic.maxatomcnt) ? true : false;

            // apply fog
            if(ic.opts['fog'] === 'yes') {
                if(ic.opts['camera'] === 'perspective') {        //perspective, orthographic
                    //ic.scene.fog = new THREE.Fog(background, ic.cam_z, ic.cam_z + 0.5 * ic.maxD);
                    //ic.scene.fog = new THREE.Fog(background, 2 * ic.maxD, 2.5 * ic.maxD);
                    //ic.scene.fog = new THREE.Fog(background, 1.5 * ic.maxD, 3 * ic.maxD);

                    if(bInstance) {
                        ic.scene.fog = undefined;
                        ic.bSetFog = false;
                    }
                    else {
                        // adjust
                        let zoomFactor = (ic._zoomFactor > 1) ? ic._zoomFactor * 1.0 : ic._zoomFactor;
                        ic.scene.fog = new THREE.Fog(background, 2.5 * ic.maxD * zoomFactor, 4 * ic.maxD * zoomFactor);
                        ic.bSetFog = true;
                        ic.camMaxDFactorFog = 3;
                    }
                }
                else if(ic.opts['camera'] === 'orthographic') {
                    //ic.scene.fog = new THREE.FogExp2(background, 2);
                    //ic.scene.fog.near = 1.5 * ic.maxD;
                    //ic.scene.fog.far = 3 * ic.maxD;

                    ic.scene.fog = undefined;
                    ic.bSetFog = false;
                }
            }
            else {
                ic.scene.fog = undefined;
                ic.bSetFog = false;
            }

            //if(bZoomin && !bInstance) {
            //    ic.transformCls.zoominSelection();
            //}
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Box {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Create a cube for "atom" with the "defaultRadius". "forceDefault" means to use the default radius.
        //"scale" means scale on the radius. "color" means the color of the cube. "bHighlight" is an option
        //to draw the highlight for the atom.
        createBox(atom, defaultRadius, forceDefault, scale, color, bHighlight) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            if(defaultRadius === undefined) defaultRadius = 0.8;
            if(forceDefault === undefined) forceDefault = false;
            if(scale === undefined) scale = 0.8;

            if(bHighlight) {
                if(color === undefined) color = ic.hColor;
            }
            else {
                if(color === undefined) color = atom.color;
            }

            let radius = forceDefault ? defaultRadius
              : (me.parasCls.vdwRadii[atom.elem.toUpperCase()] || defaultRadius) * (scale ? scale : 1);

            this.createBox_base(atom.coord, radius, color, bHighlight);
        }

        createBox_base(coord, radius, color, bHighlight, bOther, bGlycan, opacity) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            let mesh;

            if(opacity === undefined) opacity = (bGlycan) ? 0.5 : 1.0;

            new THREE.BoxGeometry(1, 1, 1);

            //if(bHighlight || bGlycan) {
              mesh = new THREE.Mesh(ic.boxGeometry, new THREE.MeshPhongMaterial({ transparent: true, opacity: opacity,
                  specular: ic.frac, shininess: ic.shininess, emissive: ic.emissive, color: color }));
            // }
            // else {
            //   mesh = new THREE.Mesh(ic.boxGeometry, new THREE.MeshPhongMaterial({needsUpdate: true,
            //       specular: ic.frac, shininess: ic.shininess, emissive: ic.emissive, color: color }));
            // }

            mesh.scale.x = mesh.scale.y = mesh.scale.z = radius;

            mesh.position.copy(coord);
            ic.mdl.add(mesh);

            if(bHighlight) {
                ic.prevHighlightObjects.push(mesh);
            }
            else if(bOther) {
                ic.prevOtherMesh.push(mesh);
            }
            else {
                ic.objects.push(mesh);
            }
        }

        createBoxRepresentation_P_CA(atoms, scale, bHighlight) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            let thisClass = this;
            ic.reprSubCls.createRepresentationSub(atoms, function (atom0) {
                if(atom0.name === 'CA' || atom0.name === "O3'" || atom0.name === "O3*") {
                    thisClass.createBox(atom0, undefined, undefined, scale, undefined, bHighlight);
                }
            });
        }

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Brick {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        createBrick(p0, p1, radius, color) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            let cylinderGeometry = new THREE.CylinderGeometry(1, 1, 1, 4, 1);

            let mesh = new THREE.Mesh(cylinderGeometry, new THREE.MeshPhongMaterial(
                { specular: ic.frac, shininess: ic.shininess, emissive: ic.emissive, color: color }));

            mesh.position.copy(p0).add(p1).multiplyScalar(0.5);
            mesh.matrixAutoUpdate = false;
            mesh.lookAt(p1.clone().sub(p0));
            mesh.updateMatrix();

            mesh.matrix.multiply(new THREE.Matrix4().makeScale(radius, radius,
              p0.distanceTo(p1))).multiply(new THREE.Matrix4().makeRotationX(Math.PI * 0.5));

            ic.mdl.add(mesh);
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class CurveStripArrow {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        createCurveSubArrow(p, width, colors, div, bHighlight, bRibbon, num, positionIndex,
          pntsCA, prevCOArray, bShowArray, calphaIdArray, bShowArrow, prevone, nexttwo) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            let divPoints = [], positions = [];

            divPoints.push(p);
            positions.push(positionIndex);

            this.prepareStrand(divPoints, positions, width, colors, div, undefined, bHighlight, bRibbon, num,
              pntsCA, prevCOArray, false, bShowArray, calphaIdArray, bShowArrow, prevone, nexttwo);

            divPoints = [];
            positions = [];
        }

        createStripArrow(p0, p1, colors, div, thickness, bHighlight, num, start, end,
          pntsCA, prevCOArray, bShowArray, calphaIdArray, bShowArrow, prevone, nexttwo) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            let divPoints = [], positions = [];

            divPoints.push(p0);
            divPoints.push(p1);
            positions.push(start);
            positions.push(end);

            this.prepareStrand(divPoints, positions, undefined, colors, div, thickness, bHighlight, undefined, num,
              pntsCA, prevCOArray, true, bShowArray, calphaIdArray, bShowArrow, prevone, nexttwo);

            divPoints = [];
            positions = [];
        }

        /**
         * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
         */

        prepareStrand(divPoints, positions, width, colors, div, thickness, bHighlight, bRibbon, num,
          pntsCA, prevCOArray, bStrip, bShowArray, calphaIdArray, bShowArrow, prevone, nexttwo) { let ic = this.icn3d, me = ic.icn3dui;
            if(pntsCA.length === 1) {
                return;
            }

            let oriColors = colors;
            let bHelix = (bShowArrow) ? false : true;

            let colorsLastTwo = [];
            colorsLastTwo.push(colors[colors.length - 2]);
            colorsLastTwo.push(colors[colors.length - 1]);

            div = div || ic.axisDIV;
            let numM1Inv2 = 2 / (num - 1);
            let delta, lastCAIndex, lastPrevCOIndex, v;

            let pnts = {};
            for(let i = 0, il = positions.length; i < il; ++i) pnts[i] = [];

            // smooth C-alpha
            let pnts_clrs = me.subdivideCls.subdivide(pntsCA, colors, div, undefined, undefined, prevone, nexttwo);
            let pntsCASmooth = pnts_clrs[0]; // get all smoothen pnts, do not use 'bShowArray'
            //colors = pnts_clrs[2];

            if(pntsCASmooth.length === 1) {
                return;
            }

            // draw the sheet without the last residue
            // use the sheet coord for n-2 residues
            let colorsTmp = [];
            let i, lastIndex = (bShowArrow === undefined || bShowArrow) ? pntsCA.length - 2 : pntsCA.length;

            let il = lastIndex;
            for (i = 0; i < il; ++i) {
                for(let index = 0, indexl = positions.length; index < indexl; ++index) {
                    pnts[index].push(divPoints[index][i]);
                }
                colorsTmp.push(colors[i]);
            }
            colorsTmp.push(colors[i]);

            if(bShowArrow === undefined || bShowArrow) {
                // assign the sheet coord from C-alpha for the 2nd to the last residue of the sheet
                for(let i = 0, il = positions.length; i < il; ++i) {
                    delta = -1 + numM1Inv2 * positions[i];
                    lastCAIndex = pntsCASmooth.length - 1 - div;
                    lastPrevCOIndex = pntsCA.length - 2;
                    v = new THREE.Vector3(pntsCASmooth[lastCAIndex].x + prevCOArray[lastPrevCOIndex].x * delta,
                      pntsCASmooth[lastCAIndex].y + prevCOArray[lastPrevCOIndex].y * delta,
                      pntsCASmooth[lastCAIndex].z + prevCOArray[lastPrevCOIndex].z * delta);
                    pnts[i].push(v);
                }
            }

            let posIndex = [];
            let results;
            for(let i = 0, il = positions.length; i < il; ++i) {
                results = me.subdivideCls.subdivide(pnts[i], colorsTmp, div, bShowArray, bHighlight);
                pnts[i] = results[0];
                colors = results[2];
                if(i === 0) {
                    posIndex = results[1];
                }
            }

            if(bStrip) {
                if(bHelix) {
                    if(!ic.bDoublecolor) {
                        ic.stripCls.createStrip(pnts[0], pnts[1], colors, div, thickness, bHighlight, true,
                          undefined, calphaIdArray, posIndex, prevone, nexttwo, pntsCA, prevCOArray);
                    }
                    else {
                        ic.stripCls.createStrip(pnts[0], pnts[1], oriColors, div, thickness, bHighlight, true,
                          undefined, calphaIdArray, posIndex, prevone, nexttwo, pntsCA, prevCOArray);
                    }
                }
                else {
                    ic.stripCls.createStrip(pnts[0], pnts[1], colors, div, thickness, bHighlight, true,
                      undefined, calphaIdArray, posIndex, prevone, nexttwo);
                }
            }
            else {
                ic.curveCls.createCurveSub(pnts[0], width, colors, div, bHighlight, bRibbon, true,
                  undefined, calphaIdArray, posIndex, prevone, nexttwo);
            }

            if(bShowArrow === undefined || bShowArrow) {
                // draw the arrow
                colorsTmp = [];

                posIndex = [];
                for(let index = 0, indexl = positions.length; index < indexl; ++index) {
                    pnts[index] = [];

                    for (let i = div * (pntsCA.length - 2), il = div * (pntsCA.length - 1);
                      bShowArray[parseInt(i/div)] && i < il; i = i + div) {
                        let pos = parseInt(i/div);
                        for (let j = 0; j < div; ++j) {
                            let delta = -1 + numM1Inv2 * positions[index];
                            let scale = 1.8; // scale of the arrow width
                            delta = delta * scale * (div - j) / div;
                            let oriIndex = parseInt(i/div);

                            let v = new THREE.Vector3(pntsCASmooth[i+j].x + prevCOArray[oriIndex].x * delta,
                              pntsCASmooth[i+j].y + prevCOArray[oriIndex].y * delta,
                              pntsCASmooth[i+j].z + prevCOArray[oriIndex].z * delta);
                            v.smoothen = true;
                            pnts[index].push(v);
                            colorsTmp.push(colorsLastTwo[0]);
                            if(index === 0) posIndex.push(pos);
                        }
                    }

                    // last residue
                    // make the arrow end with 0
                    let delta = 0;
                    let lastCAIndex = pntsCASmooth.length - 1;
                    let lastPrevCOIndex = pntsCA.length - 1;

                    //if(bShowArray[lastPrevCOIndex]) {
                        let v = new THREE.Vector3(pntsCASmooth[lastCAIndex].x + prevCOArray[lastPrevCOIndex].x * delta,
                          pntsCASmooth[lastCAIndex].y + prevCOArray[lastPrevCOIndex].y * delta,
                          pntsCASmooth[lastCAIndex].z + prevCOArray[lastPrevCOIndex].z * delta);
                        v.smoothen = true;
                        pnts[index].push(v);
                        colorsTmp.push(colorsLastTwo[1]);
                        if(index === 0) posIndex.push(lastCAIndex);
                    //}
                }

                pntsCASmooth = [];

                //colorsTmp.push(colors[colors.length - 2]);
                //colorsTmp.push(colors[colors.length - 1]);

                if(bStrip) {
                    ic.stripCls.createStrip(pnts[0], pnts[1], colorsTmp, div, thickness, bHighlight, true,
                      undefined, undefined, posIndex, prevone, nexttwo);
                }
                else {
                    ic.curveCls.createCurveSub(pnts[0], width, colorsTmp, div, bHighlight, bRibbon, true,
                      undefined, undefined, posIndex, prevone, nexttwo);
                }
            }

            for(let i in pnts) {
                for(let j = 0, jl = pnts[i].length; j < jl; ++j) {
                    pnts[i][j] = null;
                }
                pnts[i] = [];
            }

            pnts = {};
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Curve {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        // modified from iview (http://star.cse.cuhk.edu.hk/iview/)
        createCurveSub(_pnts, width, colors, div, bHighlight, bRibbon, bNoSmoothen, bShowArray, calphaIdArray, positions, prevone, nexttwo) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            if (_pnts.length === 0) return;
            div = div || 5;
            let pnts;
            if(!bNoSmoothen) {
                let bExtendLastRes = true;
                let pnts_clrs = me.subdivideCls.subdivide(_pnts, colors, div, bShowArray, bHighlight, prevone, nexttwo, bExtendLastRes);
                pnts = pnts_clrs[0];
                colors = pnts_clrs[2];
            }
            else {
                pnts = _pnts;
            }
            if (pnts.length === 0) return;

            ic.stripCls.setCalphaDrawnCoord(pnts, div, calphaIdArray);

            if(bHighlight === 1) {
                let radius = ic.coilWidth / 2;
                //var radiusSegments = 8;
                let radiusSegments = 4; // save memory
                let closed = false;

                if(pnts.length > 1) {
                    if(positions !== undefined) {
                        let currPos, prevPos;
                        let currPoints = [];
                        for(let i = 0, il = pnts.length; i < il; ++i) {
                            currPos = positions[i];

                            if( (currPos !== prevPos && parseInt(currPos) !== parseInt(prevPos) + 1 && prevPos !== undefined) || (i === il -1) ) {
                                // first tube
                                let geometry0 = new THREE.TubeGeometry(
                                    new THREE.CatmullRomCurve3(currPoints), // path
                                    currPoints.length, // segments
                                    radius,
                                    radiusSegments,
                                    closed
                                );

                                let mesh = new THREE.Mesh(geometry0, ic.matShader);
                                mesh.renderOrder = ic.renderOrderPicking;
                                //ic.mdlPicking.add(mesh);
                                ic.mdl.add(mesh);

                                ic.prevHighlightObjects.push(mesh);

                                geometry0 = null;

                                currPoints = [];
                            }

                            currPoints.push(pnts[i]);

                            prevPos = currPos;
                        }

                        currPoints = [];
                    }
                    else {
                        let geometry0 = new THREE.TubeGeometry(
                            new THREE.CatmullRomCurve3(pnts), // path
                            pnts.length, // segments
                            radius,
                            radiusSegments,
                            closed
                        );

                        let mesh = new THREE.Mesh(geometry0, ic.matShader);
                        mesh.renderOrder = ic.renderOrderPicking;
                        //ic.mdlPicking.add(mesh);
                        ic.mdl.add(mesh);

                        ic.prevHighlightObjects.push(mesh);

                        geometry0 = null;
                    }
                }
            }
            else {
                //var geo = new THREE.Geometry();
                let geo = new THREE.BufferGeometry();

                let verticeArray = [], colorArray = [];

                let offset = 0, color;
                if(bHighlight === 2 && bRibbon) {
                    for (let i = 0; i < pnts.length; ++i, offset += 3) {
                        // shift the highlight a little bit to avoid the overlap with ribbon
                        pnts[i].addScalar(0.6); // ic.ribbonthickness is 0.4
                        //geo.vertices.push(pnts[i]);
                        //geo.colors.push(me.parasCls.thr(colors[i]));

                        //vertices = vertices.concat(pnts[i].toArray());
                        verticeArray[offset] = pnts[i].x;
                        verticeArray[offset+1] = pnts[i].y;
                        verticeArray[offset+2] = pnts[i].z;

                        //colors = colors.concat(me.parasCls.thr(colors[i]).toArray());
                        color = me.parasCls.thr(colors[i]);

                        colorArray[offset] = color.r;
                        colorArray[offset+1] = color.g;
                        colorArray[offset+2] = color.b;
                    }
                }
                else {
                    for (let i = 0; i < pnts.length; ++i, offset += 3) {
                        //geo.vertices.push(pnts[i]);
                        //geo.colors.push(me.parasCls.thr(colors[i]));

                        //vertices = vertices.concat(pnts[i].toArray());
                        verticeArray[offset] = pnts[i].x;
                        verticeArray[offset+1] = pnts[i].y;
                        verticeArray[offset+2] = pnts[i].z;

                        //colors = colors.concat(me.parasCls.thr(colors[i]).toArray());
                        color = me.parasCls.thr(colors[i]);

                        colorArray[offset] = color.r;
                        colorArray[offset+1] = color.g;
                        colorArray[offset+2] = color.b;
                    }
                }

                let nComp = 3;
                geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(verticeArray), nComp));
                geo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(colorArray), nComp));

                //geo.computeVertexNormals();

                //var line = new THREE.Line(geo, new THREE.LineBasicMaterial({ linewidth: width, vertexColors: true }), THREE.LineStrip);
                let line = new THREE.Line(geo, new THREE.LineBasicMaterial({ linewidth: width, vertexColors: true }));
                ic.mdl.add(line);
                if(bHighlight === 2) {
                    ic.prevHighlightObjects.push(line);
                }
                else {
                    ic.objects.push(line);
                }
            }

            pnts = null;
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Cylinder {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        // modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
        createCylinder(p0, p1, radius, color, bHighlight, color2, bPicking, bGlycan, opacity) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            let opacity_ori = opacity;
            if(opacity === undefined) opacity = (bGlycan) ? 0.5 : 1.0;

            let mesh;
            if(bHighlight === 1) {
                mesh = new THREE.Mesh(ic.cylinderGeometryOutline, ic.matShader);

                mesh.position.copy(p0).add(p1).multiplyScalar(0.5);
                mesh.matrixAutoUpdate = false;
                mesh.lookAt(p1.clone().sub(p0));
                mesh.updateMatrix();

                mesh.matrix.multiply(new THREE.Matrix4().makeScale(radius, radius,
                  p0.distanceTo(p1))).multiply(new THREE.Matrix4().makeRotationX(Math.PI * 0.5));

                mesh.renderOrder = ic.renderOrderPicking;
                ic.mdl.add(mesh);

                ic.prevHighlightObjects.push(mesh);
            }
            else {
                if(bHighlight === 2) {
                  mesh = new THREE.Mesh(ic.cylinderGeometry, new THREE.MeshPhongMaterial(
                      {transparent: true, opacity: opacity, specular: ic.frac, shininess: ic.shininess, emissive: ic.emissive, color: color }));

                  radius *= 1.5;
                }
                //else if(bGlycan) {
                else {
                  mesh = new THREE.Mesh(ic.cylinderGeometry, new THREE.MeshPhongMaterial(
                      {transparent: true, opacity: opacity, specular: ic.frac, shininess: ic.shininess, emissive: ic.emissive, color: color }));
                }
                // else {
                //   mesh = new THREE.Mesh(ic.cylinderGeometry, new THREE.MeshPhongMaterial(
                //       {specular: ic.frac, shininess: ic.shininess, emissive: ic.emissive, color: color }));
                // }

                mesh.position.copy(p0).add(p1).multiplyScalar(0.5);
                mesh.matrixAutoUpdate = false;
                mesh.lookAt(p1.clone().sub(p0));
                mesh.updateMatrix();

                mesh.matrix.multiply(new THREE.Matrix4().makeScale(radius, radius, p0.distanceTo(p1))).multiply(
                    new THREE.Matrix4().makeRotationX(Math.PI * 0.5));

                if(ic.bImpo && !opacity_ori && !bGlycan) {
                  ic.posArray.push(p0.x);
                  ic.posArray.push(p0.y);
                  ic.posArray.push(p0.z);

                  if(!color) color = me.parasCls.thr(0xFFFFFF);
                  ic.colorArray.push(color.r);
                  ic.colorArray.push(color.g);
                  ic.colorArray.push(color.b);

                  ic.pos2Array.push(p1.x);
                  ic.pos2Array.push(p1.y);
                  ic.pos2Array.push(p1.z);

                  if(color2 !== undefined) {
                      ic.color2Array.push(color2.r);
                      ic.color2Array.push(color2.g);
                      ic.color2Array.push(color2.b);
                  }
                  else {
                      ic.color2Array.push(color.r);
                      ic.color2Array.push(color.g);
                      ic.color2Array.push(color.b);
                  }

                  ic.radiusArray.push(radius);

                  if(ic.cnt <= ic.maxatomcnt) ic.mdl_ghost.add(mesh);
                }
                else {
                    ic.mdl.add(mesh);
                }

                if(bHighlight === 2) {
                    if(ic.bImpo && !opacity_ori) {
                        if(ic.cnt <= ic.maxatomcnt) ic.prevHighlightObjects_ghost.push(mesh);
                    }
                    else {
                        ic.prevHighlightObjects.push(mesh);
                    }
                }
                else {
                    if(ic.bImpo && !opacity_ori) {
                        if(ic.cnt <= ic.maxatomcnt) ic.objects_ghost.push(mesh);
                    }
                    else {
                        if(bPicking === undefined || bPicking) ic.objects.push(mesh);
                    }
                }
            }
        }

        createCylinder_base(p0, p1, radius, color, bHighlight, color2, bPicking) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            let mesh = new THREE.Mesh(ic.cylinderGeometry, new THREE.MeshPhongMaterial(
                {specular: ic.frac, shininess: ic.shininess, emissive: ic.emissive, color: color }));

            mesh.position.copy(p0).add(p1).multiplyScalar(0.5);
            mesh.matrixAutoUpdate = false;
            mesh.lookAt(p1.clone().sub(p0));
            mesh.updateMatrix();

            mesh.matrix.multiply(new THREE.Matrix4().makeScale(radius, radius, p0.distanceTo(p1))).multiply(
                new THREE.Matrix4().makeRotationX(Math.PI * 0.5));

            return mesh;
        }

        // modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
        //Create cylinders for alpha helices and ribbons for beta strands in "atoms".
        //"radius" is radius of the cylinders. "bHighlight" is an option to draw the highlight for these atoms.
        //The highlight could be outlines with bHighlight=1 and 3D objects with bHighlight=2 as mentioned above.
        createCylinderHelix(atoms, radius, bHighlight) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            let start = null;
            let currentChain, currentResi;
            let others = {}, beta = {};
            let i;
            for (i in atoms) {
                let atom = atoms[i];
                if (atom.het) continue;
                if ((atom.ss !== 'helix' && atom.ss !== 'sheet') || atom.ssend || atom.ssbegin) others[atom.serial] = atom;
                if (atom.ss === 'sheet') beta[atom.serial] = atom;
                if (atom.name !== 'CA') continue;
                if (atom.ss === 'helix' && atom.ssend) {
                    if (start !== null && currentChain === atom.chain && parseInt(currentResi) < parseInt(atom.resi)) {
                        if(bHighlight === 1 || bHighlight === 2) {
                            this.createCylinder(start.coord, atom.coord, radius, ic.hColor, bHighlight);
                        }
                        else {                
                            this.createCylinder(start.coord, atom.coord, radius, atom.color);
                        }
                    }

                    start = null;
                }

                if (start === null && atom.ss === 'helix' && atom.ssbegin) {
                    start = atom;

                    currentChain = atom.chain;
                    currentResi = atom.resi;
                }
            }

            if(bHighlight === 1 || bHighlight === 2) {
                if(Object.keys(others).length > 0) ic.tubeCls.createTube(others, 'CA', ic.coilWidth, bHighlight);
                if(Object.keys(beta).length > 0) ic.strandCls.createStrand(beta, undefined, undefined, true, 0,
                    ic.helixSheetWidth, false, ic.ribbonthickness * 2, bHighlight);
            }
            else {
                if(Object.keys(others).length > 0) ic.tubeCls.createTube(others, 'CA', ic.coilWidth);
                if(Object.keys(beta).length > 0) ic.strandCls.createStrand(beta, undefined, undefined, true, 0,
                    ic.helixSheetWidth, false, ic.ribbonthickness * 2);
            }
        }

        // modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
        //Create small cylinders (thick lines) for "atoms", whose atom name should be in the array atomNameArray.
        //"radius" is radius of the small cylinders. "bLine" is an option to show the cylinders as lines.
        //"bHighlight" is an option to draw the highlight for these atoms. The highlight could be outlines
        //with bHighlight=1 and 3D objects with bHighlight=2 as mentioned above.
        createCylinderCurve(atoms, atomNameArray, radius, bLines, bHighlight) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            let start = null;
            let currentChain, currentResi;
            let i;

            let atom, maxDistance = 8.0; // max residue-residue (or nucleitide-nucleitide) distance allowed

            let chainid, currentChainid;

            for (i in atoms) {
                atom = atoms[i];
                if (atom.het) continue;

                chainid = atom.structure + '_' + atom.chain;
                currentChainid = atom.structure + '_' + currentChain;

                //if (atom.name !== atomName) continue;
                if(atomNameArray.indexOf(atom.name) == -1) continue;

                if (start !== null && currentChain === atom.chain 
                    && ic.ParserUtilsCls.getResiNCBI(currentChainid, currentResi) + 1 === ic.ParserUtilsCls.getResiNCBI(chainid, atom.resi)
                    && Math.abs(start.coord.x - atom.coord.x) < maxDistance
                    && Math.abs(start.coord.y - atom.coord.y) < maxDistance
                    && Math.abs(start.coord.z - atom.coord.z) < maxDistance ) {
                    let middleCoord = start.coord.clone().add(atom.coord).multiplyScalar(0.5);

                    if(!bHighlight) {
                        if(bLines) {
                            let line = ic.lineCls.createSingleLine( start.coord, middleCoord, start.color, false);
                            ic.mdl.add(line);
                            ic.objects.push(line);
                            line = ic.lineCls.createSingleLine( middleCoord, atom.coord, atom.color, false);
                            ic.mdl.add(line);
                            ic.objects.push(line);
                        }
                        else {
                            this.createCylinder(start.coord, middleCoord, radius, start.color);
                            this.createCylinder(middleCoord, atom.coord, radius, atom.color);
                            ic.sphereCls.createSphere(atom, radius, true, 1, bHighlight);
                        }
                    }
                    else if(bHighlight === 1) {
                        this.createCylinder(start.coord, middleCoord, radius, start.color, bHighlight);
                        this.createCylinder(middleCoord, atom.coord, radius, atom.color, bHighlight);
                        ic.sphereCls.createSphere(atom, radius, true, 1, bHighlight);
                    }
                }

                start = atom;
                currentChain = atom.chain;
                currentResi = atom.resi;

                // create a sphere for each c-alpha
                ic.sphereCls.createSphere(atom, radius, true, 1, bHighlight);

                if(bHighlight === 2) ic.boxCls.createBox(atom, undefined, undefined, undefined, undefined, bHighlight);
            }
            if (start !== null && currentChain === atom.chain 
                && ic.ParserUtilsCls.getResiNCBI(currentChainid, currentResi) + 1 === ic.ParserUtilsCls.getResiNCBI(chainid, atom.resi)
                && Math.abs(start.coord.x - atom.coord.x) < maxDistance
                && Math.abs(start.coord.y - atom.coord.y) < maxDistance
                && Math.abs(start.coord.z - atom.coord.z) < maxDistance ) {
                let middleCoord = start.coord.add(atom.coord).multiplyScalar(0.5);
                if(!bHighlight) {
                    if(bLines) {
                        let line = ic.lineCls.createSingleLine( start.coord, middleCoord, start.color, false);
                        ic.mdl.add(line);
                        ic.objects.push(line);
                        line = ic.lineCls.createSingleLine( middleCoord, atom.coord, atom.color, false);
                        ic.mdl.add(line);
                        ic.objects.push(line);
                    }
                    else {
                        this.createCylinder(start.coord, middleCoord, radius, start.color);
                        this.createCylinder(middleCoord, atom.coord, radius, atom.color);
                    }
                }
                else if(bHighlight === 1) {
                    this.createCylinder(start.coord, middleCoord, radius, start.color, bHighlight);
                    this.createCylinder(middleCoord, atom.coord, radius, atom.color, bHighlight);
                    ic.sphereCls.createSphere(atom, radius, true, 1, bHighlight);
                }
            }
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Line$1 {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        // modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
        //Create lines for "atoms". "bHighlight" is an option to draw the highlight for these atoms.
        //The highlight could be outlines with bHighlight=1 and 3D objects with bHighlight=2.
        createLineRepresentation(atoms, bHighlight) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            //var geo = new THREE.Geometry();
            let geo = new THREE.BufferGeometry();
            let vertices = [], colors = [], offset = 0, offset2 = 0;

            ic.reprSubCls.createRepresentationSub(atoms, undefined, function (atom0, atom1) {
                if (atom0.color === atom1.color) {
                    vertices[offset++] = atom0.coord.x;
                    vertices[offset++] = atom0.coord.y;
                    vertices[offset++] = atom0.coord.z;
                    vertices[offset++] = atom1.coord.x;
                    vertices[offset++] = atom1.coord.y;
                    vertices[offset++] = atom1.coord.z;

                    colors[offset2++] = atom0.color.r;
                    colors[offset2++] = atom0.color.g;
                    colors[offset2++] = atom0.color.b;
                    colors[offset2++] = atom1.color.r;
                    colors[offset2++] = atom1.color.g;
                    colors[offset2++] = atom1.color.b;
                } else {
                    let mp = atom0.coord.clone().add(atom1.coord).multiplyScalar(0.5);
                    vertices[offset++] = atom0.coord.x;
                    vertices[offset++] = atom0.coord.y;
                    vertices[offset++] = atom0.coord.z;
                    vertices[offset++] = mp.x;
                    vertices[offset++] = mp.y;
                    vertices[offset++] = mp.z;
                    vertices[offset++] = atom1.coord.x;
                    vertices[offset++] = atom1.coord.y;
                    vertices[offset++] = atom1.coord.z;
                    vertices[offset++] = mp.x;
                    vertices[offset++] = mp.y;
                    vertices[offset++] = mp.z;

                    colors[offset2++] = atom0.color.r;
                    colors[offset2++] = atom0.color.g;
                    colors[offset2++] = atom0.color.b;
                    colors[offset2++] = atom0.color.r;
                    colors[offset2++] = atom0.color.g;
                    colors[offset2++] = atom0.color.b;
                    colors[offset2++] = atom1.color.r;
                    colors[offset2++] = atom1.color.g;
                    colors[offset2++] = atom1.color.b;
                    colors[offset2++] = atom1.color.r;
                    colors[offset2++] = atom1.color.g;
                    colors[offset2++] = atom1.color.b;
                }
            });

            let nComp = 3;
            geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), nComp));
            geo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), nComp));

            //geo.computeVertexNormals();

            if(bHighlight !== 2) {
                let line;
                if(bHighlight === 1) ;
                else {
                    line = new THREE.LineSegments(geo, new THREE.LineBasicMaterial(
                        {linewidth: ic.linewidth, vertexColors: true }));
                    ic.mdl.add(line);
                }

                if(bHighlight === 1) {
                    ic.prevHighlightObjects.push(line);
                }
                else {
                    ic.objects.push(line);
                }
            }
            else if(bHighlight === 2) {
                ic.boxCls.createBoxRepresentation_P_CA(atoms, 0.8, bHighlight);
            }
        }

        createConnCalphSidechain(atoms, style) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            // find all residues with style2 as 'nothing' or undefined
            let residueHash = {};
            for(let i in atoms) {
                let atom = atoms[i];
                if(!atom.het && atom.style2 === style) {
                    let resid = atom.structure + '_' + atom.chain + '_' + atom.resi;
                    residueHash[resid] = 1;
                }
            }

            let coordArray = [];
            let colorArray = [];
            for(let resid in residueHash) {
                let atom = ic.firstAtomObjCls.getFirstAtomObjByName(ic.residues[resid], 'CA');

                if(atom !== undefined) {
                    for(let i = 0, il = atom.bonds.length; i < il; ++i) {
                        let bondAtom = ic.atoms[atom.bonds[i]];
                        // hydrogen connected to Calpha: HA
                        //if(bondAtom.name === 'HA' || (bondAtom.name !== 'C' && bondAtom.name !== 'N'
                        //  && bondAtom.elem !== 'H' && bondAtom.resi == atom.resi) ) {
                        if(bondAtom.name !== 'C' && bondAtom.name !== 'N'
                            && bondAtom.elem !== 'H' && bondAtom.resi == atom.resi) {
                            coordArray.push(atom.coord);
                            coordArray.push(bondAtom.coord);

                            colorArray.push(atom.color);
                            colorArray.push(bondAtom.color);
                        }
                    }
                }
    /*
                // hydrogen connected to N: H
                atom = ic.firstAtomObjCls.getFirstAtomObjByName(ic.residues[resid], 'N');

                if(atom !== undefined) {
                    for(let i = 0, il = atom.bonds.length; i < il; ++i) {
                        let bondAtom = ic.atoms[atom.bonds[i]];
                        // hydrogen connected to N: H
                        if(bondAtom.name === 'H') {
                            coordArray.push(atom.coord);
                            coordArray.push(bondAtom.coord);

                            colorArray.push(atom.color);
                            colorArray.push(bondAtom.color);
                        }
                    }
                }
    */            
            }

            for(let i = 0, il = coordArray.length; i < il; i += 2) {
                if(style === 'ball and stick' || style === 'stick' || style === 'ball and stick2' || style === 'stick2') {
                    let radius = (style === 'stick' || style === 'stick2') ? ic.cylinderRadius : ic.cylinderRadius * 0.5;
                    ic.cylinderCls.createCylinder(coordArray[i], coordArray[i+1], radius, colorArray[i+1]);
                }
                else if(style === 'lines' || style === 'lines2') {
                    let line = this.createSingleLine(coordArray[i], coordArray[i+1], colorArray[i+1], false, 0.5);
                    ic.mdl.add(line);
                }
            }
        }

        createSingleLine( src, dst, colorHex, dashed, dashSize ) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            //var geom = new THREE.Geometry();
            let geo = new THREE.BufferGeometry();
            let vertices = [];

            let mat;

            if(dashed) {
                mat = new THREE.LineDashedMaterial({ linewidth: 1, color: colorHex, dashSize: dashSize, gapSize: 0.5*dashSize });
            } else {
                mat = new THREE.LineBasicMaterial({ linewidth: 1, color: colorHex });
            }

            vertices[0] = src.x;
            vertices[1] = src.y;
            vertices[2] = src.z;
            vertices[3] = dst.x;
            vertices[4] = dst.y;
            vertices[5] = dst.z;

            let nComp = 3;
            geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), nComp));

            //geo.computeVertexNormals();

            //if(dashed) geo.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines
            let axis = new THREE.LineSegments( geo, mat );
            if(dashed) axis.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines

            return axis;
        }

        // show extra lines, not used for pk, so no ic.objects
        //Create lines for a list of "lines", each of which has the properties 'position1', 'position2',
        //'color', and a boolean of 'dashed'.
        createLines(lines) {  let ic = this.icn3d, me = ic.icn3dui;
           if(me.bNode) return;

           if(lines !== undefined) {
             for(let name in lines) {
                 let lineArray = lines[name];

                 for(let i = 0, il = lineArray.length; i < il; ++i) {
                   let line = lineArray[i];

                   let p1 = line.position1;
                   let p2 = line.position2;

                   let dashed = (line.dashed) ? line.dashed : false;
                   let dashSize = (name == 'missingres') ? 0.8 : 0.3;

                   let radius = (line.radius) ? line.radius : ic.lineRadius;
                   let opacity = (line.opacity) ? line.opacity : 1.0;

                   let colorStr = '#' + line.color.replace(/\#/g, '');

                   let color = me.parasCls.thr(colorStr);

                   if(!dashed) {
                        if(name == 'stabilizer') {
                            ic.brickCls.createBrick(p1, p2, radius, color);
                        }
                        else {
                            ic.cylinderCls.createCylinder(p1, p2, radius, color, undefined, undefined, undefined, undefined, opacity);
                        }
                   }
                   else {
                     let distance = p1.distanceTo(p2);

                     let nsteps = parseInt(distance / dashSize);
                     let step = p2.clone().sub(p1).multiplyScalar(dashSize/distance);

                     let start, end;
                     for(let j = 0; j < nsteps; ++j) {
                         if(j % 2 == 1) {
                              start = p1.clone().add(step.clone().multiplyScalar(j));
                              end = p1.clone().add(step.clone().multiplyScalar(j + 1));

                              if(name == 'stabilizer') {
                                ic.brickCls.createBrick(start, end, radius, color);
                              }
                              else {
                                ic.cylinderCls.createCylinder(start, end, radius, color, undefined, undefined, undefined, undefined, opacity);
                              }
                          }
                     }
                   }
                 }
             }
           }

           // do not add the artificial lines to raycasting objects
        };

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class ReprSub {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        // from iview (http://istar.cse.cuhk.edu.hk/iview/)
        createRepresentationSub(atoms, f0, f01) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;
            for (let i in atoms) {
                let atom0 = atoms[i];
                f0 && f0(atom0);

                for (let j in atom0.bonds) {
                    let atom1 = this.icn3d.atoms[atom0.bonds[j]];
                    if (atom1 === undefined || atom1.serial < atom0.serial) continue;
                    if (atom1.chain === atom0.chain && ((atom1.resi === atom0.resi)
                      || (atom0.name === 'C' && atom1.name === 'N') || (atom0.name === 'O3\'' && atom1.name === 'P')
                      || (atom0.name === 'O3*' && atom1.name === 'P') || (atom0.name === 'SG' && atom1.name === 'SG'))) {
                        f01 && f01(atom0, atom1);
                    }
                }
            }
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Sphere$1 {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        // modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
        createSphere(atom, defaultRadius, forceDefault, scale, bHighlight) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            if(defaultRadius === undefined) defaultRadius = 0.8;
            if(forceDefault === undefined) forceDefault = false;

            let radius = (me.parasCls.vdwRadii[atom.elem.toUpperCase()] || defaultRadius);
            if(forceDefault) {
                radius = defaultRadius;
                scale = 1;
            }

            this.createSphereBase(atom.coord, atom.color, radius, scale, bHighlight);
        }

        createSphereBase(pos, color, radius, scale, bHighlight, bGlycan, opacity) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            let mesh;

            if(scale === undefined) scale = 1.0;

            let opacity_ori = opacity;
            if(opacity === undefined) opacity = (bGlycan) ? 0.5 : 1.0;

            if(bHighlight === 2) {
              scale *= 1.5;

              color = ic.hColor;

              mesh = new THREE.Mesh(ic.sphereGeometry, new THREE.MeshPhongMaterial({ transparent: true, opacity: opacity, specular: ic.frac, shininess: ic.shininess, emissive: ic.emissive, color: color }));

              mesh.scale.x = mesh.scale.y = mesh.scale.z = radius * (scale ? scale : 1);
              mesh.position.copy(pos);
              ic.mdl.add(mesh);
            }
            else if(bHighlight === 1) {
              mesh = new THREE.Mesh(ic.sphereGeometry, ic.matShader);

              mesh.scale.x = mesh.scale.y = mesh.scale.z = radius * (scale ? scale : 1);
              mesh.position.copy(pos);
              mesh.renderOrder = ic.renderOrderPicking;
              ic.mdl.add(mesh);
            }
            else {
              if(color === undefined) {
                  color = me.parasCls.defaultAtomColor;
              }
              
              //if(bGlycan) {
                  mesh = new THREE.Mesh(ic.sphereGeometry, new THREE.MeshPhongMaterial({ transparent: true, opacity: opacity, specular: ic.frac, shininess: ic.shininess, emissive: ic.emissive, color: color }));
            //   }
            //   else {
            //       mesh = new THREE.Mesh(ic.sphereGeometry, new THREE.MeshPhongMaterial({ specular: ic.frac, shininess: ic.shininess, emissive: ic.emissive, color: color }));
            //   }

              mesh.scale.x = mesh.scale.y = mesh.scale.z = radius * (scale ? scale : 1);
              mesh.position.copy(pos);

              if(ic.bImpo && !opacity_ori && !bGlycan) {
                  ic.posArraySphere.push(pos.x);
                  ic.posArraySphere.push(pos.y);
                  ic.posArraySphere.push(pos.z);

                  ic.colorArraySphere.push(color.r);
                  ic.colorArraySphere.push(color.g);
                  ic.colorArraySphere.push(color.b);

                  let realRadius = radius * (scale ? scale : 1);
                  ic.radiusArraySphere.push(realRadius);

                  if(ic.cnt <= ic.maxatomcnt) ic.mdl_ghost.add(mesh);
              }
              else {
                  ic.mdl.add(mesh);
              }
            }

            if(bHighlight === 1 || bHighlight === 2) {
                if(ic.bImpo) {
                    if(ic.cnt <= ic.maxatomcnt) ic.prevHighlightObjects_ghost.push(mesh);
                }
                else {
                    ic.prevHighlightObjects.push(mesh);
                }
            }
            else {
                if(ic.bImpo && !opacity_ori) { // imposter didn't work with transparency yet in iCn3D
                    if(ic.cnt <= ic.maxatomcnt) ic.objects_ghost.push(mesh);
                }
                else {
                    ic.objects.push(mesh);
                }
            }
        }

        // modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
        //Create spheres for "atoms" with the "radius". "forceDefault" means to use the default radius.
        //"scale" means scale on the radius. "bHighlight" is an option to draw the highlight for these atoms.
        //The highlight could be outlines with bHighlight=1 and 3D objects with bHighlight=2.
        createSphereRepresentation(atoms, defaultRadius, forceDefault, scale, bHighlight) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            let thisClass = this;

            ic.reprSubCls.createRepresentationSub(atoms, function (atom0) {
                thisClass.createSphere(atom0, defaultRadius, forceDefault, scale, bHighlight);
            });
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Stick {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        // modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
        //Create sticks for "atoms". "bondR" is the radius of the sticks. "atomR" is the radius of the spheres in the joints.
        //"scale" means scale on the radius. "bHighlight" is an option to draw the highlight for these atoms.
        //The highlight could be outlines with bHighlight=1 and 3D objects with bHighlight=2.
        createStickRepresentation(atoms, atomR, bondR, scale, bHighlight, bSchematic) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            let factor = (bSchematic !== undefined && bSchematic) ? atomR / ic.cylinderRadius : 1;
            let doubleBondRadius = ic.cylinderRadius * factor * 0.4; // 0.3
            let triBondRadius = ic.cylinderRadius * factor * 0.3; // 0.2

                ic.reprSubCls.createRepresentationSub(atoms, function (atom0) {
                        ic.sphereCls.createSphere(atom0, atomR, !scale, scale, bHighlight);
                }, function (atom0, atom1) {
                    let mp = atom0.coord.clone().add(atom1.coord).multiplyScalar(0.5);
                    let pair = atom0.serial + '_' + atom1.serial;

                    if(ic.doublebonds.hasOwnProperty(pair)) { // show double bond
                        let a0, a1, a2;

                        let v0;
                        let random = new THREE.Vector3(Math.random(),Math.random(),Math.random());
                        if(atom0.bonds.length == 1 && atom1.bonds.length == 1) {
                            v0 = atom1.coord.clone();
                            v0.sub(atom0.coord);

                            let v = random.clone();
                            v0.cross(v).normalize().multiplyScalar(0.2 * factor);
                        }
                        else {
                            if(atom0.bonds.length >= atom1.bonds.length && atom0.bonds.length > 1) {
                                a0 = atom0.serial;
                                a1 = atom0.bonds[0];
                                a2 = atom0.bonds[1];
                            }
                            //else {
                            else if(atom1.bonds.length >= atom0.bonds.length && atom1.bonds.length > 1) {
                                a0 = atom1.serial;
                                a1 = atom1.bonds[0];
                                a2 = atom1.bonds[1];
                            }
                            else {
                                console.log("Double bond was not drawn due to the undefined cross plane");
                                return;
                            }

                            let v1 = ic.atoms[a0].coord.clone();
                            v1.sub(ic.atoms[a1].coord);
                            let v2 = ic.atoms[a0].coord.clone();
                            v2.sub(ic.atoms[a2].coord);

                            v1.cross(v2);

                            // parallel
                            if(parseInt(v1.length() * 10000) == 0) {
                                //v1 = random.clone();
                                // use a constant so that they are fixed,e.g., in CO2
                                v1 = new THREE.Vector3(0.2, 0.3, 0.5);
                            }

                            v0 = atom1.coord.clone();
                            v0.sub(atom0.coord);

                            v0.cross(v1).normalize().multiplyScalar(0.2 * factor);
                            // parallel
                            if(parseInt(v0.length() * 10000) == 0) {
                                //v1 = random.clone();
                                // use a constant so that they are fixed,e.g., in CO2
                                v1 = new THREE.Vector3(0.5, 0.3, 0.2);
                                v0.cross(v1).normalize().multiplyScalar(0.2 * factor);
                            }
                        }

                        if (atom0.color === atom1.color) {
                            if(ic.dAtoms.hasOwnProperty(atom0.serial) && ic.dAtoms.hasOwnProperty(atom1.serial)) {
                                ic.cylinderCls.createCylinder(atom0.coord.clone().add(v0), atom1.coord.clone().add(v0), doubleBondRadius, atom0.color, bHighlight);
                                ic.cylinderCls.createCylinder(atom0.coord.clone().sub(v0), atom1.coord.clone().sub(v0), doubleBondRadius, atom0.color, bHighlight);
                            }
                        } else {
                            if(ic.bImpo) {
                                if(ic.dAtoms.hasOwnProperty(atom0.serial) && ic.dAtoms.hasOwnProperty(atom1.serial)) {
                                    ic.cylinderCls.createCylinder(atom0.coord.clone().add(v0), atom1.coord.clone().add(v0), doubleBondRadius, atom0.color, bHighlight, atom1.color);
                                    ic.cylinderCls.createCylinder(atom0.coord.clone().sub(v0), atom1.coord.clone().sub(v0), doubleBondRadius, atom0.color, bHighlight, atom1.color);
                                }
                            }
                            else {
                                if(ic.dAtoms.hasOwnProperty(atom0.serial) && ic.dAtoms.hasOwnProperty(atom1.serial)) {
                                    ic.cylinderCls.createCylinder(atom0.coord.clone().add(v0), mp.clone().add(v0), doubleBondRadius, atom0.color, bHighlight);
                                    ic.cylinderCls.createCylinder(atom1.coord.clone().add(v0), mp.clone().add(v0), doubleBondRadius, atom1.color, bHighlight);

                                    ic.cylinderCls.createCylinder(atom0.coord.clone().sub(v0), mp.clone().sub(v0), doubleBondRadius, atom0.color, bHighlight);
                                    ic.cylinderCls.createCylinder(atom1.coord.clone().sub(v0), mp.clone().sub(v0), doubleBondRadius, atom1.color, bHighlight);
                                }
                            }
                        }
                    }
                    else if(ic.aromaticbonds.hasOwnProperty(pair)) { // show aromatic bond
                        let a0, a1, a2;
                        if(atom0.bonds.length > atom1.bonds.length && atom0.bonds.length > 1) {
                            a0 = atom0.serial;
                            a1 = atom0.bonds[0];
                            a2 = atom0.bonds[1];
                        }
                        else if(atom1.bonds.length > 1) {
                            a0 = atom1.serial;
                            a1 = atom1.bonds[0];
                            a2 = atom1.bonds[1];
                        }
                        else {
                            return;
                        }

                        let v1 = ic.atoms[a0].coord.clone();
                        v1.sub(ic.atoms[a1].coord);
                        let v2 = ic.atoms[a0].coord.clone();
                        v2.sub(ic.atoms[a2].coord);

                        v1.cross(v2);

                        let v0 = atom1.coord.clone();
                        v0.sub(atom0.coord);

                        v0.cross(v1).normalize().multiplyScalar(0.2 * factor);

                        // find an aromatic neighbor
                        let aromaticNeighbor = 0;
                        for(let i = 0, il = atom0.bondOrder.length; i < il; ++i) {
                            if(atom0.bondOrder[i] === '1.5' && atom0.bonds[i] !== atom1.serial) {
                                aromaticNeighbor = atom0.bonds[i];
                            }
                        }

                        let dashed = "add";
                        if(aromaticNeighbor === 0 ) { // no neighbor found, atom order does not matter
                            dashed = "add";
                        }
                        else {
                            // calculate the angle between atom1, atom0add, atomNeighbor and the angle atom1, atom0sub, atomNeighbor
                            let atom0add = atom0.coord.clone().add(v0);
                            let atom0sub = atom0.coord.clone().sub(v0);

                            let a = atom1.coord.clone().sub(atom0add).normalize();
                            let b = ic.atoms[aromaticNeighbor].coord.clone().sub(atom0add).normalize();

                            let c = atom1.coord.clone().sub(atom0sub).normalize();
                            let d = ic.atoms[aromaticNeighbor].coord.clone().sub(atom0sub).normalize();

                            let angleadd = Math.acos(a.dot(b));
                            let anglesub = Math.acos(c.dot(d));

                            if(angleadd < anglesub) {
                                dashed = 'sub';
                            }
                            else {
                                dashed = 'add';
                            }
                        }

                        if (atom0.color === atom1.color) {
                            let base, step;
                            if(dashed === 'add') {
                                ic.cylinderCls.createCylinder(atom0.coord.clone().sub(v0), atom1.coord.clone().sub(v0), doubleBondRadius, atom0.color, bHighlight);

                                base = atom0.coord.clone().add(v0);
                                step = atom1.coord.clone().add(v0).sub(base).multiplyScalar(1.0/11);
                            }
                            else {
                                ic.cylinderCls.createCylinder(atom0.coord.clone().add(v0), atom1.coord.clone().add(v0), doubleBondRadius, atom0.color, bHighlight);

                                base = atom0.coord.clone().sub(v0);
                                step = atom1.coord.clone().sub(v0).sub(base).multiplyScalar(1.0/11);
                            }

                            for(let i = 0; i <= 10; ++i) {
                                if(i % 2 == 0) {
                                    let pos1 = base.clone().add(step.clone().multiplyScalar(i));
                                    let pos2 = base.clone().add(step.clone().multiplyScalar(i + 1));
                                    ic.cylinderCls.createCylinder(pos1, pos2, doubleBondRadius, atom0.color, bHighlight);
                                }
                            }

                        } else {
                            let base, step;
                            if(dashed === 'add') {
                                if(ic.dAtoms.hasOwnProperty(atom0.serial) && ic.dAtoms.hasOwnProperty(atom1.serial)) {
                                    ic.cylinderCls.createCylinder(atom0.coord.clone().sub(v0), mp.clone().sub(v0), doubleBondRadius, atom0.color, bHighlight);
                                    ic.cylinderCls.createCylinder(atom1.coord.clone().sub(v0), mp.clone().sub(v0), doubleBondRadius, atom1.color, bHighlight);
                                }

                                base = atom0.coord.clone().add(v0);
                                step = atom1.coord.clone().add(v0).sub(base).multiplyScalar(1.0/11);
                            }
                            else {
                                if(ic.dAtoms.hasOwnProperty(atom0.serial) && ic.dAtoms.hasOwnProperty(atom1.serial)) {
                                    ic.cylinderCls.createCylinder(atom0.coord.clone().add(v0), mp.clone().add(v0), doubleBondRadius, atom0.color, bHighlight);
                                    ic.cylinderCls.createCylinder(atom1.coord.clone().add(v0), mp.clone().add(v0), doubleBondRadius, atom1.color, bHighlight);
                                }

                                base = atom0.coord.clone().sub(v0);
                                step = atom1.coord.clone().sub(v0).sub(base).multiplyScalar(1.0/11);
                            }

                            for(let i = 0; i <= 10; ++i) {
                                if(i % 2 == 0 && ic.dAtoms.hasOwnProperty(atom0.serial) && ic.dAtoms.hasOwnProperty(atom1.serial)) {
                                    let pos1 = base.clone().add(step.clone().multiplyScalar(i));
                                    let pos2 = base.clone().add(step.clone().multiplyScalar(i + 1));
                                    if(i < 5) {
                                        ic.cylinderCls.createCylinder(pos1, pos2, doubleBondRadius, atom0.color, bHighlight);
                                    }
                                    else {
                                        ic.cylinderCls.createCylinder(pos1, pos2, doubleBondRadius, atom1.color, bHighlight);
                                    }
                                }
                            }
                        }
                    }
                    else if(ic.triplebonds.hasOwnProperty(pair)) { // show triple bond
                        let random = new THREE.Vector3(Math.random(),Math.random(),Math.random());
                        let v = atom1.coord.clone();
                        v.sub(atom0.coord);

                        let c = random.clone();
                        c.cross(v).normalize().multiplyScalar(0.3 * factor);

                        if (atom0.color === atom1.color) {
                            if(ic.dAtoms.hasOwnProperty(atom0.serial) && ic.dAtoms.hasOwnProperty(atom1.serial)) {
                                ic.cylinderCls.createCylinder(atom0.coord, atom1.coord, triBondRadius, atom0.color, bHighlight);
                                ic.cylinderCls.createCylinder(atom0.coord.clone().add(c), atom1.coord.clone().add(c), triBondRadius, atom0.color, bHighlight);
                                ic.cylinderCls.createCylinder(atom0.coord.clone().sub(c), atom1.coord.clone().sub(c), ic.triBondRadius, atom0.color, bHighlight);
                            }
                        } else {
                            if(ic.bImpo) {
                                if(ic.dAtoms.hasOwnProperty(atom0.serial) && ic.dAtoms.hasOwnProperty(atom1.serial)) {
                                    ic.cylinderCls.createCylinder(atom0.coord, atom1.coord, triBondRadius, atom0.color, bHighlight, atom1.color);
                                    ic.cylinderCls.createCylinder(atom0.coord.clone().add(c), atom1.coord.clone().add(c), triBondRadius, atom0.color, bHighlight, atom1.color);
                                    ic.cylinderCls.createCylinder(atom0.coord.clone().sub(c), atom1.coord.clone().sub(c), triBondRadius, atom0.color, bHighlight, atom1.color);
                                }
                            }
                            else {
                                if(ic.dAtoms.hasOwnProperty(atom0.serial) && ic.dAtoms.hasOwnProperty(atom1.serial)) {
                                    ic.cylinderCls.createCylinder(atom0.coord, mp, triBondRadius, atom0.color, bHighlight);
                                    ic.cylinderCls.createCylinder(atom1.coord, mp, triBondRadius, atom1.color, bHighlight);

                                    ic.cylinderCls.createCylinder(atom0.coord.clone().add(c), mp.clone().add(c), triBondRadius, atom0.color, bHighlight);
                                    ic.cylinderCls.createCylinder(atom1.coord.clone().add(c), mp.clone().add(c), triBondRadius, atom1.color, bHighlight);

                                    ic.cylinderCls.createCylinder(atom0.coord.clone().sub(c), mp.clone().sub(c), triBondRadius, atom0.color, bHighlight);
                                    ic.cylinderCls.createCylinder(atom1.coord.clone().sub(c), mp.clone().sub(c), triBondRadius, atom1.color, bHighlight);
                                }
                            }
                        }
                    }
                    else {
                        if (atom0.color === atom1.color) {
                            ic.cylinderCls.createCylinder(atom0.coord, atom1.coord, bondR, atom0.color, bHighlight);
                        } else {
                            if(ic.bImpo) {
                                if(ic.dAtoms.hasOwnProperty(atom0.serial) && ic.dAtoms.hasOwnProperty(atom1.serial)) {
                                    ic.cylinderCls.createCylinder(atom0.coord, atom1.coord, bondR, atom0.color, bHighlight, atom1.color);
                                }
                            }
                            else {
                                if(ic.dAtoms.hasOwnProperty(atom0.serial) && ic.dAtoms.hasOwnProperty(atom1.serial)) {
                                    ic.cylinderCls.createCylinder(atom0.coord, mp, bondR, atom0.color, bHighlight);
                                    ic.cylinderCls.createCylinder(atom1.coord, mp, bondR, atom1.color, bHighlight);
                                }
                            }
                        }
                    }
                });
        }

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class FirstAtomObj {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Return the first atom in the atom hash, which has the atom serial number as the key.
        getFirstAtomObj(atomsHash) { let ic = this.icn3d; ic.icn3dui;
            if(atomsHash === undefined || Object.keys(atomsHash).length === 0) {
                return undefined;
            }

            let atomKeys = Object.keys(atomsHash);
            let firstIndex = atomKeys[0];

            return ic.atoms[firstIndex];
        }

        // n is the position of the selected atom
        getMiddleAtomObj(atomsHash, n) { let ic = this.icn3d; ic.icn3dui;
            if(atomsHash === undefined || Object.keys(atomsHash).length === 0) {
                return undefined;
            }

            let atomKeys = Object.keys(atomsHash);
            let middleIndex = (n && n < atomKeys.length) ? atomKeys[n] : atomKeys[parseInt(atomKeys.length / 2)];

            return ic.atoms[middleIndex];
        }

        getFirstCalphaAtomObj(atomsHash) { let ic = this.icn3d; ic.icn3dui;
            if(atomsHash === undefined || Object.keys(atomsHash).length === 0) {
                return undefined;
            }

            let firstIndex;

            for(let i in atomsHash) {
                if(ic.atoms[i].name == 'CA') {
                    firstIndex = i;
                    break;
                }
            }

            if(!firstIndex) {
                for(let i in atomsHash) {
                    if(ic.atoms[i].name == "O3'" || ic.atoms[i].name == "O3*") {
                        firstIndex = i;
                        break;
                    }
                }
            }

            return (firstIndex !== undefined) ? ic.atoms[firstIndex] : this.getFirstAtomObj(atomsHash);
        }

        getFirstAtomObjByName(atomsHash, atomName) { let ic = this.icn3d; ic.icn3dui;
            if(atomsHash === undefined || Object.keys(atomsHash).length === 0) {
                return ic.atoms[0];
            }

            let firstIndex;

            for(let i in atomsHash) {
                if(ic.atoms[i].name == atomName) {
                    firstIndex = i;
                    break;
                }
            }

            return (firstIndex !== undefined) ? ic.atoms[firstIndex] : undefined;
        }

        //Return the last atom in the atom hash, which has the atom serial number as the key.
        getLastAtomObj(atomsHash) { let ic = this.icn3d; ic.icn3dui;
            if(atomsHash === undefined || Object.keys(atomsHash).length === 0) {
                return ic.atoms[0];
            }

            let atomKeys = Object.keys(atomsHash);
            let lastIndex = atomKeys[atomKeys.length - 1];

            return ic.atoms[lastIndex];
        }

        //Return the residue hash from the atom hash. The residue hash has the resid as the key and 1 as the value.
        getResiduesFromAtoms(atomsHash) { let ic = this.icn3d; ic.icn3dui;
            let residuesHash = {};
            for(let i in atomsHash) {
                let residueid = ic.atoms[i].structure + '_' + ic.atoms[i].chain + '_' + ic.atoms[i].resi;
                residuesHash[residueid] = 1;
            }

            return residuesHash;
        }

        getResiduesFromCalphaAtoms(atomsHash) { let ic = this.icn3d; ic.icn3dui;
            let residuesHash = {};
            for(let i in atomsHash) {
                if((ic.atoms[i].name == 'CA' && ic.proteins.hasOwnProperty(i)) || !ic.proteins.hasOwnProperty(i)) {
                    let residueid = ic.atoms[i].structure + '_' + ic.atoms[i].chain + '_' + ic.atoms[i].resi;
                    //residuesHash[residueid] = 1;
                    residuesHash[residueid] = ic.atoms[i].resn;
                }
            }

            return residuesHash;
        }

        //Return the chain hash from the atom hash. The chain hash has the chainid as the key and 1 as the value.
        getChainsFromAtoms(atomsHash) { let ic = this.icn3d; ic.icn3dui;
            let chainsHash = {};
            for(let i in atomsHash) {
               let atom = ic.atoms[i];
               let chainid = atom.structure + "_" + atom.chain;

               chainsHash[chainid] = 1;
            }

            return chainsHash;
        }

        getAtomFromResi(resid, atomName) { let ic = this.icn3d; ic.icn3dui;
            if(ic.residues.hasOwnProperty(resid)) {
                for(let i in ic.residues[resid]) {
                    if(ic.atoms[i].name === atomName && !ic.atoms[i].het) {
                        return ic.atoms[i];
                    }
                }
            }

            return undefined;
        }

        getAtomCoordFromResi(resid, atomName) { let ic = this.icn3d; ic.icn3dui;
            let atom = this.getAtomFromResi(resid, atomName);
            if(atom !== undefined) {
                let coord = (atom.coord2 !== undefined) ? atom.coord2 : atom.coord;

                return coord;
            }

            return undefined;
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Strip {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        // modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
        createStrip(p0, p1, colors, div, thickness, bHighlight, bNoSmoothen, bShowArray,
          calphaIdArray, positions, prevone, nexttwo, pntsCA, prevCOArray) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            if (p0.length < 2) return;
            div = div || ic.axisDIV;

            // if(pntsCA && ic.bDoublecolor && !ic.bCalphaOnly) {
            if(pntsCA && ic.bDoublecolor) {
                let bExtendLastRes = false; //true;

                let pnts_clrs = me.subdivideCls.subdivide(pntsCA, colors, div, bShowArray, bHighlight, prevone, nexttwo, bExtendLastRes);
                pntsCA = pnts_clrs[0];

                this.setCalphaDrawnCoord(pntsCA, div, calphaIdArray);

                for(let i = 0, il = prevCOArray.length; i < il; ++i) {
                    prevCOArray[i].normalize();
                }

                let pnts_clrs2 = me.subdivideCls.subdivide(prevCOArray, colors, div, bShowArray, bHighlight, prevone, nexttwo, bExtendLastRes);
                prevCOArray = pnts_clrs2[0];

                colors = pnts_clrs[2];
            }
            else {

                if(!bNoSmoothen) {
                    //var bExtendLastRes = true;
                    let bExtendLastRes = false;
                    let pnts_clrs0 = me.subdivideCls.subdivide(p0, colors, div, bShowArray, bHighlight, prevone, nexttwo, bExtendLastRes);
                    let pnts_clrs1 = me.subdivideCls.subdivide(p1, colors, div, bShowArray, bHighlight, prevone, nexttwo, bExtendLastRes);
                    p0 = pnts_clrs0[0];
                    p1 = pnts_clrs1[0];
                    colors = pnts_clrs0[2];
                }
                if (p0.length < 2) return;

                this.setCalphaDrawnCoord(p0, div, calphaIdArray);
            }

            if(bHighlight === 1) {
                //mesh = new THREE.Mesh(geo, ic.matShader);

                let radius = ic.coilWidth / 2;
                //var radiusSegments = 8;
                let radiusSegments = 4; // save memory
                let closed = false;

                if(positions !== undefined) {
                    let currPos, prevPos;
                    let currP0 = [], currP1 = [];

                    for(let i = 0, il = p0.length; i < il; ++i) {
                        currPos = positions[i];

                        if((currPos !== prevPos && parseInt(currPos) !== parseInt(prevPos) + 1 && prevPos !== undefined) || (i === il -1) ) {
                            // first tube
                            let geometry0 = new THREE.TubeGeometry(
                                new THREE.CatmullRomCurve3(currP0), // path
                                currP0.length, // segments
                                radius,
                                radiusSegments,
                                closed
                            );

                            let mesh = new THREE.Mesh(geometry0, ic.matShader);
                            mesh.renderOrder = ic.renderOrderPicking;
                            //ic.mdlPicking.add(mesh);
                            ic.mdl.add(mesh);

                            ic.prevHighlightObjects.push(mesh);

                            geometry0 = null;

                            // second tube
                            let geometry1 = new THREE.TubeGeometry(
                                new THREE.CatmullRomCurve3(currP1), // path
                                currP1.length, // segments
                                radius,
                                radiusSegments,
                                closed
                            );

                            mesh = new THREE.Mesh(geometry1, ic.matShader);
                            mesh.renderOrder = ic.renderOrderPicking;
                            //ic.mdlPicking.add(mesh);
                            ic.mdl.add(mesh);

                            ic.prevHighlightObjects.push(mesh);

                            geometry1 = null;

                            currP0 = [];
                            currP1 = [];
                        }

                        currP0.push(p0[i]);
                        currP1.push(p1[i]);

                        prevPos = currPos;
                    }

                    currP0 = [];
                    currP1 = [];
                }
                else {
                    // first tube
                    let geometry0 = new THREE.TubeGeometry(
                        new THREE.CatmullRomCurve3(p0), // path
                        p0.length, // segments
                        radius,
                        radiusSegments,
                        closed
                    );

                    let mesh = new THREE.Mesh(geometry0, ic.matShader);
                    mesh.renderOrder = ic.renderOrderPicking;
                    //ic.mdlPicking.add(mesh);
                    ic.mdl.add(mesh);

                    ic.prevHighlightObjects.push(mesh);

                    geometry0 = null;

                    // second tube
                    let geometry1 = new THREE.TubeGeometry(
                        new THREE.CatmullRomCurve3(p1), // path
                        p1.length, // segments
                        radius,
                        radiusSegments,
                        closed
                    );

                    mesh = new THREE.Mesh(geometry1, ic.matShader);
                    mesh.renderOrder = ic.renderOrderPicking;
                    //ic.mdlPicking.add(mesh);
                    ic.mdl.add(mesh);

                    ic.prevHighlightObjects.push(mesh);

                    geometry1 = null;
                }
            }
            else {
                //https://threejsfundamentals.org/threejs/lessons/threejs-custom-buffergeometry.html

                let geo = new THREE.BufferGeometry();
                //var vs = geo.vertices, fs = geo.faces;
                let vs = [];
                let colorArray = [], indexArray = [];
                let axis, p0v, p1v, a0v, a1v;

                let offset = 0, offset2 = 0, offset3 = 0;
                for (let i = 0, lim = p0.length; i < lim; ++i) {
                    p0v = p0[i];
                    p1v = p1[i];

                    if(!p0v || !p1v) continue;

                    //vs = vs.concat((p0v).toArray()); // 0
                    //vs = vs.concat((p0v).toArray()); // 1
                    //vs = vs.concat((p1v).toArray()); // 2
                    //vs = vs.concat((p1v).toArray()); // 3

                    for(let j = 0; j < 2; ++j) {
                        vs[offset++] = p0v.x;
                        vs[offset++] = p0v.y;
                        vs[offset++] = p0v.z;
                    }
                    for(let j = 0; j < 2; ++j) {
                        vs[offset++] = p1v.x;
                        vs[offset++] = p1v.y;
                        vs[offset++] = p1v.z;
                    }

                    if (i < lim - 1) {
                        axis = p1[i].clone().sub(p0[i]).cross(p0[i + 1].clone().sub(p0[i])).normalize().multiplyScalar(thickness);
                    }
                    a0v = p0[i].clone().add(axis);
                    a1v = p1[i].clone().add(axis);

                    //vs = vs.concat((a0v).toArray()); // 4
                    //vs = vs.concat((a0v).toArray()); // 5
                    //vs = vs.concat((a1v).toArray()); // 6
                    //vs = vs.concat((a1v).toArray()); // 7

                    for(let j = 0; j < 2; ++j) {
                        vs[offset++] = a0v.x;
                        vs[offset++] = a0v.y;
                        vs[offset++] = a0v.z;
                    }
                    for(let j = 0; j < 2; ++j) {
                        vs[offset++] = a1v.x;
                        vs[offset++] = a1v.y;
                        vs[offset++] = a1v.z;
                    }

                    for(let j = 0; j < 8; ++j) {
                        //colorArray = colorArray.concat(colors[i].toArray());
                        let color = (colors[i]) ? colors[i] : (colors[i-1] ? colors[i-1] : {r:0, g:0, b:0});
                        colorArray[offset2++] = color.r;
                        colorArray[offset2++] = color.g;
                        colorArray[offset2++] = color.b;
                   }
                }
                let faces = [[0, 2, -6, -8], [-4, -2, 6, 4], [7, 3, -5, -1], [-3, -7, 1, 5]];

                for (let i = 1, lim = p0.length; i < lim; ++i) {
                    let offsetTmp = 8 * i;
                    //var color = me.parasCls.thr(colors[i - 1]);
                    for (let j = 0; j < 4; ++j) {
                        //fs.push(new THREE.Face3(offset + faces[j][0], offset + faces[j][1], offset + faces[j][2], undefined, color));
                        //fs.push(new THREE.Face3(offset + faces[j][3], offset + faces[j][0], offset + faces[j][2], undefined, color));
                        //indexArray = indexArray.concat([offsetTmp + faces[j][0], offsetTmp + faces[j][1], offsetTmp + faces[j][2]]);
                        //indexArray = indexArray.concat([offsetTmp + faces[j][3], offsetTmp + faces[j][0], offsetTmp + faces[j][2]]);
                        indexArray[offset3++] = offsetTmp + faces[j][0];
                        indexArray[offset3++] = offsetTmp + faces[j][1];
                        indexArray[offset3++] = offsetTmp + faces[j][2];

                        indexArray[offset3++] = offsetTmp + faces[j][3];
                        indexArray[offset3++] = offsetTmp + faces[j][0];
                        indexArray[offset3++] = offsetTmp + faces[j][2];
                    }
                }
                let nComp = 3;
                let vsize = vs.length / nComp - 8; // Cap
                for (let i = 0; i < 4; ++i) {
                    for(let j = 0; j < nComp; ++j) {
                        //vs = vs.concat([vs[i * 2 * nComp + j]]);
                        vs[offset++] = vs[i * 2 * nComp + j];
                    }

                    for(let j = 0; j < nComp; ++j) {
                        //vs = vs.concat([vs[(vsize + i * 2) * nComp + j]]);
                        vs[offset++] = vs[(vsize + i * 2) * nComp + j];
                    }

                    //colorArray = colorArray.concat(colors[0].toArray());
                    if(colors[0]) {
                        colorArray[offset2++] = colors[0].r;
                        colorArray[offset2++] = colors[0].g;
                        colorArray[offset2++] = colors[0].b;
                        //colorArray = colorArray.concat(colors[p0.length - 1].toArray());
                        let color = (colors[p0.length - 1]) ? colors[p0.length - 1] : (colors[p0.length - 2] ? colors[p0.length - 2] : {r:0, g:0, b:0});
                        colorArray[offset2++] = color.r;
                        colorArray[offset2++] = color.g;
                        colorArray[offset2++] = color.b;
                    }
                }            vsize += 8;
                //fs.push(new THREE.Face3(vsize, vsize + 2, vsize + 6, undefined, fs[0].color));
                //fs.push(new THREE.Face3(vsize + 4, vsize, vsize + 6, undefined, fs[0].color));
                //fs.push(new THREE.Face3(vsize + 1, vsize + 5, vsize + 7, undefined, fs[fs.length - 3].color));
                //fs.push(new THREE.Face3(vsize + 3, vsize + 1, vsize + 7, undefined, fs[fs.length - 3].color));

                //indexArray = indexArray.concat([vsize, vsize + 2, vsize + 6]);
                //indexArray = indexArray.concat([vsize + 4, vsize, vsize + 6]);
                //indexArray = indexArray.concat([vsize + 1, vsize + 5, vsize + 7]);
                //indexArray = indexArray.concat([vsize + 3, vsize + 1, vsize + 7]);

                indexArray[offset3++] = vsize;
                indexArray[offset3++] = vsize + 2;
                indexArray[offset3++] = vsize + 6;
                indexArray[offset3++] = vsize + 4;
                indexArray[offset3++] = vsize;
                indexArray[offset3++] = vsize + 6;
                indexArray[offset3++] = vsize + 1;
                indexArray[offset3++] = vsize + 5;
                indexArray[offset3++] = vsize + 7;
                indexArray[offset3++] = vsize + 3;
                indexArray[offset3++] = vsize + 1;
                indexArray[offset3++] = vsize + 7;

                geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vs), nComp));
                geo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(colorArray), nComp));

                geo.setIndex(new THREE.BufferAttribute(new Uint32Array(indexArray), 1));
                //geo.setIndex(indexArray);

                //geo.computeFaceNormals();
                //geo.computeVertexNormals(false);
                geo.computeVertexNormals();

                let mesh;

                if(bHighlight === 2) {
                  //mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ transparent: true, opacity: 0.5, specular: ic.frac, shininess: ic.shininess, emissive: ic.emissive, vertexColors: THREE.FaceColors, side: THREE.DoubleSide }));
                  mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ transparent: true, opacity: 0.5, specular: ic.frac,
                        shininess: ic.shininess, emissive: ic.emissive, vertexColors: true, side: THREE.DoubleSide }));

                  ic.mdl.add(mesh);
                  ic.prevHighlightObjects.push(mesh);
                }
                else {
                  //mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ specular: ic.frac, shininess: ic.shininess, emissive: ic.emissive, vertexColors: THREE.FaceColors, side: THREE.DoubleSide }));
                  mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ specular: ic.frac, shininess: ic.shininess, emissive: ic.emissive, vertexColors: true, side: THREE.DoubleSide }));

                  ic.mdl.add(mesh);
                  ic.objects.push(mesh);
                }
            }

            p0 = null;
            p1 = null;
        }

        setCalphaDrawnCoord(pnts, div, calphaIdArray) { let ic = this.icn3d; ic.icn3dui;
            let index = 0;

            if(calphaIdArray !== undefined) {
                for(let i = 0, il = pnts.length; i < il; i += div) { // pnts.length = (calphaIdArray.length - 1) * div + 1
                    let serial = calphaIdArray[index];

                    if(ic.atoms.hasOwnProperty(serial)) {
                        ic.atoms[serial].coord2 = pnts[i].clone();
                    }

                    ++index;
                }
            }
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Tube {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        // modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
        //Create tubes for "atoms" with certain "atomName". "radius" is the radius of the tubes.
        //"bHighlight" is an option to draw the highlight for these atoms. The highlight could be
        //outlines with bHighlight=1 and 3D objects with bHighlight=2.
        createTube(atoms, atomName, radius, bHighlight, bCustom, bNonCoil) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            let pnts = [], colors = [], radii = [], prevone = [], nexttwo = [];
            let currentChain, currentResi;
            let index = 0;
            let maxDist = 6.0;
            let maxDist2 = 3.0; // avoid tube between the residues in 3 residue helix

            let pnts_colors_radii_prevone_nexttwo = [];
            let firstAtom, atom, prevAtom;

            for (let i in atoms) {
                atom = atoms[i];
                if ((atom.name === atomName) && !atom.het) {
                    if(index == 0) {
                        firstAtom = atom;
                    }

                    atom.structure + '_' + atom.chain + '_' + (parseInt(atom.resi) - 1).toString();

                    if (index > 0 && (currentChain !== atom.chain || Math.abs(atom.coord.x - prevAtom.coord.x) > maxDist || Math.abs(atom.coord.y - prevAtom.coord.y) > maxDist || Math.abs(atom.coord.z - prevAtom.coord.z) > maxDist
                      || (prevAtom.ssbegin) // e.g., https://www.ncbi.nlm.nih.gov/Structure/icn3d/?pdbid=7JO8 where a beta sheet has just two residues
    //                  || (parseInt(currentResi) + 1 < parseInt(atom.resi) && (Math.abs(atom.coord.x - prevAtom.coord.x) > maxDist2 || Math.abs(atom.coord.y - prevAtom.coord.y) > maxDist2 || Math.abs(atom.coord.z - prevAtom.coord.z) > maxDist2) && ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[resid]) && ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[resid]).ss == 'helix')
                      || (ic.ParserUtilsCls.getResiNCBI(atom.structure + '_' + currentChain, currentResi) + 1 < ic.ParserUtilsCls.getResiNCBI(atom.structure + '_' + atom.chain, atom.resi) && (Math.abs(atom.coord.x - prevAtom.coord.x) > maxDist2 || Math.abs(atom.coord.y - prevAtom.coord.y) > maxDist2 || Math.abs(atom.coord.z - prevAtom.coord.z) > maxDist2))
                      ) ) {
                        if(bHighlight !== 2) {
                            if(!isNaN(firstAtom.resi) && !isNaN(prevAtom.resi)) {
                                let prevoneResid = firstAtom.structure + '_' + firstAtom.chain + '_' + (parseInt(firstAtom.resi) - 1).toString();
                                let prevoneCoord = ic.firstAtomObjCls.getAtomCoordFromResi(prevoneResid, atomName);
                                prevone = (prevoneCoord !== undefined) ? [prevoneCoord] : [];

                                let nextoneResid = prevAtom.structure + '_' + prevAtom.chain + '_' + (parseInt(prevAtom.resi) + 1).toString();
                                let nexttwoResid = prevAtom.structure + '_' + prevAtom.chain + '_' + (parseInt(prevAtom.resi) + 2).toString();
                                let nextthreeResid = prevAtom.structure + '_' + prevAtom.chain + '_' + (parseInt(prevAtom.resi) + 3).toString();

                                if(ic.residues.hasOwnProperty(nextoneResid)) {
                                    let nextAtom = ic.firstAtomObjCls.getAtomFromResi(nextoneResid, atomName);
                                    if(nextAtom !== undefined && nextAtom.ssbegin) { // include the residue
                                        nextoneResid = prevAtom.structure + '_' + prevAtom.chain + '_' + (parseInt(prevAtom.resi) + 2).toString();
                                        nexttwoResid = prevAtom.structure + '_' + prevAtom.chain + '_' + (parseInt(prevAtom.resi) + 3).toString();

                                        pnts.push(nextAtom.coord);
                                        if(bCustom) {
                                            radii.push(this.getCustomtubesize(nextoneResid));
                                        }
                                        else {
                                            radii.push(this.getRadius(radius, nextAtom));
                                        }
                                        colors.push(nextAtom.color);
                                    }
                                }

                                // add one more residue if only one residue is available
                                if(pnts.length == 1 && ic.residues.hasOwnProperty(nextoneResid)) {
                                    let nextAtom = ic.firstAtomObjCls.getAtomFromResi(nextoneResid, atomName);

                                    if(nextAtom) {
                                        pnts.push(nextAtom.coord);
                                        colors.push(nextAtom.color);

                                        let radiusFinal = this.getRadius(radius, atom);
                                        radii.push(radiusFinal);

                                        nextoneResid = nexttwoResid;
                                        nexttwoResid = nextthreeResid;
                                    }
                                }

                                let nextoneCoord = ic.firstAtomObjCls.getAtomCoordFromResi(nextoneResid, atomName);
                                if(nextoneCoord !== undefined) {
                                    nexttwo.push(nextoneCoord);
                                }

                                let nexttwoCoord = ic.firstAtomObjCls.getAtomCoordFromResi(nexttwoResid, atomName);
                                if(nexttwoCoord !== undefined) {
                                    nexttwo.push(nexttwoCoord);
                                }
                            }

                            pnts_colors_radii_prevone_nexttwo.push({'pnts':pnts, 'colors':colors, 'radii':radii, 'prevone':prevone, 'nexttwo':nexttwo});
                        }
                        pnts = []; colors = []; radii = []; prevone = []; nexttwo = [];
                        firstAtom = atom;
                        index = 0;
                    }

                    if(pnts.length == 0 && !isNaN(atom.resi)) {
                        let prevoneResid = atom.structure + '_' + atom.chain + '_' + (parseInt(atom.resi) - 1).toString();
                        if(ic.residues.hasOwnProperty(prevoneResid)) {
                            prevAtom = ic.firstAtomObjCls.getAtomFromResi(prevoneResid, atomName);
                            if(prevAtom !== undefined && prevAtom.ssend) { // include the residue
                                pnts.push(prevAtom.coord);
                                if(bCustom) {
                                    radii.push(this.getCustomtubesize(prevoneResid));
                                }
                                else {
                                    radii.push(this.getRadius(radius, prevAtom));
                                }
                                colors.push(prevAtom.color);
                            }
                        }
                    }

                    pnts.push(atom.coord);

                    let radiusFinal;
                    if(bCustom) {
                        radiusFinal = this.getCustomtubesize(atom.structure + '_' + atom.chain + '_' + atom.resi);
                    }
                    else {
                        radiusFinal = this.getRadius(radius, atom);
                    }
                    
                    // draw all atoms in tubes and assign zero radius when the residue is not coil
                    // if(!bNonCoil && atom.ss != 'coil' && !atom.ssbegin && !atom.ssend ) radiusFinal = 0;

                    //radii.push(radius || (atom.b > 0 ? atom.b * 0.01 : ic.coilWidth));
                    radii.push(radiusFinal);

                    colors.push(atom.color);
                    // the starting residue of a coil uses the color from the next residue to avoid using the color of the last helix/sheet residue
                    if(index === 1) colors[colors.length - 2] = atom.color;

                    currentChain = atom.chain;
                    currentResi = atom.resi;

                    let scale = 1.2;
                    if(bHighlight === 2 && !atom.ssbegin) {
                        ic.boxCls.createBox(atom, undefined, undefined, scale, undefined, bHighlight);
                    }

                    ++index;

                    prevAtom = atom;
                }
            }

            if(bHighlight !== 2) {
                prevone = [];
                if(firstAtom !== undefined && !isNaN(firstAtom.resi)) {
                    let prevoneResid = firstAtom.structure + '_' + firstAtom.chain + '_' + (parseInt(firstAtom.resi) - 1).toString();
                    let prevoneCoord = ic.firstAtomObjCls.getAtomCoordFromResi(prevoneResid, atomName);
                    prevone = (prevoneCoord !== undefined) ? [prevoneCoord] : [];
                }

                nexttwo = [];
                if(atom !== undefined && !isNaN(atom.resi)) {
                    let nextoneResid = atom.structure + '_' + atom.chain + '_' + (parseInt(atom.resi) + 1).toString();
                    let nexttwoResid = atom.structure + '_' + atom.chain + '_' + (parseInt(atom.resi) + 2).toString();
                    let nextthreeResid = atom.structure + '_' + atom.chain + '_' + (parseInt(atom.resi) + 3).toString();

                    // add one more residue if only one residue is available
                    if(pnts.length == 1 && ic.residues.hasOwnProperty(nextoneResid)) {
                        let nextAtom = ic.firstAtomObjCls.getAtomFromResi(nextoneResid, atomName);

                        if(nextAtom) {
                            pnts.push(nextAtom.coord);
                            colors.push(nextAtom.color);

                            let radiusFinal = this.getRadius(radius, atom);
                            radii.push(radiusFinal);

                            nextoneResid = nexttwoResid;
                            nexttwoResid = nextthreeResid;
                        }
                    }

                    let nextoneCoord = ic.firstAtomObjCls.getAtomCoordFromResi(nextoneResid, atomName);
                    if(nextoneCoord !== undefined) {
                        nexttwo.push(nextoneCoord);
                    }

                    let nexttwoCoord = ic.firstAtomObjCls.getAtomCoordFromResi(nexttwoResid, atomName);
                    if(nexttwoCoord !== undefined) {
                        nexttwo.push(nexttwoCoord);
                    }
                }

                pnts_colors_radii_prevone_nexttwo.push({'pnts':pnts, 'colors':colors, 'radii':radii, 'prevone':prevone, 'nexttwo':nexttwo});
            }

            for(let i = 0, il = pnts_colors_radii_prevone_nexttwo.length; i < il; ++i) {
                let pnts = pnts_colors_radii_prevone_nexttwo[i].pnts;
                let colors = pnts_colors_radii_prevone_nexttwo[i].colors;
                let radii = pnts_colors_radii_prevone_nexttwo[i].radii;
                let prevone = pnts_colors_radii_prevone_nexttwo[i].prevone;
                let nexttwo = pnts_colors_radii_prevone_nexttwo[i].nexttwo;

                this.createTubeSub(pnts, colors, radii, bHighlight, prevone, nexttwo, bNonCoil);
            }

            pnts_colors_radii_prevone_nexttwo = [];
        }

    /*    
        createTube(atoms, atomName, radius, bHighlight, bCustom, bNonCoil) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            let pnts = [], colors = [], radii = [], prevone = [], nexttwo = [];
            let currentChain, currentResi;
            let index = 0;
            let maxDist = 6.0;
            let maxDist2 = 3.0; // avoid tube between the residues in 3 residue helix

            let pnts_colors_radii_prevone_nexttwo = [];
            let firstAtom, atom, prevAtom;

            for (let i in atoms) {
                atom = atoms[i];
                if ((atom.name === atomName) && !atom.het) {
                    if(index == 0) {
                        firstAtom = atom;
                    }

                    if (index > 0 && (currentChain !== atom.chain || Math.abs(atom.coord.x - prevAtom.coord.x) > maxDist || Math.abs(atom.coord.y - prevAtom.coord.y) > maxDist || Math.abs(atom.coord.z - prevAtom.coord.z) > maxDist
                      || (ic.ParserUtilsCls.getResiNCBI(atom.structure + '_' + currentChain, currentResi) + 1 < ic.ParserUtilsCls.getResiNCBI(atom.structure + '_' + atom.chain, atom.resi) && (Math.abs(atom.coord.x - prevAtom.coord.x) > maxDist2 || Math.abs(atom.coord.y - prevAtom.coord.y) > maxDist2 || Math.abs(atom.coord.z - prevAtom.coord.z) > maxDist2))
                      ) ) {
                        if(bHighlight !== 2) {
                            if(!isNaN(firstAtom.resi) && !isNaN(prevAtom.resi)) {
                                let prevoneResid = firstAtom.structure + '_' + firstAtom.chain + '_' + (parseInt(firstAtom.resi) - 1).toString();
                                let prevoneCoord = ic.firstAtomObjCls.getAtomCoordFromResi(prevoneResid, atomName);
                                prevone = (prevoneCoord !== undefined) ? [prevoneCoord] : [];

                                let nextoneResid = prevAtom.structure + '_' + prevAtom.chain + '_' + (parseInt(prevAtom.resi) + 1).toString();

                                // add one more residue if only one residue is available
                                if(pnts.length == 1 && ic.residues.hasOwnProperty(nextoneResid)) {
                                    let nextAtom = ic.firstAtomObjCls.getAtomFromResi(nextoneResid, atomName);

                                    if(nextAtom) {
                                        pnts.push(nextAtom.coord);
                                        colors.push(nextAtom.color);

                                        let radiusFinal = this.getRadius(radius, atom);
                                        radii.push(radiusFinal);
                                    }
                                }
                           
                            }

                            pnts_colors_radii_prevone_nexttwo.push({'pnts':pnts, 'colors':colors, 'radii':radii, 'prevone':prevone, 'nexttwo':nexttwo});
                        }
                        pnts = []; colors = []; radii = []; prevone = []; nexttwo = [];
                        firstAtom = atom;
                        index = 0;
                    }

                    pnts.push(atom.coord);

                    let radiusFinal;
                    if(bCustom) {
                        radiusFinal = this.getCustomtubesize(atom.structure + '_' + atom.chain + '_' + atom.resi);
                    }
                    else {
                        radiusFinal = this.getRadius(radius, atom);
                    }

                    // draw all atoms in tubes and assign zero radius when the residue is not coil
                    if(!bNonCoil && atom.ss != 'coil' && !atom.ssbegin && !atom.ssend ) radiusFinal = 0;

                    //radii.push(radius || (atom.b > 0 ? atom.b * 0.01 : ic.coilWidth));
                    radii.push(radiusFinal);

                    colors.push(atom.color);
                    // the starting residue of a coil uses the color from the next residue to avoid using the color of the last helix/sheet residue
                    if(index === 1) colors[colors.length - 2] = atom.color;

                    currentChain = atom.chain;
                    currentResi = atom.resi;

                    let scale = 1.2;
                    if(bHighlight === 2 && !atom.ssbegin) {
                        ic.boxCls.createBox(atom, undefined, undefined, scale, undefined, bHighlight);
                    }

                    ++index;

                    prevAtom = atom;
                }
            }

            if(bHighlight !== 2) {
                pnts_colors_radii_prevone_nexttwo.push({'pnts':pnts, 'colors':colors, 'radii':radii, 'prevone':prevone, 'nexttwo':nexttwo});
            }

            for(let i = 0, il = pnts_colors_radii_prevone_nexttwo.length; i < il; ++i) {
                let pnts = pnts_colors_radii_prevone_nexttwo[i].pnts;
                let colors = pnts_colors_radii_prevone_nexttwo[i].colors;
                let radii = pnts_colors_radii_prevone_nexttwo[i].radii;
                let prevone = []; // = pnts_colors_radii_prevone_nexttwo[i].prevone;
                let nexttwo = []; // = pnts_colors_radii_prevone_nexttwo[i].nexttwo;

                this.createTubeSub(pnts, colors, radii, bHighlight, prevone, nexttwo, bNonCoil);
            }

            pnts_colors_radii_prevone_nexttwo = [];    
        }
    */

        getCustomtubesize(resid) { let ic = this.icn3d; ic.icn3dui;
            let pos = resid.lastIndexOf('_');
            let resi = resid.substr(pos + 1);
            let chainid = resid.substr(0, pos);

            let radiusFinal = (ic.queryresi2score[chainid] && ic.queryresi2score[chainid].hasOwnProperty(resi)) ? ic.queryresi2score[chainid][resi] * 0.01 : ic.coilWidth;

            return radiusFinal;
        };

        // modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
        createTubeSub(_pnts, colors, radii, bHighlight, prevone, nexttwo, bNonCoil) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            if (_pnts.length < 2) return;

            let circleDiv = ic.tubeDIV, axisDiv = ic.axisDIV;
            let circleDivInv = 1 / circleDiv, axisDivInv = 1 / axisDiv;
            //var geo = new THREE.Geometry();
            let geo = new THREE.BufferGeometry();
            let verticeArray = [], colorArray = [],indexArray = [], color;
            let offset = 0, offset2 = 0, offset3 = 0;

            let pnts_clrs = me.subdivideCls.subdivide(_pnts, colors, axisDiv, undefined, undefined, prevone, nexttwo);

            let pnts = pnts_clrs[0];
            colors = pnts_clrs[2];

            let constRadiius;
            // a threshold to stop drawing the tube if it's less than this ratio of radius
            let thresholdRatio = 1; //0.9;

            let prevAxis1 = new THREE.Vector3(), prevAxis2;
            for (let i = 0, lim = pnts.length; i < lim; ++i) {
                let r, idx = (i - 1) * axisDivInv;

                if (i === 0) {
                    r = radii[0];
                    if(r > 0) constRadiius = r;
                }
                else {
                    if (idx % 1 === 0) {
                        r = radii[idx];
                        if(r > 0) constRadiius = r;
                    }
                    else {
                        let floored = Math.floor(idx);
                        let tmp = idx - floored;
                        // draw all atoms in tubes and assign zero radius when the residue is not coil
                        // r = radii[floored] * tmp + radii[floored + 1] * (1 - tmp);
                        r = radii[floored] * (1 - tmp) + radii[floored + 1] * tmp;

                        // a threshold to stop drawing the tube if it's less than this ratio of radius.
                        // The extra bit of tube connects coil with strands or helices
                        if(!bNonCoil) {
                            if(r < thresholdRatio * constRadiius) {
                                r = 0;
                            }
                            // else if(r < constRadiius) {
                            //     r *= 0.5; // use small radius for the connection between coild and sheets/helices 
                            // }
                        }
                    }
                }
                let delta, axis1, axis2;
                if (i < lim - 1) {
                    delta = pnts[i].clone().sub(pnts[i + 1]);
                    axis1 = new THREE.Vector3(0, -delta.z, delta.y).normalize().multiplyScalar(r);
                    axis2 = delta.clone().cross(axis1).normalize().multiplyScalar(r);
                    //      let dir = 1, offset = 0;
                    if (prevAxis1.dot(axis1) < 0) {
                        axis1.negate(); axis2.negate();  //dir = -1;//offset = 2 * Math.PI / axisDiv;
                    }
                    prevAxis1 = axis1; prevAxis2 = axis2;
                } else {
                    axis1 = prevAxis1; axis2 = prevAxis2;
                }
                for (let j = 0; j < circleDiv; ++j) {
                    let angle = 2 * Math.PI * circleDivInv * j; //* dir  + offset;
                    let point = pnts[i].clone().add(axis1.clone().multiplyScalar(Math.cos(angle))).add(axis2.clone().multiplyScalar(Math.sin(angle)));
                    verticeArray[offset++] = point.x;
                    verticeArray[offset++] = point.y;
                    verticeArray[offset++] = point.z;

                    color = (i == colors.length - 1 && colors.length > 1) ? me.parasCls.thr(colors[colors.length - 2]) : me.parasCls.thr(colors[i]);
                    colorArray[offset2++] = color.r;
                    colorArray[offset2++] = color.g;
                    colorArray[offset2++] = color.b;
                }
            }
            let offsetTmp = 0, nComp = 3;
            for (let i = 0, lim = pnts.length - 1; i < lim; ++i) {
                let reg = 0;
                //var r1 = geo.vertices[offset].clone().sub(geo.vertices[offset + circleDiv]).lengthSq();
                //var r2 = geo.vertices[offset].clone().sub(geo.vertices[offset + circleDiv + 1]).lengthSq();
                let pos = offsetTmp * nComp;
                let point1 = new THREE.Vector3(verticeArray[pos], verticeArray[pos + 1], verticeArray[pos + 2]);
                pos = (offsetTmp + circleDiv) * nComp;
                let point2 = new THREE.Vector3(verticeArray[pos], verticeArray[pos + 1], verticeArray[pos + 2]);
                pos = (offsetTmp + circleDiv + 1) * nComp;
                let point3 = new THREE.Vector3(verticeArray[pos], verticeArray[pos + 1], verticeArray[pos + 2]);

                let r1 = point1.clone().sub(point2).lengthSq();
                let r2 = point1.clone().sub(point3).lengthSq();
                if (r1 > r2) { r1 = r2; reg = 1; }            for (let j = 0; j < circleDiv; ++j) {
                    //geo.faces.push(new THREE.Face3(offset + j, offset + (j + reg) % circleDiv + circleDiv, offset + (j + 1) % circleDiv, undefined, c));
                    //geo.faces.push(new THREE.Face3(offset + (j + 1) % circleDiv, offset + (j + reg) % circleDiv + circleDiv, offset + (j + reg + 1) % circleDiv + circleDiv, undefined, c));
                    //indexArray = indexArray.concat([offset + j, offset + (j + reg) % circleDiv + circleDiv, offset + (j + 1) % circleDiv]);
                    indexArray[offset3++] = offsetTmp + j;
                    indexArray[offset3++] = offsetTmp + (j + reg) % circleDiv + circleDiv;
                    indexArray[offset3++] = offsetTmp + (j + 1) % circleDiv;

                    //indexArray = indexArray.concat([offset + (j + 1) % circleDiv, offset + (j + reg) % circleDiv + circleDiv, offset + (j + reg + 1) % circleDiv + circleDiv]);
                    indexArray[offset3++] = offsetTmp + (j + 1) % circleDiv;
                    indexArray[offset3++] = offsetTmp + (j + reg) % circleDiv + circleDiv;
                    indexArray[offset3++] = offsetTmp + (j + reg + 1) % circleDiv + circleDiv;
                }
                offsetTmp += circleDiv;
            }

            geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(verticeArray), nComp));
            geo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(colorArray), nComp));

            geo.setIndex(new THREE.BufferAttribute(new Uint32Array(indexArray), 1));
            //geo.setIndex(indexArray);

            //geo.computeFaceNormals();
            //geo.computeVertexNormals(false);
            geo.computeVertexNormals();

            let mesh;
            if(bHighlight === 2) {
              //mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ transparent: true, opacity: 0.5, specular: ic.frac, shininess: ic.shininess, emissive: ic.emissive, vertexColors: THREE.FaceColors, side: THREE.DoubleSide }));
              mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ transparent: true, opacity: 0.5, specular: ic.frac, shininess: ic.shininess, emissive: ic.emissive, vertexColors: true, side: THREE.DoubleSide }));

              if(ic.mdl) ic.mdl.add(mesh);
            }
            else if(bHighlight === 1) {
              mesh = new THREE.Mesh(geo, ic.matShader);
              mesh.renderOrder = ic.renderOrderPicking;
              //ic.mdlPicking.add(mesh);
              if(ic.mdl) ic.mdl.add(mesh);
            }
            else {
              //mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ specular: ic.frac, shininess: ic.shininess, emissive: ic.emissive, vertexColors: THREE.FaceColors, side: THREE.DoubleSide }));
              mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ specular: ic.frac, shininess: ic.shininess, emissive: ic.emissive, vertexColors: true, side: THREE.DoubleSide }));

              if(ic.mdl) ic.mdl.add(mesh);
            }

            if(bHighlight === 1 || bHighlight === 2) {
                ic.prevHighlightObjects.push(mesh);
            }
            else {
                ic.objects.push(mesh);
            }
        }

        getRadius(radius, atom) { let ic = this.icn3d; ic.icn3dui;
            let radiusFinal = radius;
            if(radius) {
                radiusFinal = radius;
            }
            else {
                if(atom.b > 0 && atom.b <= 100) {
                    radiusFinal = atom.b * 0.01;
                }
                else if(atom.b > 100) {
                    radiusFinal = 100 * 0.01;
                }
                else {
                    radiusFinal = ic.coilWidth;
                }
            }

            return radiusFinal;
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Strand {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        // significantly modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
        //Create the style of ribbon or strand for "atoms". "num" means how many lines define the curve.
        //"num" is 2 for ribbon and 6 for strand. "div" means how many pnts are used to smooth the curve.
        //It's typically 5. "coilWidth" is the width of curve for coil. "helixSheetWidth" is the width of curve for helix or sheet.
        //"doNotSmoothen" is a flag to smooth the curve or not. "thickness" is the thickness of the curve.
        //"bHighlight" is an option to draw the highlight for these atoms. The highlight could be outlines
        //with bHighlight=1 and 3D objects with bHighlight=2.
        createStrand(atoms, num, div, fill, coilWidth, helixSheetWidth, doNotSmoothen, thickness, bHighlight) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            let bRibbon = fill ? true: false;

            // when highlight, the input atoms may only include part of sheet or helix
            // include the whole sheet or helix when highlighting
            let atomsAdjust = {};

            //if( (bHighlight === 1 || bHighlight === 2) && !ic.bAllAtoms) {
            //if( !ic.bAllAtoms) {
            if( Object.keys(atoms).length < Object.keys(ic.atoms).length) {
                atomsAdjust = this.getSSExpandedAtoms(atoms);
            }
            else {
                atomsAdjust = atoms;
            }

            if(bHighlight === 2) {
                if(fill) {
                    fill = false;
                    num = null;
                    div = null;
                    coilWidth = null;
                    helixSheetWidth = null;
                    thickness = undefined;
                }
                else {
                    fill = true;
                    num = 2;
                    div = undefined;
                    coilWidth = undefined;
                    helixSheetWidth = undefined;
                    thickness = ic.ribbonthickness;
                }
            }

            num = num || ic.strandDIV;
            div = div || ic.axisDIV;
            coilWidth = coilWidth || ic.coilWidth;
            doNotSmoothen = doNotSmoothen || false;
            helixSheetWidth = helixSheetWidth || ic.helixSheetWidth;
            let pnts = {}; for (let k = 0; k < num; ++k) pnts[k] = [];
            let pntsCA = [];
            let prevCOArray = [];
            let bShowArray = [];
            let calphaIdArray = []; // used to store one of the final positions drawn in 3D
            let colors = [];
            let currentChain, currentCA = null, currentO = null, currentColor = null, prevCoorCA = null, prevCoorO = null, prevColor = null;
            let prevCO = null, ss = null, ssend = false, atomid = null, prevAtomid = null, prevResi = null, calphaid = null, prevCalphaid = null;
            let strandWidth, bSheetSegment = false, bHelixSegment = false;
            let atom, tubeAtoms = {};

            // test the first 30 atoms to see whether only C-alpha is available
            ic.bCalphaOnly = me.utilsCls.isCalphaPhosOnly(atomsAdjust); //, 'CA');

            // when highlight, draw whole beta sheet and use bShowArray to show the highlight part
            let residueHash = {};
            for(let i in atomsAdjust) {
                let atom = atomsAdjust[i];

                let residueid = atom.structure + '_' + atom.chain + '_' + atom.resi;
                residueHash[residueid] = 1;
            }
            let totalResidueCount = Object.keys(residueHash).length;

            let drawnResidueCount = 0;

            let bFullAtom = (Object.keys(ic.hAtoms).length == Object.keys(ic.atoms).length) ? true : false;

            let caArray = []; // record all C-alpha atoms to predict the helix

            for (let i in atomsAdjust) {
              atom = atomsAdjust[i];
              if ((atom.name === 'O' || atom.name === 'CA') && !atom.het) {
                // "CA" has to appear before "O"

                if (atom.name === 'CA') {
                    if ( atoms.hasOwnProperty(i) && ((atom.ss !== 'helix' && atom.ss !== 'sheet') || atom.ssend || atom.ssbegin) ) {
                        tubeAtoms[i] = atom;
                    }

                    currentCA = atom.coord;
                    currentColor = atom.color;
                    calphaid = atom.serial;

                    caArray.push(atom.serial);
                }

                if (atom.name === 'O' || (ic.bCalphaOnly && atom.name === 'CA')) {
                    if(currentCA === null || currentCA === undefined) {
                        currentCA = atom.coord;
                        currentColor = atom.color;
                        calphaid = atom.serial;
                    }

                    if(atom.name === 'O') {
                        currentO = atom.coord;
                    }
                    // smoothen each coil, helix and sheet separately. The joint residue has to be included both in the previous and next segment
                    let bSameChain = true;
    //                    if (currentChain !== atom.chain || currentResi + 1 !== atom.resi) {
                    if (currentChain !== atom.chain) {
                        bSameChain = false;
                    }

                    if(atom.ssend && atom.ss === 'sheet') {
                        bSheetSegment = true;
                    }
                    else if(atom.ssend && atom.ss === 'helix') {
                        bHelixSegment = true;
                    }

                    // assign the previous residue
                    if(prevCoorO) {
                        if(bHighlight === 1 || bHighlight === 2) {
                            colors.push(ic.hColor);
                        }
                        else {
                            colors.push(prevColor);
                        }

                        if(ss !== 'coil' && atom.ss === 'coil') {
                            strandWidth = coilWidth;
                        }
                        else if(ssend && atom.ssbegin) { // a transition between two ss
                            strandWidth = coilWidth;
                        }
                        else {
                            strandWidth = (ss === 'coil') ? coilWidth : helixSheetWidth;
                        }

                        let O, oldCA, resSpan = 4;
                        if(atom.name === 'O') {
                            O = prevCoorO.clone();
                            if(prevCoorCA !== null && prevCoorCA !== undefined) {
                                O.sub(prevCoorCA);
                            }
                            else {
                                prevCoorCA = prevCoorO.clone();
                                if(caArray.length > resSpan + 1) { // use the calpha and the previous 4th c-alpha to calculate the helix direction
                                    O = prevCoorCA.clone();
                                    oldCA = ic.atoms[caArray[caArray.length - 1 - resSpan - 1]].coord.clone();
                                    //O.sub(oldCA);
                                    oldCA.sub(O);
                                }
                                else {
                                    O = new THREE.Vector3(Math.random(),Math.random(),Math.random());
                                }
                            }
                        }
                        else if(ic.bCalphaOnly && atom.name === 'CA') {
                            if(caArray.length > resSpan + 1) { // use the calpha and the previous 4th c-alpha to calculate the helix direction
                                O = prevCoorCA.clone();
                                oldCA = ic.atoms[caArray[caArray.length - 1 - resSpan - 1]].coord.clone();
                                //O.sub(oldCA);
                                oldCA.sub(O);
                            }
                            else {
                                O = new THREE.Vector3(Math.random(),Math.random(),Math.random());
                            }
                        }

                        O.normalize(); // can be omitted for performance
                        O.multiplyScalar(strandWidth);
                        if (prevCO !== null && O.dot(prevCO) < 0) O.negate();
                        prevCO = O;

                        for (let j = 0, numM1Inv2 = 2 / (num - 1); j < num; ++j) {
                            let delta = -1 + numM1Inv2 * j;
                            let v = new THREE.Vector3(prevCoorCA.x + prevCO.x * delta, prevCoorCA.y + prevCO.y * delta, prevCoorCA.z + prevCO.z * delta);
                            if (!doNotSmoothen && ss === 'sheet') v.smoothen = true;
                            pnts[j].push(v);
                        }

                        pntsCA.push(prevCoorCA);
                        prevCOArray.push(prevCO);

                        if(atoms.hasOwnProperty(prevAtomid)) {
                            bShowArray.push(prevResi);
                            calphaIdArray.push(prevCalphaid);
                        }
                        else {
                            bShowArray.push(0);
                            calphaIdArray.push(0);
                        }

                        ++drawnResidueCount;
                    }

                    let maxDist = 6.0;
                    let bBrokenSs = (prevCoorCA && Math.abs(currentCA.x - prevCoorCA.x) > maxDist) || (prevCoorCA && Math.abs(currentCA.y - prevCoorCA.y) > maxDist) || (prevCoorCA && Math.abs(currentCA.z - prevCoorCA.z) > maxDist);
                    // The following code didn't work to select one residue
                    // let bBrokenSs = !atoms.hasOwnProperty(atom.serial) || (prevCoorCA && Math.abs(currentCA.x - prevCoorCA.x) > maxDist) || (prevCoorCA && Math.abs(currentCA.y - prevCoorCA.y) > maxDist) || (prevCoorCA && Math.abs(currentCA.z - prevCoorCA.z) > maxDist);

                    // if(bBrokenSs && atom.ss === 'sheet') {
                    //     bSheetSegment = true;
                    // }
                    // else if(bBrokenSs && atom.ss === 'helix') {
                    //     bHelixSegment = true;
                    // }

                    if ((atom.ssbegin || atom.ssend || (drawnResidueCount === totalResidueCount - 1) || bBrokenSs) && pnts[0].length > 0 && bSameChain) {
                        let atomName = 'CA';

                        let prevone = [], nexttwo = [];

                        if(isNaN(ic.atoms[prevAtomid].resi)) {
                            prevone = [];
                        }
                        else {
                            let prevoneResid = ic.atoms[prevAtomid].structure + '_' + ic.atoms[prevAtomid].chain + '_' + (parseInt(ic.atoms[prevAtomid].resi) - 1).toString();
                            let prevoneCoord = ic.firstAtomObjCls.getAtomCoordFromResi(prevoneResid, atomName);
                            prevone = (prevoneCoord !== undefined) ? [prevoneCoord] : [];
                        }

                        if(!isNaN(ic.atoms[prevAtomid].resi)) {
                            let nextoneResid = ic.atoms[prevAtomid].structure + '_' + ic.atoms[prevAtomid].chain + '_' + (parseInt(ic.atoms[prevAtomid].resi) + 1).toString();
                            let nextoneCoord = ic.firstAtomObjCls.getAtomCoordFromResi(nextoneResid, atomName);
                            if(nextoneCoord !== undefined) {
                                nexttwo.push(nextoneCoord);
                            }

                            let nexttwoResid = ic.atoms[prevAtomid].structure + '_' + ic.atoms[prevAtomid].chain + '_' + (parseInt(ic.atoms[prevAtomid].resi) + 2).toString();
                            let nexttwoCoord = ic.firstAtomObjCls.getAtomCoordFromResi(nexttwoResid, atomName);
                            if(nexttwoCoord !== undefined) {
                                nexttwo.push(nexttwoCoord);
                            }
                        }

                        if(!bBrokenSs) { // include the current residue
                            // assign the current joint residue to the previous segment
                            if(bHighlight === 1 || bHighlight === 2) {
                                colors.push(ic.hColor);
                            }
                            else {
                                //colors.push(atom.color);
                                colors.push(prevColor);
                            }

                            if(atom.ssend && atom.ss === 'sheet') { // current residue is the end of ss and is the end of arrow
                                strandWidth = 0; // make the arrow end sharp
                            }
                            else if(ss === 'coil' && atom.ssbegin) {
                                strandWidth = coilWidth;
                            }
                            else if(ssend && atom.ssbegin) { // current residue is the start of ss and  the previous residue is the end of ss, then use coil
                                strandWidth = coilWidth;
                            }
                            else { // use the ss from the previous residue
                                strandWidth = (atom.ss === 'coil') ? coilWidth : helixSheetWidth;
                            }

                            let O, oldCA, resSpan = 4;
                            if(atom.name === 'O') {
                                O = currentO.clone();
                                O.sub(currentCA);
                            }
                            else if(ic.bCalphaOnly && atom.name === 'CA') {
                                if(caArray.length > resSpan) { // use the calpha and the previous 4th c-alpha to calculate the helix direction
                                    O = currentCA.clone();
                                    oldCA = ic.atoms[caArray[caArray.length - 1 - resSpan]].coord.clone();
                                    //O.sub(oldCA);
                                    oldCA.sub(O);
                                }
                                else {
                                    O = new THREE.Vector3(Math.random(),Math.random(),Math.random());
                                }
                            }

                            O.normalize(); // can be omitted for performance
                            O.multiplyScalar(strandWidth);
                            if (prevCO !== null && O.dot(prevCO) < 0) O.negate();
                            prevCO = O;

                            for (let j = 0, numM1Inv2 = 2 / (num - 1); j < num; ++j) {
                                let delta = -1 + numM1Inv2 * j;
                                let v = new THREE.Vector3(currentCA.x + prevCO.x * delta, currentCA.y + prevCO.y * delta, currentCA.z + prevCO.z * delta);
                                if (!doNotSmoothen && ss === 'sheet') v.smoothen = true;
                                pnts[j].push(v);
                            }

                            atomid = atom.serial;

                            pntsCA.push(currentCA);
                            prevCOArray.push(prevCO);

                            // when a coil connects to a sheet and the last residue of coild is highlighted, the first sheet residue is set as atom.highlightStyle. This residue should not be shown.
                            //if(atoms.hasOwnProperty(atomid) && (bHighlight === 1 && !atom.notshow) ) {
                            if(atoms.hasOwnProperty(atomid)) {
                                bShowArray.push(atom.resi);
                                calphaIdArray.push(calphaid);
                            }
                            else {
                                bShowArray.push(0);
                                calphaIdArray.push(0);
                            }
                        }

                        // draw the current segment
                        for (let j = 0; !fill && j < num; ++j) {
                            if(bSheetSegment) {
                                ic.curveStripArrowCls.createCurveSubArrow(pnts[j], 1, colors, div, bHighlight, bRibbon, num, j, pntsCA, prevCOArray, bShowArray, calphaIdArray, true, prevone, nexttwo);
                            }
                            else if(bHelixSegment) {
                                if(bFullAtom) {
                                    ic.curveCls.createCurveSub(pnts[j], 1, colors, div, bHighlight, bRibbon, false, bShowArray, calphaIdArray, undefined, prevone, nexttwo);
                                }
                                else {
                                    ic.curveStripArrowCls.createCurveSubArrow(pnts[j], 1, colors, div, bHighlight, bRibbon, num, j, pntsCA, prevCOArray, bShowArray, calphaIdArray, false, prevone, nexttwo);
                                }
                            }
                        }
                        if (fill) {
                            if(bSheetSegment) {
                                let start = 0, end = num - 1;
                                ic.curveStripArrowCls.createStripArrow(pnts[0], pnts[num - 1], colors, div, thickness, bHighlight, num, start, end, pntsCA, prevCOArray, bShowArray, calphaIdArray, true, prevone, nexttwo);
                            }
                            else if(bHelixSegment) {
                                if(bFullAtom) {
                                    ic.stripCls.createStrip(pnts[0], pnts[num - 1], colors, div, thickness, bHighlight, false, bShowArray, calphaIdArray, undefined, prevone, nexttwo, pntsCA, prevCOArray);
                                }
                                else {
                                    let start = 0, end = num - 1;
                                    ic.curveStripArrowCls.createStripArrow(pnts[0], pnts[num - 1], colors, div, thickness, bHighlight, num, start, end, pntsCA, prevCOArray, bShowArray, calphaIdArray, false, prevone, nexttwo);
                                }
                            }
                            else {
                                if(bHighlight === 2) { // draw coils only when highlighted. if not highlighted, coils will be drawn as tubes separately
                                    ic.stripCls.createStrip(pnts[0], pnts[num - 1], colors, div, thickness, bHighlight, false, bShowArray, calphaIdArray, undefined, prevone, nexttwo, pntsCA, prevCOArray);
                                }
                            }
                        }
                        for (let k = 0; k < num; ++k) pnts[k] = [];

                        colors = [];
                        pntsCA = [];
                        prevCOArray = [];
                        bShowArray = [];
                        calphaIdArray = [];
                        bSheetSegment = false;
                        bHelixSegment = false;
                    } // end if (atom.ssbegin || atom.ssend)

                    // end of a chain
    //                    if ((currentChain !== atom.chain || currentResi + 1 !== atom.resi) && pnts[0].length > 0) {
                    if ((currentChain !== atom.chain) && pnts[0].length > 0) {

                        let atomName = 'CA';

                        let prevone = [], nexttwo = [];
                        if(isNaN(ic.atoms[prevAtomid].resi)) {
                            prevone = [];
                        }
                        else {
                            let prevoneResid = ic.atoms[prevAtomid].structure + '_' + ic.atoms[prevAtomid].chain + '_' + (parseInt(ic.atoms[prevAtomid].resi) - 1).toString();
                            ic.firstAtomObjCls.getAtomCoordFromResi(prevoneResid, atomName);
                        }

                        for (let j = 0; !fill && j < num; ++j) {
                            if(bSheetSegment) {
                                ic.curveStripArrowCls.createCurveSubArrow(pnts[j], 1, colors, div, bHighlight, bRibbon, num, j, pntsCA, prevCOArray, bShowArray, calphaIdArray, true, prevone, nexttwo);
                            }
                            else if(bHelixSegment) {
                                if(bFullAtom) {
                                    ic.curveCls.createCurveSub(pnts[j], 1, colors, div, bHighlight, bRibbon, false, bShowArray, calphaIdArray, undefined, prevone, nexttwo);
                                }
                                else {
                                    ic.curveStripArrowCls.createCurveSubArrow(pnts[j], 1, colors, div, bHighlight, bRibbon, num, j, pntsCA, prevCOArray, bShowArray, calphaIdArray, false, prevone, nexttwo);
                                }
                            }
                        }
                        if (fill) {
                            if(bSheetSegment) {
                                let start = 0, end = num - 1;
                                ic.curveStripArrowCls.createStripArrow(pnts[0], pnts[num - 1], colors, div, thickness, bHighlight, num, start, end, pntsCA, prevCOArray, bShowArray, calphaIdArray, true, prevone, nexttwo);
                            }
                            else if(bHelixSegment) {
                                if(bFullAtom) {
                                    ic.stripCls.createStrip(pnts[0], pnts[num - 1], colors, div, thickness, bHighlight, false, bShowArray, calphaIdArray, undefined, prevone, nexttwo, pntsCA, prevCOArray);
                                }
                                else {
                                    let start = 0, end = num - 1;
                                    ic.curveStripArrowCls.createStripArrow(pnts[0], pnts[num - 1], colors, div, thickness, bHighlight, num, start, end, pntsCA, prevCOArray, bShowArray, calphaIdArray, false, prevone, nexttwo);
                                }
                            }
                        }

                        for (let k = 0; k < num; ++k) pnts[k] = [];
                        colors = [];
                        pntsCA = [];
                        prevCOArray = [];
                        bShowArray = [];
                        calphaIdArray = [];
                        bSheetSegment = false;
                        bHelixSegment = false;
                    }

                    currentChain = atom.chain;
                    ss = atom.ss;
                    ssend = atom.ssend;
                    prevAtomid = atom.serial;
                    prevResi = atom.resi;

                    prevCalphaid = calphaid;

                    // only update when atom.name === 'O'
                    prevCoorCA = currentCA;
                    prevCoorO = atom.coord;
                    prevColor = currentColor;
                } // end if (atom.name === 'O' || (ic.bCalphaOnly && atom.name === 'CA') ) {
              } // end if ((atom.name === 'O' || atom.name === 'CA') && !atom.het) {
            } // end for

            caArray = [];

            ic.tubeCls.createTube(tubeAtoms, 'CA', coilWidth, bHighlight);

            tubeAtoms = {};
            pnts = {};
        }

        getSSExpandedAtoms(atoms, bHighlight) { let ic = this.icn3d, me = ic.icn3dui;
            let currChain, currResi, currAtom, prevChain, prevResi, prevAtom;
            let firstAtom, lastAtom;
            let index = 0, length = Object.keys(atoms).length;

            let atomsAdjust = me.hashUtilsCls.cloneHash(atoms);
            for(let serial in atoms) {
              currChain = atoms[serial].structure + '_' + atoms[serial].chain;
              currResi = atoms[serial].resi; //parseInt(atoms[serial].resi);
              currAtom = atoms[serial];

              if(prevChain === undefined) firstAtom = atoms[serial];

              if( (currChain !== prevChain && prevChain !== undefined)
               || (currResi !== prevResi && currResi !== parseInt(prevResi) + 1 && prevResi !== undefined) || index === length - 1) {
                if( (currChain !== prevChain && prevChain !== undefined)
                  || (currResi !== prevResi && currResi !== parseInt(prevResi) + 1 && prevResi !== undefined) ) {
                    lastAtom = prevAtom;
                }
                else if(index === length - 1) {
                    lastAtom = currAtom;
                }

                // fill the beginning
                let beginResi = firstAtom.resi;
                if(!isNaN(firstAtom.resi) && firstAtom.ss !== 'coil' && !(firstAtom.ssbegin) ) {
                    for(let i = parseInt(firstAtom.resi) - 1; i > 0; --i) {
                        let residueid = firstAtom.structure + '_' + firstAtom.chain + '_' + i;
                        if(!ic.residues.hasOwnProperty(residueid)) break;

                        let atom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[residueid]);

                        if(atom.ss === firstAtom.ss && atom.ssbegin) {
                            beginResi = atom.resi;
                            break;
                        }
                    }

                    for(let i = beginResi; i < firstAtom.resi; ++i) {
                        let residueid = firstAtom.structure + '_' + firstAtom.chain + '_' + i;
                        atomsAdjust = me.hashUtilsCls.unionHash(atomsAdjust, me.hashUtilsCls.hash2Atoms(ic.residues[residueid],
                          ic.atoms));
                    }
                }

                // add one extra residue for coils between strands/helix if the style is NOT stick, ball and stick, lines, sphere, and dot
                // if(!isNaN(firstAtom.resi) && ic.pk === 3 && bHighlight === 1 && firstAtom.ss === 'coil') {
                if(!isNaN(firstAtom.resi) && ic.pk === 3 && bHighlight === 1 && firstAtom.ss === 'coil' && firstAtom.style != 'stick' && firstAtom.style != 'ball and stick' && firstAtom.style != 'lines' && firstAtom.style != 'sphere' && firstAtom.style != 'dot') {
                        let residueid = firstAtom.structure + '_' + firstAtom.chain + '_' + (parseInt(firstAtom.resi) - 1).toString();
                        if(ic.residues.hasOwnProperty(residueid)) {
                            atomsAdjust = me.hashUtilsCls.unionHash(atomsAdjust, me.hashUtilsCls.hash2Atoms(ic.residues[residueid],
                              ic.atoms));
                            atoms = me.hashUtilsCls.unionHash(atoms, me.hashUtilsCls.hash2Atoms(ic.residues[residueid], ic.atoms));
                        }
                }

                // fill the end
                let endResi = lastAtom.resi;
                // when a coil connects to a sheet and the last residue of coil is highlighted, the first sheet residue is set as atom.notshow. This residue should not be shown.

                if(lastAtom.ss !== undefined && lastAtom.ss !== 'coil' && !(lastAtom.ssend) && !(lastAtom.notshow)) {

                    let endChainResi = ic.firstAtomObjCls.getLastAtomObj(ic.chains[lastAtom.structure + '_' + lastAtom.chain]).resi;
                    for(let i = parseInt(lastAtom.resi) + 1; i <= parseInt(endChainResi); ++i) {
                        let residueid = lastAtom.structure + '_' + lastAtom.chain + '_' + i;
                        if(!ic.residues.hasOwnProperty(residueid)) break;

                        let atom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[residueid]);

                        if(atom.ss === lastAtom.ss && atom.ssend) {
                            endResi = atom.resi;
                            break;
                        }
                    }

                    for(let i = parseInt(lastAtom.resi) + 1; i <= parseInt(endResi); ++i) {
                        let residueid = lastAtom.structure + '_' + lastAtom.chain + '_' + i;
                        atomsAdjust = me.hashUtilsCls.unionHash(atomsAdjust, me.hashUtilsCls.hash2Atoms(ic.residues[residueid],
                          ic.atoms));
                    }
                }

                // add one extra residue for coils between strands/helix if the style is NOT stick, ball and stick, lines, sphere, and dot
                if(ic.pk === 3 && bHighlight === 1 && lastAtom.ss === 'coil' && firstAtom.style != 'stick' && firstAtom.style != 'ball and stick' && firstAtom.style != 'lines' && firstAtom.style != 'sphere' && firstAtom.style != 'dot') {
                        let residueid = lastAtom.structure + '_' + lastAtom.chain + '_' + (parseInt(lastAtom.resi) + 1).toString();
                        if(ic.residues.hasOwnProperty(residueid)) {
                            atomsAdjust = me.hashUtilsCls.unionHash(atomsAdjust, me.hashUtilsCls.hash2Atoms(ic.residues[residueid],
                              ic.atoms));
                            atoms = me.hashUtilsCls.unionHash(atoms, me.hashUtilsCls.hash2Atoms(ic.residues[residueid], ic.atoms));
                        }
                }

                // reset notshow
                if(lastAtom.notshow) lastAtom.notshow = undefined;

                firstAtom = currAtom;
              }

              prevChain = currChain;
              prevResi = currResi;
              prevAtom = currAtom;

              ++index;
            }

            return atomsAdjust;
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class CartoonNucl {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        // modified from GLmol (http://webglmol.osdn.jp/index-en.html)
        //Create curves for nucleotide "atoms". "div" means how many pnts are used to smooth the curve. It's typically 5.
        //"thickness" is the thickness of the curve. "bHighlight" is an option to draw the highlight for these atoms.
        //The highlight could be outlines with bHighlight=1 and 3D objects with bHighlight=2.
        drawCartoonNucleicAcid(atomlist, div, thickness, bHighlight) {
           this.drawStrandNucleicAcid(atomlist, 2, div, true, undefined, thickness, bHighlight);
        }

        // modified from GLmol (http://webglmol.osdn.jp/index-en.html)
        drawStrandNucleicAcid(atomlist, num, div, fill, nucleicAcidWidth, thickness, bHighlight) { let ic = this.icn3d, me = ic.icn3dui;
           if(me.bNode) return;

           if(bHighlight === 2) {
               num = undefined;
               thickness = undefined;
           }

           nucleicAcidWidth = nucleicAcidWidth || ic.nucleicAcidWidth;
           div = div || ic.axisDIV;
           num = num || ic.nucleicAcidStrandDIV;
           let i, j, k;
           let pnts = []; for (k = 0; k < num; k++) pnts[k] = [];
           let colors = [];
           let currentChain, currentResi, currentO3;
           let prevOO = null;

           for (i in atomlist) {
              let atom = atomlist[i];
              if (atom === undefined) continue;

              let chainid = atom.structure + '_' + atom.chain;
              let currentChainid = atom.structure + '_' + currentChain;

              if ((atom.name === 'O3\'' || atom.name === 'OP2' || atom.name === 'O3*' || atom.name === 'O2P') && !atom.het) {
                 if (atom.name === 'O3\'' || atom.name === 'O3*') { // to connect 3' end. FIXME: better way to do?
                    if (currentChain !== atom.chain 
                      || ic.ParserUtilsCls.getResiNCBI(currentChainid, currentResi) + 1 !== ic.ParserUtilsCls.getResiNCBI(chainid, atom.resi)) {
        //            if (currentChain !== atom.chain) {
                       if (currentO3 && prevOO) {
                          for (j = 0; j < num; j++) {
                             let delta = -1 + 2 / (num - 1) * j;
                             pnts[j].push(new THREE.Vector3(currentO3.x + prevOO.x * delta,
                              currentO3.y + prevOO.y * delta, currentO3.z + prevOO.z * delta));
                          }
                       }
                       if (fill) ic.stripCls.createStrip(pnts[0], pnts[1], colors, div, thickness, bHighlight);
                       for (j = 0; !thickness && j < num; j++)
                          ic.curveCls.createCurveSub(pnts[j], 1 ,colors, div, bHighlight);
                       pnts = []; for (k = 0; k < num; k++) pnts[k] = [];
                       colors = [];
                       prevOO = null;
                    }
                    currentO3 = new THREE.Vector3(atom.coord.x, atom.coord.y, atom.coord.z);
                    currentChain = atom.chain;
                    currentResi = atom.resi;
                    if(bHighlight === 1 || bHighlight === 2) {
                        colors.push(ic.hColor);
                    }
                    else {
                        colors.push(atom.color);
                    }

                 }
                 else if (atom.name === 'OP2' || atom.name === 'O2P') {
                    if (!currentO3) {prevOO = null; continue;} // for 5' phosphate (e.g. 3QX3)
                    let O = new THREE.Vector3(atom.coord.x, atom.coord.y, atom.coord.z);
                    O.sub(currentO3);
                    O.normalize().multiplyScalar(nucleicAcidWidth);  // TODO: refactor
                    //if (prevOO !== undefined && O.dot(prevOO) < 0) {
                    if (prevOO !== null && O.dot(prevOO) < 0) {
                       O.negate();
                    }
                    prevOO = O;
                    for (j = 0; j < num; j++) {
                       let delta = -1 + 2 / (num - 1) * j;
                       pnts[j].push(new THREE.Vector3(currentO3.x + prevOO.x * delta,
                         currentO3.y + prevOO.y * delta, currentO3.z + prevOO.z * delta));
                    }
                    currentO3 = null;
                 }
              }
           }

           if (currentO3 && prevOO) {
              for (j = 0; j < num; j++) {
                 let delta = -1 + 2 / (num - 1) * j;
                 pnts[j].push(new THREE.Vector3(currentO3.x + prevOO.x * delta,
                   currentO3.y + prevOO.y * delta, currentO3.z + prevOO.z * delta));
              }
           }
           if (fill) ic.stripCls.createStrip(pnts[0], pnts[1], colors, div, thickness, bHighlight);
           for (j = 0; !thickness && j < num; j++)
              ic.curveCls.createCurveSub(pnts[j], 1 ,colors, div, bHighlight);
        }

        // modified from GLmol (http://webglmol.osdn.jp/index-en.html)
        //Create sticks between two nucleotide curves for nucleotide "atoms". "bHighlight" is an option to
        //draw the highlight for these atoms. The highlight could be outlines with bHighlight=1 and 3D objects with bHighlight=2.
        drawNucleicAcidStick(atomlist, bHighlight) { let ic = this.icn3d, me = ic.icn3dui;
           if(me.bNode) return;

           let currentChain, currentResi, start = null, end = null;
           let i;

           for (i in atomlist) {
              let atom = atomlist[i];
              if (atom === undefined || atom.het) continue;

              if (atom.resi !== currentResi || atom.chain !== currentChain) {
                 if (start !== null && end !== null) {
                    ic.cylinderCls.createCylinder(new THREE.Vector3(start.coord.x, start.coord.y, start.coord.z),
                                      new THREE.Vector3(end.coord.x, end.coord.y, end.coord.z), ic.cylinderRadius, start.color, bHighlight);
                 }
                 start = null; end = null;
              }
              if (atom.name === 'O3\'' || atom.name === 'O3*') start = atom;

              if (atom.resn.trim() === 'A' || atom.resn.trim() === 'G' || atom.resn.trim() === 'DA' || atom.resn.trim() === 'DG') {
                 //if (atom.name === 'N1')  end = atom; //  N1(AG), N3(CTU)
                 if (atom.name === 'N9')  end = atom; //  N1(AG), N3(CTU)
              //} else if (atom.name === 'N3') {
              } else if (atom.name === 'N1') {
                 end = atom;
              }

              currentResi = atom.resi; currentChain = atom.chain;
           }
           if (start !== null && end !== null)
              ic.cylinderCls.createCylinder(new THREE.Vector3(start.coord.x, start.coord.y, start.coord.z),
                                new THREE.Vector3(end.coord.x, end.coord.y, end.coord.z), ic.cylinderRadius, start.color, bHighlight);
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class TextSprite {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        // modified from 3Dmol (http://3dmol.csb.pitt.edu/)
        // new: http://stackoverflow.com/questions/23514274/three-js-2d-text-sprite-labels
        // old: http://stemkoski.github.io/Three.js/Sprite-Text-Labels.html
        makeTextSprite( message, parameters ) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            if ( parameters === undefined ) parameters = {};
            let fontface = parameters.hasOwnProperty("fontface") ? parameters["fontface"] : "Arial";
            let fontsize = parameters.hasOwnProperty("fontsize") ? parameters["fontsize"] : 18;
            let factor = parameters.hasOwnProperty("factor") ? parameters["factor"] : 1;

            let a = parameters.hasOwnProperty("alpha") ? parameters["alpha"] : 1.0;

            let bBkgd = false; //true;
            let bSchematic = false;
            if(parameters.hasOwnProperty("bSchematic") &&  parameters["bSchematic"]) {
                bSchematic = true;
                bBkgd = true;

                fontsize = 40;
            }

            let backgroundColor, borderColor, borderThickness;
            if(parameters.hasOwnProperty("backgroundColor") &&  parameters["backgroundColor"] !== undefined) {
                backgroundColor = me.utilsCls.hexToRgb(parameters["backgroundColor"], a);

                borderColor = parameters.hasOwnProperty("borderColor") ? me.utilsCls.hexToRgb(parameters["borderColor"], a) : { r:0, g:0, b:0, a:1.0 };
                borderThickness = parameters.hasOwnProperty("borderThickness") ? parameters["borderThickness"] : 4;
            }
            else {
                bBkgd = false;
                backgroundColor = undefined;
                borderColor = undefined;
                borderThickness = 0;
            }

            let textAlpha = 1.0;
            // default yellow
            //let textColor = parameters.hasOwnProperty("textColor") &&  parameters["textColor"] !== undefined ? me.utilsCls.hexToRgb(parameters["textColor"], textAlpha) : { r:255, g:255, b:0, a:1.0 };
            // default black or white
            let defaultColor = (ic.opts.background != 'black') ? { r:0, g:0, b:0, a:1.0 } : { r:255, g:255, b:0, a:1.0 };
            let textColor = parameters.hasOwnProperty("textColor") &&  parameters["textColor"] !== undefined ? me.utilsCls.hexToRgb(parameters["textColor"], textAlpha) 
                : defaultColor;
            if(!textColor) textColor = defaultColor;

            let canvas = document.createElement('canvas');

            let context = canvas.getContext('2d');

            context.font = "Bold " + fontsize + "px " + fontface;

            let metrics = context.measureText( message );

            let textWidth = metrics.width;

            let width = textWidth + 2*borderThickness;
            let height = fontsize + 2*borderThickness;

            if(bSchematic) {
                if(width > height) {
                    height = width;
                }
                else {
                    width = height;
                }
            }

            let expandWidthFactor = 0.8 * textWidth / height;

            canvas.width = width;
            canvas.height = height;

            context.clearRect(0, 0, width, height);

            //var radius = context.measureText( "M" ).width;

            if(bBkgd) {
                // background color
                context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + "," + backgroundColor.b + "," + backgroundColor.a + ")";
                // border color
                context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + "," + borderColor.b + "," + borderColor.a + ")";

                context.lineWidth = borderThickness;

                if(bSchematic) {
                    let r = width * 0.4; //width * 0.35;
                    this.circle(context, 0, 0, width, height, r);
                }
                else {
                    //var r = (message.length <= textLengthThreshold) ? height * 0.5 : 0;
                    //var r = height * 0.8;
                    let r = 0;
                    this.roundRect(context, 0, 0, width, height, r);
                }
            }

            // need to redefine again
            context.font = "Bold " + fontsize + "px " + fontface;

            context.textAlign = "center";
            context.textBaseline = "middle";

            context.fillStyle = "rgba("+textColor.r+", "+textColor.g+", "+textColor.b+", 1.0)";
            context.strokeStyle = "rgba("+textColor.r+", "+textColor.g+", "+textColor.b+", 1.0)";

            context.fillText( message, width * 0.5, height * 0.5);

            // canvas contents will be used for a texture
            let texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;

            let frontOfTarget = true;
            //var spriteMaterial = new THREE.SpriteMaterial( { map: texture, useScreenCoordinates: false } );
            let spriteMaterial = new THREE.SpriteMaterial( {
                map: texture,
                //useScreenCoordinates: false,
                depthTest: !frontOfTarget,
                depthWrite: !frontOfTarget,
                //needsUpdate: true
            } );

            //https://stackoverflow.com/questions/29421702/threejs-texture
            spriteMaterial.map.minFilter = THREE.LinearFilter;

            let sprite = new THREE.Sprite( spriteMaterial );

            if(bSchematic) {
                //sprite.scale.set(factor, factor, 1.0);
                sprite.scale.set(0.3*factor, 0.3*factor, 1.0);
            }
            else {
                sprite.scale.set(expandWidthFactor * factor, factor, 1.0);
            }

            sprite.renderOrder = 1; // larger than the default 0

            return sprite;
        }

        // function for drawing rounded rectangles
        roundRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x+r, y);
            ctx.lineTo(x+w-r, y);
            ctx.quadraticCurveTo(x+w, y, x+w, y+r);
            ctx.lineTo(x+w, y+h-r);
            ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
            ctx.lineTo(x+r, y+h);
            ctx.quadraticCurveTo(x, y+h, x, y+h-r);
            ctx.lineTo(x, y+r);
            ctx.quadraticCurveTo(x, y, x+r, y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }

        circle(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.arc(x+w/2, (y+h/2) * 0.9, r, 0, 2*Math.PI, true); // adjust the y by 0.9
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }
    }

    class Label {
        constructor(icn3d) {
            this.icn3d = icn3d;

            this.textSpriteCls = new TextSprite(icn3d);
        }

        // modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
        //Create labels for a list of "labels", each of which has the properties 'position',
        //'text', 'size', 'color', and 'background'.
        createLabelRepresentation(labels) { let ic = this.icn3d; ic.icn3dui;
            let dimFactor = ic.oriMaxD / 100;
            if(dimFactor < 0.4) dimFactor = 0.4;

            let oriFactor = 3 * dimFactor * ic.labelScale;

            for(let name in labels) {
                let labelArray = (labels[name] !== undefined) ? labels[name] : [];
                let defaultColor = (ic.opts.background != 'black') ? ic.colorWhitebkgd : ic.colorBlackbkgd;

                for (let i = 0, il = labelArray.length; i < il; ++i) {
                    let label = labelArray[i];
                    // make sure fontsize is a number

                    if(label.size == 0) label.size = undefined;
                    if(label.color == 0) label.color = undefined;
                    if(label.background == 0) label.background = undefined;

                    let labelsize = (label.size !== undefined) ? label.size : ic.LABELSIZE;
                    let labelcolor = (label.color !== undefined) ? label.color : defaultColor;
                    if(ic.labelcolor) labelcolor = ic.labelcolor;
                    
                    let labelbackground = (label.background !== undefined) ? label.background : '#cccccc';
                    let labelalpha = (label.alpha !== undefined) ? label.alpha : 1.0;

                    // if label.background is undefined, no background will be drawn
                    labelbackground = label.background;

                    if(labelcolor !== undefined && labelbackground !== undefined && labelcolor.toLowerCase() === labelbackground.toString().toLowerCase()) {
                        labelcolor = "#888888";
                    }

                    let bb;
                    if(label.bSchematic !== undefined && label.bSchematic) {
                        bb = this.textSpriteCls.makeTextSprite(label.text, {fontsize: parseInt(labelsize), textColor: labelcolor, borderColor: labelbackground, backgroundColor: labelbackground, alpha: labelalpha, bSchematic: 1, factor: oriFactor});
                    }
                    else {
                        if(label.text.length === 1) {
                            bb = this.textSpriteCls.makeTextSprite(label.text, {fontsize: parseInt(labelsize), textColor: labelcolor, borderColor: labelbackground, backgroundColor: labelbackground, alpha: labelalpha, bSchematic: 1, factor: oriFactor});
                        }
                        else {
                            let factor = (label.factor) ? oriFactor * label.factor : oriFactor;
                            bb = this.textSpriteCls.makeTextSprite(label.text, {fontsize: parseInt(labelsize), textColor: labelcolor, borderColor: labelbackground, backgroundColor: labelbackground, alpha: labelalpha, bSchematic: 0, factor: factor});
                        }
                    }

                    let labelOffset = (name == 'schematic' || name == 'residue') ? 0 : ic.coilWidth; // 0.3
                    bb.position.set(parseFloat(label.position.x) + labelOffset, parseFloat(label.position.y) + labelOffset, parseFloat(label.position.z) + labelOffset);
                    ic.mdl.add(bb);          
                    // do not add labels to objects for pk
                }
            }
        }

        hideLabels() { let ic = this.icn3d; ic.icn3dui;
            // remove previous labels
            if(ic.mdl !== undefined) {
                for(let i = 0, il = ic.mdl.children.length; i < il; ++i) {
                     let mesh = ic.mdl.children[i];
                     if(mesh !== undefined && mesh.type === 'Sprite') {
                         ic.mdl.remove(mesh); // somehow didn't work
                     }
                }
            }
        }

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Axes {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        // http://soledadpenades.com/articles/three-js-tutorials/drawing-the-coordinate-axes/
        //Build the xyz-axes from the center of atoms. The maximum axes length is equal to "radius" in angstrom.
        buildAxes(radius, center, positionX, positionY, positionZ, bSelection) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            new THREE.Object3D();

            let x = 0, y = 0, z = 0;

            if(bSelection) {
                x = center.x;
                y = center.y;
                z = center.z;
            }
            else {
                x -= radius * 0.3; //0.707; // move to the left
                y -= radius * 0.3; //0.707; // move to the botom
            }
            let origin = new THREE.Vector3( x, y, z );

            let axisLen = radius / 10;
            let r = radius / 100;

            let axisVecX, axisVecY, axisVecZ;
            let axisLenX, axisLenY, axisLenZ;
            axisLenX = axisLenY = axisLenZ = axisLen;
            if(bSelection) {
                axisVecX = positionX.clone().sub(center);
                axisVecY = positionY.clone().sub(center);
                axisVecZ = positionZ.clone().sub(center);

                axisLenX = axisVecX.length();
                axisLenY = axisVecY.length();
                axisLenZ = axisVecZ.length();

                r = axisLenX / 100;

                if(r < 0.4) r = 0.4;
            }

            let meshX, meshY, meshZ;
            if(bSelection) {
                meshX = ic.cylinderCls.createCylinder_base( center, positionX, r, me.parasCls.thr(0xFF0000)); // +X
                meshY = ic.cylinderCls.createCylinder_base( center, positionY, r, me.parasCls.thr(0x00FF00)); // +Y
                meshZ = ic.cylinderCls.createCylinder_base( center, positionZ, r, me.parasCls.thr(0x0000FF)); // +Z
            }
            else {
                meshX = ic.cylinderCls.createCylinder_base( new THREE.Vector3( x, y, z ), new THREE.Vector3( x + axisLenX, y, z ), r, me.parasCls.thr(0xFF0000)); // +X
                meshY = ic.cylinderCls.createCylinder_base( new THREE.Vector3( x, y, z ), new THREE.Vector3( x, y + axisLenY, z ), r, me.parasCls.thr(0x00FF00)); // +Y
                meshZ = ic.cylinderCls.createCylinder_base( new THREE.Vector3( x, y, z ), new THREE.Vector3( x, y, z + axisLenZ ), r, me.parasCls.thr(0x0000FF)); // +Z
            }

            ic.mdl.add( meshX );
            ic.mdl.add( meshY );
            ic.mdl.add( meshZ );

            let dirX = (bSelection) ? axisVecX.normalize() : new THREE.Vector3( 1, 0, 0 );
            let colorX = 0xff0000;
            let posX = (bSelection) ? positionX : new THREE.Vector3(origin.x + axisLen, origin.y, origin.z);
            let arrowX = this.createArrow( dirX, posX, axisLenX, colorX, 4*r, 4*r);
            ic.mdl.add( arrowX );

            let dirY = (bSelection) ? axisVecY.normalize() : new THREE.Vector3( 0, 1, 0 );
            let colorY = 0x00ff00;
            let posY = (bSelection) ? positionY : new THREE.Vector3(origin.x, origin.y + axisLen, origin.z);
            let arrowY = this.createArrow( dirY, posY, axisLenY, colorY, 4*r, 4*r);
            ic.mdl.add( arrowY );

            let dirZ = (bSelection) ? axisVecZ.normalize() : new THREE.Vector3( 0, 0, 1 );
            let colorZ = 0x0000ff;
            let posZ = (bSelection) ? positionZ : new THREE.Vector3(origin.x, origin.y, origin.z + axisLen);
            let arrowZ = this.createArrow( dirZ, posZ, axisLenZ, colorZ, 4*r, 4*r);
            ic.mdl.add( arrowZ );
        }

        buildAllAxes(radius, bSelection) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            if(ic.pc1) {
                for(let i = 0, il = ic.axes.length; i < il; ++i) {
                   let center = ic.axes[i][0];
                   let positionX = ic.axes[i][1];
                   let positionY = ic.axes[i][2];
                   let positionZ = ic.axes[i][3];

                   this.buildAxes(radius, center, positionX, positionY, positionZ, bSelection);
                }
            }
        }

        createArrow(dir, origin, axisLen, color, headLength, headWidth, bGlycan) {  let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            // let coneGeometry = new THREE.CylinderBufferGeometry( 0, 0.5, 1, 32, 1 );
            let coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 32, 1 );
            //coneGeometry.translate( 0, - 0.5, 0 );
            coneGeometry.translate( 0, 0.5, 0 );
            let material;
            if(bGlycan) {
                material = new THREE.MeshPhongMaterial({ transparent: true, opacity: 0.5, specular: ic.frac, shininess: ic.shininess, emissive: ic.emissive, color: color });

            }
            else {
                material = new THREE.MeshPhongMaterial({ specular: ic.frac, shininess: ic.shininess, emissive: ic.emissive, side: THREE.DoubleSide, color: color});
            }

            let cone = new THREE.Mesh( coneGeometry, material);
        //    cone.matrixAutoUpdate = false;

            let quaternion = new THREE.Quaternion();
            // dir is assumed to be normalized
            if ( dir.y > 0.99999 ) {
                quaternion.set( 0, 0, 0, 1 );
            } else if ( dir.y < - 0.99999 ) {
                quaternion.set( 1, 0, 0, 0 );
            } else {
                let axis = new THREE.Vector3();
                axis.set( dir.z, 0, - dir.x ).normalize();
                let radians = Math.acos( dir.y );
                quaternion.setFromAxisAngle( axis, radians );
            }

            cone.applyQuaternion(quaternion);
            cone.scale.set( headWidth, headLength, headWidth );
            //origin.add(new THREE.Vector3(0, axisLen, 0));
            cone.position.copy( origin );

            return cone;
        }

        setPc1Axes(bXAxis) { let ic = this.icn3d, me = ic.icn3dui;
           if(me.bNode) return;

           let atomHash = me.hashUtilsCls.intHash(ic.hAtoms, ic.dAtoms);

           // do PCA, get first eigen vector
           let coordArray = [];
           let prevResid = '';
           let bSmall = (Object.keys(atomHash).length < 100) ? true : false;
           for(let serial in atomHash) {
               let atom = ic.atoms[serial];
               let resid = atom.structure + '_' + atom.chain + '_' + atom.resi;
               if(!bSmall && resid == prevResid) continue; // speed up
               coordArray.push(atom.coord.clone());
           }

           let eigenRet = me.rmsdSuprCls.getEigenForSelection(coordArray, coordArray.length);
           let vecX = new THREE.Vector3(eigenRet.h1[0], eigenRet.h1[1], eigenRet.h1[2]);

           if(eigenRet.k == 0 && ic.bRender) {
               alert("Can't determine the first principal component. Please select a subset and try it again.");
               return;
           }

           let result = ic.applyCenterCls.centerAtoms(atomHash);
           let maxD = result.maxD;
           let center = result.center;

        /*
           let positionXTmp = center.clone().add(vecX.normalize().multiplyScalar(maxD * 0.5));
           let positionXMinusTmp = center.clone().multiplyScalar(2).sub(positionXTmp);

           let linex = new THREE.Line3( positionXMinusTmp, positionXTmp );

           let maxLenY = 0, maxLenX = 0, coordY, coordYInLine;
           prevResid = '';
           for(let serial in atomHash) {
               let atom = ic.atoms[serial];
               let resid = atom.structure + '_' + atom.chain + '_' + atom.resi;
               if(!bSmall && resid == prevResid) continue; // speed up

               let posInLine = new THREE.Vector3();
               linex.closestPointToPoint ( atom.coord, false, posInLine);

               let lenY = posInLine.distanceTo(atom.coord);
               if(lenY > maxLenY) {
                   coordY = atom.coord;
                   coordYInLine = posInLine;

                   maxLenY = lenY;
               }

               let lenX = posInLine.distanceTo(center);
               if(lenX > maxLenX) {
                   maxLenX = lenX;
               }
           }

           let positionX = center.clone().add(vecX.normalize().multiplyScalar(maxLenX));

           // translate
           centerTrans = center.clone().sub(coordYInLine);
           let positionY = coordY.clone().add(centerTrans);

           let vecZ = new THREE.Vector3();
           let vecY = positionY.clone().sub(center);
           vecZ.crossVectors( positionX.clone().sub(center), vecY ).normalize();
           vecZ.multiplyScalar(vecY.length());

           positionZ = center.clone().add(vecZ);

           this.buildAxes(undefined, center, positionX, positionY, positionZ, true);

           let axisPos = [center, positionX, positionY, positionZ];
           ic.axes.push(axisPos);

           ic.drawCls.draw();
        */

           let positionX = center.clone().add(vecX.normalize().multiplyScalar(maxD * 0.4));

           let prinXaxis = vecX.normalize();
           me.htmlCls.clickMenuCls.setLogCmd('Principle X-Axis: ' + prinXaxis.x.toFixed(3) + " " + prinXaxis.y.toFixed(3) + " " + prinXaxis.z.toFixed(3), false);

           if(bXAxis) return prinXaxis;

           let vecY = new THREE.Vector3(eigenRet.h2[0], eigenRet.h2[1], eigenRet.h2[2]);
           let positionY = center.clone().add(vecY.normalize().multiplyScalar(maxD * 0.3));

           let vecZ = new THREE.Vector3(eigenRet.h3[0], eigenRet.h3[1], eigenRet.h3[2]);
           let positionZ = center.clone().add(vecZ.normalize().multiplyScalar(maxD * 0.3));

           this.buildAxes(undefined, center, positionX, positionY, positionZ, true);

           let axisPos = [center, positionX, positionY, positionZ];
           ic.axes.push(axisPos);

           ic.drawCls.draw();

           return axisPos;
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Glycan {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        showGlycans() { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            let glycan2resids = {};
            //var atomHash = me.hashUtilsCls.intHash(ic.hAtoms, ic.dAtoms);
            let atomHash = ic.dAtoms;

            for(let i in atomHash) {
                let atom = ic.atoms[i];
                if(atom.het && me.parasCls.glycanHash.hasOwnProperty(atom.resn) != -1) {
                    if(glycan2resids[atom.resn] === undefined) glycan2resids[atom.resn] = {};
                    if(atom.chain != 'Misc') {
                        glycan2resids[atom.resn][atom.structure + '_' + atom.chain + '_' + atom.resi] = 1;
                    }
                }
            }

            // two types of shape: cube,sphere
            // four types of color: ic.glycanColors
            let glycanNames = Object.keys(glycan2resids);
            for(let i = 0, il = glycanNames.length; i < il; ++i) {
                let glycanName = glycanNames[i];
                if(!me.parasCls.glycanHash.hasOwnProperty(glycanName)) continue;

                let shape = me.parasCls.glycanHash[glycanName].s;
                let color = new THREE.Color('#' + me.parasCls.glycanHash[glycanName].c);

                let resiArray = Object.keys(glycan2resids[glycanName]);
                for(let j = 0, jl = resiArray.length; j < jl; ++j) {
                    let result = ic.applyCenterCls.centerAtoms(ic.residues[resiArray[j]]);
                    let center = result.center;
                    let radius = result.maxD * 0.5 * 0.6;

                    if(shape == 'cube') {
                        ic.boxCls.createBox_base(center, radius, color, false, false, true);
                    }
                    else if(shape == 'sphere') {
                        ic.sphereCls.createSphereBase(center, color, radius, 1, false, true);
                    }
                    else if(shape == 'cone') {
                        let dirZ = new THREE.Vector3( 0, 0, 1 );

                        let arrowZ = ic.axesCls.createArrow( dirZ, new THREE.Vector3(0, 0, -1*radius).add(center), 0, color, 2*radius, 2*radius, true);
                        ic.mdl.add( arrowZ );
                        ic.objects.push(arrowZ);
                    }
                    else if(shape == 'cylinder') {
                        let p0 = new THREE.Vector3(0, 0, radius).add(center);
                        let p1 = new THREE.Vector3(0, 0, -1*radius).add(center);
                        ic.cylinderCls.createCylinder(p0, p1, radius, color, false, color, false, true);
                    }
                }
            }
        }

    }

    /* marchingcube.js
     * @author David Koes  / https://github.com/3dmol/3Dmol.js/tree/master/3Dmol
     * Modified by Jiyao Wang / https://github.com/ncbi/icn3d
     */

    //var $3Dmol = $3Dmol || {};

    class MarchingCube {
        constructor(icn3d) {
            this.icn3d = icn3d;

    //Encapsulate marching cube algorithm for isosurface generation
    //(currently used by protein surface rendering and generic volumetric data reading)
    //$3Dmol.MarchingCubeInitializer = function() { let me = this, ic = me.icn3d; "use strict";

        //Marching cube algorithm - assume data has been pre-treated so isovalue is 0
        //(i.e. select points greater than 0)
        //origin -  vector of origin of volumetric data(default is(0,0,0))
        // nX, nY, nZ - specifies number of voxels in each dimension
        // scale - cube diagonal unit vector scale(3Dmol vector)(specifying distance between data points); diagonal of cube
        // - default is 1 - assumes unit cube(1,1,1) diag)
        // fulltable - if true, use full marching cubes and tritables - else use trimmed table(e.g. surf render)
        // voxel - if true, draws with a blocky voxel style(default false)
        // verts, faces - vertex and face arrays to fill up

            //to match with protein surface...
            this.ISDONE = 2;
            //var my = {};

            /*
             * These tables are based off those by Paul Bourke and Geoffrey Heller:
             * http://paulbourke.net/geometry/polygonise/
             * http://paulbourke.net/geometry/polygonise/table2.txt
             *
             * However, they have been substantially modified to reflect a more
             * sensible corner numbering scheme and the discrete nature of our voxel data
             *(resulting in fewer faces).
             */
            let edgeTableOri = [ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                    0xb00, 0x0, 0x0, 0x0, 0x700, 0x0, 0xd00, 0xe00, 0xf00, 0x0, 0x0, 0x0,
                    0x8a, 0x0, 0x15, 0x0, 0x86, 0x0, 0x0, 0x0, 0x28c, 0x0, 0x813, 0xf19,
                    0xe10, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x0, 0x0, 0x126, 0x0, 0x0, 0x15, 0x1c,
                    0x0, 0xf23, 0x419, 0xd20, 0x0, 0xa8, 0xa2, 0xaa, 0x0, 0x285, 0x9ab,
                    0x8a2, 0x0, 0x2af, 0x125, 0xac, 0xfaa, 0xea3, 0xda9, 0xca0, 0x0, 0x0,
                    0x0, 0x0, 0x0, 0x45, 0x0, 0x384, 0x0, 0x0, 0x0, 0x700, 0x8a, 0x83,
                    0x648, 0x780, 0x0, 0x51, 0x0, 0x81a, 0x54, 0x55, 0x54, 0x56, 0x0, 0x51,
                    0x0, 0xe5c, 0x14a, 0x451, 0x759, 0x650, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x45,
                    0x0, 0x1f6, 0x0, 0x0, 0x15, 0xdfc, 0x8a, 0x7f3, 0x4f9, 0x5f0, 0xb00,
                    0x68, 0x921, 0x6a, 0x348, 0x245, 0x16f, 0x66, 0xb00, 0xe6f, 0xd65,
                    0xc6c, 0x76a, 0x663, 0x569, 0x460, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                    0xf46, 0x0, 0x0, 0x45, 0x24c, 0x2a, 0x823, 0x29, 0xb40, 0x0, 0x0, 0x0,
                    0x6ba, 0x0, 0x8f5, 0xfff, 0xef6, 0x0, 0xff, 0x2f5, 0x2fc, 0x9ea, 0x8f3,
                    0xbf9, 0xaf0, 0x0, 0x0, 0x51, 0x152, 0x0, 0xf55, 0x45f, 0xd56, 0x54,
                    0x357, 0x55, 0x154, 0x852, 0xb53, 0x59, 0x950, 0x700, 0x2c8, 0xc2,
                    0x48a, 0xfc4, 0xec5, 0xdcf, 0xcc6, 0x2c4, 0x2cf, 0xc5, 0xcc, 0xbca,
                    0xac3, 0x9c9, 0x8c0, 0x0, 0x0, 0x0, 0x0, 0xa8, 0x1a4, 0xa8, 0x7a6,
                    0xa2, 0xa2, 0x2a4, 0xbac, 0xaa, 0xa3, 0x2a8, 0x3a0, 0xd00, 0xc18,
                    0xd00, 0xe3a, 0x34, 0x35, 0x73f, 0x636, 0x924, 0x83f, 0xb35, 0xa3c,
                    0x12a, 0x33, 0x339, 0x230, 0xe00, 0xe00, 0xc12, 0xd9a, 0x684, 0x795,
                    0x49f, 0x596, 0x92, 0xb9f, 0x815, 0x99c, 0x9a, 0x393, 0x99, 0x190,
                    0xf00, 0xe08, 0xd01, 0xc0a, 0x704, 0x605, 0x50f, 0x406, 0xb02, 0xa0f,
                    0x905, 0x80c, 0x30a, 0x203, 0x109, 0x0 ];

            this.edgeTable = new Uint32Array(edgeTableOri);

            this.triTable = [ [], [], [], [], [], [], [], [ 11, 9, 8 ], [], [], [],
                    [ 8, 10, 9 ], [], [ 10, 8, 11 ], [ 9, 11, 10 ],
                    [ 8, 10, 9, 8, 11, 10 ], [], [], [], [ 1, 7, 3 ], [], [ 4, 2, 0 ], [],
                    [ 2, 1, 7 ], [], [], [], [ 2, 7, 3, 2, 9, 7 ], [],
                    [ 1, 4, 11, 1, 0, 4 ], [ 3, 8, 0, 11, 9, 4, 11, 10, 9 ],
                    [ 4, 11, 9, 11, 10, 9 ], [], [], [], [ 5, 3, 1 ], [], [], [],
                    [ 2, 5, 8, 2, 1, 5 ], [], [], [ 2, 4, 0 ], [ 3, 2, 4 ], [],
                    [ 0, 9, 1, 8, 10, 5, 8, 11, 10 ], [ 3, 4, 0, 3, 10, 4 ],
                    [ 5, 8, 10, 8, 11, 10 ], [], [ 3, 5, 7 ], [ 7, 1, 5 ],
                    [ 1, 7, 3, 1, 5, 7 ], [], [ 9, 2, 0, 9, 7, 2 ],
                    [ 0, 3, 8, 1, 7, 11, 1, 5, 7 ], [ 11, 1, 7, 1, 5, 7 ], [],
                    [ 9, 1, 0, 5, 3, 2, 5, 7, 3 ], [ 8, 2, 5, 8, 0, 2 ],
                    [ 2, 5, 3, 5, 7, 3 ], [ 3, 9, 1, 3, 8, 9, 7, 11, 10, 7, 10, 5 ],
                    [ 9, 1, 0, 10, 7, 11, 10, 5, 7 ], [ 3, 8, 0, 7, 10, 5, 7, 11, 10 ],
                    [ 11, 5, 7, 11, 10, 5 ], [], [], [], [], [], [ 0, 6, 2 ], [],
                    [ 7, 2, 9, 7, 9, 8 ], [], [], [], [ 8, 10, 9 ], [ 7, 1, 3 ],
                    [ 7, 1, 0 ], [ 6, 9, 3, 6, 10, 9 ], [ 7, 10, 8, 10, 9, 8 ], [],
                    [ 6, 0, 4 ], [], [ 11, 1, 4, 11, 3, 1 ], [ 2, 4, 6 ],
                    [ 2, 0, 4, 2, 4, 6 ], [ 2, 4, 6 ], [ 1, 4, 2, 4, 6, 2 ], [],
                    [ 6, 0, 4 ], [], [ 2, 11, 3, 6, 9, 4, 6, 10, 9 ], [ 8, 6, 1, 8, 1, 3 ],
                    [ 10, 0, 6, 0, 4, 6 ], [ 8, 0, 3, 9, 6, 10, 9, 4, 6 ],
                    [ 10, 4, 6, 10, 9, 4 ], [], [], [], [ 5, 3, 1 ], [], [ 0, 6, 2 ], [],
                    [ 7, 4, 8, 5, 2, 1, 5, 6, 2 ], [], [], [ 2, 4, 0 ],
                    [ 7, 4, 8, 2, 11, 3, 10, 5, 6 ], [ 7, 1, 3 ],
                    [ 5, 6, 10, 0, 9, 1, 8, 7, 4 ], [ 5, 6, 10, 7, 0, 3, 7, 4, 0 ],
                    [ 10, 5, 6, 4, 8, 7 ], [ 9, 11, 8 ], [ 3, 5, 6 ],
                    [ 0, 5, 11, 0, 11, 8 ], [ 6, 3, 5, 3, 1, 5 ], [ 3, 9, 6, 3, 8, 9 ],
                    [ 9, 6, 0, 6, 2, 0 ], [ 0, 3, 8, 2, 5, 6, 2, 1, 5 ],
                    [ 1, 6, 2, 1, 5, 6 ], [ 9, 11, 8 ], [ 1, 0, 9, 6, 10, 5, 11, 3, 2 ],
                    [ 6, 10, 5, 2, 8, 0, 2, 11, 8 ], [ 3, 2, 11, 10, 5, 6 ],
                    [ 10, 5, 6, 9, 3, 8, 9, 1, 3 ], [ 0, 9, 1, 5, 6, 10 ],
                    [ 8, 0, 3, 10, 5, 6 ], [ 10, 5, 6 ], [], [], [], [], [], [], [],
                    [ 1, 10, 2, 9, 11, 6, 9, 8, 11 ], [], [], [ 6, 0, 2 ],
                    [ 3, 6, 9, 3, 2, 6 ], [ 3, 5, 1 ], [ 0, 5, 1, 0, 11, 5 ], [ 0, 3, 5 ],
                    [ 6, 9, 11, 9, 8, 11 ], [], [], [], [ 4, 5, 9, 7, 1, 10, 7, 3, 1 ], [],
                    [ 11, 6, 7, 2, 4, 5, 2, 0, 4 ],
                    [ 11, 6, 7, 8, 0, 3, 1, 10, 2, 9, 4, 5 ],
                    [ 6, 7, 11, 1, 10, 2, 9, 4, 5 ], [],
                    [ 4, 1, 0, 4, 5, 1, 6, 7, 3, 6, 3, 2 ], [ 9, 4, 5, 0, 6, 7, 0, 2, 6 ],
                    [ 4, 5, 9, 6, 3, 2, 6, 7, 3 ], [ 6, 7, 11, 5, 3, 8, 5, 1, 3 ],
                    [ 6, 7, 11, 4, 1, 0, 4, 5, 1 ], [ 4, 5, 9, 3, 8, 0, 11, 6, 7 ],
                    [ 9, 4, 5, 7, 11, 6 ], [], [], [ 0, 6, 4 ], [ 8, 6, 4, 8, 1, 6 ], [],
                    [ 0, 10, 2, 0, 9, 10, 4, 8, 11, 4, 11, 6 ],
                    [ 10, 2, 1, 6, 0, 3, 6, 4, 0 ], [ 10, 2, 1, 11, 4, 8, 11, 6, 4 ],
                    [ 4, 2, 6 ], [ 1, 0, 9, 2, 4, 8, 2, 6, 4 ], [ 2, 4, 0, 2, 6, 4 ],
                    [ 8, 2, 4, 2, 6, 4 ], [ 11, 4, 1, 11, 6, 4 ],
                    [ 0, 9, 1, 4, 11, 6, 4, 8, 11 ], [ 3, 6, 0, 6, 4, 0 ],
                    [ 8, 6, 4, 8, 11, 6 ], [ 10, 8, 9 ], [ 6, 3, 9, 6, 7, 3 ], [ 6, 7, 1 ],
                    [ 10, 7, 1, 7, 3, 1 ], [ 7, 11, 6, 8, 10, 2, 8, 9, 10 ],
                    [ 11, 6, 7, 10, 0, 9, 10, 2, 0 ], [ 2, 1, 10, 7, 11, 6, 8, 0, 3 ],
                    [ 1, 10, 2, 6, 7, 11 ], [ 7, 2, 6, 7, 9, 2 ],
                    [ 1, 0, 9, 3, 6, 7, 3, 2, 6 ], [ 7, 0, 6, 0, 2, 6 ],
                    [ 2, 7, 3, 2, 6, 7 ], [ 7, 11, 6, 3, 9, 1, 3, 8, 9 ],
                    [ 9, 1, 0, 11, 6, 7 ], [ 0, 3, 8, 11, 6, 7 ], [ 11, 6, 7 ], [], [], [],
                    [], [ 5, 3, 7 ], [ 8, 5, 2, 8, 7, 5 ], [ 5, 3, 7 ],
                    [ 1, 10, 2, 5, 8, 7, 5, 9, 8 ], [ 1, 7, 5 ], [ 1, 7, 5 ],
                    [ 9, 2, 7, 9, 7, 5 ], [ 11, 3, 2, 8, 5, 9, 8, 7, 5 ],
                    [ 1, 3, 7, 1, 7, 5 ], [ 0, 7, 1, 7, 5, 1 ], [ 9, 3, 5, 3, 7, 5 ],
                    [ 9, 7, 5, 9, 8, 7 ], [ 8, 10, 11 ], [ 3, 4, 10, 3, 10, 11 ],
                    [ 8, 10, 11 ], [ 5, 9, 4, 1, 11, 3, 1, 10, 11 ], [ 2, 4, 5 ],
                    [ 5, 2, 4, 2, 0, 4 ], [ 0, 3, 8, 5, 9, 4, 10, 2, 1 ],
                    [ 2, 1, 10, 9, 4, 5 ], [ 2, 8, 5, 2, 11, 8 ],
                    [ 3, 2, 11, 1, 4, 5, 1, 0, 4 ], [ 9, 4, 5, 8, 2, 11, 8, 0, 2 ],
                    [ 11, 3, 2, 9, 4, 5 ], [ 8, 5, 3, 5, 1, 3 ], [ 5, 0, 4, 5, 1, 0 ],
                    [ 3, 8, 0, 4, 5, 9 ], [ 9, 4, 5 ], [ 11, 9, 10 ], [ 11, 9, 10 ],
                    [ 1, 11, 4, 1, 10, 11 ], [ 8, 7, 4, 11, 1, 10, 11, 3, 1 ],
                    [ 2, 7, 9, 2, 9, 10 ], [ 4, 8, 7, 0, 10, 2, 0, 9, 10 ],
                    [ 2, 1, 10, 0, 7, 4, 0, 3, 7 ], [ 10, 2, 1, 8, 7, 4 ], [ 1, 7, 4 ],
                    [ 3, 2, 11, 4, 8, 7, 9, 1, 0 ], [ 11, 4, 2, 4, 0, 2 ],
                    [ 2, 11, 3, 7, 4, 8 ], [ 4, 1, 7, 1, 3, 7 ], [ 1, 0, 9, 8, 7, 4 ],
                    [ 3, 4, 0, 3, 7, 4 ], [ 8, 7, 4 ], [ 8, 9, 10, 8, 10, 11 ],
                    [ 3, 9, 11, 9, 10, 11 ], [ 0, 10, 8, 10, 11, 8 ],
                    [ 10, 3, 1, 10, 11, 3 ], [ 2, 8, 10, 8, 9, 10 ], [ 9, 2, 0, 9, 10, 2 ],
                    [ 8, 0, 3, 1, 10, 2 ], [ 10, 2, 1 ], [ 1, 11, 9, 11, 8, 9 ],
                    [ 11, 3, 2, 0, 9, 1 ], [ 11, 0, 2, 11, 8, 0 ], [ 11, 3, 2 ],
                    [ 8, 1, 3, 8, 9, 1 ], [ 9, 1, 0 ], [ 8, 0, 3 ], [] ];

            this.edgeTable2 = [ 0x0, 0x109, 0x203, 0x30a, 0x80c, 0x905, 0xa0f,
                    0xb06, 0x406, 0x50f, 0x605, 0x70c, 0xc0a, 0xd03, 0xe09, 0xf00, 0x190,
                    0x99, 0x393, 0x29a, 0x99c, 0x895, 0xb9f, 0xa96, 0x596, 0x49f, 0x795,
                    0x69c, 0xd9a, 0xc93, 0xf99, 0xe90, 0x230, 0x339, 0x33, 0x13a, 0xa3c,
                    0xb35, 0x83f, 0x936, 0x636, 0x73f, 0x435, 0x53c, 0xe3a, 0xf33, 0xc39,
                    0xd30, 0x3a0, 0x2a9, 0x1a3, 0xaa, 0xbac, 0xaa5, 0x9af, 0x8a6, 0x7a6,
                    0x6af, 0x5a5, 0x4ac, 0xfaa, 0xea3, 0xda9, 0xca0, 0x8c0, 0x9c9, 0xac3,
                    0xbca, 0xcc, 0x1c5, 0x2cf, 0x3c6, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0x4ca,
                    0x5c3, 0x6c9, 0x7c0, 0x950, 0x859, 0xb53, 0xa5a, 0x15c, 0x55, 0x35f,
                    0x256, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x55a, 0x453, 0x759, 0x650, 0xaf0,
                    0xbf9, 0x8f3, 0x9fa, 0x2fc, 0x3f5, 0xff, 0x1f6, 0xef6, 0xfff, 0xcf5,
                    0xdfc, 0x6fa, 0x7f3, 0x4f9, 0x5f0, 0xb60, 0xa69, 0x963, 0x86a, 0x36c,
                    0x265, 0x16f, 0x66, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x76a, 0x663, 0x569,
                    0x460, 0x460, 0x569, 0x663, 0x76a, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x66,
                    0x16f, 0x265, 0x36c, 0x86a, 0x963, 0xa69, 0xb60, 0x5f0, 0x4f9, 0x7f3,
                    0x6fa, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x1f6, 0xff, 0x3f5, 0x2fc, 0x9fa,
                    0x8f3, 0xbf9, 0xaf0, 0x650, 0x759, 0x453, 0x55a, 0xe5c, 0xf55, 0xc5f,
                    0xd56, 0x256, 0x35f, 0x55, 0x15c, 0xa5a, 0xb53, 0x859, 0x950, 0x7c0,
                    0x6c9, 0x5c3, 0x4ca, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0x3c6, 0x2cf, 0x1c5,
                    0xcc, 0xbca, 0xac3, 0x9c9, 0x8c0, 0xca0, 0xda9, 0xea3, 0xfaa, 0x4ac,
                    0x5a5, 0x6af, 0x7a6, 0x8a6, 0x9af, 0xaa5, 0xbac, 0xaa, 0x1a3, 0x2a9,
                    0x3a0, 0xd30, 0xc39, 0xf33, 0xe3a, 0x53c, 0x435, 0x73f, 0x636, 0x936,
                    0x83f, 0xb35, 0xa3c, 0x13a, 0x33, 0x339, 0x230, 0xe90, 0xf99, 0xc93,
                    0xd9a, 0x69c, 0x795, 0x49f, 0x596, 0xa96, 0xb9f, 0x895, 0x99c, 0x29a,
                    0x393, 0x99, 0x190, 0xf00, 0xe09, 0xd03, 0xc0a, 0x70c, 0x605, 0x50f,
                    0x406, 0xb06, 0xa0f, 0x905, 0x80c, 0x30a, 0x203, 0x109, 0x0 ];

            this.triTable2 = [ [], [ 8, 3, 0 ], [ 9, 0, 1 ], [ 8, 3, 1, 8, 1, 9 ],
                    [ 11, 2, 3 ], [ 11, 2, 0, 11, 0, 8 ], [ 11, 2, 3, 0, 1, 9 ],
                    [ 2, 1, 11, 1, 9, 11, 11, 9, 8 ], [ 10, 1, 2 ], [ 8, 3, 0, 1, 2, 10 ],
                    [ 9, 0, 2, 9, 2, 10 ], [ 3, 2, 8, 2, 10, 8, 8, 10, 9 ],
                    [ 10, 1, 3, 10, 3, 11 ], [ 1, 0, 10, 0, 8, 10, 10, 8, 11 ],
                    [ 0, 3, 9, 3, 11, 9, 9, 11, 10 ], [ 8, 10, 9, 8, 11, 10 ], [ 8, 4, 7 ],
                    [ 3, 0, 4, 3, 4, 7 ], [ 1, 9, 0, 8, 4, 7 ],
                    [ 9, 4, 1, 4, 7, 1, 1, 7, 3 ], [ 2, 3, 11, 7, 8, 4 ],
                    [ 7, 11, 4, 11, 2, 4, 4, 2, 0 ], [ 3, 11, 2, 4, 7, 8, 9, 0, 1 ],
                    [ 2, 7, 11, 2, 1, 7, 1, 4, 7, 1, 9, 4 ], [ 10, 1, 2, 8, 4, 7 ],
                    [ 2, 10, 1, 0, 4, 7, 0, 7, 3 ], [ 4, 7, 8, 0, 2, 10, 0, 10, 9 ],
                    [ 2, 7, 3, 2, 9, 7, 7, 9, 4, 2, 10, 9 ],
                    [ 8, 4, 7, 11, 10, 1, 11, 1, 3 ],
                    [ 11, 4, 7, 1, 4, 11, 1, 11, 10, 1, 0, 4 ],
                    [ 3, 8, 0, 7, 11, 4, 11, 9, 4, 11, 10, 9 ],
                    [ 7, 11, 4, 4, 11, 9, 11, 10, 9 ], [ 9, 5, 4 ], [ 3, 0, 8, 4, 9, 5 ],
                    [ 5, 4, 0, 5, 0, 1 ], [ 4, 8, 5, 8, 3, 5, 5, 3, 1 ],
                    [ 11, 2, 3, 9, 5, 4 ], [ 9, 5, 4, 8, 11, 2, 8, 2, 0 ],
                    [ 3, 11, 2, 1, 5, 4, 1, 4, 0 ],
                    [ 8, 5, 4, 2, 5, 8, 2, 8, 11, 2, 1, 5 ], [ 2, 10, 1, 9, 5, 4 ],
                    [ 0, 8, 3, 5, 4, 9, 10, 1, 2 ], [ 10, 5, 2, 5, 4, 2, 2, 4, 0 ],
                    [ 3, 4, 8, 3, 2, 4, 2, 5, 4, 2, 10, 5 ],
                    [ 5, 4, 9, 1, 3, 11, 1, 11, 10 ],
                    [ 0, 9, 1, 4, 8, 5, 8, 10, 5, 8, 11, 10 ],
                    [ 3, 4, 0, 3, 10, 4, 4, 10, 5, 3, 11, 10 ],
                    [ 4, 8, 5, 5, 8, 10, 8, 11, 10 ], [ 9, 5, 7, 9, 7, 8 ],
                    [ 0, 9, 3, 9, 5, 3, 3, 5, 7 ], [ 8, 0, 7, 0, 1, 7, 7, 1, 5 ],
                    [ 1, 7, 3, 1, 5, 7 ], [ 11, 2, 3, 8, 9, 5, 8, 5, 7 ],
                    [ 9, 2, 0, 9, 7, 2, 2, 7, 11, 9, 5, 7 ],
                    [ 0, 3, 8, 2, 1, 11, 1, 7, 11, 1, 5, 7 ],
                    [ 2, 1, 11, 11, 1, 7, 1, 5, 7 ], [ 1, 2, 10, 5, 7, 8, 5, 8, 9 ],
                    [ 9, 1, 0, 10, 5, 2, 5, 3, 2, 5, 7, 3 ],
                    [ 5, 2, 10, 8, 2, 5, 8, 5, 7, 8, 0, 2 ],
                    [ 10, 5, 2, 2, 5, 3, 5, 7, 3 ],
                    [ 3, 9, 1, 3, 8, 9, 7, 11, 10, 7, 10, 5 ],
                    [ 9, 1, 0, 10, 7, 11, 10, 5, 7 ], [ 3, 8, 0, 7, 10, 5, 7, 11, 10 ],
                    [ 11, 5, 7, 11, 10, 5 ], [ 11, 7, 6 ], [ 0, 8, 3, 11, 7, 6 ],
                    [ 9, 0, 1, 11, 7, 6 ], [ 7, 6, 11, 3, 1, 9, 3, 9, 8 ],
                    [ 2, 3, 7, 2, 7, 6 ], [ 8, 7, 0, 7, 6, 0, 0, 6, 2 ],
                    [ 1, 9, 0, 3, 7, 6, 3, 6, 2 ], [ 7, 6, 2, 7, 2, 9, 2, 1, 9, 7, 9, 8 ],
                    [ 1, 2, 10, 6, 11, 7 ], [ 2, 10, 1, 7, 6, 11, 8, 3, 0 ],
                    [ 11, 7, 6, 10, 9, 0, 10, 0, 2 ],
                    [ 7, 6, 11, 3, 2, 8, 8, 2, 10, 8, 10, 9 ],
                    [ 6, 10, 7, 10, 1, 7, 7, 1, 3 ],
                    [ 6, 10, 1, 6, 1, 7, 7, 1, 0, 7, 0, 8 ],
                    [ 9, 0, 3, 6, 9, 3, 6, 10, 9, 6, 3, 7 ],
                    [ 6, 10, 7, 7, 10, 8, 10, 9, 8 ], [ 8, 4, 6, 8, 6, 11 ],
                    [ 11, 3, 6, 3, 0, 6, 6, 0, 4 ], [ 0, 1, 9, 4, 6, 11, 4, 11, 8 ],
                    [ 1, 9, 4, 11, 1, 4, 11, 3, 1, 11, 4, 6 ],
                    [ 3, 8, 2, 8, 4, 2, 2, 4, 6 ], [ 2, 0, 4, 2, 4, 6 ],
                    [ 1, 9, 0, 3, 8, 2, 2, 8, 4, 2, 4, 6 ], [ 9, 4, 1, 1, 4, 2, 4, 6, 2 ],
                    [ 10, 1, 2, 11, 8, 4, 11, 4, 6 ],
                    [ 10, 1, 2, 11, 3, 6, 6, 3, 0, 6, 0, 4 ],
                    [ 0, 2, 10, 0, 10, 9, 4, 11, 8, 4, 6, 11 ],
                    [ 2, 11, 3, 6, 9, 4, 6, 10, 9 ],
                    [ 8, 4, 6, 8, 6, 1, 6, 10, 1, 8, 1, 3 ],
                    [ 1, 0, 10, 10, 0, 6, 0, 4, 6 ], [ 8, 0, 3, 9, 6, 10, 9, 4, 6 ],
                    [ 10, 4, 6, 10, 9, 4 ], [ 9, 5, 4, 7, 6, 11 ],
                    [ 4, 9, 5, 3, 0, 8, 11, 7, 6 ], [ 6, 11, 7, 4, 0, 1, 4, 1, 5 ],
                    [ 6, 11, 7, 4, 8, 5, 5, 8, 3, 5, 3, 1 ], [ 4, 9, 5, 6, 2, 3, 6, 3, 7 ],
                    [ 9, 5, 4, 8, 7, 0, 0, 7, 6, 0, 6, 2 ],
                    [ 4, 0, 1, 4, 1, 5, 6, 3, 7, 6, 2, 3 ], [ 7, 4, 8, 5, 2, 1, 5, 6, 2 ],
                    [ 6, 11, 7, 1, 2, 10, 9, 5, 4 ],
                    [ 11, 7, 6, 8, 3, 0, 1, 2, 10, 9, 5, 4 ],
                    [ 11, 7, 6, 10, 5, 2, 2, 5, 4, 2, 4, 0 ],
                    [ 7, 4, 8, 2, 11, 3, 10, 5, 6 ],
                    [ 4, 9, 5, 6, 10, 7, 7, 10, 1, 7, 1, 3 ],
                    [ 5, 6, 10, 0, 9, 1, 8, 7, 4 ], [ 5, 6, 10, 7, 0, 3, 7, 4, 0 ],
                    [ 10, 5, 6, 4, 8, 7 ], [ 5, 6, 9, 6, 11, 9, 9, 11, 8 ],
                    [ 0, 9, 5, 0, 5, 3, 3, 5, 6, 3, 6, 11 ],
                    [ 0, 1, 5, 0, 5, 11, 5, 6, 11, 0, 11, 8 ],
                    [ 11, 3, 6, 6, 3, 5, 3, 1, 5 ], [ 9, 5, 6, 3, 9, 6, 3, 8, 9, 3, 6, 2 ],
                    [ 5, 6, 9, 9, 6, 0, 6, 2, 0 ], [ 0, 3, 8, 2, 5, 6, 2, 1, 5 ],
                    [ 1, 6, 2, 1, 5, 6 ], [ 1, 2, 10, 5, 6, 9, 9, 6, 11, 9, 11, 8 ],
                    [ 1, 0, 9, 6, 10, 5, 11, 3, 2 ], [ 6, 10, 5, 2, 8, 0, 2, 11, 8 ],
                    [ 3, 2, 11, 10, 5, 6 ], [ 10, 5, 6, 9, 3, 8, 9, 1, 3 ],
                    [ 0, 9, 1, 5, 6, 10 ], [ 8, 0, 3, 10, 5, 6 ], [ 10, 5, 6 ],
                    [ 10, 6, 5 ], [ 8, 3, 0, 10, 6, 5 ], [ 0, 1, 9, 5, 10, 6 ],
                    [ 10, 6, 5, 9, 8, 3, 9, 3, 1 ], [ 3, 11, 2, 10, 6, 5 ],
                    [ 6, 5, 10, 2, 0, 8, 2, 8, 11 ], [ 1, 9, 0, 6, 5, 10, 11, 2, 3 ],
                    [ 1, 10, 2, 5, 9, 6, 9, 11, 6, 9, 8, 11 ], [ 1, 2, 6, 1, 6, 5 ],
                    [ 0, 8, 3, 2, 6, 5, 2, 5, 1 ], [ 5, 9, 6, 9, 0, 6, 6, 0, 2 ],
                    [ 9, 6, 5, 3, 6, 9, 3, 9, 8, 3, 2, 6 ], [ 11, 6, 3, 6, 5, 3, 3, 5, 1 ],
                    [ 0, 5, 1, 0, 11, 5, 5, 11, 6, 0, 8, 11 ],
                    [ 0, 5, 9, 0, 3, 5, 3, 6, 5, 3, 11, 6 ],
                    [ 5, 9, 6, 6, 9, 11, 9, 8, 11 ], [ 10, 6, 5, 4, 7, 8 ],
                    [ 5, 10, 6, 7, 3, 0, 7, 0, 4 ], [ 5, 10, 6, 0, 1, 9, 8, 4, 7 ],
                    [ 4, 5, 9, 6, 7, 10, 7, 1, 10, 7, 3, 1 ],
                    [ 7, 8, 4, 2, 3, 11, 10, 6, 5 ],
                    [ 11, 6, 7, 10, 2, 5, 2, 4, 5, 2, 0, 4 ],
                    [ 11, 6, 7, 8, 0, 3, 1, 10, 2, 9, 4, 5 ],
                    [ 6, 7, 11, 1, 10, 2, 9, 4, 5 ], [ 7, 8, 4, 5, 1, 2, 5, 2, 6 ],
                    [ 4, 1, 0, 4, 5, 1, 6, 7, 3, 6, 3, 2 ],
                    [ 9, 4, 5, 8, 0, 7, 0, 6, 7, 0, 2, 6 ], [ 4, 5, 9, 6, 3, 2, 6, 7, 3 ],
                    [ 6, 7, 11, 4, 5, 8, 5, 3, 8, 5, 1, 3 ],
                    [ 6, 7, 11, 4, 1, 0, 4, 5, 1 ], [ 4, 5, 9, 3, 8, 0, 11, 6, 7 ],
                    [ 9, 4, 5, 7, 11, 6 ], [ 10, 6, 4, 10, 4, 9 ],
                    [ 8, 3, 0, 9, 10, 6, 9, 6, 4 ], [ 1, 10, 0, 10, 6, 0, 0, 6, 4 ],
                    [ 8, 6, 4, 8, 1, 6, 6, 1, 10, 8, 3, 1 ],
                    [ 2, 3, 11, 6, 4, 9, 6, 9, 10 ],
                    [ 0, 10, 2, 0, 9, 10, 4, 8, 11, 4, 11, 6 ],
                    [ 10, 2, 1, 11, 6, 3, 6, 0, 3, 6, 4, 0 ],
                    [ 10, 2, 1, 11, 4, 8, 11, 6, 4 ], [ 9, 1, 4, 1, 2, 4, 4, 2, 6 ],
                    [ 1, 0, 9, 3, 2, 8, 2, 4, 8, 2, 6, 4 ], [ 2, 4, 0, 2, 6, 4 ],
                    [ 3, 2, 8, 8, 2, 4, 2, 6, 4 ],
                    [ 1, 4, 9, 11, 4, 1, 11, 1, 3, 11, 6, 4 ],
                    [ 0, 9, 1, 4, 11, 6, 4, 8, 11 ], [ 11, 6, 3, 3, 6, 0, 6, 4, 0 ],
                    [ 8, 6, 4, 8, 11, 6 ], [ 6, 7, 10, 7, 8, 10, 10, 8, 9 ],
                    [ 9, 3, 0, 6, 3, 9, 6, 9, 10, 6, 7, 3 ],
                    [ 6, 1, 10, 6, 7, 1, 7, 0, 1, 7, 8, 0 ],
                    [ 6, 7, 10, 10, 7, 1, 7, 3, 1 ],
                    [ 7, 11, 6, 3, 8, 2, 8, 10, 2, 8, 9, 10 ],
                    [ 11, 6, 7, 10, 0, 9, 10, 2, 0 ], [ 2, 1, 10, 7, 11, 6, 8, 0, 3 ],
                    [ 1, 10, 2, 6, 7, 11 ], [ 7, 2, 6, 7, 9, 2, 2, 9, 1, 7, 8, 9 ],
                    [ 1, 0, 9, 3, 6, 7, 3, 2, 6 ], [ 8, 0, 7, 7, 0, 6, 0, 2, 6 ],
                    [ 2, 7, 3, 2, 6, 7 ], [ 7, 11, 6, 3, 9, 1, 3, 8, 9 ],
                    [ 9, 1, 0, 11, 6, 7 ], [ 0, 3, 8, 11, 6, 7 ], [ 11, 6, 7 ],
                    [ 11, 7, 5, 11, 5, 10 ], [ 3, 0, 8, 7, 5, 10, 7, 10, 11 ],
                    [ 9, 0, 1, 10, 11, 7, 10, 7, 5 ],
                    [ 3, 1, 9, 3, 9, 8, 7, 10, 11, 7, 5, 10 ],
                    [ 10, 2, 5, 2, 3, 5, 5, 3, 7 ],
                    [ 5, 10, 2, 8, 5, 2, 8, 7, 5, 8, 2, 0 ],
                    [ 9, 0, 1, 10, 2, 5, 5, 2, 3, 5, 3, 7 ],
                    [ 1, 10, 2, 5, 8, 7, 5, 9, 8 ], [ 2, 11, 1, 11, 7, 1, 1, 7, 5 ],
                    [ 0, 8, 3, 2, 11, 1, 1, 11, 7, 1, 7, 5 ],
                    [ 9, 0, 2, 9, 2, 7, 2, 11, 7, 9, 7, 5 ],
                    [ 11, 3, 2, 8, 5, 9, 8, 7, 5 ], [ 1, 3, 7, 1, 7, 5 ],
                    [ 8, 7, 0, 0, 7, 1, 7, 5, 1 ], [ 0, 3, 9, 9, 3, 5, 3, 7, 5 ],
                    [ 9, 7, 5, 9, 8, 7 ], [ 4, 5, 8, 5, 10, 8, 8, 10, 11 ],
                    [ 3, 0, 4, 3, 4, 10, 4, 5, 10, 3, 10, 11 ],
                    [ 0, 1, 9, 4, 5, 8, 8, 5, 10, 8, 10, 11 ],
                    [ 5, 9, 4, 1, 11, 3, 1, 10, 11 ],
                    [ 3, 8, 4, 3, 4, 2, 2, 4, 5, 2, 5, 10 ],
                    [ 10, 2, 5, 5, 2, 4, 2, 0, 4 ], [ 0, 3, 8, 5, 9, 4, 10, 2, 1 ],
                    [ 2, 1, 10, 9, 4, 5 ], [ 8, 4, 5, 2, 8, 5, 2, 11, 8, 2, 5, 1 ],
                    [ 3, 2, 11, 1, 4, 5, 1, 0, 4 ], [ 9, 4, 5, 8, 2, 11, 8, 0, 2 ],
                    [ 11, 3, 2, 9, 4, 5 ], [ 4, 5, 8, 8, 5, 3, 5, 1, 3 ],
                    [ 5, 0, 4, 5, 1, 0 ], [ 3, 8, 0, 4, 5, 9 ], [ 9, 4, 5 ],
                    [ 7, 4, 11, 4, 9, 11, 11, 9, 10 ],
                    [ 3, 0, 8, 7, 4, 11, 11, 4, 9, 11, 9, 10 ],
                    [ 11, 7, 4, 1, 11, 4, 1, 10, 11, 1, 4, 0 ],
                    [ 8, 7, 4, 11, 1, 10, 11, 3, 1 ],
                    [ 2, 3, 7, 2, 7, 9, 7, 4, 9, 2, 9, 10 ],
                    [ 4, 8, 7, 0, 10, 2, 0, 9, 10 ], [ 2, 1, 10, 0, 7, 4, 0, 3, 7 ],
                    [ 10, 2, 1, 8, 7, 4 ], [ 2, 11, 7, 2, 7, 1, 1, 7, 4, 1, 4, 9 ],
                    [ 3, 2, 11, 4, 8, 7, 9, 1, 0 ], [ 7, 4, 11, 11, 4, 2, 4, 0, 2 ],
                    [ 2, 11, 3, 7, 4, 8 ], [ 9, 1, 4, 4, 1, 7, 1, 3, 7 ],
                    [ 1, 0, 9, 8, 7, 4 ], [ 3, 4, 0, 3, 7, 4 ], [ 8, 7, 4 ],
                    [ 8, 9, 10, 8, 10, 11 ], [ 0, 9, 3, 3, 9, 11, 9, 10, 11 ],
                    [ 1, 10, 0, 0, 10, 8, 10, 11, 8 ], [ 10, 3, 1, 10, 11, 3 ],
                    [ 3, 8, 2, 2, 8, 10, 8, 9, 10 ], [ 9, 2, 0, 9, 10, 2 ],
                    [ 8, 0, 3, 1, 10, 2 ], [ 10, 2, 1 ], [ 2, 11, 1, 1, 11, 9, 11, 8, 9 ],
                    [ 11, 3, 2, 0, 9, 1 ], [ 11, 0, 2, 11, 8, 0 ], [ 11, 3, 2 ],
                    [ 8, 1, 3, 8, 9, 1 ], [ 9, 1, 0 ], [ 8, 0, 3 ], [] ];
        }
    }

    MarchingCube.prototype.march = function(data, verts, faces, spec) {

        let fulltable = !!(spec.fulltable);
        let origin =(spec.hasOwnProperty('origin') && spec.origin.hasOwnProperty('x')) ? spec.origin : {x:0, y:0, z:0};
        let voxel = !!(spec.voxel);
        let transform = spec.matrix; //if this is set, it overrides origin and unitCube

        let nX = spec.nX || 0;
        let nY = spec.nY || 0;
        let nZ = spec.nZ || 0;

        let scale = spec.scale || 1.0;
        let unitCube = null;
        if(spec.unitCube) {
            unitCube = spec.unitCube;
        } else {
            unitCube = {x:scale,y:scale,z:scale};
        }

        //keep track of calculated vertices to avoid repeats
        let vertnums = new Int32Array(nX*nY*nZ);

        let i, il;

        for(i = 0, il = vertnums.length; i < il; ++i)
            vertnums[i] = -1;

        // create(or retrieve) a vertex at the appropriate point for
        // the edge(p1,p2)

        let getVertex = function(i, j, k, code, p1, p2) {
            let pt = {x:0,y:0,z:0};
            let val1 = !!(code &(1 << p1));
            let val2 = !!(code &(1 << p2));

            // p1 if they are the same or if !val1
            let p = p1;
            if(!val1 && val2)
                p = p2;

            // adjust i,j,k by p
            if(p & 1)
                k++;
            if(p & 2)
                j++;
            if(p & 4)
                i++;

            if(transform) {
                pt = new THREE.Vector3(i,j,k);
                pt = pt.applyMatrix4(transform);
                pt = {x: pt.x, y: pt.y, z: pt.z}; //remove vector gunk
            } else {
                pt.x = origin.x+unitCube.x*i;
                pt.y = origin.y+unitCube.y*j;
                pt.z = origin.z+unitCube.z*k;
            }

            let index =((nY * i) + j) * nZ + k;

            //Have to add option to do voxels
            if(!voxel) {

                if(vertnums[index] < 0) // not created yet
                {
                    vertnums[index] = verts.length;
                    verts.push( pt );
                }
                return vertnums[index];

            }

            else {
                verts.push(pt);
                return verts.length - 1;
            }

        };

        let intersects = new Int32Array(12);

        let etable =(fulltable) ? this.edgeTable2 : this.edgeTable;
        let tritable =(fulltable) ? this.triTable2 : this.triTable;

        //Run marching cubes algorithm
        for(i = 0; i < nX-1; ++i) {

            for(let j = 0; j < nY-1; ++j){

                for(let k = 0; k < nZ-1; ++k){

                    let code = 0;

                    for(let p = 0; p < 8; ++p) {
                        let index =((nY *(i +((p & 4) >> 2))) + j +((p & 2) >> 1)) *
                                        nZ + k +(p & 1);

                        //TODO: Need to fix vpBits in protein surface for this to work
                        let val = !!(data[index] & this.ISDONE);
                        //var val = !!(data[index] > 0);

                        code |= val << p;
                    }

                    if(code === 0 || code === 255)
                        continue;

                    let ecode = etable[code];

                    if(ecode === 0)
                        continue;

                    let ttable = tritable[code];

                    if(ecode & 1)
                        intersects[0] = getVertex(i, j, k, code, 0, 1);
                    if(ecode & 2)
                        intersects[1] = getVertex(i, j, k, code, 1, 3);
                    if(ecode & 4)
                        intersects[2] = getVertex(i, j, k, code, 3, 2);
                    if(ecode & 8)
                        intersects[3] = getVertex(i, j, k, code, 2, 0);
                    if(ecode & 16)
                        intersects[4] = getVertex(i, j, k, code, 4, 5);
                    if(ecode & 32)
                        intersects[5] = getVertex(i, j, k, code, 5, 7);
                    if(ecode & 64)
                        intersects[6] = getVertex(i, j, k, code, 7, 6);
                    if(ecode & 128)
                        intersects[7] = getVertex(i, j, k, code, 6, 4);
                    if(ecode & 256)
                        intersects[8] = getVertex(i, j, k, code, 0, 4);
                    if(ecode & 512)
                        intersects[9] = getVertex(i, j, k, code, 1, 5);
                    if(ecode & 1024)
                        intersects[10] = getVertex(i, j, k, code, 3, 7);
                    if(ecode & 2048)
                        intersects[11] = getVertex(i, j, k, code, 2, 6);

                    for(let t = 0; t < ttable.length; t += 3) {

                        let a = intersects[ttable[t]],
                            b = intersects[ttable[t+1]],
                            c = intersects[ttable[t+2]];

                        if(voxel && t >= 3) {
                            verts.push(verts[a]); a = verts.length - 1;
                            verts.push(verts[b]); b = verts.length - 1;
                            verts.push(verts[c]); c = verts.length - 1;
                        }


                        faces.push(a); faces.push(b); faces.push(c);
                    }

                }

            }

        }
    };

    MarchingCube.prototype.laplacianSmooth = function(numiter, verts, faces) {
        let tps = new Array(verts.length);
        let i, il, j, jl, k;
        for(i = 0, il = verts.length; i < il; i++)
                tps[i] = {
                    x : 0,
                    y : 0,
                    z : 0
                };
        let vertdeg = new Array(20);
        let flagvert;
        for(i = 0; i < 20; i++)
                vertdeg[i] = new Array(verts.length);
        for(i = 0, il = verts.length; i < il; i++)
                vertdeg[0][i] = 0;
        for(i = 0, il = faces.length / 3; i < il; i++) {
            let aoffset = i*3, boffset = i*3 + 1, coffset = i*3 + 2;
            flagvert = true;
            for(j = 0, jl = vertdeg[0][faces[aoffset]]; j < jl; j++) {
                if(faces[boffset] == vertdeg[j + 1][faces[aoffset]]) {
                    flagvert = false;
                    break;
                }
            }
            if(flagvert) {
                vertdeg[0][faces[aoffset]]++;
                vertdeg[vertdeg[0][faces[aoffset]]][faces[aoffset]] = faces[boffset];
            }
            flagvert = true;
            for(j = 0, jl = vertdeg[0][faces[aoffset]]; j < jl; j++) {
                if(faces[coffset] == vertdeg[j + 1][faces[aoffset]]) {
                    flagvert = false;
                    break;
                }
            }
            if(flagvert) {
                vertdeg[0][faces[aoffset]]++;
                vertdeg[vertdeg[0][faces[aoffset]]][faces[aoffset]] = faces[coffset];
            }
            // b
            flagvert = true;
            for(j = 0, jl = vertdeg[0][faces[boffset]]; j < jl; j++) {
                if(faces[aoffset] == vertdeg[j + 1][faces[boffset]]) {
                    flagvert = false;
                    break;
                }
            }
            if(flagvert) {
                vertdeg[0][faces[boffset]]++;
                vertdeg[vertdeg[0][faces[boffset]]][faces[boffset]] = faces[aoffset];
            }
            flagvert = true;
            for(j = 0, jl = vertdeg[0][faces[boffset]]; j < jl; j++) {
                if(faces[coffset] == vertdeg[j + 1][faces[boffset]]) {
                    flagvert = false;
                    break;
                }
            }
            if(flagvert) {
                vertdeg[0][faces[boffset]]++;
                vertdeg[vertdeg[0][faces[boffset]]][faces[boffset]] = faces[coffset];
            }
            // c
            flagvert = true;
            for(j = 0; j < vertdeg[0][faces[coffset]]; j++) {
                if(faces[aoffset] == vertdeg[j + 1][faces[coffset]]) {
                    flagvert = false;
                    break;
                }
            }
            if(flagvert) {
                vertdeg[0][faces[coffset]]++;
                vertdeg[vertdeg[0][faces[coffset]]][faces[coffset]] = faces[aoffset];
            }
            flagvert = true;
            for(j = 0, jl = vertdeg[0][faces[coffset]]; j < jl; j++) {
                if(faces[boffset] == vertdeg[j + 1][faces[coffset]]) {
                    flagvert = false;
                    break;
                }
            }
            if(flagvert) {
                vertdeg[0][faces[coffset]]++;
                vertdeg[vertdeg[0][faces[coffset]]][faces[coffset]] = faces[boffset];
            }
        }

        let wt = 1.00;
        let wt2 = 0.50;
        for(k = 0; k < numiter; k++) {
                for(i = 0, il = verts.length; i < il; i++) {
                        if(vertdeg[0][i] < 3) {
                                tps[i].x = verts[i].x;
                                tps[i].y = verts[i].y;
                                tps[i].z = verts[i].z;
                        } else if(vertdeg[0][i] == 3 || vertdeg[0][i] == 4) {
                                tps[i].x = 0;
                                tps[i].y = 0;
                                tps[i].z = 0;
                                for(j = 0, jl = vertdeg[0][i]; j < jl; j++) {
                                        tps[i].x += verts[vertdeg[j + 1][i]].x;
                                        tps[i].y += verts[vertdeg[j + 1][i]].y;
                                        tps[i].z += verts[vertdeg[j + 1][i]].z;
                                }
                                tps[i].x += wt2 * verts[i].x;
                                tps[i].y += wt2 * verts[i].y;
                                tps[i].z += wt2 * verts[i].z;
                                tps[i].x /= wt2 + vertdeg[0][i];
                                tps[i].y /= wt2 + vertdeg[0][i];
                                tps[i].z /= wt2 + vertdeg[0][i];
                        } else {
                                tps[i].x = 0;
                                tps[i].y = 0;
                                tps[i].z = 0;
                                for(j = 0, jl = vertdeg[0][i]; j < jl; j++) {
                                        tps[i].x += verts[vertdeg[j + 1][i]].x;
                                        tps[i].y += verts[vertdeg[j + 1][i]].y;
                                        tps[i].z += verts[vertdeg[j + 1][i]].z;
                                }
                                tps[i].x += wt * verts[i].x;
                                tps[i].y += wt * verts[i].y;
                                tps[i].z += wt * verts[i].z;
                                tps[i].x /= wt + vertdeg[0][i];
                                tps[i].y /= wt + vertdeg[0][i];
                                tps[i].z /= wt + vertdeg[0][i];
                        }
                }
                for(i = 0, il = verts.length; i < il; i++) {
                        verts[i].x = tps[i].x;
                        verts[i].y = tps[i].y;
                        verts[i].z = tps[i].z;
                }
                /*
                 * computenorm(); for(let i = 0; i < vertnumber; i++) { if
                 *(verts[i].inout) ssign = 1; else ssign = -1; verts[i].x += ssign *
                 * outwt * verts[i].pn.x; verts[i].y += ssign * outwt *
                 * verts[i].pn.y; verts[i].z += ssign * outwt * verts[i].pn.z; }
                 */
        }
    };

    /* ProteinSurface4.js
     * @author David Koes  / https://github.com/3dmol/3Dmol.js/tree/master/3Dmol
     * Modified by Jiyao Wang / https://github.com/ncbi/icn3d
     */

    // dkoes
    // Surface calculations.  This must be safe to use within a web worker.
    class ProteinSurface {
        constructor(icn3d, threshbox) {
            this.icn3d = icn3d;
            this.threshbox = threshbox;

        //$3Dmol.ProteinSurface = function(threshbox) {
            //"use strict";

            // for delphi
            this.dataArray = {};
            this.header;
            this.data = undefined;
            this.matrix = undefined;
            this.isovalue = undefined;
            this.loadPhiFrom = undefined;
            this.vpColor = null; // intarray
            this.vpPot = null; // floatarray

            // constants for vpbits bitmasks
            /** @this.*/
            this.INOUT = 1;
            /** @this.*/
            this.ISDONE = 2;
            /** @this.*/
            this.ISBOUND = 4;

            this.ptranx = 0;
            this.ptrany = 0;
            this.ptranz = 0;
            this.probeRadius = 1.4;
            this.defaultScaleFactor = 2;
            this.scaleFactor = this.defaultScaleFactor; // 2 is .5A grid; if this is made user configurable,
                                    // also have to adjust offset used to find non-shown
                                    // atoms
            this.finalScaleFactor = {};

            this.pHeight = 0;
            this.pWidth = 0;
            this.pLength = 0;
            this.cutRadius = 0;
            this.vpBits = null; // uint8 array of bitmasks
            this.vpDistance = null; // floatarray of _squared_ distances
            this.vpAtomID = null; // intarray
            this.vertnumber = 0;
            this.facenumber = 0;
            this.pminx = 0;
            this.pminy = 0;
            this.pminz = 0;
            this.pmaxx = 0;
            this.pmaxy = 0;
            this.pmaxz = 0;

            this.bCalcArea = false;
            this.atomsToShow = {};

            this.vdwRadii = {
                    "H" : 1.2,
                    "LI" : 1.82,
                    "Na" : 2.27,
                    "K" : 2.75,
                    "C" : 1.7,
                    "N" : 1.55,
                    "O" : 1.52,
                    "F" : 1.47,
                    "P" : 1.80,
                    "S" : 1.80,
                    "CL" : 1.75,
                    "BR" : 1.85,
                    "SE" : 1.90,
                    "ZN" : 1.39,
                    "CU" : 1.4,
                    "NI" : 1.63,
                    "X" : 2
                };

            this.depty = {};
            this.widxz = {};
            this.faces = undefined;
            this.verts = undefined;
            this.nb = [ new Int32Array([ 1, 0, 0 ]), new Int32Array([ -1, 0, 0 ]),
                       new Int32Array([ 0, 1, 0 ]), new Int32Array([ 0, -1, 0 ]),
                       new Int32Array([ 0, 0, 1 ]),
                       new Int32Array([ 0, 0, -1 ]),
                       new Int32Array([ 1, 1, 0 ]),
                       new Int32Array([ 1, -1, 0 ]),
                       new Int32Array([ -1, 1, 0 ]),
                       new Int32Array([ -1, -1, 0 ]),
                       new Int32Array([ 1, 0, 1 ]),
                       new Int32Array([ 1, 0, -1 ]),
                       new Int32Array([ -1, 0, 1 ]),
                       new Int32Array([ -1, 0, -1 ]),
                       new Int32Array([ 0, 1, 1 ]),
                       new Int32Array([ 0, 1, -1 ]),
                       new Int32Array([ 0, -1, 1 ]),
                       new Int32Array([ 0, -1, -1 ]),
                       new Int32Array([ 1, 1, 1 ]),
                       new Int32Array([ 1, 1, -1 ]),
                       new Int32Array([ 1, -1, 1 ]),
                       new Int32Array([ -1, 1, 1 ]),
                       new Int32Array([ 1, -1, -1 ]),
                       new Int32Array([ -1, -1, 1 ]),
                       new Int32Array([ -1, 1, -1 ]),
                       new Int32Array([ -1, -1, -1 ]) ];

            this.origextent = undefined;

            this.marchingCube = new MarchingCube();
        }
    }

    /** @param {AtomSpec} atom */
    ProteinSurface.prototype.getVDWIndex = function(atom) {
        if(!atom.elem || typeof(this.vdwRadii[atom.elem.toUpperCase()]) == "undefined") {
            return "X";
        }
        return atom.elem;
    };

    ProteinSurface.prototype.inOrigExtent = function(x, y, z) {
        if(x < this.origextent[0][0] || x > this.origextent[1][0])
            return false;
        if(y < this.origextent[0][1] || y > this.origextent[1][1])
            return false;
        if(z < this.origextent[0][2] || z > this.origextent[1][2])
            return false;
        return true;
    };

    ProteinSurface.prototype.getFacesAndVertices = function() {
        let i, il;
        let vertices = this.verts;
        for(i = 0, il = vertices.length; i < il; i++) {
            vertices[i].x = vertices[i].x / this.scaleFactor - this.ptranx;
            vertices[i].y = vertices[i].y / this.scaleFactor - this.ptrany;
            vertices[i].z = vertices[i].z / this.scaleFactor - this.ptranz;
        }

        let finalfaces = [];
        for(i = 0, il = this.faces.length; i < il; i += 3) {
            //var f = faces[i];
            let fa = this.faces[i], fb = this.faces[i+1], fc = this.faces[i+2];
            let a = vertices[fa]['atomid'], b = vertices[fb]['atomid'], c = vertices[fc]['atomid'];

            // must be a unique face for each atom
            if(!this.atomsToShow[a] || !this.atomsToShow[b] || !this.atomsToShow[c]) {
                continue;
            }

            if(fa !== fb && fb !== fc && fa !== fc){
                // !!! different between 3Dmol and iCn3D
                finalfaces.push({"a":fa, "b":fb, "c":fc});
            }

        }

        //try to help the garbage collector
        this.vpBits = null; // uint8 array of bitmasks
        this.vpDistance = null; // floatarray
        this.vpAtomID = null; // intarray

        this.vpColor = null; // intarray
        this.vpPot = null; // floatarray

        return {
            'vertices' : vertices,
            'faces' : finalfaces
        };
    };


    ProteinSurface.prototype.initparm = function(extent, btype, in_bCalcArea, atomlist
      , inHeader, inData, inMatrix, inIsovalue, inLoadPhiFrom) {
        // for delphi
        this.header = inHeader;
        this.dataArray = inData;
        this.matrix = inMatrix;
        this.isovalue = inIsovalue;
        this.loadPhiFrom = inLoadPhiFrom;

        this.bCalcArea = in_bCalcArea;

        for(let i = 0, il = atomlist.length; i < il; i++)
            this.atomsToShow[atomlist[i]] = 1;

        // !!! different between 3Dmol and iCn3D
        //if(volume > 1000000) //heuristical decrease resolution to avoid large memory consumption
        //    this.scaleFactor = this.defaultScaleFactor/2;

        let margin =(1 / this.scaleFactor) * 5.5; // need margin to avoid
                                                // boundary/round off effects
        this.origextent = extent;
        this.pminx = extent[0][0]; this.pmaxx = extent[1][0];
        this.pminy = extent[0][1]; this.pmaxy = extent[1][1];
        this.pminz = extent[0][2]; this.pmaxz = extent[1][2];

        if(!btype) {
            this.pminx -= margin;
            this.pminy -= margin;
            this.pminz -= margin;
            this.pmaxx += margin;
            this.pmaxy += margin;
            this.pmaxz += margin;
        } else {
            this.pminx -= this.probeRadius + margin;
            this.pminy -= this.probeRadius + margin;
            this.pminz -= this.probeRadius + margin;
            this.pmaxx += this.probeRadius + margin;
            this.pmaxy += this.probeRadius + margin;
            this.pmaxz += this.probeRadius + margin;
        }

        this.pminx = Math.floor(this.pminx * this.scaleFactor) / this.scaleFactor;
        this.pminy = Math.floor(this.pminy * this.scaleFactor) / this.scaleFactor;
        this.pminz = Math.floor(this.pminz * this.scaleFactor) / this.scaleFactor;
        this.pmaxx = Math.ceil(this.pmaxx * this.scaleFactor) / this.scaleFactor;
        this.pmaxy = Math.ceil(this.pmaxy * this.scaleFactor) / this.scaleFactor;
        this.pmaxz = Math.ceil(this.pmaxz * this.scaleFactor) / this.scaleFactor;

        this.ptranx = -this.pminx;
        this.ptrany = -this.pminy;
        this.ptranz = -this.pminz;

        // !!! different between 3Dmol and iCn3D
        // copied from surface.js from iview
        let boxLength = 129;
        //maxLen = this.pmaxx - this.pminx + 2*(this.probeRadius + 5.5/2)
        let maxLen = this.pmaxx - this.pminx;
        if((this.pmaxy - this.pminy) > maxLen) maxLen = this.pmaxy - this.pminy;
        if((this.pmaxz - this.pminz) > maxLen) maxLen = this.pmaxz - this.pminz;
        this.scaleFactor =(boxLength - 1.0) / maxLen;

        // 1. typically(size < 90) use the default scale factor 2
        this.scaleFactor = this.defaultScaleFactor;

        // 2. If size > 90, change scale
        //var threshbox = 180; // maximum possible boxsize
        //if(this.bCalcArea || this.defaultScaleFactor * maxLen > this.threshbox) {
        if(this.defaultScaleFactor * maxLen > this.threshbox) {
            boxLength = Math.floor(this.threshbox);
            this.scaleFactor =(this.threshbox - 1.0) / maxLen;
        }

        // 3. use a fixed scaleFactor for surface area calculation
        if(this.bCalcArea) {
            this.scaleFactor = this.defaultScaleFactor;
        }
        // end of surface.js part

        this.pLength = Math.ceil(this.scaleFactor *(this.pmaxx - this.pminx)) + 1;
        this.pWidth = Math.ceil(this.scaleFactor *(this.pmaxy - this.pminy)) + 1;
        this.pHeight = Math.ceil(this.scaleFactor *(this.pmaxz - this.pminz)) + 1;

        // this.finalScaleFactor.x =(this.pLength - 1.0) /(this.pmaxx - this.pminx);
        // this.finalScaleFactor.y =(this.pWidth - 1.0) /(this.pmaxy - this.pminy);
        // this.finalScaleFactor.z =(this.pHeight - 1.0) /(this.pmaxz - this.pminz);

        this.boundingatom(btype);
        this.cutRadius = this.probeRadius * this.scaleFactor;

        this.vpBits = new Uint8Array(this.pLength * this.pWidth * this.pHeight);
        this.vpDistance = new Float64Array(this.pLength * this.pWidth * this.pHeight); // float 32
        this.vpAtomID = new Int32Array(this.pLength * this.pWidth * this.pHeight);

        this.vpColor = [];
        this.vpPot = [];
    };

    ProteinSurface.prototype.boundingatom = function(btype) {
        let tradius = [];
        let txz, tdept, sradius, indx;
        //flagradius = btype;

        for(let i in this.vdwRadii) {
            if(!this.vdwRadii.hasOwnProperty(i))
                continue;
            let r = this.vdwRadii[i];
            if(!btype)
                tradius[i] = r * this.scaleFactor + 0.5;
            else
                tradius[i] =(r + this.probeRadius) * this.scaleFactor + 0.5;

            sradius = tradius[i] * tradius[i];
            this.widxz[i] = Math.floor(tradius[i]) + 1;
            this.depty[i] = new Int32Array(this.widxz[i] * this.widxz[i]);
            indx = 0;
            for(let j = 0; j < this.widxz[i]; j++) {
                for(let k = 0; k < this.widxz[i]; k++) {
                    txz = j * j + k * k;
                    if(txz > sradius)
                        this.depty[i][indx] = -1; // outside
                    else {
                        tdept = Math.sqrt(sradius - txz);
                        this.depty[i][indx] = Math.floor(tdept);
                    }
                    indx++;
                }
            }
        }
    };

    ProteinSurface.prototype.fillvoxels = function(atoms, atomlist) { //(int seqinit,int
        // seqterm,bool
        // atomtype,atom*
        // proseq,bool bcolor)
        let i, j, k, il;
        for(i = 0, il = this.vpBits.length; i < il; i++) {
            this.vpBits[i] = 0;
            this.vpDistance[i] = -1.0;
            this.vpAtomID[i] = -1;

            this.vpColor[i] = new THREE.Color();
            this.vpPot[i] = 0;
        }

        for(i in atomlist) {
            let atom = atoms[atomlist[i]];
            if(atom === undefined || atom.resn === 'DUM')
                continue;
            this.fillAtom(atom, atoms);
        }

        // show delphi potential on surface
        if(this.dataArray) {
            let pminx2 = 0, pmaxx2 = this.header.xExtent - 1;
            let pminy2 = 0, pmaxy2 = this.header.yExtent - 1;
            let pminz2 = 0, pmaxz2 = this.header.zExtent - 1;

            let scaleFactor2 = 1; // angstrom / grid

            let pLength2 = Math.floor(0.5 + scaleFactor2 *(pmaxx2 - pminx2)) + 1;
            let pWidth2 = Math.floor(0.5 + scaleFactor2 *(pmaxy2 - pminy2)) + 1;
            let pHeight2 = Math.floor(0.5 + scaleFactor2 *(pmaxz2 - pminz2)) + 1;

            // fill the color
            let widthHeight2 = pWidth2 * pHeight2;
            let height2 = pHeight2;

            // generate the correctly ordered this.dataArray
            let vData = new Float32Array(pLength2 * pWidth2 * pHeight2);

            // loop through the delphi box
            for(i = 0; i < pLength2; ++i) {
                for(j = 0; j < pWidth2; ++j) {
                    for(k = 0; k < pHeight2; ++k) {
                        let index = i * widthHeight2 + j * height2 + k;

                        let index2;
                        if(this.header.filetype == 'phi') { // loop z, y, x
                            index2 = k * widthHeight2 + j * height2 + i;
                        }
                        else if(this.header.filetype == 'cube') { // loop x, y, z
                            index2 = i * widthHeight2 + j * height2 + k;
                        }

                        if(index2 < this.dataArray.length) {
                            vData[index] = this.dataArray[index2];
                        }
                    }
                }
            }

            let widthHeight = this.pWidth * this.pHeight;
            let height = this.pHeight;

            // loop through the surface box
            for(i = 0; i < this.pLength; ++i) {
                for(j = 0; j < this.pWidth; ++j) {
                    for(k = 0; k < this.pHeight; ++k) {
                        // let x = i / this.finalScaleFactor.x - this.ptranx;
                        // let y = j / this.finalScaleFactor.y - this.ptrany;
                        // let z = k / this.finalScaleFactor.z - this.ptranz;

                        let x = i / this.scaleFactor - this.ptranx;
                        let y = j / this.scaleFactor - this.ptrany;
                        let z = k / this.scaleFactor - this.ptranz;

                        let r = new THREE.Vector3(x, y, z);

                        // scale to the grid
                        r.sub(this.header.ori).multiplyScalar(this.header.scale);

                        // determine the neighboring grid coordinate
                        let nx0 = Math.floor(r.x), nx1 = Math.ceil(r.x);
                        let ny0 = Math.floor(r.y), ny1 = Math.ceil(r.y);
                        let nz0 = Math.floor(r.z), nz1 = Math.ceil(r.z);
                        if(nx1 == nx0) nx1 = nx0 + 1;
                        if(ny1 == ny0) ny1 = ny0 + 1;
                        if(nz1 == nz0) nz1 = nz0 + 1;

                        if(nx1 > pLength2) nx1 = pLength2;
                        if(ny1 > pWidth2) ny1 = pWidth2;
                        if(nz1 > pHeight2) nz1 = pHeight2;

                        //https://en.wikipedia.org/wiki/Trilinear_interpolation
                        let c000 = vData[nx0 * widthHeight2 + ny0 * height2 + nz0];
                        let c100 = vData[nx1 * widthHeight2 + ny0 * height2 + nz0];
                        let c010 = vData[nx0 * widthHeight2 + ny1 * height2 + nz0];
                        let c001 = vData[nx0 * widthHeight2 + ny0 * height2 + nz1];
                        let c110 = vData[nx1 * widthHeight2 + ny1 * height2 + nz0];
                        let c011 = vData[nx0 * widthHeight2 + ny1 * height2 + nz1];
                        let c101 = vData[nx1 * widthHeight2 + ny0 * height2 + nz1];
                        let c111 = vData[nx1 * widthHeight2 + ny1 * height2 + nz1];

                        let xd = r.x - nx0;
                        let yd = r.y - ny0;
                        let zd = r.z - nz0;

                        let c00 = c000 *(1 - xd) + c100 * xd;
                        let c01 = c001 *(1 - xd) + c101 * xd;
                        let c10 = c010 *(1 - xd) + c110 * xd;
                        let c11 = c011 *(1 - xd) + c111 * xd;

                        let c0 = c00 *(1 - yd) + c10 * yd;
                        let c1 = c01 *(1 - yd) + c11 * yd;

                        let c = c0 *(1 - zd) + c1 * zd;

                        let index = i * widthHeight + j * height + k;

                        this.vpPot[index] = c;

                        // determine the color based on the potential value
                        if(c > this.isovalue) c = this.isovalue;
                        if(c < -this.isovalue) c = -this.isovalue;

                        let color;
                        if(c > 0) {
                            c /= 1.0 * this.isovalue;
                            color = new THREE.Color(1-c, 1-c, 1);
                        }
                        else {
                            c /= -1.0 * this.isovalue;
                            color = new THREE.Color(1, 1-c, 1-c);
                        }

                        this.vpColor[index] = color;
                    } // for k
                } // for j
            } // for i
        }

        for(i = 0, il = this.vpBits.length; i < il; i++)
            if(this.vpBits[i] & this.INOUT)
                this.vpBits[i] |= this.ISDONE;

    };


    ProteinSurface.prototype.fillAtom = function(atom, atoms) {
        let cx, cy, cz, ox, oy, oz, mi, mj, mk, i, j, k, si, sj, sk;
        let ii, jj, kk, n;

        // !!! different between 3Dmol and iCn3D
        cx = Math.floor(0.5 + this.scaleFactor *(atom.coord.x + this.ptranx));
        cy = Math.floor(0.5 + this.scaleFactor *(atom.coord.y + this.ptrany));
        cz = Math.floor(0.5 + this.scaleFactor *(atom.coord.z + this.ptranz));

        let at = this.getVDWIndex(atom);
        let nind = 0;
        let pWH = this.pWidth*this.pHeight;

        for(i = 0, n = this.widxz[at]; i < n; i++) {
            for(j = 0; j < n; j++) {
                if(this.depty[at][nind] != -1) {
                    for(ii = -1; ii < 2; ii++) {
        for(jj = -1; jj < 2; jj++) {
            for(kk = -1; kk < 2; kk++) {
                if(ii !== 0 && jj !== 0 && kk !== 0) {
                    mi = ii * i;
                    mk = kk * j;
                    for(k = 0; k <= this.depty[at][nind]; k++) {
                        mj = k * jj;
                        si = cx + mi;
                        sj = cy + mj;
                        sk = cz + mk;
                        if(si < 0 || sj < 0 ||
                                sk < 0 ||
                                si >= this.pLength ||
                                sj >= this.pWidth ||
                                sk >= this.pHeight)
                            continue;
                        let index = si * pWH + sj * this.pHeight + sk;

                        if(!(this.vpBits[index] & this.INOUT)) {
                            this.vpBits[index] |= this.INOUT;
                            this.vpAtomID[index] = atom.serial;
                        } else {
                            let atom2 = atoms[this.vpAtomID[index]];
                            if(atom2.serial != atom.serial) {
                                ox = cx + mi - Math.floor(0.5 + this.scaleFactor *
                                       (atom2.x + this.ptranx));
                                oy = cy + mj - Math.floor(0.5 + this.scaleFactor *
                                       (atom2.y + this.ptrany));
                                oz = cz + mk - Math.floor(0.5 + this.scaleFactor *
                                       (atom2.z + this.ptranz));
                                if(mi * mi + mj * mj + mk * mk < ox *
                                        ox + oy * oy + oz * oz)
                                    this.vpAtomID[index] = atom.serial;
                            }
                        }

                    }// k
                }// if
            }// kk
        }// jj
                    }// ii
                }// if
                nind++;
            }// j
        }// i
    };

    ProteinSurface.prototype.fillvoxelswaals = function(atoms, atomlist) {
        let i, il;
        for(i = 0, il = this.vpBits.length; i < il; i++)
            this.vpBits[i] &= ~this.ISDONE; // not isdone

        for(i in atomlist) {
            let atom = atoms[atomlist[i]];
            if(atom === undefined)
                continue;

            this.fillAtomWaals(atom, atoms);
        }
    };

    ProteinSurface.prototype.fillAtomWaals = function(atom, atoms) {
        let cx, cy, cz, ox, oy, oz, nind = 0;
        let mi, mj, mk, si, sj, sk, i, j, k, ii, jj, kk, n;

        // !!! different between 3Dmol and iCn3D
        cx = Math.floor(0.5 + this.scaleFactor *(atom.coord.x + this.ptranx));
        cy = Math.floor(0.5 + this.scaleFactor *(atom.coord.y + this.ptrany));
        cz = Math.floor(0.5 + this.scaleFactor *(atom.coord.z + this.ptranz));

        let at = this.getVDWIndex(atom);
        let pWH = this.pWidth*this.pHeight;
        for(i = 0, n = this.widxz[at]; i < n; i++) {
            for(j = 0; j < n; j++) {
                if(this.depty[at][nind] != -1) {
                    for(ii = -1; ii < 2; ii++) {
        for(jj = -1; jj < 2; jj++) {
            for(kk = -1; kk < 2; kk++) {
                if(ii !== 0 && jj !== 0 && kk !== 0) {
                    mi = ii * i;
                    mk = kk * j;
                    for(k = 0; k <= this.depty[at][nind]; k++) {
                        mj = k * jj;
                        si = cx + mi;
                        sj = cy + mj;
                        sk = cz + mk;
                        if(si < 0 || sj < 0 ||
                                sk < 0 ||
                                si >= this.pLength ||
                                sj >= this.pWidth ||
                                sk >= this.pHeight)
                            continue;
                        let index = si * pWH + sj * this.pHeight + sk;
                        if(!(this.vpBits[index] & this.ISDONE)) {
                            this.vpBits[index] |= this.ISDONE;
                            this.vpAtomID[index] = atom.serial;
                        }  else {
                            let atom2 = atoms[this.vpAtomID[index]];
                            if(atom2.serial != atom.serial) {
                                ox = cx + mi - Math.floor(0.5 + this.scaleFactor *
                                       (atom2.x + this.ptranx));
                                oy = cy + mj - Math.floor(0.5 + this.scaleFactor *
                                       (atom2.y + this.ptrany));
                                oz = cz + mk - Math.floor(0.5 + this.scaleFactor *
                                       (atom2.z + this.ptranz));
                                if(mi * mi + mj * mj + mk * mk < ox *
                                        ox + oy * oy + oz * oz)
                                    this.vpAtomID[index] = atom.serial;
                            }
                        }
                    }// k
                }// if
            }// kk
        }// jj
                    }// ii
                }// if
                nind++;
            }// j
        }// i
    };

    ProteinSurface.prototype.buildboundary = function() {
        let pWH = this.pWidth*this.pHeight;
        for(let i = 0; i < this.pLength; i++) {
            for(let j = 0; j < this.pHeight; j++) {
                for(let k = 0; k < this.pWidth; k++) {
                    let index = i * pWH + k * this.pHeight + j;
                    if(this.vpBits[index] & this.INOUT) {
                        let ii = 0;
                        while(ii < 26) {
                            let ti = i + this.nb[ii][0], tj = j + this.nb[ii][2], tk = k +
                                    this.nb[ii][1];
                            if(ti > -1 &&
                                ti < this.pLength &&
                                tk > -1 &&
                                tk < this.pWidth &&
                                tj > -1 &&
                                tj < this.pHeight &&
                                !(this.vpBits[ti * pWH + tk * this.pHeight + tj] & this.INOUT)) {
                                this.vpBits[index] |= this.ISBOUND;
                                break;
                            } else
                                ii++;
                        }
                    }
                }
            }
        }
    };

    ProteinSurface.prototype.fastdistancemap = function() {
        let i, j, k, n;

        // a little class for 3d array, should really generalize this and
        // use throughout...
        let PointGrid = function(length, width, height) {
            // the standard says this is zero initialized
            let data = new Int32Array(length * width * height * 3);

            // set position x,y,z to pt, which has ix,iy,and iz
            this.set = function(x, y, z, pt) {
                let index =((((x * width) + y) * height) + z) * 3;
                data[index] = pt.ix;
                data[index + 1] = pt.iy;
                data[index + 2] = pt.iz;
            };

            // return point at x,y,z
            this.get = function(x, y, z) {
                let index =((((x * width) + y) * height) + z) * 3;
                return {
                    ix : data[index],
                    iy : data[index + 1],
                    iz : data[index + 2]
                };
            };
        };

        let boundPoint = new PointGrid(this.pLength, this.pWidth, this.pHeight);
        let pWH = this.pWidth*this.pHeight;
        let cutRSq = this.cutRadius*this.cutRadius;

        let inarray = [];
        let outarray = [];

        let index;

        for(i = 0; i < this.pLength; i++) {
            for(j = 0; j < this.pWidth; j++) {
                for(k = 0; k < this.pHeight; k++) {
                    index = i * pWH + j * this.pHeight + k;
                    this.vpBits[index] &= ~this.ISDONE; // isdone = false
                    if(this.vpBits[index] & this.INOUT) {
                        if(this.vpBits[index] & this.ISBOUND) {
                            let triple = {
                                ix : i,
                                iy : j,
                                iz : k
                            };
                            boundPoint.set(i, j, k, triple);
                            inarray.push(triple);
                            this.vpDistance[index] = 0;
                            this.vpBits[index] |= this.ISDONE;
                            this.vpBits[index] &= ~this.ISBOUND;
                        }
                    }
                }
            }
        }

        do {
            outarray = this.fastoneshell(inarray, boundPoint);
            inarray = [];
            for(i = 0, n = outarray.length; i < n; i++) {
                index = pWH * outarray[i].ix + this.pHeight *
                    outarray[i].iy + outarray[i].iz;
                this.vpBits[index] &= ~this.ISBOUND;
                if(this.vpDistance[index] <= 1.0404 * cutRSq) {
                    inarray.push({
                        ix : outarray[i].ix,
                        iy : outarray[i].iy,
                        iz : outarray[i].iz
                    });
                }
            }
        } while(inarray.length !== 0);

        inarray = [];
        outarray = [];
        boundPoint = null;

        let cutsf = this.scaleFactor - 0.5;
        if(cutsf < 0)
            cutsf = 0;
        let cutoff = cutRSq - 0.50 /(0.1 + cutsf);
        for(i = 0; i < this.pLength; i++) {
            for(j = 0; j < this.pWidth; j++) {
                for(k = 0; k < this.pHeight; k++) {
                    index = i * pWH + j * this.pHeight + k;
                    this.vpBits[index] &= ~this.ISBOUND;
                    // ses solid
                    if(this.vpBits[index] & this.INOUT) {
                        if(!(this.vpBits[index] & this.ISDONE) ||
                               ((this.vpBits[index] & this.ISDONE) && this.vpDistance[index] >= cutoff)) {
                            this.vpBits[index] |= this.ISBOUND;
                        }
                    }
                }
            }
        }

    };

    ProteinSurface.prototype.fastoneshell = function(inarray, boundPoint) { //(int* innum,int
        // *allocout,voxel2
        // ***boundPoint, int*
        // outnum, int *elimi)
        let tx, ty, tz;
        let dx, dy, dz;
        let i, j, n;
        let square;
        let bp, index;
        let outarray = [];
        if(inarray.length === 0)
            return outarray;

        let tnv = {
            ix : -1,
            iy : -1,
            iz : -1
        };
        let pWH = this.pWidth*this.pHeight;
        for( i = 0, n = inarray.length; i < n; i++) {
            tx = inarray[i].ix;
            ty = inarray[i].iy;
            tz = inarray[i].iz;
            bp = boundPoint.get(tx, ty, tz);

            for(j = 0; j < 6; j++) {
                tnv.ix = tx + this.nb[j][0];
                tnv.iy = ty + this.nb[j][1];
                tnv.iz = tz + this.nb[j][2];

                if(tnv.ix < this.pLength && tnv.ix > -1 && tnv.iy < this.pWidth &&
                        tnv.iy > -1 && tnv.iz < this.pHeight && tnv.iz > -1) {
                    index = tnv.ix * pWH + this.pHeight * tnv.iy + tnv.iz;

                    if((this.vpBits[index] & this.INOUT) && !(this.vpBits[index] & this.ISDONE)) {

                        boundPoint.set(tnv.ix, tnv.iy, tz + this.nb[j][2], bp);
                        dx = tnv.ix - bp.ix;
                        dy = tnv.iy - bp.iy;
                        dz = tnv.iz - bp.iz;
                        square = dx * dx + dy * dy + dz * dz;
                        this.vpDistance[index] = square;
                        this.vpBits[index] |= this.ISDONE;
                        this.vpBits[index] |= this.ISBOUND;

                        outarray.push({
                            ix : tnv.ix,
                            iy : tnv.iy,
                            iz : tnv.iz
                        });
                    } else if((this.vpBits[index] & this.INOUT) &&(this.vpBits[index] & this.ISDONE)) {

                        dx = tnv.ix - bp.ix;
                        dy = tnv.iy - bp.iy;
                        dz = tnv.iz - bp.iz;
                        square = dx * dx + dy * dy + dz * dz;
                        if(square < this.vpDistance[index]) {
                            boundPoint.set(tnv.ix, tnv.iy, tnv.iz, bp);

                            this.vpDistance[index] = square;
                            if(!(this.vpBits[index] & this.ISBOUND)) {
                                this.vpBits[index] |= this.ISBOUND;
                                outarray.push({
                                    ix : tnv.ix,
                                    iy : tnv.iy,
                                    iz : tnv.iz
                                });
                            }
                        }
                    }
                }
            }
        }

        for(i = 0, n = inarray.length; i < n; i++) {
            tx = inarray[i].ix;
            ty = inarray[i].iy;
            tz = inarray[i].iz;
            bp = boundPoint.get(tx, ty, tz);

            for(j = 6; j < 18; j++) {
                tnv.ix = tx + this.nb[j][0];
                tnv.iy = ty + this.nb[j][1];
                tnv.iz = tz + this.nb[j][2];

                if(tnv.ix < this.pLength && tnv.ix > -1 && tnv.iy < this.pWidth &&
                        tnv.iy > -1 && tnv.iz < this.pHeight && tnv.iz > -1) {
                    index = tnv.ix * pWH + this.pHeight * tnv.iy + tnv.iz;

                    if((this.vpBits[index] & this.INOUT) && !(this.vpBits[index] & this.ISDONE)) {
                        boundPoint.set(tnv.ix, tnv.iy, tz + this.nb[j][2], bp);

                        dx = tnv.ix - bp.ix;
                        dy = tnv.iy - bp.iy;
                        dz = tnv.iz - bp.iz;
                        square = dx * dx + dy * dy + dz * dz;
                        this.vpDistance[index] = square;
                        this.vpBits[index] |= this.ISDONE;
                        this.vpBits[index] |= this.ISBOUND;

                        outarray.push({
                            ix : tnv.ix,
                            iy : tnv.iy,
                            iz : tnv.iz
                        });
                    } else if((this.vpBits[index] & this.INOUT) &&(this.vpBits[index] & this.ISDONE)) {
                        dx = tnv.ix - bp.ix;
                        dy = tnv.iy - bp.iy;
                        dz = tnv.iz - bp.iz;
                        square = dx * dx + dy * dy + dz * dz;
                        if(square < this.vpDistance[index]) {
                            boundPoint.set(tnv.ix, tnv.iy, tnv.iz, bp);
                            this.vpDistance[index] = square;
                            if(!(this.vpBits[index] & this.ISBOUND)) {
                                this.vpBits[index] |= this.ISBOUND;
                                outarray.push({
                                    ix : tnv.ix,
                                    iy : tnv.iy,
                                    iz : tnv.iz
                                });
                            }
                        }
                    }
                }
            }
        }

        for(i = 0, n = inarray.length; i < n; i++) {
            tx = inarray[i].ix;
            ty = inarray[i].iy;
            tz = inarray[i].iz;
            bp = boundPoint.get(tx, ty, tz);

            for(j = 18; j < 26; j++) {
                tnv.ix = tx + this.nb[j][0];
                tnv.iy = ty + this.nb[j][1];
                tnv.iz = tz + this.nb[j][2];

                if(tnv.ix < this.pLength && tnv.ix > -1 && tnv.iy < this.pWidth &&
                        tnv.iy > -1 && tnv.iz < this.pHeight && tnv.iz > -1) {
                    index = tnv.ix * pWH + this.pHeight * tnv.iy + tnv.iz;

                    if((this.vpBits[index] & this.INOUT) && !(this.vpBits[index] & this.ISDONE)) {
                        boundPoint.set(tnv.ix, tnv.iy, tz + this.nb[j][2], bp);

                        dx = tnv.ix - bp.ix;
                        dy = tnv.iy - bp.iy;
                        dz = tnv.iz - bp.iz;
                        square = dx * dx + dy * dy + dz * dz;
                        this.vpDistance[index] = square;
                        this.vpBits[index] |= this.ISDONE;
                        this.vpBits[index] |= this.ISBOUND;

                        outarray.push({
                            ix : tnv.ix,
                            iy : tnv.iy,
                            iz : tnv.iz
                        });
                    } else if((this.vpBits[index] & this.INOUT)  &&(this.vpBits[index] & this.ISDONE)) {
                        dx = tnv.ix - bp.ix;
                        dy = tnv.iy - bp.iy;
                        dz = tnv.iz - bp.iz;
                        square = dx * dx + dy * dy + dz * dz;
                        if(square < this.vpDistance[index]) {
                            boundPoint.set(tnv.ix, tnv.iy, tnv.iz, bp);

                            this.vpDistance[index] = square;
                            if(!(this.vpBits[index] & this.ISBOUND)) {
                                this.vpBits[index] |= this.ISBOUND;
                                outarray.push({
                                    ix : tnv.ix,
                                    iy : tnv.iy,
                                    iz : tnv.iz
                                });
                            }
                        }
                    }
                }
            }
        }

        return outarray;
    };

    ProteinSurface.prototype.marchingcubeinit = function(stype) {
        for( let i = 0, lim = this.vpBits.length; i < lim; i++) {
            if(stype == 1) {// vdw
                this.vpBits[i] &= ~this.ISBOUND;
            } else if(stype == 4) { // ses
                this.vpBits[i] &= ~this.ISDONE;
                if(this.vpBits[i] & this.ISBOUND)
                    this.vpBits[i] |= this.ISDONE;
                this.vpBits[i] &= ~this.ISBOUND;
            } else if(stype == 2) {// after vdw
                if((this.vpBits[i] & this.ISBOUND) &&(this.vpBits[i] & this.ISDONE))
                    this.vpBits[i] &= ~this.ISBOUND;
                else if((this.vpBits[i] & this.ISBOUND) && !(this.vpBits[i] & this.ISDONE))
                    this.vpBits[i] |= this.ISDONE;
            } else if(stype == 3) { // sas
                this.vpBits[i] &= ~this.ISBOUND;
            }
        }
    };

    // this code allows me to empirically prune the marching cubes code tables
    // to more efficiently handle discrete data
    ProteinSurface.prototype.counter = function() {
        let data = Array(256);
        for( let i = 0; i < 256; i++)
            data[i] = [];

        this.incrementUsed = function(i, j) {
            if(typeof data[i][j] === 'undefined')
                data[i][j] = {
                    used : 0,
                    unused : 0
                };
            data[i][j].used++;
        };

        this.incrementUnused = function(i, j) {
            if(typeof data[i][j] === 'undefined')
                data[i][j] = {
                    used : 0,
                    unused : 0
                };
            data[i][j].unused++;

        };

        let redoTable = function(triTable) {
            let str = "[";
            for( let i = 0; i < triTable.length; i++) {
                let code = 0;
                let table = triTable[i];
                for( let j = 0; j < table.length; j++) {
                    code |=(1 <<(table[j]));
                }
                str += "0x" + code.toString(16) + ", ";
            }
            str += "]";
        };

        this.print = function() {

            let table = this.marchingCube.triTable;
            let newtable = [];
            for( let i = 0; i < table.length; i++) {
                let newarr = [];
                for( let j = 0; j < table[i].length; j += 3) {
                    let k = j / 3;
                    if(typeof data[i][k] === 'undefined' || !data[i][k].unused) {
                        newarr.push(table[i][j]);
                        newarr.push(table[i][j + 1]);
                        newarr.push(table[i][j + 2]);
                    }
                    if(typeof data[i][k] === 'undefined')
                        console.log("undef " + i + "," + k);
                }
                newtable.push(newarr);
            }
            redoTable(newtable);
        };
    };

    ProteinSurface.prototype.marchingcube = function(stype) {
        this.marchingcubeinit(stype);
        this.verts = []; this.faces = [];
        this.marchingCube.march(this.vpBits, this.verts, this.faces, {
            smooth : 1,
            nX : this.pLength,
            nY : this.pWidth,
            nZ : this.pHeight
        });

        let pWH = this.pWidth*this.pHeight;
        for(let i = 0, vlen = this.verts.length; i < vlen; i++) {
            this.verts[i]['atomid'] = this.vpAtomID[this.verts[i].x * pWH + this.pHeight *
                    this.verts[i].y + this.verts[i].z];
            if(this.dataArray) this.verts[i]['color'] = this.vpColor[this.verts[i].x * pWH + this.pHeight *
                    this.verts[i].y + this.verts[i].z];
            if(this.dataArray) this.verts[i]['pot'] = this.vpPot[this.verts[i].x * pWH + this.pHeight *
                    this.verts[i].y + this.verts[i].z];
        }

        // calculate surface area
        let serial2area, area = 0;
        if(this.bCalcArea) {
            let faceHash = {};
            serial2area = {};
            for(let i = 0, il = this.faces.length; i < il; i += 3) {
                let fa = this.faces[i], fb = this.faces[i+1], fc = this.faces[i+2];

                if(fa == fb || fb == fc || fa == fc) continue;

                let fmin = Math.min(fa, fb, fc);
                let fmax = Math.max(fa, fb, fc);
                let fmid = fa + fb + fc - fmin - fmax;
                let fmin_fmid_fmax = fmin + '_' + fmid + '_' + fmax;

                if(faceHash.hasOwnProperty(fmin_fmid_fmax)) {
                    continue;
                }

                faceHash[fmin_fmid_fmax] = 1;

                let ai = this.verts[fa]['atomid'], bi = this.verts[fb]['atomid'], ci = this.verts[fc]['atomid'];

                if(!this.atomsToShow[ai] || !this.atomsToShow[bi] || !this.atomsToShow[ci]) {
                    continue;
                }

                //if(fa !== fb && fb !== fc && fa !== fc){
                    let a = this.verts[fa];
                    let b = this.verts[fb];
                    let c = this.verts[fc];

                    let ab2 =(a.x - b.x) *(a.x - b.x) +(a.y - b.y) *(a.y - b.y) +(a.z - b.z) *(a.z - b.z);
                    let ac2 =(a.x - c.x) *(a.x - c.x) +(a.y - c.y) *(a.y - c.y) +(a.z - c.z) *(a.z - c.z);
                    let cb2 =(c.x - b.x) *(c.x - b.x) +(c.y - b.y) *(c.y - b.y) +(c.z - b.z) *(c.z - b.z);

                    let min = Math.min(ab2, ac2, cb2);
                    let max = Math.max(ab2, ac2, cb2);
                    let mid = ab2 + ac2 + cb2 - min - max;

                    // there are only three kinds of triangles as shown at
                    // https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0008140
                    // case 1: 1, 1, sqrt(2)     area: 0.5 * a * a;
                    // case 2: sqrt(2), sqrt(2), sqrt(2)    area: 0.5 * a * a * sqrt(3) * 0.5;
                    // case 3: 1, sqrt(2), sqrt(3)      area: 0.5 * a * b
                    let currArea = 0;
                    if(parseInt((max - min)*100) == 0) { // case 2
                        currArea = 0.433 * min;
                    }
                    else if(parseInt((mid - min)*100) == 0) { // case 1
                        currArea = 0.5 * min;
                    }
                    else { // case 3
                        currArea = 0.707 * min;
                    }

                    let partArea = currArea / 3;

                    if(serial2area[ai] === undefined) serial2area[ai] = partArea;
                    else serial2area[ai] += partArea;

                    if(serial2area[bi] === undefined) serial2area[bi] = partArea;
                    else serial2area[bi] += partArea;

                    if(serial2area[ci] === undefined) serial2area[ci] = partArea;
                    else serial2area[ci] += partArea;

                    area += currArea;
                //}
            } // for loop

            //maxScaleFactor = Math.max(this.finalScaleFactor.x, this.finalScaleFactor.y, this.finalScaleFactor.z);
            //area = area / maxScaleFactor / maxScaleFactor;
            area = area / this.scaleFactor / this.scaleFactor;
        }

        if(!this.bCalcArea) this.marchingCube.laplacianSmooth(1, this.verts, this.faces);

        //return {"area": area, "serial2area": serial2area, "scaleFactor": maxScaleFactor};
        return {"area": area, "serial2area": serial2area, "scaleFactor": this.scaleFactor};
    };

    /* ProteinSurface4.js
     * @author David Koes  / https://github.com/3dmol/3Dmol.js/tree/master/3Dmol
     * Modified by Jiyao Wang / https://github.com/ncbi/icn3d
     */

    // dkoes
    // Surface calculations.  This must be safe to use within a web worker.
    class ElectronMap {
        constructor(icn3d) {
            this.icn3d = icn3d;

    //$3Dmol.ElectronMap = function(threshbox) {
        //"use strict";

            // constants for vpbits bitmasks
            /** @this.*/
            this.INOUT = 1;
            /** @this.*/
            this.ISDONE = 2;
            /** @this.*/
            this.ISBOUND = 4;

            this.isovalue = 1.5;
            this.dataArray = {};
            this.matrix = undefined;
            this.center = undefined;
            this.maxdist = undefined;
            this.pmin = undefined;
            this.pmax = undefined;
            this.water = undefined;
            this.header = undefined;
            this.type = undefined;
            this.rmsd_supr = undefined;
            this.loadPhiFrom = undefined;

            this.ptranx = 0;
            this.ptrany = 0;
            this.ptranz = 0;
            this.probeRadius = 1.4;
            this.defaultScaleFactor = 2;
            this.scaleFactor = this.defaultScaleFactor; // 2 is .5A grid; if this is made user configurable,
                                    // also have to adjust offset used to find non-shown
                                    // atoms
            this.pHeight = 0;
            this.pWidth = 0;
            this.pLength = 0;
            this.cutRadius = 0;
            this.vpBits = null; // uint8 array of bitmasks
            this.vpGridTrans = null; // array of translated number of grids
            this.vpAtomID = null; // uint8 array
            this.vertnumber = 0;
            this.facenumber = 0;
            this.pminx = 0;
            this.pminy = 0;
            this.pminz = 0;
            this.pmaxx = 0;
            this.pmaxy = 0;
            this.pmaxz = 0;

            this.depty = {};
            this.widxz = {};
            this.faces = undefined;
            this.verts = undefined;
            this.nb = [ new Int32Array([ 1, 0, 0 ]), new Int32Array([ -1, 0, 0 ]),
                       new Int32Array([ 0, 1, 0 ]), new Int32Array([ 0, -1, 0 ]),
                       new Int32Array([ 0, 0, 1 ]),
                       new Int32Array([ 0, 0, -1 ]),
                       new Int32Array([ 1, 1, 0 ]),
                       new Int32Array([ 1, -1, 0 ]),
                       new Int32Array([ -1, 1, 0 ]),
                       new Int32Array([ -1, -1, 0 ]),
                       new Int32Array([ 1, 0, 1 ]),
                       new Int32Array([ 1, 0, -1 ]),
                       new Int32Array([ -1, 0, 1 ]),
                       new Int32Array([ -1, 0, -1 ]),
                       new Int32Array([ 0, 1, 1 ]),
                       new Int32Array([ 0, 1, -1 ]),
                       new Int32Array([ 0, -1, 1 ]),
                       new Int32Array([ 0, -1, -1 ]),
                       new Int32Array([ 1, 1, 1 ]),
                       new Int32Array([ 1, 1, -1 ]),
                       new Int32Array([ 1, -1, 1 ]),
                       new Int32Array([ -1, 1, 1 ]),
                       new Int32Array([ 1, -1, -1 ]),
                       new Int32Array([ -1, -1, 1 ]),
                       new Int32Array([ -1, 1, -1 ]),
                       new Int32Array([ -1, -1, -1 ]) ];

            this.marchingCube = new MarchingCube();
        }
    }

    ElectronMap.prototype.getFacesAndVertices = function(allatoms, atomlist) {
        let atomsToShow = {};
        let i, il;
        for(i = 0, il = atomlist.length; i < il; i++)
            atomsToShow[atomlist[i]] = 1;
        let vertices = this.verts;

        let vertTrans = {};
        for(i = 0, il = vertices.length; i < il; i++) {
            let r;
            if(this.type == 'phi') {
                r = new THREE.Vector3(vertices[i].x, vertices[i].y, vertices[i].z).multiplyScalar(1.0/this.header.scale).applyMatrix4(this.matrix);
            }
            else {
                // ccp4 has no translation vector. Only translated vertices are used.
                if(this.ccp4) {
                    let index = vertices[i].index;
                    let finalIndex;
                    if(this.vpGridTrans[index]) {
                        finalIndex = index;

                        vertices[i].x += this.vpGridTrans[finalIndex][0] * this.header.xExtent * this.scaleFactor;
                        vertices[i].y += this.vpGridTrans[finalIndex][1] * this.header.xExtent * this.scaleFactor;
                        vertices[i].z += this.vpGridTrans[finalIndex][2] * this.header.xExtent * this.scaleFactor;

                        vertTrans[finalIndex] = 1;
                    }
                }
                r = new THREE.Vector3(vertices[i].x, vertices[i].y, vertices[i].z).applyMatrix4(this.matrix);
            }
    //            vertices[i].x = r.x / this.scaleFactor - this.ptranx;
    //            vertices[i].y = r.y / this.scaleFactor - this.ptrany;
    //            vertices[i].z = r.z / this.scaleFactor - this.ptranz;

            vertices[i].x = r.x;
            vertices[i].y = r.y;
            vertices[i].z = r.z;
        }

        let finalfaces = [];

        for(i = 0, il = this.faces.length; i < il; i += 3) {
            //var f = this.faces[i];
            let fa = this.faces[i], fb = this.faces[i+1], fc = this.faces[i+2];

            if(fa !== fb && fb !== fc && fa !== fc){
                if(this.ccp4) {
                    // only transferred vertices will be used
                    if(vertTrans.hasOwnProperty(vertices[fa].index) && vertTrans.hasOwnProperty(vertices[fb].index) 
                      && vertTrans.hasOwnProperty(vertices[fc].index)) {
                        finalfaces.push({"a":fa, "b":fb, "c":fc});
                    }
                }
                else {
                    finalfaces.push({"a":fa, "b":fb, "c":fc});
                }
            }
        }

        //try to help the garbage collector
        this.vpBits = null; // uint8 array of bitmasks
        this.vpGridTrans = null; // uint8 array
        this.vpAtomID = null; // intarray

        return {
            'vertices' : vertices, //shownVertices,
            'faces' : finalfaces
        };
    };


    ElectronMap.prototype.initparm = function(inHeader, inData, inMatrix, inIsovalue, inCenter, inMaxdist,
      inPmin, inPmax, inWater, inType, inRmsd_supr, inLoadPhiFrom, inIcn3d) {
        this.header = inHeader;
        this.loadPhiFrom = inLoadPhiFrom;
        //icn3d = inIcn3d;

        if(this.header && this.header.max !== undefined) { // EM density map from EBI
            this.isovalue = this.header.min +(this.header.max - this.header.min) * inIsovalue / 100.0;
        }
        else if(this.header && this.header.mean !== undefined) { // density map from EBI
            this.isovalue = this.header.mean + this.header.sigma * inIsovalue; // electron density map from EBI
        }
        else {
            this.isovalue = inIsovalue;
        }

        this.dataArray = inData;
        this.matrix = inMatrix;
        this.center = inCenter;
        this.maxdist = inMaxdist;
        this.pmin = inPmin;
        this.pmax = inPmax;
        this.water = inWater;
        this.type = inType;

        this.rmsd_supr = inRmsd_supr;

        this.pminx = 0; this.pmaxx = this.header.xExtent - 1;
        this.pminy = 0; this.pmaxy = this.header.yExtent - 1;
        this.pminz = 0; this.pmaxz = this.header.zExtent - 1;

        this.ptranx = -this.pminx;
        this.ptrany = -this.pminy;
        this.ptranz = -this.pminz;

        let maxLen = this.pmaxx - this.pminx;
        if((this.pmaxy - this.pminy) > maxLen) maxLen = this.pmaxy - this.pminy;
        if((this.pmaxz - this.pminz) > maxLen) maxLen = this.pmaxz - this.pminz;

        this.scaleFactor = 1; // angstrom / grid

        this.pLength = Math.floor(0.5 + this.scaleFactor *(this.pmaxx - this.pminx)) + 1;
        this.pWidth = Math.floor(0.5 + this.scaleFactor *(this.pmaxy - this.pminy)) + 1;
        this.pHeight = Math.floor(0.5 + this.scaleFactor *(this.pmaxz - this.pminz)) + 1;

        //this.boundingatom();
        this.cutRadius = this.probeRadius * this.scaleFactor;

        this.vpBits = new Uint8Array(this.pLength * this.pWidth * this.pHeight);
        if(this.ccp4) this.vpGridTrans = new Array(this.pLength * this.pWidth * this.pHeight);

        this.vpAtomID = new Uint8Array(this.pLength * this.pWidth * this.pHeight);
    };

    ElectronMap.prototype.transformMemPro = function(inCoord, rot, centerFrom, centerTo) {
        let coord = inCoord.clone();
        coord.sub(centerFrom);

        let x = coord.x*rot[0] + coord.y*rot[1] + coord.z*rot[2] + centerTo.x;
        let y = coord.x*rot[3] + coord.y*rot[4] + coord.z*rot[5] + centerTo.y;
        let z = coord.x*rot[6] + coord.y*rot[7] + coord.z*rot[8] + centerTo.z;

        coord.x = x;
        coord.y = y;
        coord.z = z;

        return coord;
    };

    ElectronMap.prototype.fillvoxels = function(atoms, atomlist) { //(int seqinit,int
        // seqterm,bool
        // atomthis.type,atom*
        // proseq,bool bcolor)
        let i, j, k, il, jl, kl;
        for(i = 0, il = this.vpBits.length; i < il; i++) {
            this.vpBits[i] = 0;
            this.vpAtomID[i] = 0;
        }

        let widthHeight = this.pWidth * this.pHeight;
        let height = this.pHeight;

        if(this.type == 'phi' && !this.header.bSurface) { // equipotential map
            // Do NOT exclude map far away from the atoms
            //var index = 0;
            for(i = 0; i < this.pLength; ++i) {
                for(j = 0; j < this.pWidth; ++j) {
                    for(k = 0; k < this.pHeight; ++k) {
                        let index = i * widthHeight + j * height + k;

                        let index2;
                        if(this.header.filetype == 'phi') { // loop z, y, x
                            index2 = k * widthHeight + j * height + i;
                        }
                        else if(this.header.filetype == 'cube') { // loop x, y, z
                            index2 = i * widthHeight + j * height + k;
                        }

                        if(index2 < this.dataArray.length) {
                            this.vpBits[index] =(this.dataArray[index2] >= this.isovalue || this.dataArray[index2] <= -this.isovalue) ? 1 : 0;
                            this.vpAtomID[index] =(this.dataArray[index2] >= 0) ? 1 : 0; // determine whether it's positive
                        }
                        //++index;
                    }
                }
            }
        }
        else {
            //var inverseMatrix = new THREE.Matrix4().getInverse(this.matrix);
            let inverseMatrix = new THREE.Matrix4().copy( this.matrix ).invert();

            let indexArray = [];
            this.maxdist = parseInt(this.maxdist); // has to be integer

            let rot, inverseRot = new Array(9), centerFrom, centerTo;
            if(this.rmsd_supr !== undefined && this.rmsd_supr.rot !== undefined) {
              rot = this.rmsd_supr.rot;
              centerFrom = this.rmsd_supr.trans1;
              centerTo = this.rmsd_supr.trans2;

              let m = new THREE.Matrix3(), inverseM = new THREE.Matrix3();
              m.set(rot[0], rot[1], rot[2], rot[3], rot[4], rot[5], rot[6], rot[7], rot[8]);
              //inverseM.getInverse(m);
              inverseM.copy(m).invert();

              inverseRot[0] = inverseM.elements[0];
              inverseRot[1] = inverseM.elements[3];
              inverseRot[2] = inverseM.elements[6];
              inverseRot[3] = inverseM.elements[1];
              inverseRot[4] = inverseM.elements[4];
              inverseRot[5] = inverseM.elements[7];
              inverseRot[6] = inverseM.elements[2];
              inverseRot[7] = inverseM.elements[5];
              inverseRot[8] = inverseM.elements[8];
            }

            if(this.type == 'phi' && this.header.bSurface) { // surface with potential
                // Do NOT exclude map far away from the atoms

                // generate the correctly ordered this.dataArray
                let vData = new Float32Array(this.pLength * this.pWidth * this.pHeight);

                for(i = 0; i < this.pLength; ++i) {
                    for(j = 0; j < this.pWidth; ++j) {
                        for(k = 0; k < this.pHeight; ++k) {
                            let index = i * widthHeight + j * height + k;

                            let index2;
                            if(this.header.filetype == 'phi') { // loop z, y, x
                                index2 = k * widthHeight + j * height + i;
                            }
                            else if(this.header.filetype == 'cube') { // loop x, y, z
                                index2 = i * widthHeight + j * height + k;
                            }

                            if(index2 < this.dataArray.length) {
                                vData[index] = this.dataArray[index2];
                            }
                        }
                    }
                }

                for(let serial in atomlist) {
                    let atom = atoms[atomlist[serial]];

                    if(atom.resn === 'DUM') continue;

                    let r = atom.coord.clone();
                    if(this.loadPhiFrom != 'delphi') { // transform to the original position if the potential file is imported
                        if(this.rmsd_supr !== undefined && this.rmsd_supr.rot !== undefined) {
                            // revert to the original coord
                            let coord = this.transformMemPro(atom.coord, inverseRot, centerTo, centerFrom);
                            r = coord.applyMatrix4(inverseMatrix);
                        }
                        else {
                            r = atom.coord.clone().applyMatrix4(inverseMatrix);
                        }
                    }

                    // scale to the grid
                    r.sub(this.header.ori).multiplyScalar(this.header.scale);

                    // determine the neighboring grid coordinate
                    let nx0 = Math.floor(r.x), nx1 = Math.ceil(r.x);
                    let ny0 = Math.floor(r.y), ny1 = Math.ceil(r.y);
                    let nz0 = Math.floor(r.z), nz1 = Math.ceil(r.z);
                    if(nx1 == nx0) nx1 = nx0 + 1;
                    if(ny1 == ny0) ny1 = ny0 + 1;
                    if(nz1 == nz0) nz1 = nz0 + 1;

                    if(nx1 > this.pLength) nx1 = this.pLength;
                    if(ny1 > this.pWidth) ny1 = this.pWidth;
                    if(nz1 > this.pHeight) nz1 = this.pHeight;

                    //https://en.wikipedia.org/wiki/Trilinear_interpolation
                    let c000 = vData[nx0 * widthHeight + ny0 * height + nz0];
                    let c100 = vData[nx1 * widthHeight + ny0 * height + nz0];
                    let c010 = vData[nx0 * widthHeight + ny1 * height + nz0];
                    let c001 = vData[nx0 * widthHeight + ny0 * height + nz1];
                    let c110 = vData[nx1 * widthHeight + ny1 * height + nz0];
                    let c011 = vData[nx0 * widthHeight + ny1 * height + nz1];
                    let c101 = vData[nx1 * widthHeight + ny0 * height + nz1];
                    let c111 = vData[nx1 * widthHeight + ny1 * height + nz1];

                    let xd = r.x - nx0;
                    let yd = r.y - ny0;
                    let zd = r.z - nz0;

                    let c00 = c000 *(1 - xd) + c100 * xd;
                    let c01 = c001 *(1 - xd) + c101 * xd;
                    let c10 = c010 *(1 - xd) + c110 * xd;
                    let c11 = c011 *(1 - xd) + c111 * xd;

                    let c0 = c00 *(1 - yd) + c10 * yd;
                    let c1 = c01 *(1 - yd) + c11 * yd;

                    let c = c0 *(1 - zd) + c1 * zd;

                    // determine the color based on the potential value
                    if(c > this.isovalue) c = this.isovalue;
                    if(c < -this.isovalue) c = -this.isovalue;

                    let color;
                    if(c > 0) {
                        c /= 1.0 * this.isovalue;
                        color = new THREE.Color(1-c, 1-c, 1);
                    }
                    else {
                        c /= -1.0 * this.isovalue;
                        color = new THREE.Color(1, 1-c, 1-c);
                    }

                    this.icn3d.atoms[atomlist[serial]].color = color;
                    this.icn3d.atomPrevColors[atomlist[serial]] = color;
                }
            }
            else {
                // let index2ori = {};
                let maxdist = this.maxdist;
                for(let serial in atomlist) {
                    let atom = atoms[atomlist[serial]];

                    if(atom.resn === 'DUM') continue;

                    let r;
                    if(this.rmsd_supr !== undefined && this.rmsd_supr.rot !== undefined) {
                        // revert to the original coord
                        let coord = this.transformMemPro(atom.coord, inverseRot, centerTo, centerFrom);
                        r = coord.applyMatrix4(inverseMatrix);
                    }
                    else {
                        r = atom.coord.clone().applyMatrix4(inverseMatrix);
                    }

                    // show map near the structure
                    for(i = Math.floor(r.x) - maxdist, il = Math.ceil(r.x) + maxdist; i <= il; ++i) {
                        if(i < 0 || i > this.header.xExtent*this.scaleFactor - 1) continue;
                        for(j = Math.floor(r.y) - maxdist, jl = Math.ceil(r.y) + maxdist; j<= jl; ++j) {
                            if(j < 0 || j > this.header.yExtent*this.scaleFactor - 1) continue;
                            for(k = Math.floor(r.z) - maxdist, kl = Math.ceil(r.z) + maxdist; k<= kl; ++k) {
                                if(k < 0 || k > this.header.zExtent*this.scaleFactor - 1) continue;
                                let index = i * widthHeight + j * height + k;
                                indexArray.push(index);
                            }
                        }
                    }
                }

                // show all
                // for(i = 0; i < this.pLength; ++i) {
                //     for(j = 0; j < this.pWidth; ++j) {
                //         for(k = 0; k < this.pHeight; ++k) {
                //             let index = i * widthHeight + j * height + k;
                //             indexArray.push(index);
                //         }
                //     }
                // }

                for(i = 0, il = indexArray.length; i < il; ++i) {
                    let index = indexArray[i];

                    if(this.type == '2fofc') {
                        this.vpBits[index] =(this.dataArray[index] >= this.isovalue) ? 1 : 0;
                        //this.vpAtomID[index] =(this.dataArray[index] >= 0) ? 1 : 0; // determine whether it's positive
                    }
                    else if(this.type == 'fofc') {
                        this.vpBits[index] =(this.dataArray[index] >= this.isovalue || this.dataArray[index] <= -this.isovalue) ? 1 : 0;
                        this.vpAtomID[index] =(this.dataArray[index] >= 0) ? 1 : 0; // determine whether it's positive
                    }
                    else if(this.type == 'em') {
                        this.vpBits[index] =(this.dataArray[index] >= this.isovalue) ? 1 : 0;
                        //this.vpAtomID[index] =(this.dataArray[index] >= 0) ? 1 : 0; // determine whether it's positive
                    }
                }
            }
        }

        for(i = 0, il = this.vpBits.length; i < il; i++)
            if(this.vpBits[i] & this.INOUT)
                this.vpBits[i] |= this.ISDONE;

    };

    ElectronMap.prototype.buildboundary = function() {
        let pWH = this.pWidth*this.pHeight;
        let i, j, k;

        for(i = 0; i < this.pLength; i++) {
            for(j = 0; j < this.pHeight; j++) {
                for(k = 0; k < this.pWidth; k++) {
                    let index = i * pWH + k * this.pHeight + j;
                    if(this.vpBits[index] & this.INOUT) {
                        let ii = 0;
                        while(ii < 26) {
                            let ti = i + this.nb[ii][0], tj = j + this.nb[ii][2], tk = k +
                                    this.nb[ii][1];
                            if(ti > -1 &&
                                ti < this.pLength &&
                                tk > -1 &&
                                tk < this.pWidth &&
                                tj > -1 &&
                                tj < this.pHeight &&
                                !(this.vpBits[ti * pWH + tk * this.pHeight + tj] & this.INOUT)) {
                                this.vpBits[index] |= this.ISBOUND;
                                break;
                            } else
                                ii++;
                        }
                    }
                }
            }
        }
    };

    ElectronMap.prototype.marchingcubeinit = function(stype) {
        for( let i = 0, lim = this.vpBits.length; i < lim; i++) {
            if(stype == 1) {// vdw
                this.vpBits[i] &= ~this.ISBOUND;
            } else if(stype == 4) { // ses
                this.vpBits[i] &= ~this.ISDONE;
                if(this.vpBits[i] & this.ISBOUND)
                    this.vpBits[i] |= this.ISDONE;
                this.vpBits[i] &= ~this.ISBOUND;
            } else if(stype == 2) {// after vdw
                if((this.vpBits[i] & this.ISBOUND) &&(this.vpBits[i] & this.ISDONE))
                    this.vpBits[i] &= ~this.ISBOUND;
                else if((this.vpBits[i] & this.ISBOUND) && !(this.vpBits[i] & this.ISDONE))
                    this.vpBits[i] |= this.ISDONE;
            } else if(stype == 3) { // sas
                this.vpBits[i] &= ~this.ISBOUND;
            }
            else {
                this.vpBits[i] &= ~this.ISBOUND;
            }
        }
    };

    // this code allows me to empirically prune the marching cubes code tables
    // to more efficiently handle discrete data
    ElectronMap.prototype.counter = function() {
        let data = Array(256);
        for( let i = 0; i < 256; i++)
            data[i] = [];

        this.incrementUsed = function(i, j) {
            if(typeof data[i][j] === 'undefined')
                data[i][j] = {
                    used : 0,
                    unused : 0
                };
            data[i][j].used++;
        };

        this.incrementUnused = function(i, j) {
            if(typeof data[i][j] === 'undefined')
                data[i][j] = {
                    used : 0,
                    unused : 0
                };
            data[i][j].unused++;

        };

        let redoTable = function(triTable) {
            let str = "[";
            for( let i = 0; i < triTable.length; i++) {
                let code = 0;
                let table = triTable[i];
                for( let j = 0; j < table.length; j++) {
                    code |=(1 <<(table[j]));
                }
                str += "0x" + code.toString(16) + ", ";
            }
            str += "]";
        };

        this.print = function() {

            let table = this.marchingCube.triTable;
            let newtable = [];
            for( let i = 0; i < table.length; i++) {
                let newarr = [];
                for( let j = 0; j < table[i].length; j += 3) {
                    let k = j / 3;
                    if(typeof data[i][k] === 'undefined' || !data[i][k].unused) {
                        newarr.push(table[i][j]);
                        newarr.push(table[i][j + 1]);
                        newarr.push(table[i][j + 2]);
                    }
                    if(typeof data[i][k] === 'undefined')
                        console.log("undef " + i + "," + k);
                }
                newtable.push(newarr);
            }
            redoTable(newtable);
        };
    };

    ElectronMap.prototype.marchingcube = function(stype) {
        this.marchingcubeinit(stype);
        this.verts = []; this.faces = [];

        this.marchingCube.march(this.vpBits, this.verts, this.faces, {
            smooth : 1,
            nX : this.pLength,
            nY : this.pWidth,
            nZ : this.pHeight
        });

        let pWH = this.pWidth*this.pHeight;
        for(let i = 0, vlen = this.verts.length; i < vlen; i++) {
            // positive values
            this.verts[i]['atomid'] = this.vpAtomID[this.verts[i].x * pWH + this.pHeight *
                    this.verts[i].y + this.verts[i].z];
        }

        this.marchingCube.laplacianSmooth(1, this.verts, this.faces);

    };

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Surface {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        // modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
        //Create surface for "atoms". "type" can be 1 (Van der Waals surface), 2 (molecular surface),
        //and 3 (solvent accessible surface). "wireframe" is a boolean to determine whether to show
        //the surface as a mesh. "opacity" is a value between 0 and 1. "1" means not transparent at all.
        //"0" means 100% transparent.
        createSurfaceRepresentation(atoms, type, wireframe, opacity) { let ic = this.icn3d, me = ic.icn3dui;
            //if(me.bNode) return;

            let thisClass = this;

            if(Object.keys(atoms).length == 0) return;

            if(opacity == undefined) opacity = 1.0;

            ic.opacity = opacity;

            let geo;

            let extent = ic.contactCls.getExtent(atoms);

            // surface from 3Dmol
            let distance = 5; // consider atom 5 angstrom from the selected atoms

            let extendedAtoms = [];

            if(ic.bConsiderNeighbors) {
                let unionAtoms;
                unionAtoms = me.hashUtilsCls.unionHash(unionAtoms, atoms);
                unionAtoms = me.hashUtilsCls.unionHash(unionAtoms, ic.contactCls.getAtomsWithinAtom(ic.atoms, atoms, distance));

                extendedAtoms = Object.keys(unionAtoms);
            }
            else {
                extendedAtoms = Object.keys(atoms);
            }

            //var sigma2fofc = 1.5;
            //var sigmafofc = 3.0;
            let maxdist = 1; // maximum distance to show electron density map, set it between 1 AND 2

            (parseInt(10*opacity) != 10 && !wireframe && !(ic.bInstanced && Object.keys(ic.atoms).length * ic.biomtMatrices.length > ic.maxatomcnt) ) ? true : false;

            let ps;

            let cfg = {
                    allatoms: ic.atoms,
                    atomsToShow: Object.keys(atoms),
                    extendedAtoms: extendedAtoms,
                    water: ic.water,
                    //header: ic.mapData.header2,
                    //data: ic.mapData.data2,
                    //matrix: ic.mapData.matrix2,
                    //isovalue: ic.mapData.sigma2,
                    center: ic.center,
                    maxdist: maxdist,
                    pmin: ic.pmin,
                    pmax: ic.pmax,
                    //type: '2fofc',
                    rmsd_supr: ic.rmsd_supr
                };

            if(type == 11) { // 2fofc
                cfg.header = ic.mapData.header2;
                cfg.data = ic.mapData.data2;
                cfg.matrix = ic.mapData.matrix2;
                cfg.isovalue = ic.mapData.sigma2;
                cfg.type = '2fofc';

                //ccp4
                cfg.ccp4 = ic.mapData.ccp4;
                cfg.grid = ic.mapData.grid2;
                cfg.unit_cell = ic.mapData.unit_cell2;

                if(cfg.header || cfg.ccp4) ps = this.SetupMap(cfg);
                else return;

                if(cfg.ccp4) {
                    ic.mapData = {};
                    return;
                }
            }
            else if(type == 12) { // fofc
                cfg.header = ic.mapData.header;
                cfg.data = ic.mapData.data;
                cfg.matrix = ic.mapData.matrix;
                cfg.isovalue = ic.mapData.sigma;
                cfg.type = 'fofc';

                //ccp4
                cfg.ccp4 = ic.mapData.ccp4;
                cfg.grid = ic.mapData.grid;
                cfg.unit_cell = ic.mapData.unit_cell;

                if(cfg.header || cfg.ccp4) ps = this.SetupMap(cfg);
                else return;

                if(cfg.ccp4) {
                    ic.mapData = {};
                    return;
                }
            }
            else if(type == 13) { // em
                cfg.maxdist = 3; // EM map has no unit cell. It could include more grid space.

                cfg.header = ic.mapData.headerEm;
                cfg.data = ic.mapData.dataEm;
                cfg.matrix = ic.mapData.matrixEm;
                cfg.isovalue = ic.mapData.sigmaEm;
                cfg.type = 'em';

                ps = this.SetupMap(cfg);
            }
            else if(type == 14) { // phimap, equipotential
                cfg.header = ic.mapData.headerPhi;
                cfg.data = ic.mapData.dataPhi;
                cfg.matrix = ic.mapData.matrixPhi;
                cfg.isovalue = ic.mapData.contourPhi;
                cfg.type = 'phi';
                cfg.loadPhiFrom = ic.loadPhiFrom;
                
                ps = this.SetupMap(cfg);
            }
            else {
                 //1: van der waals surface, 2: molecular surface, 3: solvent accessible surface
                 

                //exclude water
                let atomsToShow = me.hashUtilsCls.exclHash(atoms, ic.water);
                //extendedAtoms = Object.keys(atomsToShow);
                extendedAtoms = me.hashUtilsCls.exclHash(extendedAtoms, ic.water);

                let realType = type;
                if(realType == 21) realType = 1;
                else if(realType == 22) realType = 2;
                else if(realType == 23) realType = 3;

                cfg = {
                    extent: extent,
                    allatoms: ic.atoms,
                    atomsToShow: Object.keys(atomsToShow),
                    extendedAtoms: extendedAtoms,
                    type: realType,
                    threshbox: (ic.transparentRenderOrder) ? 60 : ic.threshbox,
                    bCalcArea: ic.bCalcArea
                };

                cfg.header = ic.mapData.headerPhi; // header.bSurface is true
                cfg.data = ic.mapData.dataPhi;
                cfg.matrix = ic.mapData.matrixPhi;
                cfg.isovalue = ic.mapData.contourPhi;
                //cfg.type = 'phi';
                cfg.loadPhiFrom = ic.loadPhiFrom;
                //cfg.icn3d = me;

                //cfg.rmsd_supr: ic.rmsd_supr

                ps = this.SetupSurface(cfg);
            }
            
            if(ic.bCalcArea) {
                ic.areavalue = ps.area.toFixed(2);
                let serial2area = ps.serial2area;
                let scaleFactorSq = ps.scaleFactor * ps.scaleFactor;

                ic.resid2area = {};
                let structureHash = {}, chainHash = {};
                for(let i in serial2area) {
                    let atom = ic.atoms[i];
                    let resid = atom.structure + '_' + atom.chain + '_' + atom.resi + '_' + atom.resn;
                    structureHash[atom.structure] = 1;
                    chainHash[atom.structure + '_' + atom.chain] = 1;

                    if(ic.resid2area[resid] === undefined) ic.resid2area[resid] = serial2area[i];
                    else ic.resid2area[resid] += serial2area[i];
                }

                let html = '<table border="1" cellpadding="10" cellspacing="0">';
                let structureStr = (Object.keys(structureHash).length > 1) ? '<th>Structure</th>' : '';
                let chainStr = (Object.keys(chainHash).length > 1) ? '<th>Chain</th>' : '';
                html += '<tr>' + structureStr + chainStr + '<th>Residue</th><th>Number</th><th>SASA (&#8491;<sup>2</sup>)</th><th>Percent Out</th><th>In/Out</th></tr>';
                for(let resid in ic.resid2area) {
                    //var idArray = resid.split('_');
                    let pos = resid.lastIndexOf('_');
                    let resn = resid.substr(pos + 1);

                    let idArray = me.utilsCls.getIdArray(resid.substr(0, pos));

                    structureStr = (Object.keys(structureHash).length > 1) ? '<td>' + idArray[0] + '</td>' : '';
                    chainStr = (Object.keys(chainHash).length > 1) ? '<td>' + idArray[1] + '</td>' : '';
                    // outside: >= 50%; Inside: < 20%; middle: 35
                    let inoutStr = '', percent = '';
                    ic.resid2area[resid] = (ic.resid2area[resid] / scaleFactorSq).toFixed(2);
                    if(me.parasCls.residueArea.hasOwnProperty(resn)) {
                        percent = parseInt(ic.resid2area[resid] / me.parasCls.residueArea[resn] * 100);
                        if(percent > 100) percent = 100;

                        if(percent >= 50) inoutStr = 'out';
                        if(percent < 20) inoutStr = 'in';
                    }

                    html += '<tr align="center">' + structureStr + chainStr + '<td>' + resn + '</td><td align="right">' + idArray[2] + '</td><td align="right">'
                        + ic.resid2area[resid] + '</td><td align="right">' + percent + '%</td><td>' + inoutStr + '</td></tr>';
                }

                html += '</table>';

                ic.areahtml = html;

                return;
            }

            let verts = ps.vertices;
            let faces = ps.faces;

            let colorFor2fofc = me.parasCls.thr('#00FFFF');
            let colorForfofcPos = me.parasCls.thr('#00FF00');
            //var colorForfofcNeg = me.parasCls.thr('#ff3300');
            let colorForfofcNeg = me.parasCls.thr('#ff0000');
            let colorForEm = me.parasCls.thr('#00FFFF');

            let colorForPhiPos = me.parasCls.thr('#0000FF');
            let colorForPhiNeg = me.parasCls.thr('#FF0000');

            let rot, centerFrom, centerTo;
            if((type == 11 || type == 12 || type == 13 || type == 14 ) && ic.rmsd_supr !== undefined && ic.rmsd_supr.rot !== undefined) {
              rot = ic.rmsd_supr.rot;
              centerFrom = ic.rmsd_supr.trans1;
              centerTo = ic.rmsd_supr.trans2;
            }

            // Direct "delphi" calculation uses the transformed PDB file, not the original PDB
            let bTrans = (type == 11 || type == 12 || type == 13 || (type == 14 && ic.loadPhiFrom != 'delphi') )
              && ic.rmsd_supr !== undefined && ic.rmsd_supr.rot !== undefined;

            //geo = new THREE.Geometry();
            geo = new THREE.BufferGeometry();
            let verticeArray = [], colorArray = [], indexArray = [], color;
            
            //var geoVertices = verts.map(function (v) {
            let offset = 0;
            for(let i = 0, il = verts.length; i < il; ++i, offset += 3) {
                let v = verts[i];

                let r = new THREE.Vector3(v.x, v.y, v.z);
                if(bTrans) {
                   r = thisClass.transformMemPro(r, rot, centerFrom, centerTo);
                }

                //verticeArray = verticeArray.concat(r.toArray());
                verticeArray[offset] = r.x;
                verticeArray[offset + 1] = r.y;
                verticeArray[offset + 2] = r.z;

                if(type == 11) { // 2fofc
                    color = colorFor2fofc;
                }
                else if(type == 12) { // fofc
                    color = (v.atomid) ? colorForfofcPos : colorForfofcNeg;
                }
                else if(type == 13) { // em
                    color = colorForEm;
                }
                else if(type == 14) { // phi
                    color = (v.atomid) ? colorForPhiPos : colorForPhiNeg;
                }
                else if(type == 21 || type == 22 || type == 23) { // potential on surface
                    color = v.color;

                    let atomid = v.atomid;
                    ic.atoms[atomid].pot = v.pot; // unit kt/e (25.6 mV)
                }
                else {
                    let atomid = v.atomid;
                    color = ic.atoms[atomid].color;
                }

                //colorArray = colorArray.concat(color.toArray());
                colorArray[offset] = color.r;
                colorArray[offset + 1] = color.g;
                colorArray[offset + 2] = color.b;

                //r.atomid = v.atomid;
                //r.color = v.color;
                //return r;
            }
            //});

            if(me.bNode) return;

            offset = 0;
            for(let i = 0, il = faces.length; i < il; ++i, offset += 3) {
                let f = faces[i];

                //indexArray = indexArray.concat(f.a, f.b, f.c);
                indexArray[offset] = f.a;
                indexArray[offset + 1] = f.b;
                indexArray[offset + 2] = f.c;
            }

            let nComp = 3;
            geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(verticeArray), nComp));
            geo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(colorArray), nComp));

            geo.setIndex(new THREE.BufferAttribute(new Uint32Array(indexArray), 1));
            //geo.setIndex(indexArray);

            //http://analyticphysics.com/Coding%20Methods/Special%20Topics%20in%20Three.js.htm
            //geo.computeVertexNormals(true);
            //geo.colorsNeedUpdate = true;
            //geo.normalsNeedUpdate = true;

            geo.computeVertexNormals();
            
            geo.type = 'Surface'; // to be recognized in vrml.js for 3D printing
            // use the regular way to show transparency for type == 15 (surface with potential)
        //    if(ic.transparentRenderOrder && (type == 1 || type == 2 || type == 3)) { // WebGL has some ordering problem when dealing with transparency
            if(ic.transparentRenderOrder) { // WebGL has some ordering problem when dealing with transparency
              //var normalArrayIn = JSON.parse(JSON.stringify(geo)).data.normals;
              //var normalArrayIn = geo.getAttribute('normal').array;

              // the following method minimize the number of objects by a factor of 3
              let va2faces = {};

              for(let i = 0, il = faces.length; i < il; ++i) {
                let va = faces[i].a;
                let vb = faces[i].b;
                let vc = faces[i].c;

                // It produces less objects using va as the key
                if(va2faces[va] === undefined) va2faces[va] = [];
                //va2faces[va].push(va);
                va2faces[va].push(vb);
                va2faces[va].push(vc);
              }

              for(let va in va2faces) {
                //this.geometry = new THREE.Geometry();
                this.geometry = new THREE.BufferGeometry();
                //this.geometry.vertices = [];
                //this.geometry.faces = [];
                let verticeArray = [], colorArray = [], indexArray = [];
                let offset = 0, offset2 = 0, offset3 = 0;

                let faceVertices = va2faces[va];
                let sum = new THREE.Vector3(0,0,0);
                let nComp = 3;

                let verticesLen = 0;
                for(let i = 0, il = faceVertices.length; i < il; i += 2) {
                    let vb = faceVertices[i];
                    let vc = faceVertices[i + 1];

                    verticeArray[offset++] = verts[va].x;
                    verticeArray[offset++] = verts[va].y;
                    verticeArray[offset++] = verts[va].z;

                    verticeArray[offset++] = verts[vb].x;
                    verticeArray[offset++] = verts[vb].y;
                    verticeArray[offset++] = verts[vb].z;

                    verticeArray[offset++] = verts[vc].x;
                    verticeArray[offset++] = verts[vc].y;
                    verticeArray[offset++] = verts[vc].z;

                    if(type == 21 || type == 22 || type == 23) { // potential on surface
                        colorArray[offset2++] = verts[va].color.r;
                        colorArray[offset2++] = verts[va].color.g;
                        colorArray[offset2++] = verts[va].color.b;

                        colorArray[offset2++] = verts[vb].color.r;
                        colorArray[offset2++] = verts[vb].color.g;
                        colorArray[offset2++] = verts[vb].color.b;

                        colorArray[offset2++] = verts[vc].color.r;
                        colorArray[offset2++] = verts[vc].color.g;
                        colorArray[offset2++] = verts[vc].color.b;
                    }
                    else {
                        colorArray[offset2++] = ic.atoms[verts[va].atomid].color.r;
                        colorArray[offset2++] = ic.atoms[verts[va].atomid].color.g;
                        colorArray[offset2++] = ic.atoms[verts[va].atomid].color.b;
        
                        colorArray[offset2++] = ic.atoms[verts[vb].atomid].color.r;
                        colorArray[offset2++] = ic.atoms[verts[vb].atomid].color.g;
                        colorArray[offset2++] = ic.atoms[verts[vb].atomid].color.b;
        
                        colorArray[offset2++] = ic.atoms[verts[vc].atomid].color.r;
                        colorArray[offset2++] = ic.atoms[verts[vc].atomid].color.g;
                        colorArray[offset2++] = ic.atoms[verts[vc].atomid].color.b;
                    }

                    let initPos = i / 2 * 3;
                    //this.geometry.faces.push(new THREE.Face3(initPos, initPos + 1, initPos + 2, normals, vertexColors));

                    indexArray[offset3++] = initPos;
                    indexArray[offset3++] = initPos + 1;
                    indexArray[offset3++] = initPos + 2;

                    sum = sum.add(new THREE.Vector3(verts[initPos].x, verts[initPos].y, verts[initPos].z));
                    sum = sum.add(new THREE.Vector3(verts[initPos + 1].x, verts[initPos + 1].y, verts[initPos + 1].z));
                    sum = sum.add(new THREE.Vector3(verts[initPos + 2].x, verts[initPos + 2].y, verts[initPos + 2].z));

                    verticesLen += 3;
                }

                this.geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(verticeArray), nComp));
                this.geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(colorArray), nComp));
    //            this.geometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(normalArray), nComp));

                this.geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indexArray), 1));
                //geo.setIndex(indexArray);

                //this.geometry.colorsNeedUpdate = true;
                this.geometry.computeVertexNormals();

                this.geometry.type = 'Surface'; // to be recognized in vrml.js for 3D printing

                let mesh = new THREE.Mesh(this.geometry, new THREE.MeshBasicMaterial({ //new THREE.MeshPhongMaterial({
                    specular: ic.frac,
                    shininess: 0, //10, //30,
                    emissive: ic.emissive,
                    //vertexColors: THREE.VertexColors,
                    vertexColors: true,
                    wireframe: wireframe,
                    opacity: opacity,
                    transparent: true,
                    side: THREE.DoubleSide,
                    //needsUpdate: true
                }));

                //http://www.html5gamedevs.com/topic/7288-threejs-transparency-bug-or-limitation-or-what/
                //mesh.renderOrder = 0; // default 0
                //var sum = new THREE.Vector3(0,0,0);
                //for(let i = 0, il = mesh.geometry.vertices.length; i < il; ++i) {
                //    sum = sum.add(mesh.geometry.vertices[i]);
                //}

                let realPos;
                if(ic.bControlGl && !me.bNode) {
                    //realPos = sum.multiplyScalar(1.0 / mesh.geometry.vertices.length).sub(ic.oriCenter).applyMatrix4(window.cam.matrixWorldInverse);
                    realPos = sum.multiplyScalar(1.0 / verticesLen).sub(ic.oriCenter).applyMatrix4(window.cam.matrixWorldInverse);
                }
                else {
                    //realPos = sum.multiplyScalar(1.0 / mesh.geometry.vertices.length).sub(ic.oriCenter).applyMatrix4(ic.cam.matrixWorldInverse);
                    realPos = sum.multiplyScalar(1.0 / verticesLen).sub(ic.oriCenter).applyMatrix4(ic.cam.matrixWorldInverse);
                }
                mesh.renderOrder = (ic.cam_z > 0) ? -parseInt(realPos.z) : parseInt(realPos.z);

                mesh.onBeforeRender = function(renderer, scene, camera, geometry, material, group) {
                    //https://juejin.im/post/5a0872d4f265da43062a4156
                    let sum = new THREE.Vector3(0,0,0);
                    let vertices = geometry.getAttribute('position').array;
                    for(let i = 0, il = vertices.length; i < il; i += 3) {
                        sum = sum.add(new THREE.Vector3(vertices[i], vertices[i+1], vertices[i+2]));
                    }

                    let realPos;
                    if(ic.bControlGl && !me.bNode) {
                        //realPos = sum.multiplyScalar(1.0 / this.geometry.vertices.length).sub(ic.oriCenter).applyMatrix4(window.cam.matrixWorldInverse);
                        realPos = sum.multiplyScalar(3.0 / vertices.length).sub(ic.oriCenter).applyMatrix4(window.cam.matrixWorldInverse);
                    }
                    else {
                        //realPos = sum.multiplyScalar(1.0 / this.geometry.vertices.length).sub(ic.oriCenter).applyMatrix4(ic.cam.matrixWorldInverse);
                        //realPos = thisClass.sum.multiplyScalar(1.0 / thisClass.verticesLen).sub(ic.oriCenter).applyMatrix4(ic.cam.matrixWorldInverse);
                        realPos = sum.multiplyScalar(3.0 / vertices.length).sub(ic.oriCenter).applyMatrix4(ic.cam.matrixWorldInverse);
                    }
                    this.renderOrder = (ic.cam_z > 0) ? -parseInt(realPos.z) : parseInt(realPos.z);
                };

                ic.mdl.add(mesh);

                if(type == 11 || type == 12) {
                    ic.prevMaps.push(mesh);
                }
                else if(type == 13) {
                    ic.prevEmmaps.push(mesh);
                }
                else if(type == 14) {
                    ic.prevPhimaps.push(mesh);
                }
                else {
                    ic.prevSurfaces.push(mesh);
                }
              } // for(let va
            }
            else {         
                let mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({
                    specular: ic.frac,
                    shininess: 20, //10, //30,
                    emissive: ic.emissive,
                    //vertexColors: THREE.VertexColors,
                    vertexColors: true,
                    wireframe: wireframe,
                    opacity: opacity,
                    transparent: true,
                    depthWrite: (parseInt(10*opacity) != 10) ? false : true, // important to make the transparency work
                    side: THREE.DoubleSide,
                    //needsUpdate: true 
                    //depthTest: (ic.ic.transparentRenderOrder) ? false : true
                }));

                //http://www.html5gamedevs.com/topic/7288-threejs-transparency-bug-or-limitation-or-what/
                mesh.renderOrder = -2; // default: 0, picking: -1

                ic.mdl.add(mesh);
                
                if(type == 11 || type == 12) {
                    ic.prevMaps.push(mesh);
                }
                else if(type == 13) {
                    ic.prevEmmaps.push(mesh);
                }
                else if(type == 14) {
                    ic.prevPhimaps.push(mesh);
                }
                else {
                    ic.prevSurfaces.push(mesh);
                }
            }
            
            // remove the reference
            ps = null;
            verts = null;
            faces = null;

            // remove the reference
            geo = null;

            // do not add surface to raycasting objects for pk
        }

        transformMemPro(inCoord, rot, centerFrom, centerTo, bOut) { let ic = this.icn3d; ic.icn3dui;
            let coord = inCoord.clone();

            coord.sub(centerFrom);
        if(bOut) console.log("sub coord: " + JSON.stringify(coord));

            let x = coord.x*rot[0] + coord.y*rot[1] + coord.z*rot[2] + centerTo.x;
            let y = coord.x*rot[3] + coord.y*rot[4] + coord.z*rot[5] + centerTo.y;
            let z = coord.x*rot[6] + coord.y*rot[7] + coord.z*rot[8] + centerTo.z;

            coord.x = x;
            coord.y = y;
            coord.z = z;
        if(bOut) console.log("out coord: " + JSON.stringify(coord));

            return coord;
        }

        SetupSurface(data) { let ic = this.icn3d; ic.icn3dui;

            let threshbox = data.threshbox; // maximum possible boxsize, default 180

            let ps = new ProteinSurface(ic, threshbox);
            ps.initparm(data.extent,(data.type === 1) ? false : true, data.bCalcArea, data.atomsToShow
              , data.header, data.data, data.matrix, data.isovalue, data.loadPhiFrom);

            ps.fillvoxels(data.allatoms, data.extendedAtoms);

            ps.buildboundary();

            //if(data.type === 4 || data.type === 2) {
            if(data.type === 2) {
                ps.fastdistancemap();
                ps.boundingatom(false);
                ps.fillvoxelswaals(data.allatoms, data.extendedAtoms);
            }

            //ps.marchingcube(data.type);
            let area_serial2area = ps.marchingcube();

            ps.vpBits = null; // uint8 array of bitmasks
            ps.vpDistance = null; // floatarray of _squared_ distances
            ps.vpAtomID = null; // intarray

            let result = ps.getFacesAndVertices(data.atomsToShow);
            result.area = area_serial2area.area;
            result.serial2area = area_serial2area.serial2area;
            result.scaleFactor = area_serial2area.scaleFactor;

            ps.faces = null;
            ps.verts = null;

            return result;
        }

        SetupMap(data) { let ic = this.icn3d; ic.icn3dui;
            if(data.ccp4) {
                let radius = 10; 
                let center = (ic.center) ? [ic.center.x, ic.center.y, ic.center.z] : [0,0,0];
        
                let typeDetail;
                if(data.type == '2fofc') {
                  typeDetail = '2fofc';
                  let result = ic.ccp4ParserCls.extract_block(data.grid, data.unit_cell, radius, center, typeDetail); 
                  let iso = ic.ccp4ParserCls.marchingCubes(result.size, result.values, result.points, data.isovalue, 'marching cubes');
                  ic.ccp4ParserCls.makeChickenWire(iso, typeDetail);

                  result = null;
                  iso = null;
                }
                else if(data.type == 'fofc') {
                  typeDetail = 'fofc_neg';
                  let result = ic.ccp4ParserCls.extract_block(data.grid, data.unit_cell, radius, center, typeDetail); 
                  let iso = ic.ccp4ParserCls.marchingCubes(result.size, result.values, result.points, data.isovalue, 'marching cubes');
                  ic.ccp4ParserCls.makeChickenWire(iso, typeDetail);
        
                  typeDetail = 'fofc_pos';
                  result = ic.ccp4ParserCls.extract_block(data.grid, data.unit_cell, radius, center, typeDetail); 
                  iso = ic.ccp4ParserCls.marchingCubes(result.size, result.values, result.points, data.isovalue, 'marching cubes');
                  ic.ccp4ParserCls.makeChickenWire(iso, typeDetail);

                  result = null;
                  iso = null;
                }
            }
            else {
                let ps = new ElectronMap(ic); 
        
                ps.initparm(data.header, data.data, data.matrix, data.isovalue, data.center, data.maxdist,
                data.pmin, data.pmax, data.water, data.type, data.rmsd_supr, data.loadPhiFrom, data.icn3d);

                ps.fillvoxels(data.allatoms, data.extendedAtoms);

                if(!data.header.bSurface) ps.buildboundary();

                if(!data.header.bSurface) ps.marchingcube();
                
                ps.vpBits = null; // uint8 array of bitmasks
                //ps.vpDistance = null; // floatarray of _squared_ distances
                ps.vpAtomID = null; // intarray

                let result;

                if(!data.header.bSurface) result = ps.getFacesAndVertices(data.allatoms, data.atomsToShow);

                ps.faces = null;
                ps.verts = null;

                return result;
            }
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class ApplyCenter {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        applyCenterOptions(options) { let ic = this.icn3d; ic.icn3dui;
            if(options === undefined) options = ic.opts;

            let center;
            switch (options.rotationcenter.toLowerCase()) {
                case 'molecule center':
                    // move the molecule to the origin
                    if(ic.center !== undefined) {
                        this.setRotationCenter(ic.center);
                    }
                    break;
                case 'pick center':
                    if(ic.pAtom !== undefined) {
                      this.setRotationCenter(ic.pAtom.coord);
                    }
                    break;
                case 'display center':
                    center = this.centerAtoms(ic.dAtoms).center;
                    this.setRotationCenter(center);
                    break;
                case 'highlight center':
                    center = this.centerAtoms(ic.hAtoms).center;
                    this.setRotationCenter(center);
                    break;
            }
        }

        //Set the center at the position with coordinated "coord".
        setRotationCenter(coord) { let ic = this.icn3d; ic.icn3dui;
           this.setCenter(coord);
        }

        setCenter(center) { let ic = this.icn3d; ic.icn3dui;
           //if(!ic.bChainAlign) {
               ic.mdl.position.set(0,0,0);
               ic.mdlImpostor.position.set(0,0,0);
               ic.mdl_ghost.position.set(0,0,0);

               ic.mdl.position.sub(center);
               //ic.mdlPicking.position.sub(center);
               ic.mdlImpostor.position.sub(center);
               ic.mdl_ghost.position.sub(center);
           //}
        }

        //Center on the selected atoms.
        centerSelection(atoms, bNoOrientation) { let ic = this.icn3d, me = ic.icn3dui;
           //ic.transformCls.resetOrientation();

           ic.opts['rotationcenter'] = 'highlight center';

           if(atoms === undefined) {
               atoms = me.hashUtilsCls.hash2Atoms(ic.hAtoms, ic.atoms);
           }

           if(!bNoOrientation) {
                // reset parameters
                ic._zoomFactor = 1.0;
                ic.mouseChange = new THREE.Vector2(0,0);
                ic.quaternion = new THREE.Quaternion(0,0,0,1);
           }

           // center on the hAtoms if more than one residue is selected
           if(Object.keys(atoms).length > 1) {
                   let centerAtomsResults = this.centerAtoms(atoms);

                   ic.center = centerAtomsResults.center;
                   this.setCenter(ic.center);

                   // reset cameara
                   ic.cameraCls.setCamera();
           }
        }

        //Return an object {"center": center, "maxD": maxD}, where "center" is the center of
        //a set of "atoms" with a value of THREE.Vector3(), and "maxD" is the maximum distance
        //between any two atoms in the set.
        centerAtoms(atoms) { let ic = this.icn3d; ic.icn3dui;
            let pmin = new THREE.Vector3( 9999, 9999, 9999);
            let pmax = new THREE.Vector3(-9999,-9999,-9999);
            let psum = new THREE.Vector3();

            for (let i in atoms) {
                let atom = ic.atoms[i];
                let coord = atom.coord;
                psum.add(coord);
                pmin.min(coord);
                pmax.max(coord);
            }

            //let maxD = pmax.distanceTo(pmin);

            //let center = psum.multiplyScalar(1.0 / cnt);
            let center = ic.ParserUtilsCls.getGeoCenter(pmin, pmax);
            let maxD = ic.ParserUtilsCls.getStructureSize(atoms, pmin, pmax, center);

            return {"center": center, "maxD": maxD, "pmin": pmin, "pmax": pmax};
        }

        // modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
        //Set the width and height of the canvas.
        setWidthHeight(width, height) { let ic = this.icn3d; ic.icn3dui;
            //ic.renderer.setSize(width, height);
            if(ic.scaleFactor === undefined) ic.scaleFactor = 1.0;

            //antialiasing by render twice large:
            //https://stackoverflow.com/questions/17224795/antialiasing-not-working-in-three-js
            ic.renderer.setSize(width*ic.scaleFactor, height*ic.scaleFactor);
            ic.renderer.domElement.style.width = width*ic.scaleFactor + "px";
            ic.renderer.domElement.style.height = height*ic.scaleFactor + "px";
            ic.renderer.domElement.width = width*ic.scaleFactor;
            ic.renderer.domElement.height = height*ic.scaleFactor;

            //ic.container.widthInv  = 1 / (ic.scaleFactor*width);
            //ic.container.heightInv = 1 / (ic.scaleFactor*height);

            ic.container.whratio = width / height;
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class ApplyClbonds {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        applyClbondsOptions(options) { let ic = this.icn3d, me = ic.icn3dui;
           if(options === undefined) options = ic.opts;

           if(!ic.bCalcCrossLink) {
             // find all bonds to chemicals
             ic.clbondpnts = {};
             ic.clbondResid2serial = {};

             // chemical to chemical first
             this.applyClbondsOptions_base('chemical');

             // chemical to protein/nucleotide
             this.applyClbondsOptions_base('all');

             ic.bCalcCrossLink = true;
           }

           if (options.clbonds.toLowerCase() === 'yes' && options.chemicals !== 'nothing') {
             let color = '#006400';
             me.parasCls.thr(0x006400);

             ic.lines['clbond'] = [];
             ic.residuesHashClbonds = {};

             if(ic.structures) {
                 let strucArray = Object.keys(ic.structures);
                 for(let i = 0, il = strucArray.length; i < il; ++i) {
                     let struc = strucArray[i];
                     if(!ic.clbondpnts[struc]) continue;

                     for(let j = 0, jl = ic.clbondpnts[struc].length; j < jl; j += 2) {
                        let resid0 = ic.clbondpnts[struc][j];
                        let resid1 = ic.clbondpnts[struc][j+1];

                        let line = {};
                        line.color = color;
                        line.dashed = false;

                        line.radius = ic.crosslinkRadius;

                        line.serial1 = ic.clbondResid2serial[resid0 + ',' + resid1];
                        line.serial2 = ic.clbondResid2serial[resid1 + ',' + resid0];

                        if(!ic.dAtoms.hasOwnProperty(line.serial1) || !ic.dAtoms.hasOwnProperty(line.serial2)) continue;

                        line.position1 = ic.atoms[line.serial1].coord;
                        line.position2 = ic.atoms[line.serial2].coord;

                        ic.lines['clbond'].push(line);
                        //ic.cylinderCls.createCylinder(line.position1, line.position2, ic.crosslinkRadius, colorObj);

                        // show stick for these two residues
                        let residueAtoms = {};
                        residueAtoms = me.hashUtilsCls.unionHash(residueAtoms, ic.residues[resid0]);
                        residueAtoms = me.hashUtilsCls.unionHash(residueAtoms, ic.residues[resid1]);

                        // show side chains for the selected atoms
                        let atoms = me.hashUtilsCls.intHash(residueAtoms, ic.sidec);

                        // draw sidec separately
                        for(let k in atoms) {
                          ic.atoms[k].style2 = 'stick';
                        }

                        // return the residues
                        ic.residuesHashClbonds[resid0] = 1;
                        ic.residuesHashClbonds[resid1] = 1;
                    } // for j
                } // for i
            } // if
          } // if

          return ic.residuesHashClbonds;
        }

        applyClbondsOptions_base(type) { let ic = this.icn3d; ic.icn3dui;
             // chemical to chemical first
             for (let i in ic.chemicals) {
                let atom0 = ic.atoms[i];

                let chain0 = atom0.structure + '_' + atom0.chain;
                let resid0 = chain0 + '_' + atom0.resi;

                for (let j in atom0.bonds) {
                    let atom1 = ic.atoms[atom0.bonds[j]];

                    if (atom1 === undefined) continue;
                    if (atom1.chain !== atom0.chain || atom1.resi !== atom0.resi) {
                        let chain1 = atom1.structure + '_' + atom1.chain;
                        let resid1 = chain1 + '_' + atom1.resi;

                        let bType = (type == 'chemical') ? atom1.het : true; //(ic.proteins.hasOwnProperty(atom1.serial) || ic.nucleotides.hasOwnProperty(atom1.serial));

                        if(bType ) {
                            if(type == 'chemical') continue; // just connect checmicals together

                            if(ic.clbondpnts[atom0.structure] === undefined) ic.clbondpnts[atom0.structure] = [];
                            ic.clbondpnts[atom0.structure].push(resid0);
                            ic.clbondpnts[atom1.structure].push(resid1);

                            // one residue may have different atom for different clbond
                            ic.clbondResid2serial[resid0 + ',' + resid1] = atom0.serial;
                            ic.clbondResid2serial[resid1 + ',' + resid0] = atom1.serial;
                        }
                    }
                } // for j
            } // for i
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class ApplyMissingRes {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        applyMissingResOptions(options) { let ic = this.icn3d; ic.icn3dui;

            if(!ic.bCalcMissingRes) {
                // find all bonds to chemicals
                ic.missingResPnts = {};
                ic.missingResResid2serial = {};

                this.applyMissingResOptions_base();

                ic.bCalcMissingRes = true;
            }

            ic.lines['missingres'] = [];

            if(ic.structures) {
                let strucArray = Object.keys(ic.structures);
                for(let i = 0, il = strucArray.length; i < il; ++i) {
                     let struc = strucArray[i];
                     if(!ic.missingResPnts[struc]) continue;

                     for(let j = 0, jl = ic.missingResPnts[struc].length; j < jl; j += 2) {
                        let resid0 = ic.missingResPnts[struc][j];
                        let resid1 = ic.missingResPnts[struc][j+1];

                        let line = {};
                        
                        line.dashed = true;

                        line.serial1 = ic.missingResResid2serial[resid0 + ',' + resid1];
                        line.serial2 = ic.missingResResid2serial[resid1 + ',' + resid0];

                        line.color = "#" + ic.atoms[line.serial1].color.getHexString();

                        line.radius = ic.coilWidth;

                        if(!ic.dAtoms.hasOwnProperty(line.serial1) || !ic.dAtoms.hasOwnProperty(line.serial2)) continue;

                        line.position1 = ic.atoms[line.serial1].coord;
                        line.position2 = ic.atoms[line.serial2].coord;

                        ic.lines['missingres'].push(line);
                    } // for j
                } // for i
            } // if
        }

        applyMissingResOptions_base(type) { let ic = this.icn3d; ic.icn3dui;
            let misingResArray = [];
            for(let chainid in ic.chainsSeq) {
                let bStart = false;
                let startResid, currResid, prevResid;
                let bCurrCoord, bPrevCoord = false;
                for(let i = 0, il = ic.chainsSeq[chainid].length; i < il; ++i) {
                    currResid = chainid + '_' + ic.chainsSeq[chainid][i].resi;

                    if(ic.residues.hasOwnProperty(currResid)) {
                        bStart = true;

                        bCurrCoord = true;
                    }
                    else {
                        bCurrCoord = false;
                    }

                    if(!bCurrCoord && bPrevCoord) {
                        startResid = prevResid;
                    }
                    else if(bStart && startResid && bCurrCoord && !bPrevCoord) {
                        misingResArray.push(startResid);
                        misingResArray.push(currResid);

                        startResid = undefined;
                    }

                    bPrevCoord = bCurrCoord;
                    prevResid = currResid;
                }
            }

            for(let i = 0, il = misingResArray.length; i < il; i += 2) {
                let resid0 = misingResArray[i];
                let resid1 = misingResArray[i + 1];

                let structure = resid0.substr(0, resid0.indexOf('_'));
                resid0.substr(0, resid1.indexOf('_'));

                let atom0 = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[resid0]);
                let atom1 = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[resid1]);

                // one residue may have different atom for different clbond
                if(atom0 && atom1) {
                    if(ic.missingResPnts[structure] === undefined) ic.missingResPnts[structure] = [];
                    ic.missingResPnts[structure].push(resid0);
                    ic.missingResPnts[structure].push(resid1);

                    ic.missingResResid2serial[resid0 + ',' + resid1] = atom0.serial;
                    ic.missingResResid2serial[resid1 + ',' + resid0] = atom1.serial;
                }
            } // for i
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class ApplyDisplay {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Apply style and label options to a certain set of atoms.
        applyDisplayOptions(options, atoms, bHighlight) { let ic = this.icn3d, me = ic.icn3dui;

            // get parameters from cookies
            if(!me.bNode && me.htmlCls.setHtmlCls.getCookie('lineRadius') != '') {
                let lineRadius = parseFloat(me.htmlCls.setHtmlCls.getCookie('lineRadius'));
                let coilWidth = parseFloat(me.htmlCls.setHtmlCls.getCookie('coilWidth'));
                let cylinderRadius = parseFloat(me.htmlCls.setHtmlCls.getCookie('cylinderRadius'));
                let clRad = me.htmlCls.setHtmlCls.getCookie('crosslinkRadius');
                let crosslinkRadius = (clRad && !isNaN(clRad)) ? parseFloat(clRad) : ic.crosslinkRadius;
                let traceRadius = parseFloat(me.htmlCls.setHtmlCls.getCookie('traceRadius'));
                let dotSphereScale = parseFloat(me.htmlCls.setHtmlCls.getCookie('dotSphereScale'));
                let ribbonthickness = parseFloat(me.htmlCls.setHtmlCls.getCookie('ribbonthickness'));
                let helixSheetWidth = parseFloat(me.htmlCls.setHtmlCls.getCookie('helixSheetWidth'));
                let nucleicAcidWidth = parseFloat(me.htmlCls.setHtmlCls.getCookie('nucleicAcidWidth'));

                if(!ic.bSetThicknessOnce && (ic.lineRadius != lineRadius || ic.coilWidth != coilWidth || ic.cylinderRadius != cylinderRadius || ic.crosslinkRadius != crosslinkRadius || ic.traceRadius != traceRadius || ic.dotSphereScale != dotSphereScale || ic.ribbonthickness != ribbonthickness || ic.helixSheetWidth != helixSheetWidth || ic.nucleicAcidWidth != nucleicAcidWidth) ) {
                    ic.bSetThicknessOnce = true;

                    me.htmlCls.clickMenuCls.setLogCmd('set thickness | linerad ' + lineRadius + ' | coilrad ' + coilWidth + ' | stickrad ' + cylinderRadius + ' | crosslinkrad ' + crosslinkRadius + ' | tracerad ' + traceRadius + ' | ribbonthick ' + ribbonthickness + ' | proteinwidth ' + helixSheetWidth + ' | nucleotidewidth ' + nucleicAcidWidth  + ' | ballscale ' + dotSphereScale, true);
                }

                ic.lineRadius = lineRadius;
                ic.coilWidth = coilWidth;
                ic.cylinderRadius = cylinderRadius;
                ic.crosslinkRadius = crosslinkRadius;
                ic.traceRadius = traceRadius;
                ic.dotSphereScale = dotSphereScale;
                ic.ribbonthickness = ribbonthickness;
                ic.helixSheetWidth = helixSheetWidth;
                ic.nucleicAcidWidth = nucleicAcidWidth;
            }

            let residueHash = {};
            let singletonResidueHash = {};
            let atomsObj = {};
            let residueid;

            if(bHighlight === 1 && Object.keys(atoms).length < Object.keys(ic.atoms).length) {
                atomsObj = me.hashUtilsCls.hash2Atoms(atoms, ic.atoms);

                residueHash = ic.firstAtomObjCls.getResiduesFromAtoms(atoms, ic.atoms);

                // find singleton residues
                for(let i in residueHash) {
                    residueid = i;

                    let last = i.lastIndexOf('_');
                    let base = i.substr(0, last + 1);
                    let lastResiStr = i.substr(last + 1);
                    if(isNaN(lastResiStr)) continue;

                    let lastResi = parseInt(lastResiStr);

                    let prevResidueid = base + (lastResi - 1).toString();
                    base + (lastResi + 1).toString();

                    if(!residueHash.hasOwnProperty(prevResidueid) && !residueHash.hasOwnProperty(prevResidueid)) {
                        singletonResidueHash[i] = 1;
                    }
                }

                // show the only atom in a transparent box
                if(Object.keys(atomsObj).length === 1 && Object.keys(ic.residues[residueid]).length > 1
                      && atomsObj[Object.keys(atomsObj)[0]].style !== 'sphere' && atomsObj[Object.keys(atomsObj)[0]].style !== 'dot') {
                    if(ic.bCid === undefined || !ic.bCid) {
                        for(let i in atomsObj) {
                            let atom = atomsObj[i];
                            let scale = 1.0;
                            ic.boxCls.createBox(atom, undefined, undefined, scale, undefined, bHighlight);
                        }
                    }
                }
                else {
                    // if only one residue, add the next residue in order to show highlight
                    for(let residueid in singletonResidueHash) {
                        // get calpha
                        let calpha = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[residueid]);
                        let sideAtom = ic.firstAtomObjCls.getFirstAtomObj(ic.selectionCls.getSideAtoms(ic.residues[residueid]));
                        let atom = calpha;

                        let prevResidueid = atom.structure + '_' + atom.chain + '_' + (parseInt(atom.resi) - 1).toString();
                        let nextResidueid = atom.structure + '_' + atom.chain + '_' + (parseInt(atom.resi) + 1).toString();

                        //ribbon, strand, cylinder and plate, nucleotide cartoon, o3 trace, schematic, c alpha trace, b factor tube, lines, stick, ball and stick, sphere, dot

                        if(atom.style === 'cylinder and plate' && atom.ss === 'helix') { // no way to highlight part of cylinder
                            for(let i in ic.residues[residueid]) {
                                let atom = ic.atoms[i];
                                let scale = 1.0;
                                ic.boxCls.createBox(atom, undefined, undefined, scale, undefined, bHighlight);
                            }
                        }
                        else if( (atom.style === 'ribbon' && atom.ss === 'coil') || (atom.style === 'strand' && atom.ss === 'coil') || atom.style === 'o3 trace' || atom.style === 'schematic' || atom.style === 'c alpha trace' || atom.style === 'b factor tube' || (atom.style === 'cylinder and plate' && atom.ss !== 'helix') ) {
                            // do not add extra residue if the side chain is shown
                            if(sideAtom !== undefined && sideAtom.style2 !== undefined && sideAtom.style2 !== 'nothing') continue;

                            let bAddResidue = false;
                            // add the next residue with same style
                            if(!isNaN(atom.resi) && !bAddResidue && ic.residues.hasOwnProperty(nextResidueid)) {
                                let index2 = Object.keys(ic.residues[nextResidueid])[0];
                                let atom2 = me.hashUtilsCls.hash2Atoms(ic.residues[nextResidueid], ic.atoms)[index2];
                                if( (atom.style === atom2.style && !atom2.ssbegin) || atom2.ssbegin) {
                                    let residueAtoms = ic.residues[nextResidueid];
                                    atoms = me.hashUtilsCls.unionHash(atoms, residueAtoms);

                                    bAddResidue = true;

                                    // record the highlight style for the artificial residue
                                    if(atom2.ssbegin) {
                                        for(let i in residueAtoms) {
                                            ic.atoms[i].notshow = true;
                                        }
                                    }
                                }
                            }

                            // add the previous residue with same style
                            if(!isNaN(atom.resi) && !bAddResidue && ic.residues.hasOwnProperty(prevResidueid)) {
                                let index2 = Object.keys(ic.residues[prevResidueid])[0];
                                let atom2 = me.hashUtilsCls.hash2Atoms(ic.residues[prevResidueid], ic.atoms)[index2];
                                if(atom.style === atom2.style) {
                                    atoms = me.hashUtilsCls.unionHash(atoms, ic.residues[prevResidueid]);

                                    bAddResidue = true;
                                }
                            }
                        }
                        else if( (atom.style === 'ribbon' && atom.ss !== 'coil' && atom.ssend) || (atom.style === 'strand' && atom.ss !== 'coil' && atom.ssend)) {
                            // do not add extra residue if the side chain is shown
                            if(sideAtom !== undefined && sideAtom.style2 !== undefined && sideAtom.style2 !== 'nothing') continue;

                            let bAddResidue = false;
                            // add the next residue with same style
                            if(!isNaN(atom.resi) && !bAddResidue && ic.residues.hasOwnProperty(nextResidueid)) {
                                let index2 = Object.keys(ic.residues[nextResidueid])[0];
                                me.hashUtilsCls.hash2Atoms(ic.residues[nextResidueid], ic.atoms)[index2];
                                //if(atom.style === atom2.style && !atom2.ssbegin) {
                                    atoms = me.hashUtilsCls.unionHash(atoms, ic.residues[nextResidueid]);

                                    bAddResidue = true;
                                //}
                            }
                        }
                    } // end for
                } // end else {

                atomsObj = {};
            } // end if(bHighlight === 1)

            if(ic.bInitial && ic.bMembrane === undefined) {
                if(me.htmlCls.setHtmlCls.getCookie('membrane') != '') {
                    let bMembrane = parseInt(me.htmlCls.setHtmlCls.getCookie('membrane'));

                    if(ic.bMembrane != bMembrane) {
                        me.htmlCls.clickMenuCls.setLogCmd('set membrane ' + bMembrane, true);
                    }

                    ic.bMembrane = (!isNaN(bMembrane)) ? parseInt(bMembrane) : 0;
                }

                // show membrane
                if(ic.bMembrane) {
                    ic.selectionCls.toggleMembrane(true);
                }
                else {
                    ic.selectionCls.toggleMembrane(false);
                }
            }

            ic.setStyleCls.setStyle2Atoms(atoms);

            //ic.bAllAtoms = false;
            //if(atoms && atoms !== undefined ) {
            //    ic.bAllAtoms = (Object.keys(atoms).length === Object.keys(ic.atoms).length);
            //}

            let chemicalSchematicRadius = ic.cylinderRadius * 0.5;

            // remove schematic labels
            //if(ic.labels !== undefined) ic.labels['schematic'] = undefined;
            if(ic.labels !== undefined) delete ic.labels['schematic'];
    /*
            if(bHighlight) {
                //let residueHashCalpha = ic.firstAtomObjCls.getResiduesFromCalphaAtoms(ic.hAtoms);

                let proteinAtoms = me.hashUtilsCls.intHash(ic.hAtoms, ic.proteins);

                let residueHash = ic.firstAtomObjCls.getResiduesFromAtoms(proteinAtoms);
                let residueHashCalpha = ic.firstAtomObjCls.getResiduesFromCalphaAtoms(proteinAtoms);

                if(Object.keys(residueHash).length > Object.keys(residueHashCalpha).length) { // some residues have only side chains
                    bOnlySideChains = true;
                }
            }
    */
            for(let style in ic.style2atoms) {
              // 14 styles: ribbon, strand, cylinder and plate, nucleotide cartoon, o3 trace, schematic, c alpha trace, b factor tube, lines, stick, ball and stick, sphere, dot, nothing
              let atomHash = ic.style2atoms[style];
              //var bPhosphorusOnly = me.utilsCls.isCalphaPhosOnly(me.hashUtilsCls.hash2Atoms(atomHash), "O3'", "O3*") || me.utilsCls.isCalphaPhosOnly(me.hashUtilsCls.hash2Atoms(atomHash), "P");
              //let bPhosphorusOnly = me.utilsCls.isCalphaPhosOnly(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms));
              let nucleotidesAtoms = me.hashUtilsCls.intHash(atomHash, ic.nucleotides);
              let bPhosphorusOnly = me.utilsCls.isCalphaPhosOnly(me.hashUtilsCls.hash2Atoms(nucleotidesAtoms, ic.atoms));

              if(style === 'ribbon') {
              //if(style === 'ribbon' && (!bHighlight || (bHighlight && !bOnlySideChains))) {
                  ic.strandCls.createStrand(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms), 2, undefined, true, undefined, undefined, false, ic.ribbonthickness, bHighlight);
              }
              else if(style === 'strand') {
              //else if(style === 'strand' && (!bHighlight || (bHighlight && !bOnlySideChains))) {
                  ic.strandCls.createStrand(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms), null, null, null, null, null, false, undefined, bHighlight);
              }
              else if(style === 'cylinder and plate') {
              //else if(style === 'cylinder and plate' && (!bHighlight || (bHighlight && !bOnlySideChains))) {
                ic.cylinderCls.createCylinderHelix(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms), ic.cylinderHelixRadius, bHighlight);
              }
              else if(style === 'nucleotide cartoon') {
                if(bPhosphorusOnly) {
                    ic.cylinderCls.createCylinderCurve(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms), ["P"], ic.traceRadius, false, bHighlight);
                }
                else {
                    ic.cartoonNuclCls.drawCartoonNucleicAcid(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms), null, ic.ribbonthickness, bHighlight);

                    if(bHighlight !== 2) ic.cartoonNuclCls.drawNucleicAcidStick(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms), bHighlight);
                }
              }
              else if(style === 'o3 trace') {
                if(bPhosphorusOnly) {
                    ic.cylinderCls.createCylinderCurve(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms), ["P"], ic.traceRadius, false, bHighlight);
                }
                else {
                    ic.cylinderCls.createCylinderCurve(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms), ["O3'", "O3*"], ic.traceRadius, false, bHighlight);
                }
              }
              else if(style === 'schematic') {
                // either proteins, nucleotides, or chemicals
                let firstAtom = ic.firstAtomObjCls.getFirstAtomObj(atomHash);

                //if(firstAtom.het) { // chemicals
                if(ic.chemicals.hasOwnProperty(firstAtom.serial)) { // chemicals
                    ic.residueLabelsCls.addNonCarbonAtomLabels(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms));

                    let bSchematic = true;
                    ic.stickCls.createStickRepresentation(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms), chemicalSchematicRadius, chemicalSchematicRadius, undefined, bHighlight, bSchematic);
                }
                else { // nucleotides or proteins
                    ic.residueLabelsCls.addResidueLabels(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms), true);

                    if(bPhosphorusOnly) {
                        ic.cylinderCls.createCylinderCurve(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms), ["P"], ic.traceRadius, false, bHighlight);
                    }
                    else {
                        ic.cylinderCls.createCylinderCurve(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms), ["O3'", "O3*"], ic.traceRadius, false, bHighlight);
                    }
                    ic.cylinderCls.createCylinderCurve(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms), ['CA'], ic.traceRadius, false, bHighlight);
                }
              }
              else if(style === 'c alpha trace') {
                ic.cylinderCls.createCylinderCurve(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms), ['CA'], ic.traceRadius, false, bHighlight);
              }
              else if(style === 'b factor tube') {
                ic.tubeCls.createTube(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms), 'CA', null, bHighlight, false, true);
              }
              else if(style === 'custom tube') {
                ic.tubeCls.createTube(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms), 'CA', null, bHighlight, true, true);
              }
              else if(style === 'lines' || style === 'lines2') {
                if(bHighlight === 1) {
                    ic.stickCls.createStickRepresentation(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms), ic.hlLineRadius, ic.hlLineRadius, undefined, bHighlight);
                }
                else {
                    ic.lineCls.createLineRepresentation(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms), bHighlight);
                }

                ic.lineCls.createConnCalphSidechain(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms), style);
              }
              else if(style === 'stick' || style === 'stick2') {
                ic.stickCls.createStickRepresentation(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms), ic.cylinderRadius, ic.cylinderRadius, undefined, bHighlight, undefined);
                ic.lineCls.createConnCalphSidechain(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms), style);
              }
              else if(style === 'backbone') {
                atomHash = this.selectMainChainSubset(atomHash);
                ic.stickCls.createStickRepresentation(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms), ic.cylinderRadius, ic.cylinderRadius, undefined, bHighlight, undefined);
              }
              else if(style === 'ball and stick' || style === 'ball and stick2') {
                ic.stickCls.createStickRepresentation(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms), ic.cylinderRadius, ic.cylinderRadius * 0.5, ic.dotSphereScale, bHighlight, undefined);
                ic.lineCls.createConnCalphSidechain(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms), style);
              }
              else if(style === 'sphere' || style === 'sphere2') {
                ic.sphereCls.createSphereRepresentation(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms), ic.sphereRadius, undefined, undefined, bHighlight);
              }
              else if(style === 'dot') {
                ic.sphereCls.createSphereRepresentation(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms), ic.sphereRadius, false, ic.dotSphereScale, bHighlight);
              }
            } // end for loop

            if(ic.cnt > ic.maxmaxatomcnt) { // release memory
                ic.init_base();
            }

            // hide the previous labels
            if(ic.labels !== undefined && Object.keys(ic.labels).length > 0) {
                ic.labelCls.hideLabels();

                // change label color
                for(let labeltype in ic.labels) {
                    if(labeltype != 'schematic') this.changeLabelColor(ic.labels[labeltype]);
                }

                // labels
                ic.labelCls.createLabelRepresentation(ic.labels);
            }
        }

        changeLabelColor(labelArray) { let ic = this.icn3d; ic.icn3dui;
            if(labelArray) {
                for(let i = 0, il = labelArray.length; i < il; ++i) {
                    let label = labelArray[i];
                    if((ic.opts.background != 'black') && label.color == ic.colorBlackbkgd) {
                        label.color = ic.colorWhitebkgd;
                    }
                    else if((ic.opts.background == 'black') && label.color == ic.colorWhitebkgd) {
                        label.color = ic.colorBlackbkgd;
                    }
                }
            }
        }

        selectMainChainSubset(atoms) { let ic = this.icn3d; ic.icn3dui;
            let nuclMainArray = ["C1'", "C1*", "C2'", "C2*", "C3'", "C3*", "C4'", "C4*", "C5'", "C5*", "O3'", "O3*", "O4'", "O4*", "O5'", "O5*", "P", "OP1", "O1P", "OP2", "O2P"];

            let atomHash = {};
            for(let i in atoms) {
                if( (ic.proteins.hasOwnProperty(i) && (ic.atoms[i].name === "N" || ic.atoms[i].name === "C" || ic.atoms[i].name === "O"
                  || (ic.atoms[i].name === "CA" && ic.atoms[i].elem === "C") ) )
                  || (ic.nucleotides.hasOwnProperty(i) && nuclMainArray.indexOf(ic.atoms[i].name) !== -1) ) {
                    atomHash[i] = 1;
                }
            }

            return atomHash;
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class ApplyOther {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Apply the rest options (e.g., hydrogen bonds, center, etc).
        applyOtherOptions(options) { let ic = this.icn3d, me = ic.icn3dui;
                if(options === undefined) options = ic.opts;

        //    if(ic.lines !== undefined) {
                // contact lines
                ic.hBondCls.setHbondsContacts(options, 'contact');

                // halogen lines
                ic.hBondCls.setHbondsContacts(options, 'halogen');
                // pi-cation lines
                ic.hBondCls.setHbondsContacts(options, 'pi-cation');
                // pi-stacking lines
                ic.hBondCls.setHbondsContacts(options, 'pi-stacking');

                // hbond lines
                ic.hBondCls.setHbondsContacts(options, 'hbond');
                // salt bridge lines
                ic.hBondCls.setHbondsContacts(options, 'saltbridge');
                if (ic.pairArray !== undefined && ic.pairArray.length > 0) {
                    this.updateStabilizer(); // to update ic.stabilizerpnts

                    let color = '#FFFFFF';
                    let pnts = ic.stabilizerpnts;
                    ic.lines['stabilizer'] = []; // reset
                    for (let i = 0, lim = Math.floor(pnts.length / 2); i < lim; i++) {
                        let line = {};
                        line.position1 = pnts[2 * i];
                        line.position2 = pnts[2 * i + 1];
                        line.color = color;
                        line.dashed = false; // if true, there will be too many cylinders in the dashed lines

                        ic.lines['stabilizer'].push(line);
                    }
                }

                ic.lineCls.createLines(ic.lines);
        //    }

            // distance sets
            if(ic.distPnts && ic.distPnts.length > 0) {
                for(let i = 0, il = ic.distPnts.length; i < il; ++i) {
                   ic.boxCls.createBox_base(ic.distPnts[i], ic.originSize, ic.hColor, false);
                }
            }

            // maps
            if(ic.prevMaps !== undefined) {
                for(let i = 0, il = ic.prevMaps.length; i < il; ++i) {
                    ic.mdl.add(ic.prevMaps[i]);
                }
            }

            // EM map
            if(ic.prevEmmaps !== undefined) {
                for(let i = 0, il = ic.prevEmmaps.length; i < il; ++i) {
                    ic.mdl.add(ic.prevEmmaps[i]);
                }
            }

            if(ic.prevPhimaps !== undefined) {
                for(let i = 0, il = ic.prevPhimaps.length; i < il; ++i) {
                    ic.mdl.add(ic.prevPhimaps[i]);
                }
            }

            // surfaces
            if(ic.prevSurfaces !== undefined) {
                for(let i = 0, il = ic.prevSurfaces.length; i < il; ++i) {
                    ic.mdl.add(ic.prevSurfaces[i]);
                }
            }

            // symmetry axes and polygon
            if(ic.symmetryHash !== undefined && ic.symmetrytitle !== undefined) {
                ic.applySymdCls.applySymmetry(ic.symmetrytitle);
            }

            if(ic.symdArray !== undefined && ic.symdArray.length > 0) {
                //var bSymd = true;
                //ic.applySymmetry(ic.symdtitle, bSymd);
                ic.applySymdCls.applySymd();
            }

            // other meshes
            if(ic.prevOtherMesh !== undefined) {
                for(let i = 0, il = ic.prevOtherMesh.length; i < il; ++i) {
                    ic.mdl.add(ic.prevOtherMesh[i]);
                }
            }

            if(ic.bInitial && ic.bGlycansCartoon === undefined) {
                if(me.htmlCls.setHtmlCls.getCookie('glycan') != '') {
                    let bGlycansCartoon = parseInt(me.htmlCls.setHtmlCls.getCookie('glycan'));

                    if(ic.bGlycansCartoon != bGlycansCartoon) {
                        me.htmlCls.clickMenuCls.setLogCmd('set glycan ' + bGlycansCartoon, true);
                    }

                    ic.bGlycansCartoon = bGlycansCartoon;
                }
            }

            // add cartoon for glycans
            if(ic.bGlycansCartoon && !ic.bAlternate) {
                ic.glycanCls.showGlycans();
            }

            // add extra spheres or cubes
            for(let command in ic.shapeCmdHash) {
                if(command.substr(0, 8) == 'add cube') {
                    ic.applyCommandCls.addShape(command, 'cube');
                }
                else { // 'add sphere'
                    ic.applyCommandCls.addShape(command, 'sphere');
                }
            }

            ic.applyCenterCls.applyCenterOptions(options);

            ic.axesCls.buildAllAxes(undefined, true);

            switch (options.axis.toLowerCase()) {
                case 'yes':
                    ic.axis = true;
                    ic.axesCls.buildAxes(ic.maxD/2);

                    break;
                case 'no':
                    ic.axis = false;
                    break;
            }
            switch (options.pk.toLowerCase()) {
                case 'atom':
                    ic.pk = 1;
                    break;
                case 'no':
                    ic.pk = 0;
                    break;
                case 'residue':
                    ic.pk = 2;
                    break;
                case 'strand':
                    ic.pk = 3;
                    break;
            }
        }

        applyChemicalbindingOptions(options) { let ic = this.icn3d, me = ic.icn3dui;
            if(options === undefined) options = ic.opts;

            // display mode
            if (options.chemicalbinding === 'show') {
                let startAtoms;
                if(ic.chemicals !== undefined && Object.keys(ic.chemicals).length > 0) { // show chemical-protein interaction
                    startAtoms = me.hashUtilsCls.hash2Atoms(ic.chemicals, ic.atoms);
                }

                // find atoms in chainid1, which interact with chainid2
                let radius = 4;

                if(startAtoms !== undefined) {
                    let targetAtoms = ic.contactCls.getAtomsWithinAtom(ic.atoms, startAtoms, radius);

                    // show hydrogens
                    let threshold = 3.5;
                    ic.opts["hbonds"] = "yes";

                    if(Object.keys(targetAtoms).length > 0) {
                        ic.hBondCls.calculateChemicalHbonds(startAtoms, targetAtoms, parseFloat(threshold) );
                    }

                    // zoom in on the atoms
                    if(!ic.bSetFog) ic.transformCls.zoominSelection( me.hashUtilsCls.unionHash(startAtoms, targetAtoms) );
                }
            }
            else if (options.chemicalbinding === 'hide') {
                // truen off hdonds
                ic.hBondCls.hideHbonds();
                ic.showInterCls.hideExtraBonds();

                // center on the atoms
                if(!ic.bSetFog) ic.transformCls.zoominSelection(ic.atoms);
            }
        }

        updateStabilizer() { let ic = this.icn3d; ic.icn3dui;
            ic.stabilizerpnts = [];

            if(ic.pairArray !== undefined) {
                for(let i = 0, il = ic.pairArray.length; i < il; i += 2) {
                    let coordI = this.getResidueRepPos(ic.pairArray[i]);
                    let coordJ = this.getResidueRepPos(ic.pairArray[i + 1]);

                    ic.stabilizerpnts.push(coordI);
                    ic.stabilizerpnts.push(coordJ);
                }
            }
        }

        getResidueRepPos(serial) { let ic = this.icn3d; ic.icn3dui;
            let atomIn = ic.atoms[serial];
            let residueid = atomIn.structure + "_" + atomIn.chain + "_" + atomIn.resi;

            let pos;
            if(!ic.proteins.hasOwnProperty(serial) && !ic.nucleotides.hasOwnProperty(serial)) { // chemicals or ions
                pos = atomIn.coord;
            }
            else {
                for(let i in ic.residues[residueid]) {
                    let atom = ic.atoms[i];
                    if(atom.name === 'N3') { // nucleotide: N3
                        pos = ic.atoms[i].coord;
                        break;
                    }
                    else if(atom.name === 'CA' && atom.ss == 'coil') { // protein coil: CA
                        pos = ic.atoms[i].coord;
                        break;
                    }
                    else if(atom.name === 'CA' && (atom.ss == 'helix' || atom.ss == 'sheet')) { // protein secondary: CA
                        pos = (ic.atoms[i].coord2 !== undefined) ? ic.atoms[i].coord2 : ic.atoms[i].coord;
                        break;
                    }
                }
            }

            if(pos === undefined) pos = atomIn.coord;

            return pos;
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class ApplySsbonds {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Apply the disulfide bond options.
        applySsbondsOptions(options) { let ic = this.icn3d, me = ic.icn3dui;
            if(options === undefined) options = ic.opts;

            if (options.ssbonds.toLowerCase() === 'yes' && ic.ssbondpnts !== undefined) {
              let color = '#FFFF00';
              let colorObj = me.parasCls.thr(0xFFFF00);

              let structureArray = Object.keys(ic.structures);
              let start, end;

              if(ic.bAlternate) {
                  let nStructures = structureArray.length;
                  start = ic.ALTERNATE_STRUCTURE % nStructures;
                  end = ic.ALTERNATE_STRUCTURE % nStructures + 1;
              }
              else {
                //   let structureHash = me.utilsCls.getDisplayedStructures();
                //   structureArray = Object.keys(structureHash);

                  start = 0;
                  end = structureArray.length;
              }

              ic.lines['ssbond'] = [];

              for(let s = start, sl = end; s < sl; ++s) {
                  let structure = structureArray[s];

                  if(!ic.ssbondpnts[structure]) continue;

                  //for(let i = 0, lim = Math.floor(ic.ssbondpnts[structure].length / 2); i < lim; i++) {
                  for(let i = Math.floor(ic.ssbondpnts[structure].length / 2) - 1; i >= 0; i--) {
                    let res1 = ic.ssbondpnts[structure][2 * i], res2 = ic.ssbondpnts[structure][2 * i + 1];

                    let line = {};
                    line.color = color;
                    line.dashed = false;

                    // each Cys has two S atoms
                    let serial1Array = [], serial2Array = [];
                    let position1Array = [], position2Array = [];

                    let bFound = false, bCalpha = false;
                    for(let j in ic.residues[res1]) {
                        if(ic.atoms[j].name === 'SG') {
                            position1Array.push(ic.atoms[j].coord);
                            serial1Array.push(ic.atoms[j].serial);
                            bFound = true;
                        }
                    }

                    if(!bFound) {
                        for(let j in ic.residues[res1]) {
                            if(ic.atoms[j].name === 'CA') {
                                position1Array.push(ic.atoms[j].coord);
                                serial1Array.push(ic.atoms[j].serial);
                                bFound = true;
                                bCalpha = true;
                                break;
                            }
                        }
                    }

                    bFound = false;
                    for(let j in ic.residues[res2]) {
                        if(ic.atoms[j].name === 'SG') {
                            position2Array.push(ic.atoms[j].coord);
                            serial2Array.push(ic.atoms[j].serial);
                            bFound = true;
                        }
                    }

                    if(!bFound) {
                        for(let j in ic.residues[res2]) {
                            if(ic.atoms[j].name === 'CA') {
                                position2Array.push(ic.atoms[j].coord);
                                serial2Array.push(ic.atoms[j].serial);
                                bFound = true;
                                bCalpha = true;
                                break;
                            }
                        }
                    }

                    // determine whether it's true disulfide bonds
                    // disulfide bond is about 2.05 angstrom
                    let distMax = (bCalpha) ? 7.0 : 3.0;

                    let bSsbond = false;
                    for(let m = 0, ml = position1Array.length; m < ml; ++m) {
                        for(let n = 0, nl = position2Array.length; n < nl; ++n) {
                            if(position1Array[m].distanceTo(position2Array[n]) < distMax) {
                                bSsbond = true;

                                line.serial1 = serial1Array[m];
                                line.position1 = position1Array[m];

                                line.serial2 = serial2Array[n];
                                line.position2 = position2Array[n];

                                break;
                            }
                        }
                    }

                    // only draw bonds connected with currently displayed atoms
                    if(line.serial1 !== undefined && line.serial2 !== undefined && !ic.dAtoms.hasOwnProperty(line.serial1) && !ic.dAtoms.hasOwnProperty(line.serial2)) continue;

                    //if(line.position1 === undefined || line.position2 === undefined || line.position1.distanceTo(line.position2) > distMax) {
                    if(!bSsbond) {
                        ic.ssbondpnts[structure].splice(2 * i, 2);
                        continue;
                    }

                    //if(ic.atoms[serial1].ids !== undefined) { // mmdb id as input
                        // remove the original disulfide bonds
                        let pos = ic.atoms[line.serial1].bonds.indexOf(line.serial2);
                        let array1, array2;
                        if(pos != -1) {
                            array1 = ic.atoms[line.serial1].bonds.slice(0, pos);
                            array2 = ic.atoms[line.serial1].bonds.slice(pos + 1);

                            ic.atoms[line.serial1].bonds = array1.concat(array2);
                        }

                        pos = ic.atoms[line.serial2].bonds.indexOf(line.serial1);
                        if(pos != -1) {
                            array1 = ic.atoms[line.serial2].bonds.slice(0, pos);
                            array2 = ic.atoms[line.serial2].bonds.slice(pos + 1);

                            ic.atoms[line.serial2].bonds = array1.concat(array2);
                        }
                    //}

                    //if(ic.lines['ssbond'] === undefined) ic.lines['ssbond'] = [];
                    ic.lines['ssbond'].push(line);

                    // show ball and stick for these two residues
                    let residueAtoms;
                    residueAtoms = me.hashUtilsCls.unionHash(residueAtoms, ic.residues[res1]);
                    residueAtoms = me.hashUtilsCls.unionHash(residueAtoms, ic.residues[res2]);

                    let atom = ic.firstAtomObjCls.getFirstAtomObj(residueAtoms);
                    let style = (atom.style == 'lines') ? 'lines' : 'stick';

                    // create bonds for disulfide bonds
                    if(atom.style != 'lines') ic.cylinderCls.createCylinder(line.position1, line.position2, ic.cylinderRadius, colorObj);

                    // show side chains for the selected atoms
                    let atoms = me.hashUtilsCls.intHash(residueAtoms, ic.sidec);
        //            let calpha_atoms = me.hashUtilsCls.intHash(residueAtoms, ic.calphas);
                    // include calphas
        //            atoms = me.hashUtilsCls.unionHash(atoms, calpha_atoms);

                    // draw sidec separately
                    for(let j in atoms) {
                      ic.atoms[j].style2 = style;
                    }
                  } // for(let i = 0,
              } // for(let s = 0,
            } // if (options.ssbonds.toLowerCase() === 'yes'
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class ApplySymd {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        applySymd() { let ic = this.icn3d; ic.icn3dui;
            for(let i = 0, il = ic.symdArray.length; i < il; ++i) {
                let symdHash = ic.symdArray[i];
                let title = Object.keys(symdHash)[0];
                this.applySymmetry(title, true, symdHash[title]);
            }
        }

        applySymmetry(title, bSymd, inDataArray) { let ic = this.icn3d, me = ic.icn3dui;
            //var dataArray = (bSymd) ? ic.symdHash[title] : ic.symmetryHash[title]; // start_end_colorAxis_colorPolygon_order_chain
            let dataArray = (bSymd) ? inDataArray : ic.symmetryHash[title]; // start_end_colorAxis_colorPolygon_order_chain
            if(!dataArray) dataArray = [];

            let symmetryType = title.substr(0, 1);
            let nSide = parseInt(title.substring(1, title.indexOf(' ')));

            //var axisRadius = 2 * ic.cylinderRadius * ic.oriMaxD / 150;
            //var polygonRadius = 1 * ic.cylinderRadius * ic.oriMaxD / 150;

            let axisRadius = 1.5 * ic.cylinderRadius;
            let polygonRadius = 1 * ic.cylinderRadius;

            let pointArray = [];
            for(let i = 0, il = dataArray.length; i < il; ++i) {
                let start = dataArray[i][0];
                let end = dataArray[i][1];
                let colorAxis = dataArray[i][2];
                let colorPolygon = dataArray[i][3];
                let order = dataArray[i][4];
                let chain = dataArray[i][5];

                ic.cylinderCls.createCylinder(start, end, axisRadius, colorAxis, 0);

                let SymAxis = end.clone().sub(start).normalize();
                me.htmlCls.clickMenuCls.setLogCmd('Symmetry Axis: ' + SymAxis.x.toFixed(3) + " " + SymAxis.y.toFixed(3) + " " + SymAxis.z.toFixed(3), false);     

                if(ic.bAxisOnly) continue;

                if(symmetryType == 'C' || (symmetryType == 'D' && order == nSide) ) {
                    // find the center and size of the selected protein chain

                    let selection = {};
                    // check the number of chains
                    Object.keys(ic.chains).length;
                    let bMultiChain = false;
                    let chainHashTmp = {};

                    if(bSymd && Object.keys(ic.hAtoms).length < Object.keys(ic.atoms).length) {
                        for(let serial in ic.hAtoms) {
                            let atom = ic.atoms[serial];
                            let chainid = atom.structure + '_' + atom.chain;
                            chainHashTmp[chainid] = 1;
                        }

                        if(Object.keys(chainHashTmp).length > 1) {
                            bMultiChain = true;
                        }
                    }

                    //if(!bSymd || bMultiChain || Object.keys(ic.hAtoms).length < Object.keys(ic.atoms).length) {
                    if(!bSymd) {
                        let selectedChain = Object.keys(ic.structures)[0] + '_' + chain;

                        if(!ic.chains.hasOwnProperty(selectedChain)) {
                            selectedChain = Object.keys(ic.structures)[0] + '_' + chain.toLowerCase();
                        }

                        if(!ic.chains.hasOwnProperty(selectedChain)) {
                            selectedChain = Object.keys(ic.chains)[0];
                            for(let chainid in ic.chains) {
                                let firstSerial = Object.keys(ic.chains[chainid])[0];
                                if(ic.proteins.hasOwnProperty(firstSerial)) {
                                    selectedChain = chainid;
                                    break;
                                }
                            }
                        }
                        selection = ic.chains[selectedChain];
                    }
                    else if(bMultiChain) {
                        let selectedChain = Object.keys(chainHashTmp)[0];
                        selection = ic.chains[selectedChain];
                    }
                    else { // bSymd, subset, and one chain
                        if(Object.keys(ic.hAtoms).length == 0) {
                            ic.hAtoms = me.hashUtilsCls.cloneHash(ic.dAtoms);
                        }

                        // pick the first 1/order of selection
                        let cnt = parseInt(Object.keys(ic.hAtoms).length / order);
                        let j = 0, lastSerial;

                        for(let serial in ic.hAtoms) {
                            selection[serial] = 1;
                            lastSerial = serial;
                            ++j;
                            if(j > cnt) break;
                        }

                        // add the whole residue for the last serial
                        let resid = ic.atoms[lastSerial].structure + '_' + ic.atoms[lastSerial].chain + '_' + ic.atoms[lastSerial].resi;
                        selection = me.hashUtilsCls.unionHash(selection, ic.residues[resid]);
                    }


                    let middle = start.clone().add(end).multiplyScalar(0.5);

                    let psum = new THREE.Vector3();
                    let cnt = 0;

                    // apply the transformation to make the axis in the z-axis
                    let axis = end.clone().sub(start).normalize();
                    let vTo = new THREE.Vector3(0, 0, 1);

                    let quaternion = new THREE.Quaternion();
                    quaternion.setFromUnitVectors (axis, vTo);

                    let distSqMax = -9999;
                    for (let serial in selection) {
                        let atom = ic.atoms[serial];
                        let coord = atom.coord.clone();
                        psum.add(coord);

                        coord.sub(middle).applyQuaternion(quaternion);

                        let distSq = coord.x*coord.x + coord.y*coord.y;

                        if(distSq > distSqMax) distSqMax = distSq;

                        ++cnt;
                    }

                    //let center = psum.multiplyScalar(1.0 / cnt);
                    let center = ic.ParserUtilsCls.getMassCenter(psum, cnt);

                    let line = new THREE.Line3(start, end);

                    // project center on line
                    let proj = new THREE.Vector3();
                    line.closestPointToPoint(center, true, proj);

                    let rLen = Math.sqrt(distSqMax);

                    let rDir = center.clone().sub(proj).normalize().multiplyScalar(rLen);

                    //var start2 = start.clone().add(rDir);
                    //var end2 = end.clone().add(rDir);

                    let start2 = middle.clone().add(start.clone().sub(middle).multiplyScalar(0.83)).add(rDir);
                    let end2 = middle.clone().add(end.clone().sub(middle).multiplyScalar(0.83)).add(rDir);

                    //var axis = end.clone().sub(start).normalize();
                    let anglePerSide = 2*Math.PI / nSide;

                    let startInit, endInit, startPrev, endPrev;
                    for(let j = 0; j < nSide; ++j) {
                        let angle = (0.5 + j) * anglePerSide;

                        let startCurr = start2.clone().sub(start);
                        startCurr.applyAxisAngle(axis, angle).add(start);

                        let endCurr = end2.clone().sub(start);
                        endCurr.applyAxisAngle(axis, angle).add(start);

                        ic.cylinderCls.createCylinder(startCurr, endCurr, polygonRadius, colorPolygon, 0);

                        ic.sphereCls.createSphereBase(startCurr, colorPolygon, polygonRadius, 1.0, 0);
                        ic.sphereCls.createSphereBase(endCurr, colorPolygon, polygonRadius, 1.0, 0);

                        if(j == 0) {
                            startInit = startCurr;
                            endInit = endCurr;
                        }
                        else {
                            ic.cylinderCls.createCylinder(startCurr, startPrev, polygonRadius, colorPolygon, 0);
                            ic.cylinderCls.createCylinder(endCurr, endPrev, polygonRadius, colorPolygon, 0);
                        }

                        startPrev = startCurr;
                        endPrev = endCurr;
                    }

                    if(startInit && startPrev) ic.cylinderCls.createCylinder(startInit, startPrev, polygonRadius, colorPolygon, 0);
                    if(endInit && endPrev) ic.cylinderCls.createCylinder(endInit, endPrev, polygonRadius, colorPolygon, 0);
                }
                else if( (symmetryType == 'T' && order == 3)
                  || (symmetryType == 'O' && order == 4)
                  || (symmetryType == 'I' && order == 5) ) {
                    pointArray.push(start);
                    pointArray.push(end);
                }
                else ;

                if(symmetryType == 'T') {
                    let pos1 = pointArray[0]; // pointArray: start, end, start, end, ...
                    ic.sphereCls.createSphereBase(pos1, colorPolygon, polygonRadius, 1.0, 0);

                    let dist2 = pos1.distanceTo(pointArray[2]);
                    let dist3 = pos1.distanceTo(pointArray[3]);

                    let distSmall, posSel;
                    if(dist2 < dist3) {
                        distSmall = dist2;
                        posSel = pointArray[3];
                    }
                    else {
                        distSmall = dist3;
                        posSel = pointArray[2];
                    }

                    ic.sphereCls.createSphereBase(posSel, colorPolygon, polygonRadius, 1.0, 0);
                    ic.cylinderCls.createCylinder(pos1, posSel, polygonRadius, colorPolygon, 0);

                    let iPrev;
                    for(let i = 4, il = pointArray.length; i < il; ++i) {
                        let pos2 = pointArray[i];

                        let dist = pos1.distanceTo(pos2);
                        if(dist > distSmall) {
                            ic.sphereCls.createSphereBase(pos2, colorPolygon, polygonRadius, 1.0, 0);
                            ic.cylinderCls.createCylinder(pos1, pos2, polygonRadius, colorPolygon, 0);

                            ic.cylinderCls.createCylinder(posSel, pos2, polygonRadius, colorPolygon, 0);
                            if(iPrev !== undefined) {
                                ic.cylinderCls.createCylinder(pointArray[iPrev], pos2, polygonRadius, colorPolygon, 0);
                            }

                            iPrev = i;
                        }
                    }
                }
                else if(symmetryType == 'O') {
                    for(let i = 0, il = pointArray.length; i < il; i += 2) {
                        let pos1 = pointArray[i];
                        let pos2 = pointArray[i+1];
                        ic.sphereCls.createSphereBase(pos1, colorPolygon, polygonRadius, 1.0, 0);
                        ic.sphereCls.createSphereBase(pos2, colorPolygon, polygonRadius, 1.0, 0);
                        for(let j = i + 2, jl = pointArray.length; j < jl; ++j) {
                            let pos3 = pointArray[j];
                            ic.sphereCls.createSphereBase(pos3, colorPolygon, polygonRadius, 1.0, 0);
                            ic.cylinderCls.createCylinder(pos1, pos3, polygonRadius, colorPolygon, 0);
                            ic.cylinderCls.createCylinder(pos2, pos3, polygonRadius, colorPolygon, 0);
                        }
                    }
                }
                else if(symmetryType == 'I') {
                    for(let i = 0, il = pointArray.length; i < il; i += 2) {
                        let pos1 = pointArray[i];
                        let pos2 = pointArray[i+1];
                        ic.sphereCls.createSphereBase(pos1, colorPolygon, polygonRadius, 1.0, 0);
                        ic.sphereCls.createSphereBase(pos2, colorPolygon, polygonRadius, 1.0, 0);
                        for(let j = i + 2, jl = pointArray.length; j < jl; j += 2) {
                            let pos3 = pointArray[j];
                            let pos4 = pointArray[j+1];

                            let dist3 = pos1.distanceTo(pos3);
                            let dist4 = pos1.distanceTo(pos4);

                            let pos1Sel, pos2Sel;
                            if(dist3 < dist4) {
                                pos1Sel = pos3;
                                pos2Sel = pos4;
                            }
                            else {
                                pos1Sel = pos4;
                                pos2Sel = pos3;
                            }

                            ic.sphereCls.createSphereBase(pos1Sel, colorPolygon, polygonRadius, 1.0, 0);
                            ic.sphereCls.createSphereBase(pos2Sel, colorPolygon, polygonRadius, 1.0, 0);
                            ic.cylinderCls.createCylinder(pos1, pos1Sel, polygonRadius, colorPolygon, 0);
                            ic.cylinderCls.createCylinder(pos2, pos2Sel, polygonRadius, colorPolygon, 0);
                        }
                    }
                }
            }
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class ApplyMap {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Apply the surface options.
        applySurfaceOptions(options) { let ic = this.icn3d, me = ic.icn3dui;
            if(options === undefined) options = ic.opts;

            //switch (options.wirefraic.toLowerCase()) {
            switch (options.wireframe) {
                case 'yes':
                    options.wireframe = true;
                    break;
                case 'no':
                    options.wireframe = false;
                    break;
            }

            options.opacity = parseFloat(options.opacity);

            let atoms, currAtoms;

            // only show the surface for atoms which are displaying
            atoms = me.hashUtilsCls.intHash(ic.dAtoms, ic.hAtoms);
            // exclude water molecules
            if(options['water'] === 'nothing') atoms = me.hashUtilsCls.exclHash(atoms, ic.water);

            currAtoms = me.hashUtilsCls.hash2Atoms(atoms, ic.atoms);

            switch (options.surface.toLowerCase()) {
                case 'van der waals surface':
                    ic.surfaceCls.createSurfaceRepresentation(currAtoms, 1, options.wireframe, options.opacity);
                    break;
        //            case 'solvent excluded surface':
        //                ic.surfaceCls.createSurfaceRepresentation(currAtoms, 2, options.wireframe, options.opacity);
        //                break;
                case 'solvent accessible surface':
                    ic.surfaceCls.createSurfaceRepresentation(currAtoms, 3, options.wireframe, options.opacity);
                    break;
                case 'molecular surface':
                    ic.surfaceCls.createSurfaceRepresentation(currAtoms, 2, options.wireframe, options.opacity);
                    break;
                case 'van der waals surface with context':
                    ic.surfaceCls.createSurfaceRepresentation(currAtoms, 1, options.wireframe, options.opacity);
                    break;
                case 'solvent accessible surface with context':
                    ic.surfaceCls.createSurfaceRepresentation(currAtoms, 3, options.wireframe, options.opacity);
                    break;
                case 'molecular surface with context':
                    ic.surfaceCls.createSurfaceRepresentation(currAtoms, 2, options.wireframe, options.opacity);
                    break;
                case 'nothing':
                    // remove surfaces
                    this.removeSurfaces();
                    break;
            }
        }

        //Apply options for electron density map.
        applyMapOptions(options) { let ic = this.icn3d, me = ic.icn3dui;
            if(options === undefined) options = ic.opts;

            switch (options.mapwireframe) {
                case 'yes':
                    options.mapwireframe = true;
                    break;
                case 'no':
                    options.mapwireframe = false;
                    break;
            }

            let atoms, currAtoms;

            // only show the surface for atoms which are displaying
            atoms = me.hashUtilsCls.intHash(ic.dAtoms, ic.hAtoms);

            currAtoms = me.hashUtilsCls.hash2Atoms(atoms, ic.atoms);

            switch (options.map.toLowerCase()) {
                case '2fofc':
                    ic.surfaceCls.createSurfaceRepresentation(currAtoms, 11, options.mapwireframe);
                    break;
                case 'fofc':
                    ic.surfaceCls.createSurfaceRepresentation(currAtoms, 12, options.mapwireframe);
                    break;
                case 'nothing':
                    // remove surfaces
                    this.removeMaps();
                    break;
            }
        }

        //Apply options for EM density map.
        applyEmmapOptions(options) { let ic = this.icn3d, me = ic.icn3dui;
            if(options === undefined) options = ic.opts;

            switch (options.emmapwireframe) {
                case 'yes':
                    options.emmapwireframe = true;
                    break;
                case 'no':
                    options.emmapwireframe = false;
                    break;
            }

            let atoms, currAtoms;

            // only show the surface for atoms which are displaying
            atoms = me.hashUtilsCls.intHash(ic.dAtoms, ic.hAtoms);

            currAtoms = me.hashUtilsCls.hash2Atoms(atoms, ic.atoms);

            switch (options.emmap.toLowerCase()) {
                case 'em':
                    ic.surfaceCls.createSurfaceRepresentation(currAtoms, 13, options.emmapwireframe);
                    break;
                case 'nothing':
                    // remove surfaces
                    this.removeEmmaps();
                    break;
            }
        }

        applyPhimapOptions(options) { let ic = this.icn3d, me = ic.icn3dui;
            if(options === undefined) options = ic.opts;

            switch (options.phimapwireframe) {
                case 'yes':
                    options.phimapwireframe = true;
                    break;
                case 'no':
                    options.phimapwireframe = false;
                    break;
            }

            let atoms, currAtoms;

            // only show the surface for atoms which are displaying
            atoms = me.hashUtilsCls.intHash(ic.dAtoms, ic.hAtoms);

            currAtoms = me.hashUtilsCls.hash2Atoms(atoms, ic.atoms);

            switch (options.phimap.toLowerCase()) {
                case 'phi':
                    ic.surfaceCls.createSurfaceRepresentation(currAtoms, 14, options.phimapwireframe);
                    break;
                case 'nothing':
                    // remove surfaces
                    this.removePhimaps();
                    break;
            }
        }

        applyphisurfaceOptions(options) { let ic = this.icn3d, me = ic.icn3dui;
            if(options === undefined) options = ic.opts;

            //switch (options.wirefraic.toLowerCase()) {
            switch (ic.phisurfwf) {
                case 'yes':
                    options.phisurfwf = true;
                    break;
                case 'no':
                    options.phisurfwf = false;
                    break;
            }

            options.phisurfop = parseFloat(ic.phisurfop);

            let atoms, currAtoms;

            // only show the surface for atoms which are displaying
            atoms = me.hashUtilsCls.intHash(ic.dAtoms, ic.hAtoms);
            // exclude water molecules
            if(options['water'] === 'nothing') atoms = me.hashUtilsCls.exclHash(atoms, ic.water);

            currAtoms = me.hashUtilsCls.hash2Atoms(atoms, ic.atoms);

            switch (options.phisurface.toLowerCase()) {
                case 'phi':
                    ic.surfaceCls.createSurfaceRepresentation(currAtoms, parseInt(ic.phisurftype), options.phisurfwf, options.phisurfop);
                    break;
                case 'nothing':
                    // remove surfaces
                    this.removeSurfaces();
                    break;
            }
        }

        //Remove previously drawn surfaces.
        removeSurfaces() { let ic = this.icn3d; ic.icn3dui;
           // remove prevous highlight
           for(let i = 0, il = ic.prevSurfaces.length; i < il; ++i) {
               ic.mdl.remove(ic.prevSurfaces[i]);
           }

           ic.prevSurfaces = [];
        }

        removeLastSurface() { let ic = this.icn3d; ic.icn3dui;
           // remove prevous highlight
           if(ic.prevSurfaces.length > 0) {
               ic.mdl.remove(ic.prevSurfaces[ic.prevSurfaces.length - 1]);
               ic.prevSurfaces.slice(ic.prevSurfaces.length - 1, 1);
           }
        }

        removeMaps() { let ic = this.icn3d; ic.icn3dui;
           // remove prevous highlight
           for(let i = 0, il = ic.prevMaps.length; i < il; ++i) {
               ic.mdl.remove(ic.prevMaps[i]);
           }

           ic.prevMaps = [];
        }

        removeEmmaps() { let ic = this.icn3d; ic.icn3dui;
           // remove prevous highlight
           for(let i = 0, il = ic.prevEmmaps.length; i < il; ++i) {
               ic.mdl.remove(ic.prevEmmaps[i]);
           }

           ic.prevEmmaps = [];
        }

        removePhimaps() { let ic = this.icn3d; ic.icn3dui;
           // remove prevous highlight

           for(let i = 0, il = ic.prevPhimaps.length; i < il; ++i) {
               ic.mdl.remove(ic.prevPhimaps[i]);
           }

           ic.prevPhimaps = [];
        }

        removeLastMap() { let ic = this.icn3d; ic.icn3dui;
           // remove prevous highlight
           if(ic.prevMaps.length > 0) {
               ic.mdl.remove(ic.prevMaps[ic.prevMaps.length - 1]);
               ic.prevMaps.slice(ic.prevMaps.length - 1, 1);
           }
        }

        removeLastEmmap() { let ic = this.icn3d; ic.icn3dui;
           // remove prevous highlight
           if(ic.prevEmmaps.length > 0) {
               ic.mdl.remove(ic.prevEmmaps[ic.prevEmmaps.length - 1]);
               ic.prevEmmaps.slice(ic.prevEmmaps.length - 1, 1);
           }
        }

        removeLastPhimap() { let ic = this.icn3d; ic.icn3dui;
           // remove prevous highlight
           if(ic.prevPhimaps.length > 0) {
               ic.mdl.remove(ic.prevPhimaps[ic.prevPhimaps.length - 1]);
               ic.prevPhimaps.slice(ic.prevPhimaps.length - 1, 1);
           }
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class ResidueLabels {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Add labels for all residues containing the input "atoms". The labels are one-letter residue abbreviations.
        //If "bSchematic" is true, the labels are in circles. Otherwise, they are in round-corner rectangles.
        addResidueLabels(atoms, bSchematic, alpha, bNumber, bRefnum) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            let size = 18;
            let background = "#FFFFFF"; //"#CCCCCC";

            let atomsHash = me.hashUtilsCls.intHash(ic.hAtoms, atoms);

            if(bSchematic) {
                if(ic.labels['schematic'] === undefined) ic.labels['schematic'] = [];
            }
            else {
                if(ic.labels['residue'] === undefined) ic.labels['residue'] = [];
            }

            let prevReidueID = '';
            for(let i in atomsHash) {
                let atom = ic.atoms[i];

                // allow chemicals
                //if(atom.het) continue;

                let label = {}; // Each label contains 'position', 'text', 'color', 'background'

                let currReidueID = atom.structure + '_' + atom.chain + '_' + atom.resi;

                if( (!atom.het && (atom.name === 'CA' || atom.name === "O3'" || atom.name === "O3*") )
                  || ic.water.hasOwnProperty(atom.serial)
                  || ic.ions.hasOwnProperty(atom.serial)
                  || (ic.chemicals.hasOwnProperty(atom.serial) && currReidueID !== prevReidueID) ) {
                    label.position = atom.coord;

                    label.bSchematic = 0;
                    if(bSchematic) label.bSchematic = 1;

                    label.text = me.utilsCls.residueName2Abbr(atom.resn);
                    if(bNumber) {
                        label.text += atom.resi;
                        //label.factor = 0.3;
                    }
                    else if(bRefnum) {
                        let resid = atom.structure + '_' + atom.chain + '_' + atom.resi;
                        let refnum = '';
                        if(ic.resid2refnum[resid]) {
                            refnum = (ic.resid2refnum[resid].substr(0, 1) == ' ') ? '' : ic.resid2refnum[resid];
                        }

                        label.text = refnum;
                    }
                    label.size = size;
                    label.factor = 0.3;

                    let atomColorStr = atom.color.getHexString().toUpperCase();
                    //label.color = (ic.opts.background != 'black') ? ic.colorWhitebkgd : ic.colorBlackbkgd; //(atomColorStr === "CCCCCC" || atomColorStr === "C8C8C8") ? "#888888" : "#" + atomColorStr;
                    //if(bSchematic) label.color = (atomColorStr === "CCCCCC" || atomColorStr === "C8C8C8") ? "#888888" : "#" + atomColorStr;
                    // don't change residue labels
                    if(bNumber) {
                        label.color = (ic.opts.background != 'black') ? ic.colorWhitebkgd : ic.colorBlackbkgd;
                    }
                    else if(bRefnum) {
                        label.color = '#00FFFF';
                    }
                    else {
                        label.color = (atomColorStr === "CCCCCC" || atomColorStr === "C8C8C8") ? "#888888" : "#" + atomColorStr;
                    }
                    label.background = background;
                    //label.alpha = alpha; // ic.labelCls.hideLabels() didn't work. Remove this line for now

                    if(bSchematic) {
                        ic.labels['schematic'].push(label);
                    }
                    else {
                        ic.labels['residue'].push(label);
                    }
                }

                prevReidueID = currReidueID;
            }

            ic.hlObjectsCls.removeHlObjects();
        }

        //Add labels for each Ig domain
        addIgLabels(atoms) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            let size = 60; //18;

            ic.labels['ig'] = [];
            let chainidHash = ic.firstAtomObjCls.getChainsFromAtoms(atoms);

            for(let chainid in ic.igLabel2Pos) {
                if(!chainidHash.hasOwnProperty(chainid)) continue;

                for(let text in ic.igLabel2Pos[chainid]) {
                    let label = {}; // Each label contains 'position', 'text', 'color', 'background'
                    label.position = ic.igLabel2Pos[chainid][text];
                    label.text = text;

                    label.size = size;
                    label.color = '#00FFFF';

                    ic.labels['ig'].push(label);
                }
            }

            ic.hlObjectsCls.removeHlObjects();
        }

        addNonCarbonAtomLabels(atoms) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            let size = 18;
            let background = "#FFFFFF";

            let atomsHash = me.hashUtilsCls.intHash(ic.hAtoms, atoms);

            if(ic.labels['schematic'] === undefined) ic.labels['schematic'] = [];

            for(let i in atomsHash) {
                let atom = ic.atoms[i];

                //if(!atom.het) continue;
                if(!ic.residues.hasOwnProperty(atom.structure + '_' + atom.chain + '_' + atom.resi)) continue;
                if(atom.elem === 'C') continue;

                let label = {}; // Each label contains 'position', 'text', 'color', 'background'

                label.position = atom.coord;

                label.bSchematic = 1;

                label.text = atom.elem;
                label.size = size;

                label.color = (ic.opts.background != 'black') ? ic.colorWhitebkgd : atom.color.getHexString();
                label.background = background;

                ic.labels['schematic'].push(label);
            }

            ic.hlObjectsCls.removeHlObjects();
        };

        addAtomLabels(atoms, bElement) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            let size = 18;
            //let background = (bElement) ? "#FFFFFF" : "#CCCCCC";
            let background = "#FFFFFF";

            let atomsHash = me.hashUtilsCls.intHash(ic.hAtoms, atoms);
            atomsHash = me.hashUtilsCls.intHash(ic.dAtoms, atomsHash);

            if(ic.labels['residue'] === undefined) ic.labels['residue'] = [];

            for(let i in atomsHash) {
                let atom = ic.atoms[i];

                let label = {}; // Each label contains 'position', 'text', 'color', 'background'

                label.position = atom.coord;

                label.bSchematic = 0;

                label.text = (bElement) ? atom.elem : atom.name.padEnd(2, ' ');
                label.size = size;

                if(bElement) {
                    label.bSchematic = true;
                }

                let atomColorStr = atom.color.getHexString().toUpperCase();
                label.color = (ic.opts.background != 'black') ? ic.colorWhitebkgd : ic.colorBlackbkgd; //(atomColorStr === "CCCCCC" || atomColorStr === "C8C8C8") ? "#888888" : "#" + atomColorStr; 
                if(bElement) label.color = (atomColorStr === "CCCCCC" || atomColorStr === "C8C8C8") ? "#888888" : "#" + atomColorStr;
                label.background = background;

                ic.labels['residue'].push(label);
            }

            ic.hlObjectsCls.removeHlObjects();
        };

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Impostor {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        onBeforeRender(renderer, scene, camera, geometry, material, group) {
          let u = material.uniforms;
          let updateList = [];

          if (u.objectId) {
            u.objectId.value = SupportsReadPixelsFloat ? this.id : this.id / 255;
            updateList.push('objectId');
          }

          if (u.modelViewMatrixInverse || u.modelViewMatrixInverseTranspose ||
              u.modelViewProjectionMatrix || u.modelViewProjectionMatrixInverse
          ) {
            this.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, this.matrixWorld);
          }

          if (u.modelViewMatrixInverse) {
            //u.modelViewMatrixInverse.value.getInverse(this.modelViewMatrix);
            u.modelViewMatrixInverse.value.copy( this.modelViewMatrix ).invert();
            updateList.push('modelViewMatrixInverse');
          }

          if (u.modelViewMatrixInverseTranspose) {
            if (u.modelViewMatrixInverse) {
              u.modelViewMatrixInverseTranspose.value.copy(
                u.modelViewMatrixInverse.value
              ).transpose();
            } else {
              //u.modelViewMatrixInverseTranspose.value
              //  .getInverse(this.modelViewMatrix)
              //  .transpose();
              u.modelViewMatrixInverseTranspose.value
                .copy( this.modelViewMatrix )
                .invert()
                .transpose();
            }
            updateList.push('modelViewMatrixInverseTranspose');
          }

          if (u.modelViewProjectionMatrix) {
            camera.updateProjectionMatrix();
            u.modelViewProjectionMatrix.value.multiplyMatrices(
              camera.projectionMatrix, this.modelViewMatrix
            );
            updateList.push('modelViewProjectionMatrix');
          }

          if (u.modelViewProjectionMatrixInverse) {
            let tmpMatrix = new THREE.Matrix4();
            if (u.modelViewProjectionMatrix) {
              tmpMatrix.copy(
                u.modelViewProjectionMatrix.value
              );
              //u.modelViewProjectionMatrixInverse.value.getInverse(
              //  tmpMatrix
              //);
              u.modelViewProjectionMatrixInverse.value.copy( tmpMatrix ).invert();
            } else {
              camera.updateProjectionMatrix();
              tmpMatrix.multiplyMatrices(
                camera.projectionMatrix, this.modelViewMatrix
              );
              //u.modelViewProjectionMatrixInverse.value.getInverse(
              //  tmpMatrix
              //);
              u.modelViewProjectionMatrixInverse.value.copy( tmpMatrix ).invert();
            }
            updateList.push('modelViewProjectionMatrixInverse');
          }

          if (u.projectionMatrix) {
            camera.updateProjectionMatrix();
            u.projectionMatrix.value.copy( camera.projectionMatrix );
            updateList.push('projectionMatrix');
          }

          if (u.projectionMatrixInverse) {
            camera.updateProjectionMatrix();
            //u.projectionMatrixInverse.value.getInverse(camera.projectionMatrix);
            u.projectionMatrixInverse.value.copy( camera.projectionMatrix ).invert();
            updateList.push('projectionMatrixInverse');
          }

          if (updateList.length) {
            let materialProperties = renderer.properties.get(material);

            if (materialProperties.program) {
              let gl = renderer.getContext();
              let p = materialProperties.program;
              gl.useProgram(p.program);
              let pu = p.getUniforms();

              updateList.forEach(function (name) {
                pu.setValue(gl, name, u[ name ].value);
              });
            }
          }
        }

        setParametersForShader (opacity) { let ic = this.icn3d, me = ic.icn3dui;
            let background = me.parasCls.backgroundColors[ic.opts.background.toLowerCase()];
            //if(!background) background = me.parasCls.thr(0x000000);      

            let near = 2.5*ic.maxD;
            let far = 4*ic.maxD;

            let bInstance = (ic.biomtMatrices !== undefined && ic.biomtMatrices.length * ic.cnt > ic.maxatomcnt) ? true : false;

            let nearClip;
            if(ic.opts['slab'] === 'yes') {
                if(bInstance) {
                    nearClip = 0.1;
                }
                else if(ic.camMaxDFactorFog !== undefined) {
                    nearClip = ic.maxD * ic.camMaxDFactorFog - 10; // keep some surrounding residues
                    near = (2.5*ic.maxD - nearClip < 0) ? 0 : 2.5*ic.maxD - nearClip;
                    far = 4*ic.maxD - nearClip;
                }
                else {
                    nearClip = ic.maxD * ic.camMaxDFactor;
                }
            }
            else {
                nearClip = 0.1;
            }

            let opacityValue = (opacity !== undefined) ? opacity : 1.0;

            let shiness = ic.shininess / 100.0 * 0.5;

            ic.uniforms = THREE.UniformsUtils.merge([
              THREE.UniformsLib.common,
              {
                modelViewMatrix: { value: new THREE.Matrix4() },
                modelViewMatrixInverse: { value: new THREE.Matrix4() },
                modelViewMatrixInverseTranspose: { value: new THREE.Matrix4() },
                modelViewProjectionMatrix: { value: new THREE.Matrix4() },
                modelViewProjectionMatrixInverse: { value: new THREE.Matrix4() },
                projectionMatrix: { value: new THREE.Matrix4() },
                projectionMatrixInverse: { value: new THREE.Matrix4() },

                //ambientLightColor: { type: "v3", value: [0.25, 0.25, 0.25] },
                diffuse: { type: "v3", value: [1.0, 1.0, 1.0] },
                emissive: { type: "v3", value: [0.06,0.06,0.06] }, //[0.0,0.0,0.0] },
                roughness: { type: "f", value: 0.5 },
                metalness: { type: "f", value: shiness } , //0.3 },
                opacity: { type: "f", value: opacityValue },
                nearClip: { type: "f", value: nearClip },
                ortho: { type: "f", value: 0.0 },
                shrink: { type: "f", value: 0.13 },
                fogColor: { type: "v3", value: [background.r, background.g, background.b] },
                fogNear: { type: "f", value: near },
                fogFar: { type: "f", value: far },
                fogDensity: { type: "f", value: 2.0 }
              },
                THREE.UniformsLib.ambient,
                THREE.UniformsLib.lights
            ]);

            ic.defines = {
                USE_COLOR: 1,
                //PICKING: 1,
                NEAR_CLIP: 1,
                CAP: 1
            };

            if(ic.opts['fog'] === 'yes' && !bInstance) {
                ic.defines['USE_FOG'] = 1;

                if(ic.opts['camera'] === 'orthographic') {
                    ic.defines['FOG_EXP2'] = 1;
                }
            }

            if(ic.bExtFragDepth) {
                ic.defines['USE_LOGDEPTHBUF_EXT'] = 1;
            }
        }

        drawImpostorShader () { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            this.setParametersForShader();

            this.createImpostorShaderSphere("SphereImpostor");
            this.createImpostorShaderCylinder("CylinderImpostor");
            //this.createImpostorShaderCylinder("HyperballStickImpostor");
        }

        getShader (name) { let ic = this.icn3d; ic.icn3dui;
          let shaderText = $NGL_shaderTextHash[name];
          let reInclude = /#include\s+(\S+)/gmi;

          shaderText = shaderText.replace( reInclude, function( match, p1 ){

                let chunk;
                if(THREE.ShaderChunk.hasOwnProperty(p1)) {
                    chunk = THREE.ShaderChunk[ p1 ];
                }

                return chunk ? chunk : "";

          } );

          return shaderText;
        }

        createImpostorShaderBase(shaderName, mapping, mappingIndices, data, attributeData, count, mappingSize, mappingIndicesSize, mappingItemSize) { let ic = this.icn3d; ic.icn3dui;
          let shaderMaterial =
            new THREE.ShaderMaterial({
              defines: ic.defines,
              uniforms:  ic.uniforms,
              vertexShader:   this.getShader(shaderName + ".vert"),
              fragmentShader: this.getShader(shaderName + ".frag"),
              depthTest: true,
              depthWrite: true,
              //needsUpdate: true, 
              lights: true
          });

          shaderMaterial.extensions.fragDepth = true;

          if(shaderName == 'CylinderImpostor') {
              ic.CylinderImpostorMaterial = shaderMaterial;
          }
          else if(shaderName == 'SphereImpostor') {
              ic.SphereImpostorMaterial = shaderMaterial;
          }

            //MappedBuffer
            let attributeSize = count * mappingSize;

            let n = count * mappingIndicesSize;
            let TypedArray = attributeSize > 65535 ? Uint32Array : Uint16Array;
            let index = new TypedArray( n );

                //makeIndex();
            let ix, it;

            for( let v = 0; v < count; v++ ) {
                ix = v * mappingIndicesSize;
                it = v * mappingSize;

                index.set( mappingIndices, ix );

                for( let s = 0; s < mappingIndicesSize; ++s ){
                    index[ ix + s ] += it;
                }
            }


            let geometry = new THREE.BufferGeometry();

            if( index ){
                geometry.setIndex(
                    new THREE.BufferAttribute( index, 1 )
                );
                //https://discourse.threejs.org/t/what-is-setusage-on-bufferattribute/12441
                geometry.getIndex().setUsage(THREE.DynamicDrawUsage); //.setDynamic( dynamic );
            }

            // add attributes from buffer.js
            let itemSize = {
                "f": 1, "v2": 2, "v3": 3, "c": 3
            };

            for( let name in attributeData ){

                let buf;
                let a = attributeData[ name ];

                    buf = new Float32Array(
                        attributeSize * itemSize[ a.type ]
                    );

                geometry.setAttribute(
                    name,
                    new THREE.BufferAttribute( buf, itemSize[ a.type ] )
                        .setUsage(THREE.DynamicDrawUsage) //.setDynamic( dynamic )
                );

            }

            // set attributes from mapped-buffer.js
            let attributes = geometry.attributes;

            let a, d, itemSize2, array, i, j;

            for( let name in data ){

                d = data[ name ];
                a = attributes[ name ];
                itemSize2 = a.itemSize;
                array = a.array;

                for( let k = 0; k < count; ++k ) {

                    n = k * itemSize2;
                    i = n * mappingSize;

                    for( let l = 0; l < mappingSize; ++l ) {

                        j = i + ( itemSize2 * l );

                        for( let m = 0; m < itemSize2; ++m ) {

                            array[ j + m ] = d[ n + m ];

                        }

                    }

                }

                a.needsUpdate = true;

            }

            // makemapping
            let aMapping = geometry.attributes.mapping.array;

            for( let v = 0; v < count; v++ ) {
                aMapping.set( mapping, v * mappingItemSize * mappingSize );
            }

            let mesh = new THREE.Mesh(geometry, shaderMaterial);

            // important: https://stackoverflow.com/questions/21184061/mesh-suddenly-disappears-in-three-js-clipping
            // You are moving the camera in the CPU. You are moving the vertices of the plane in the GPU
            mesh.frustumCulled = false;

            mesh.scale.x = mesh.scale.y = mesh.scale.z = 1.0;

            if(shaderName == 'CylinderImpostor') {
              mesh.type = 'Cylinder';
            }
            else if(shaderName == 'SphereImpostor') {
              mesh.type = 'Sphere';
            }

            //mesh.onBeforeRender = this.onBeforeRender(ic.renderer, ic.scene, ic.cam, geometry, shaderMaterial);
            mesh.onBeforeRender = this.onBeforeRender;

            ic.mdlImpostor.add(mesh);

            //ic.objects.push(mesh);
        }

        createImpostorShaderCylinder(shaderName) { let ic = this.icn3d; ic.icn3dui;
            let positions = new Float32Array( ic.posArray );
            let colors = new Float32Array( ic.colorArray );
            let positions2 = new Float32Array( ic.pos2Array );
            let colors2 = new Float32Array( ic.color2Array );
            let radii = new Float32Array( ic.radiusArray );

            // cylinder
            let mapping = new Float32Array([
                -1.0,  1.0, -1.0,
                -1.0, -1.0, -1.0,
                 1.0,  1.0, -1.0,
                 1.0,  1.0,  1.0,
                 1.0, -1.0, -1.0,
                 1.0, -1.0,  1.0
            ]);

            let mappingIndices = new Uint16Array([
                0, 1, 2,
                1, 4, 2,
                2, 4, 3,
                4, 5, 3
            ]);

            let mappingIndicesSize = 12;
            let mappingType = "v3";
            let mappingSize = 6;
            let mappingItemSize = 3;


            let count = positions.length / 3;

            let data = {
                "position1": positions,
                "color": colors,
                "position2": positions2,
                "color2": colors2,
                "radius": radii
            };

            let attributeData = {
                "position1": { type: "v3", value: null },
                "color": { type: "v3", value: null },
                "position2": { type: "v3", value: null },
                "color2": { type: "v3", value: null },
                "radius": { type: "f", value: null },
                "mapping": { type: mappingType, value: null }
            };

            this.createImpostorShaderBase(shaderName, mapping, mappingIndices, data, attributeData, count, mappingSize, mappingIndicesSize, mappingItemSize);

            data = null;
            positions = null;
            colors = null;
            positions2 = null;
            colors2 = null;
            radii = null;

          ic.posArray = [];
          ic.colorArray = [];
          ic.pos2Array = [];
          ic.color2Array = [];
          ic.radiusArray = [];
        }

        createImpostorShaderSphere(shaderName) { let ic = this.icn3d; ic.icn3dui;
            let positions = new Float32Array( ic.posArraySphere );
            let colors = new Float32Array( ic.colorArraySphere );
            let radii = new Float32Array( ic.radiusArraySphere );

            // sphere
            let mapping = new Float32Array([
                -1.0,  1.0,
                -1.0, -1.0,
                 1.0,  1.0,
                 1.0, -1.0
            ]);

            let mappingIndices = new Uint16Array([
                0, 1, 2,
                1, 3, 2
            ]);

            let mappingIndicesSize = 6;
            let mappingType = "v2";
            let mappingSize = 4;
            let mappingItemSize = 2;

            let count = positions.length / 3;

            let data = {
                "position": positions,
                "color": colors,
                "radius": radii
            };

            let attributeData = {
                "position": { type: "v3", value: null },
                "color": { type: "v3", value: null },
                "radius": { type: "f", value: null },
                "mapping": { type: mappingType, value: null }
            };

            this.createImpostorShaderBase(shaderName, mapping, mappingIndices, data, attributeData, count, mappingSize, mappingIndicesSize, mappingItemSize);

            data = null;
            positions = null;
            colors = null;
            radii = null;

          ic.posArraySphere = [];
          ic.colorArraySphere = [];
          ic.radiusArraySphere = [];
        }

        clearImpostors() { let ic = this.icn3d; ic.icn3dui;
            ic.posArray = [];
            ic.colorArray = [];
            ic.pos2Array = [];
            ic.color2Array = [];
            ic.radiusArray = [];

            ic.posArraySphere = [];
            ic.colorArraySphere = [];
            ic.radiusArraySphere = [];
        }

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Instancing {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        positionFromGeometry( mesh ){ let ic = this.icn3d; ic.icn3dui;
            let geometry = mesh.geometry;

            let vertices = geometry.vertices;

            let meshPosition = mesh.position;
            let scale = mesh.scale;
            let matrix = mesh.matrix;

            let j, v3;
            let n = vertices.length;
            //var position = new Float32Array( n * 3 );
            let position = [];

            for( let v = 0; v < n; v++ ){

                j = v * 3;

                if(geometry.type == 'SphereGeometry' || geometry.type == 'BoxGeometry') {
                    v3 = vertices[v].clone().multiply(scale).add(meshPosition);
                }
                else if(geometry.type == 'CylinderGeometry') {
                    v3 = vertices[v].clone().applyMatrix4(matrix);
                }
                else {
                    v3 = vertices[v];
                }

                position[ j + 0 ] = v3.x;
                position[ j + 1 ] = v3.y;
                position[ j + 2 ] = v3.z;
            }

            return position;
        }

        colorFromGeometry( mesh ){ let ic = this.icn3d, me = ic.icn3dui;
            let geometry = mesh.geometry;

            let meshColor = me.parasCls.thr(1, 1, 1);
            if(geometry.type == 'SphereGeometry' || geometry.type == 'BoxGeometry' || geometry.type == 'CylinderGeometry') {
                 if(mesh.material !== undefined) meshColor = mesh.material.color;
            }

            let faces = geometry.faces;
            geometry.vertices.length;

            (geometry.type == 'Surface') ? true : false;

            let j, f, c1, c2, c3;
            let n = faces.length;
            //var color = new Float32Array( vn * 3 );
            let color = [];

            for( let v = 0; v < n; v++ ){

                f = faces[ v ];

                if(geometry.type == 'Surface') {
                    c1 = f.vertexColors[0];
                    c2 = f.vertexColors[1];
                    c3 = f.vertexColors[2];
                }
                else if(geometry.type == 'SphereGeometry' || geometry.type == 'BoxGeometry' || geometry.type == 'CylinderGeometry') {
                    c1 = meshColor;
                    c2 = meshColor;
                    c3 = meshColor;
                }
                else {
                    c1 = f.color;
                    c2 = f.color;
                    c3 = f.color;
                }

                j = f.a * 3;
                color[ j + 0 ] = c1.r;
                color[ j + 1 ] = c1.g;
                color[ j + 2 ] = c1.b;

                j = f.b * 3;
                color[ j + 0 ] = c2.r;
                color[ j + 1 ] = c2.g;
                color[ j + 2 ] = c2.b;

                j = f.c * 3;
                color[ j + 0 ] = c3.r;
                color[ j + 1 ] = c3.g;
                color[ j + 2 ] = c3.b;

            }

            return color;
        }

        indexFromGeometry( mesh ){  let ic = this.icn3d; ic.icn3dui;
            let geometry = mesh.geometry;

            let faces = geometry.faces;

            let j, f;
            let n = faces.length;
            //var TypedArray = n * 3 > 65535 ? Uint32Array : Uint16Array;
            //var index = new TypedArray( n * 3 );
            let index = [];

            for( let v = 0; v < n; v++ ){

                j = v * 3;
                f = faces[ v ];

                index[ j + 0 ] = f.a;
                index[ j + 1 ] = f.b;
                index[ j + 2 ] = f.c;

            }

            return index;
        }

        normalFromGeometry( mesh ){  let ic = this.icn3d; ic.icn3dui;
            let geometry = mesh.geometry;

            let faces = geometry.faces;
            geometry.vertices.length;

            let j, f, nn, n1, n2, n3;
            let n = faces.length;
            //var normal = new Float32Array( vn * 3 );
            let normal = [];

            for( let v = 0; v < n; v++ ){

                f = faces[ v ];
                nn = f.vertexNormals;
                n1 = nn[ 0 ];
                n2 = nn[ 1 ];
                n3 = nn[ 2 ];

                j = f.a * 3;
                normal[ j + 0 ] = n1.x;
                normal[ j + 1 ] = n1.y;
                normal[ j + 2 ] = n1.z;

                j = f.b * 3;
                normal[ j + 0 ] = n2.x;
                normal[ j + 1 ] = n2.y;
                normal[ j + 2 ] = n2.z;

                j = f.c * 3;
                normal[ j + 0 ] = n3.x;
                normal[ j + 1 ] = n3.y;
                normal[ j + 2 ] = n3.z;

            }

            return normal;
        }

        //Draw the biological unit assembly using the matrix.
        drawSymmetryMates() {  let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

    //        if(ic.bInstanced && Object.keys(ic.atoms).length * ic.biomtMatrices.length > ic.maxatomcnt) {
            if(ic.bInstanced) {
                this.drawSymmetryMatesInstancing();
            }
            else {
                this.drawSymmetryMatesNoInstancing();
            }
        }

        applyMat(obj, mat, bVector3) {  let ic = this.icn3d; ic.icn3dui;
            // applyMatrix was renamed to applyMatrix4
            if(ic.rmsd_supr === undefined) {
    /*
              if(bVector3 === undefined) {
                  obj.applyMatrix(mat);
              }
              else if(bVector3) {
                  obj.applyMatrix4(mat);
              }
    */
              obj.applyMatrix4(mat);
            }
            else {
              let rot = ic.rmsd_supr.rot;
              let centerFrom = ic.rmsd_supr.trans1;
              let centerTo = ic.rmsd_supr.trans2;

              let rotationM4 = new THREE.Matrix4();
              rotationM4.set(rot[0], rot[1], rot[2], 0, rot[3], rot[4], rot[5], 0, rot[6], rot[7], rot[8], 0, 0, 0, 0, 1);

              let rotationM4Inv = new THREE.Matrix4();
              //rotationM4Inv.getInverse(rotationM4);
              rotationM4Inv.copy( rotationM4 ).invert();

              //modifiedMat.makeTranslation(-centerTo.x, -centerTo.y, -centerTo.z).multiply(rotationM4Inv).makeTranslation(centerFrom.x, centerFrom.y, centerFrom.z).multiply(mat).makeTranslation(-centerFrom.x, -centerFrom.y, -centerFrom.z).multiply(rotationM4).makeTranslation(centerTo.x, centerTo.y, centerTo.z);

              let tmpMat = new THREE.Matrix4();

    /*
              if(bVector3 === undefined) {
                  tmpMat.makeTranslation(-centerTo.x, -centerTo.y, -centerTo.z);
                  obj.applyMatrix(tmpMat);

                  obj.applyMatrix(rotationM4Inv);

                  tmpMat.makeTranslation(centerFrom.x, centerFrom.y, centerFrom.z);
                  obj.applyMatrix(tmpMat);

                  obj.applyMatrix(mat);

                  tmpMat.makeTranslation(-centerFrom.x, -centerFrom.y, -centerFrom.z);
                  obj.applyMatrix(tmpMat);

                  obj.applyMatrix(rotationM4);

                  tmpMat.makeTranslation(centerTo.x, centerTo.y, centerTo.z);
                  obj.applyMatrix(tmpMat);
              }
              else if(bVector3) {
    */
                  tmpMat.makeTranslation(-centerTo.x, -centerTo.y, -centerTo.z);
                  obj.applyMatrix4(tmpMat);

                  obj.applyMatrix4(rotationM4Inv);

                  tmpMat.makeTranslation(centerFrom.x, centerFrom.y, centerFrom.z);
                  obj.applyMatrix4(tmpMat);

                  obj.applyMatrix4(mat);

                  tmpMat.makeTranslation(-centerFrom.x, -centerFrom.y, -centerFrom.z);
                  obj.applyMatrix4(tmpMat);

                  obj.applyMatrix4(rotationM4);

                  tmpMat.makeTranslation(centerTo.x, centerTo.y, centerTo.z);
                  obj.applyMatrix4(tmpMat);
    //          }
            }
        }

        drawSymmetryMatesNoInstancing() {  let ic = this.icn3d; ic.icn3dui;
           if (ic.biomtMatrices === undefined || ic.biomtMatrices.length == 0) return;
           let cnt = 1; // itself
           let centerSum = ic.center.clone();

           let identity = new THREE.Matrix4();
           identity.identity();

           let mdlTmp = new THREE.Object3D();
           let mdlImpostorTmp = new THREE.Object3D();
           let mdl_ghostTmp = new THREE.Object3D();

    //       for (let i = 0; i < ic.biomtMatrices.length; i++) {  // skip itself
           for (let i = 0; i < ic.biomtMatrices.length && Object.keys(ic.structures).length == 1; i++) {  // skip itself
              let mat = ic.biomtMatrices[i];
              if (mat === undefined) continue;

              // skip itself
              if(mat.equals(identity)) continue;

              let symmetryMate;

              if(ic.mdl !== undefined) {
                  symmetryMate = ic.mdl.clone();
                  //symmetryMate.applyMatrix(mat);
                  this.applyMat(symmetryMate, mat);

                  mdlTmp.add(symmetryMate);
              }

              if(ic.mdlImpostor !== undefined) {
                  // after three.js version 128, the cylinder impostor seemed to have a problem in cloning
                  symmetryMate = ic.mdlImpostor.clone();
                  //symmetryMate.applyMatrix(mat);
                  this.applyMat(symmetryMate, mat);

                  //symmetryMate.onBeforeRender = ic.impostorCls.onBeforeRender;
                  for(let j = symmetryMate.children.length - 1; j >= 0; j--) {
                       let mesh = symmetryMate.children[j];
                       mesh.onBeforeRender = ic.impostorCls.onBeforeRender;
                       //mesh.onBeforeRender = this.onBeforeRender;

                       mesh.frustumCulled = false;
                  }

                  mdlImpostorTmp.add(symmetryMate);
              }

              if(ic.mdl_ghost !== undefined) {
                  symmetryMate = ic.mdl_ghost.clone();
                  //symmetryMate.applyMatrix(mat);
                  this.applyMat(symmetryMate, mat);

                  mdl_ghostTmp.add(symmetryMate);
              }

              let center = ic.center.clone();
              //center.applyMatrix4(mat);
              this.applyMat(center, mat, true);

              centerSum.add(center);

              ++cnt;
           }

           ic.mdl.add(mdlTmp);
           ic.mdlImpostor.add(mdlImpostorTmp);
           ic.mdl_ghost.add(mdl_ghostTmp);

           if(ic.bSetInstancing === undefined || !ic.bSetInstancing) {
               ic.maxD *= Math.sqrt(cnt);

               //ic.center = centerSum.multiplyScalar(1.0 / cnt);
               ic.center = ic.ParserUtilsCls.getMassCenter(centerSum, cnt);

               ic.maxDAssembly = ic.maxD;

               ic.centerAssembly = ic.center.clone();

               ic.applyCenterCls.setCenter(ic.center);

               // reset cameara
               ic.cameraCls.setCamera();
           }
           else {
               ic.maxD = ic.maxDAssembly;

               ic.center = ic.centerAssembly.clone();

               ic.applyCenterCls.setCenter(ic.center);

               // reset cameara
               ic.cameraCls.setCamera();
           }

           ic.bSetInstancing = true;
        }

        createInstancedGeometry(mesh) {  let ic = this.icn3d, me = ic.icn3dui;
           let baseGeometry = mesh.geometry;

           let geometry = new THREE.InstancedBufferGeometry();

           let positionArray = [];
           let normalArray = [];
           let colorArray = [];
           let indexArray = [];

           let radiusArray = [];
           let mappingArray = [];
           let position2Array = [];
           let color2Array = [];

           //else if(ic.bImpo && baseGeometry.attributes.color2 !== undefined) { // cylinder
           if(ic.bImpo && (mesh.type == 'Cylinder')) { // cylinder
               ic.instancedMaterial = this.getInstancedMaterial('CylinderInstancing');

               let positionArray2 = me.hashUtilsCls.hashvalue2array(baseGeometry.attributes.position1.array);
               let colorArray2 = me.hashUtilsCls.hashvalue2array(baseGeometry.attributes.color.array);

               let positionArray2b = me.hashUtilsCls.hashvalue2array(baseGeometry.attributes.position2.array);
               let colorArray2b = me.hashUtilsCls.hashvalue2array(baseGeometry.attributes.color2.array);

               let indexArray2 = me.hashUtilsCls.hashvalue2array(baseGeometry.index.array);
               let radiusArray2 = me.hashUtilsCls.hashvalue2array(baseGeometry.attributes.radius.array);
               let mappingArray2 = me.hashUtilsCls.hashvalue2array(baseGeometry.attributes.mapping.array);

               positionArray = positionArray.concat(positionArray2);
               colorArray = colorArray.concat(colorArray2);

               position2Array = position2Array.concat(positionArray2b);
               color2Array = color2Array.concat(colorArray2b);

               indexArray = indexArray.concat(indexArray2);
               radiusArray = radiusArray.concat(radiusArray2);
               mappingArray = mappingArray.concat(mappingArray2);

               geometry.setAttribute('position1', new THREE.BufferAttribute(new Float32Array(positionArray), 3));
               geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(colorArray), 3) );

               geometry.setAttribute('position2', new THREE.BufferAttribute(new Float32Array(position2Array), 3));
               geometry.setAttribute('color2', new THREE.BufferAttribute(new Float32Array(color2Array), 3) );

               geometry.setAttribute('radius', new THREE.BufferAttribute(new Float32Array(radiusArray), 1) );
               geometry.setAttribute('mapping', new THREE.BufferAttribute(new Float32Array(mappingArray), 3) );
               geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indexArray), 1));

               positionArray2 = null;
               colorArray2 = null;
               positionArray2b = null;
               colorArray2b = null;
               indexArray2 = null;
               radiusArray2 = null;
               mappingArray2 = null;
           }
           //else if(ic.bImpo && baseGeometry.attributes.color !== undefined) { // sphere
           else if(ic.bImpo && (mesh.type == 'Sphere')) { // sphere
               ic.instancedMaterial = this.getInstancedMaterial('SphereInstancing');

               let positionArray2 = me.hashUtilsCls.hashvalue2array(baseGeometry.attributes.position.array);
               let colorArray2 = me.hashUtilsCls.hashvalue2array(baseGeometry.attributes.color.array);
               let indexArray2 = me.hashUtilsCls.hashvalue2array(baseGeometry.index.array);
               let radiusArray2 = me.hashUtilsCls.hashvalue2array(baseGeometry.attributes.radius.array);
               let mappingArray2 = me.hashUtilsCls.hashvalue2array(baseGeometry.attributes.mapping.array);

               positionArray = positionArray.concat(positionArray2);
               colorArray = colorArray.concat(colorArray2);
               indexArray = indexArray.concat(indexArray2);
               radiusArray = radiusArray.concat(radiusArray2);
               mappingArray = mappingArray.concat(mappingArray2);

               geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positionArray), 3));
               geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(colorArray), 3) );
               geometry.setAttribute('radius', new THREE.BufferAttribute(new Float32Array(radiusArray), 1) );
               geometry.setAttribute('mapping', new THREE.BufferAttribute(new Float32Array(mappingArray), 2) );
               geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indexArray), 1));

               positionArray2 = null;
               colorArray2 = null;
               indexArray2 = null;
               radiusArray2 = null;
               mappingArray2 = null;
           }
           //if( baseGeometry.vertices && baseGeometry.faces ){
           else { // now BufferGeometry
               ic.instancedMaterial = this.getInstancedMaterial('Instancing');

               //var positionArray2 = this.positionFromGeometry( mesh );
               //var normalArray2 = this.normalFromGeometry( mesh );
               //var colorArray2 = this.colorFromGeometry( mesh );
               //var indexArray2 = this.indexFromGeometry( mesh );

               let positionArray2 = (baseGeometry.attributes.position) ? me.hashUtilsCls.hashvalue2array(baseGeometry.attributes.position.array) : [];
               let normalArray2 = (baseGeometry.attributes.normal) ? me.hashUtilsCls.hashvalue2array(baseGeometry.attributes.normal.array) : [];
               let colorArray2 = (baseGeometry.attributes.color) ? me.hashUtilsCls.hashvalue2array(baseGeometry.attributes.color.array) : [];
               let indexArray2 = (baseGeometry.index) ? me.hashUtilsCls.hashvalue2array(baseGeometry.index.array) : [];

               positionArray = positionArray.concat(positionArray2);
               normalArray = normalArray.concat(normalArray2);
               colorArray = colorArray.concat(colorArray2);
               indexArray = indexArray.concat(indexArray2);

               let bCylinderArray = [];
               let bCylinder = (baseGeometry.type == 'CylinderGeometry') ? 1.0 : 0.0;
               for(let i = 0, il = positionArray.length / 3; i < il; ++i) {
                   bCylinderArray.push(bCylinder);
               }

               geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positionArray), 3));
               geometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(normalArray), 3) );
               geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(colorArray), 3) );

               geometry.setAttribute('cylinder', new THREE.BufferAttribute(new Float32Array(bCylinderArray), 1) );
               geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indexArray), 1));

               positionArray2 = null;
               normalArray2 = null;
               colorArray2 = null;
               indexArray2 = null;

           }

           positionArray = null;
           normalArray = null;
           colorArray = null;
           indexArray = null;

           radiusArray = null;
           mappingArray = null;
           position2Array = null;
           color2Array = null;

           let matricesAttribute1 = new THREE.InstancedBufferAttribute( new Float32Array( ic.matricesElements1 ), 4 );
           let matricesAttribute2 = new THREE.InstancedBufferAttribute( new Float32Array( ic.matricesElements2 ), 4 );
           let matricesAttribute3 = new THREE.InstancedBufferAttribute( new Float32Array( ic.matricesElements3 ), 4 );
           let matricesAttribute4 = new THREE.InstancedBufferAttribute( new Float32Array( ic.matricesElements4 ), 4 );

           geometry.setAttribute( 'matrix1', matricesAttribute1 );
           geometry.setAttribute( 'matrix2', matricesAttribute2 );
           geometry.setAttribute( 'matrix3', matricesAttribute3 );
           geometry.setAttribute( 'matrix4', matricesAttribute4 );

           return geometry;
        }

        getInstancedMaterial(name) {  let ic = this.icn3d; ic.icn3dui;
           //var material = new THREE.RawShaderMaterial({
           let material = new THREE.ShaderMaterial({
              defines: ic.defines,
              uniforms:  ic.uniforms,
              vertexShader:   ic.impostorCls.getShader(name + ".vert"),
              fragmentShader: ic.impostorCls.getShader(name + ".frag"),
              depthTest: true,
              depthWrite: true,
              //needsUpdate: true, 
              lights: true
           });

           material.extensions.fragDepth = true;
           //https://stackoverflow.com/questions/33094496/three-js-shadermaterial-flatshading
           material.extensions.derivatives = '#extension GL_OES_standard_derivatives : enable';

           return material;
        }

        createInstancedMesh(mdl) { let ic = this.icn3d; ic.icn3dui;
           for(let i = 0, il = mdl.children.length; i < il; ++i) {
               let mesh = mdl.children[i];

               if(mesh.type === 'Sprite') continue;

               let geometry = this.createInstancedGeometry(mesh);

               let mesh2 = new THREE.Mesh(geometry, ic.instancedMaterial);

               mesh2.onBeforeRender = ic.impostorCls.onBeforeRender;
               //mesh2.onBeforeRender = this.onBeforeRender;

               // important: https://stackoverflow.com/questions/21184061/mesh-suddenly-disappears-in-three-js-clipping
               // You are moving the camera in the CPU. You are moving the vertices of the plane in the GPU
               mesh2.frustumCulled = false;

               mesh2.scale.x = mesh2.scale.y = mesh2.scale.z = 1.0;
               mesh2.type = mesh.type;

               geometry = null;

               mdl.add(mesh2);
           }
        }

        drawSymmetryMatesInstancing() { let ic = this.icn3d; ic.icn3dui;
           if (ic.biomtMatrices === undefined || ic.biomtMatrices.length == 0) return;
           let cnt = 1; // itself
           let centerSum = ic.center.clone();

           ic.impostorCls.setParametersForShader();

           if(ic.bSetInstancing === undefined || !ic.bSetInstancing) {
               //ic.offsets = [];
               //ic.orientations = [];
               ic.matricesElements1 = [];
               ic.matricesElements2 = [];
               ic.matricesElements3 = [];
               ic.matricesElements4 = [];

               let identity = new THREE.Matrix4();
               identity.identity();

               for (let i = 0; i < ic.biomtMatrices.length && Object.keys(ic.structures).length == 1; i++) {  // skip itself
                  let mat = ic.biomtMatrices[i];
                  if (mat === undefined) continue;

                  let matArray = mat.toArray();

                  // skip itself
                  if(mat.equals(identity)) continue;

                  ic.matricesElements1.push(matArray[0], matArray[1], matArray[2], matArray[3]);
                  ic.matricesElements2.push(matArray[4], matArray[5], matArray[6], matArray[7]);
                  ic.matricesElements3.push(matArray[8], matArray[9], matArray[10], matArray[11]);
                  ic.matricesElements4.push(matArray[12], matArray[13], matArray[14], matArray[15]);

                  let center = ic.center.clone();
                  center.applyMatrix4(mat);
                  centerSum.add(center);

                  ++cnt;
               }
           }

           this.createInstancedMesh(ic.mdl);
           this.createInstancedMesh(ic.mdlImpostor);

           if(ic.bSetInstancing === undefined || !ic.bSetInstancing) {
               ic.maxD *= Math.sqrt(cnt);

               //ic.center = centerSum.multiplyScalar(1.0 / cnt);
               ic.center = ic.ParserUtilsCls.getMassCenter(centerSum, cnt);

               ic.maxDAssembly = ic.maxD;

               ic.centerAssembly = ic.center.clone();

               ic.applyCenterCls.setCenter(ic.center);

               // reset cameara
               ic.cameraCls.setCamera();
           }
           else {
               ic.maxD = ic.maxDAssembly;

               ic.center = ic.centerAssembly.clone();

               ic.applyCenterCls.setCenter(ic.center);

               // reset cameara
               ic.cameraCls.setCamera();
           }

           ic.bSetInstancing = true;
        }

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Alternate {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        // change the display atom when alternating
        //Show structures one by one.
        async alternateStructures() { let ic = this.icn3d, me = ic.icn3dui;
            ic.bAlternate = true;

            //ic.transformCls.zoominSelection();
            
            // default ic.ALTERNATE_STRUCTURE = -1
            if(ic.ALTERNATE_STRUCTURE == -1) {
                ic.viewSelectionAtoms = me.hashUtilsCls.cloneHash(ic.dAtoms);
            }

            let viewSelectionAtomsCount = Object.keys(ic.viewSelectionAtoms).length;
            let allAtomsCount = Object.keys(ic.atoms).length;

            //ic.dAtoms = {};

            // 1. alternate all structures
            //let moleculeArray = Object.keys(ic.structures);

            // 2. only alternate displayed structures
            let structureHash = {};
            for(let i in ic.viewSelectionAtoms) {
                let structure = ic.atoms[i].structure;
                structureHash[structure] = 1;
            }
            let moleculeArray = Object.keys(structureHash);

            ic.dAtoms = {};

            let bMutation = ic.bScap; //moleculeArray.length == 2 && moleculeArray[1].replace(moleculeArray[0], '') == '2';

            for(let i = 0, il = moleculeArray.length; i < il; ++i) {
                let structure = moleculeArray[i];
                //if(i > ic.ALTERNATE_STRUCTURE || (ic.ALTERNATE_STRUCTURE === il - 1 && i === 0) ) {
                let bChoose;
                if(ic.bShift) {
                    // default ic.ALTERNATE_STRUCTURE = -1
                    if(ic.ALTERNATE_STRUCTURE < 0) ic.ALTERNATE_STRUCTURE = 1;

                    bChoose = (i == ic.ALTERNATE_STRUCTURE % il - 1) 
                      || (ic.ALTERNATE_STRUCTURE % il === 0 && i === il - 1);
                } 
                else {
                    bChoose = (i == ic.ALTERNATE_STRUCTURE % il + 1) 
                      || (ic.ALTERNATE_STRUCTURE % il === il - 1 && i === 0);
                }

                if(bChoose) {
                    for(let k in ic.structures[structure]) {
                        let chain = ic.structures[structure][k];
                        ic.dAtoms = me.hashUtilsCls.unionHash(ic.dAtoms, ic.chains[chain]);
                    }

                    //ic.ALTERNATE_STRUCTURE = i;
                    if(ic.bShift) {
                        --ic.ALTERNATE_STRUCTURE;
                    }
                    else {
                        ++ic.ALTERNATE_STRUCTURE;
                    }

                    if(ic.ALTERNATE_STRUCTURE < 0) ic.ALTERNATE_STRUCTURE += il;

                    let label = '';
                    if(bMutation) {
                        if(i == 0) {
                            label = "Wild Type ";
                        }
                        else if(i == 1) {
                            label = "Mutant ";
                        }
                    }

                    $("#" + ic.pre + "title").html(label + structure);

                    break;
                }
            } 

            if(viewSelectionAtomsCount < allAtomsCount) {
                let tmpAtoms = me.hashUtilsCls.intHash(ic.dAtoms, ic.viewSelectionAtoms);
                if(Object.keys(tmpAtoms).length > 0) {
                    ic.dAtoms = me.hashUtilsCls.cloneHash(tmpAtoms);
                }
                
                ic.bShowHighlight = false;
    //            ic.opts['rotationcenter'] = 'highlight center';
            }

            // also alternating the surfaces
            ic.applyMapCls.removeSurfaces();
            ic.applyMapCls.applySurfaceOptions();

            ic.applyMapCls.removeMaps();
            ic.applyMapCls.applyMapOptions();

            ic.applyMapCls.removeEmmaps();
            ic.applyMapCls.applyEmmapOptions();

            // allow the alternation of DelPhi map
            /*
            // Option 1: recalculate =========
            ic.applyMapCls.removePhimaps();
            await ic.delphiCls.loadDelphiFile('delphi');

            ic.applyMapCls.removeSurfaces();
            await ic.delphiCls.loadDelphiFile('delphi2');
            // ==============
            */

            // Option 2: NO recalculate, just show separately =========
            ic.applyMapCls.removePhimaps();
            ic.applyMapCls.applyPhimapOptions();

            ic.applyMapCls.removeSurfaces();
            ic.applyMapCls.applyphisurfaceOptions();
            // ==============

            // alternate the PCA axes
            ic.axes = [];
            if(ic.pc1) {
               ic.axesCls.setPc1Axes();
            }

            //ic.glycanCls.showGlycans();

            ic.opts['rotationcenter'] = 'highlight center';
            
            ic.drawCls.draw();

            ic.bShowHighlight = true; //reset
        }

        async alternateWrapper() { let ic = this.icn3d; ic.icn3dui;
           ic.bAlternate = true;
           await this.alternateStructures();
           ic.bAlternate = false;
        }

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

     class Draw {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Draw the 3D structure. It rebuilds scene, applies previous color, applies the transformation, and renders the image.
        draw(bVrAr) { let ic = this.icn3d, me = ic.icn3dui;
            ic.impostorCls.clearImpostors();
            
            if(ic.bRender && (!ic.hAtoms || Object.keys(ic.hAtoms) == 0)) ic.hAtoms = me.hashUtilsCls.cloneHash(ic.atoms);

            ic.sceneCls.rebuildScene();

            // Impostor display using the saved arrays
            if(ic.bImpo) {
                ic.impostorCls.drawImpostorShader(); // target
            }

            ic.setColorCls.applyPrevColor();

            if(ic.biomtMatrices !== undefined && ic.biomtMatrices.length > 1) {        
                if(ic.bAssembly && Object.keys(ic.structures).length == 1 && ((me.cfg.mmdbid === undefined && me.cfg.bu == 1)
                  || (me.cfg.mmdbid !== undefined && me.cfg.bu == 1 && Object.keys(ic.atoms).length * ic.biomtMatrices.length > ic.maxatomcnt)) ) {
                    ic.instancingCls.drawSymmetryMates();
                }
                else {
                    let bNoOrientation = true;
                    ic.applyCenterCls.centerSelection(undefined, bNoOrientation);
                }
            }

            // show the hAtoms
            let hAtomsLen = (ic.hAtoms !== undefined) ? Object.keys(ic.hAtoms).length : 0;

            if(hAtomsLen > 0 && hAtomsLen < Object.keys(ic.dAtoms).length) {
                ic.hlObjectsCls.removeHlObjects();
                if(ic.bShowHighlight === undefined || ic.bShowHighlight) ic.hlObjectsCls.addHlObjects();
            }

            if(ic.bRender === true) {
              if(ic.bInitial || $("#" + ic.pre + "wait").is(":visible")) {
                  if($("#" + ic.pre + "wait")) $("#" + ic.pre + "wait").hide();
                  if($("#" + ic.pre + "canvas")) $("#" + ic.pre + "canvas").show();
                  if($("#" + ic.pre + "cmdlog")) $("#" + ic.pre + "cmdlog").show();
              }

              this.applyTransformation(ic._zoomFactor, ic.mouseChange, ic.quaternion);
              this.render(bVrAr);
            }

            //ic.impostorCls.clearImpostors();

            // show membranes
            if(ic.bOpm && !me.cfg.chainalign) {
                //if(window.dialog && window.dialog.hasClass('ui-dialog-content')) window.dialog.dialog( "close" );
                
                let html = me.utilsCls.getMemDesc();
                $("#" + ic.pre + "dl_rmsd_html").html(html);
                if(!me.cfg.bSidebyside) me.htmlCls.dialogCls.openDlg('dl_rmsd', 'Membranes');
            }
        }

        //Update the rotation, translation, and zooming before rendering. Typically used before the function render().
        applyTransformation(_zoomFactor, mouseChange, quaternion) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            let para = {};
            para.update = false;

            // zoom
            para._zoomFactor = _zoomFactor;

            // translate
            para.mouseChange = new THREE.Vector2();
            para.mouseChange.copy(mouseChange);

            // rotation
            para.quaternion = new THREE.Quaternion();
            para.quaternion.copy(quaternion);

            if(ic.bControlGl && !me.bNode) {
                window.controls.update(para);
            }
            else {
                ic.controls.update(para);
            }      
        }

        //Render the scene and objects into pixels.
        render(bVrAr) { let ic = this.icn3d; ic.icn3dui;
            let thisClass = this;
            // setAnimationLoop is required for VR
            if(bVrAr) {
                ic.renderer.setAnimationLoop( function() {
                    thisClass.render_base();
                });
            }
            else {
                thisClass.render_base();
            }
        }

        handleController( controller, dt, selectPressed, squeezePressed, xArray, yArray) { let ic = this.icn3d; ic.icn3dui;
        try {
            // modified from https://github.com/NikLever/Learn-WebXR/blob/master/complete/lecture3_7/app.js

            // thumbstick move
            let yMax = 0;
            if(yArray) {
                if(yArray[0] != 0 && yArray[1] != 0) {
                    yMax = yArray[0]; // right
                }
                else if(yArray[0] != 0) {
                    yMax = yArray[0]; 
                }
                else if(yArray[1] != 0) {
                    yMax = yArray[1]; 
                }
            }
            if(yMax === undefined) yMax = 0;

            // selection only work when squeeze (menu) is not pressed
            if(selectPressed && !squeezePressed) {
                let dtAdjusted = yMax / 1000.0 * dt; 
                
                const speed = 5; //2;
                if(yMax != 0) {
                    //if(ic.dolly && ic.dolly.quaternion && ic.dummyCam) {
                        ic.uistr += "dolly";
                        const quaternion = ic.dolly.quaternion.clone();
                        ic.dummyCam.getWorldQuaternion(ic.dolly.quaternion);
                        ic.dolly.translateZ(dtAdjusted * speed);
                        //ic.dolly.position.y = 0; // limit to a plane
                        ic.dolly.quaternion.copy(quaternion); 
                    //}
                }
                else { //if(yMax == 0) {
                    controller.children[0].scale.z = 10;
                    ic.workingMatrix.identity().extractRotation( controller.matrixWorld );

                    ic.raycasterVR.ray.origin.setFromMatrixPosition( controller.matrixWorld );
                    ic.raycasterVR.ray.direction.set( 0, 0, - 1 ).applyMatrix4( ic.workingMatrix );

                    const intersects = ic.raycasterVR.intersectObjects( ic.objects );

                    if (intersects.length>0){
                        controller.children[0].scale.z = intersects[0].distance; // stop on the object

                        intersects[ 0 ].point.sub(ic.mdl.position); // mdl.position was moved to the original (0,0,0) after reading the molecule coordinates. The raycasting was done based on the original. The position of the original should be subtracted.

                        let threshold = ic.rayThreshold; //0.5;
                    
                        let atom = ic.rayCls.getAtomsFromPosition(intersects[ 0 ].point, threshold); // the second parameter is the distance threshold. The first matched atom will be returned. Use 1 angstrom, not 2 angstrom. If it's 2 angstrom, other atom will be returned.

                        while(!atom && threshold < 10) {
                            threshold = threshold + 0.5;
                            atom = ic.rayCls.getAtomsFromPosition(intersects[ 0 ].point, threshold);
                        }

                        if(atom) {
                            if(ic.pAtomNum % 2 === 0) {
                                ic.pAtom = atom;
                            }
                            else {
                                ic.pAtom2 = atom;
                            }

                            ++ic.pAtomNum;

                            //ic.pickingCls.showPicking(atom);

                            this.showPickingVr(ic.pk, atom);

                            //ic.canvasUILog.updateElement( "info", atom.structure + '_' + atom.chain + '_' + atom.resi);
                        }      
                    } 
                }
            }
        }
        catch(err) {
            //ic.canvasUILog.updateElement( "info", "ERROR: " + err );
        }  
        }

        showPickingVr(pk, atom) { let ic = this.icn3d; ic.icn3dui;
            if(!pk) pk = 2; // residues

            ic.hAtoms = ic.pickingCls.getPickedAtomList(pk, atom);

            if(pk === 2) {
                ic.residueLabelsCls.addResidueLabels(ic.hAtoms, undefined, undefined, true);
            }
            else if(pk === 1) {
                ic.residueLabelsCls.addAtomLabels(ic.hAtoms);
            }

            ic.setOptionCls.setStyle("proteins", atom.style);
        }

        //Render the scene and objects into pixels.
        render_base() { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            if(me.bNode) return;

            let cam = (ic.bControlGl && !me.bNode) ? window.cam : ic.cam;

            if(ic.directionalLight) {
                let quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors( new THREE.Vector3(0, 0, ic.cam_z).normalize(), cam.position.clone().normalize() );

                ic.directionalLight.position.copy(ic.lightPos.clone().applyQuaternion( quaternion ).normalize());
                ic.directionalLight2.position.copy(ic.lightPos2.clone().applyQuaternion( quaternion ).normalize());
                ic.directionalLight3.position.copy(ic.lightPos3.clone().applyQuaternion( quaternion ).normalize());

                // adjust the light according to the position of camera
                ic.directionalLight.applyMatrix4(cam.matrixWorld);
                ic.directionalLight2.applyMatrix4(cam.matrixWorld);
                ic.directionalLight3.applyMatrix4(cam.matrixWorld);
            }

            if(!ic.bVr) ic.renderer.setPixelRatio( window.devicePixelRatio ); // r71

            if(ic.bVr) {
                let dt = 0.04; // ic.clock.getDelta();

                if (ic.controllers){
                    let result = this.updateGamepadState();

                    for(let i = 0, il = ic.controllers.length; i < il; ++i) {
                        let controller = ic.controllers[i];
                        if(!controller) continue;
                        
                        dt = (i % 2 == 0) ? dt : -dt; // dt * y; 
                        thisClass.handleController( controller, dt, controller.userData.selectPressed, controller.userData.squeezePressed, result.xArray, result.yArray );
                    }
                }

                if ( ic.renderer.xr.isPresenting){    
                    if(ic.canvasUI) ic.canvasUI.update();
                    if(ic.canvasUILog) ic.canvasUILog.update();
                }
            }
            else if(ic.bAr) {
                if ( ic.renderer.xr.isPresenting ){    
                    ic.gestures.update();
                    if(ic.canvasUILog) ic.canvasUILog.update();
                }
            }

            if(ic.scene) {
                ic.renderer.clear();
                
                // https://github.com/gkjohnson/three-gpu-pathtracer/blob/main/example/basic.js
                ic.renderer.outputEncoding = THREE.sRGBEncoding;
                //ic.renderer.outputEncoding = THREE.LinearEncoding

                if(ic.opts['effect'] == 'stereo' && !window.icn3duiHash) {
                    ic.effect.render(ic.scene, cam);
                }
                else {
                    ic.renderer.render(ic.scene, cam);
                }           
            }
        }

        updateGamepadState() { let ic = this.icn3d; ic.icn3dui;
            let xAxisIndex = (ic.xAxisIndex) ? ic.xAxisIndex : 2;
            let yAxisIndex = (ic.yAxisIndex) ? ic.yAxisIndex : 3;
            //https://github.com/NikLever/Learn-WebXR/blob/master/complete/lecture5_3/app.js     
            // "trigger":{"button":0},
            // "squeeze":{"button":1},
            // "thumbstick":{"button":3,"xAxis":2,"yAxis":3},   "touchpad":{"button":2,"xAxis":0,"yAxis":1},
            //======= left => right =========
            // "x_button":{"button":4},     "a_button":{"button":4}
            // "y_button":{"button":5},     "b_button":{"button":5}
            // "thumbrest":{"button":6}
            if ( ic.renderer.xr.isPresenting ){
                const session = ic.renderer.xr.getSession();
                const inputSources = session.inputSources;

                let xArray = [], yArray = [];
                inputSources.forEach( inputSource => {
                    const gp = inputSource.gamepad;
                    const axes = gp.axes;

                    let x = parseInt(1000 * axes[xAxisIndex]); // -1000 => 1000
                    let y = parseInt(-1000 * axes[yAxisIndex]); // -1000 => 1000

                    xArray.push(x);
                    yArray.push(y);
                });

                return {xArray: xArray, yArray: yArray};
            }
            else {
                return {xArray: [0, 0], yArray: [0, 0]};
            }
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Contact {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

         // modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
         //This function returns atoms within a certain "distance" (in angstrom) from the "targetAtoms".
         //The returned atoms are stored in a hash with atom indices as keys and 1 as values.
         //Only those atoms in "allAtoms" are considered.
         getAtomsWithinAtom(atomlist, atomlistTarget, distance, bGetPairs, bInteraction, bInternal, bIncludeTarget) { let ic = this.icn3d, me = ic.icn3dui;
            let neighbors = this.getNeighboringAtoms(atomlist, atomlistTarget, distance, bIncludeTarget);
            if(bGetPairs) ic.resid2Residhash = {};

            let ret = {};
            for(let i in atomlistTarget) {
                //var oriAtom = atomlistTarget[i];
                let oriAtom = ic.atoms[i];

                // skip hydrogen atoms
                if(bInteraction && oriAtom.elem == 'H') continue;

                let r1 = me.parasCls.vdwRadii[oriAtom.elem.toUpperCase()];
                let chainid1 = oriAtom.structure + '_' + oriAtom.chain;

                let oriCalpha = undefined, oriResidName = undefined;
                let oriResid = oriAtom.structure + '_' + oriAtom.chain + '_' + oriAtom.resi;
                for(let serial in ic.residues[oriResid]) {
                    if(!ic.atoms[serial]) continue;

                    if((ic.atoms[serial].name === 'CA' && ic.atoms[serial].elem === 'C') || ic.atoms[serial].name === "O3'" || ic.atoms[serial].name === "O3*") {
                        oriCalpha = ic.atoms[serial];
                        break;
                    }
                }

                if(oriCalpha === undefined) oriCalpha = oriAtom;

                if(bGetPairs) {
                    let serialList = (oriAtom.name.indexOf('pi') == 0 && oriAtom.ring) ? oriAtom.ring.join(',') : oriAtom.serial;
                    oriResidName = oriAtom.resn + ' $' + oriAtom.structure + '.' + oriAtom.chain + ':' + oriAtom.resi + ' ' + serialList;
                    if(ic.resid2Residhash[oriResidName] === undefined) ic.resid2Residhash[oriResidName] = {};
                }

                let chain_resi = oriAtom.structure + '_' + oriAtom.chain + '_' + oriAtom.resi;

                for (let j in neighbors) {
                   let atom = neighbors[j];

                   // skip hydrogen atoms
                   if(bInteraction && atom.elem == 'H') continue;

                   let r2 = me.parasCls.vdwRadii[atom.elem.toUpperCase()];
                   let chainid2 = atom.structure + '_' + atom.chain;

                   if(bInteraction && !ic.crossstrucinter && oriAtom.structure != atom.structure) continue;

                   // exclude the target atoms
                   if(!bIncludeTarget && atom.serial in atomlistTarget) continue;
                   if(ic.bOpm && atom.resn === 'DUM') continue;

                   //var atomDistSq = (atom.coord.x - oriAtom.coord.x) * (atom.coord.x - oriAtom.coord.x) + (atom.coord.y - oriAtom.coord.y) * (atom.coord.y - oriAtom.coord.y) + (atom.coord.z - oriAtom.coord.z) * (atom.coord.z - oriAtom.coord.z);
                   let atomDist = atom.coord.distanceTo(oriAtom.coord);

                   // consider backbone clashes
                   if(bInteraction && atomDist < r1 + r2 
                      && (oriAtom.name === "N" || oriAtom.name === "C" || oriAtom.name === "O" || (oriAtom.name === "CA" && oriAtom.elem === "C") )
                      && (atom.name === "N" || atom.name === "C" || atom.name === "O" || (atom.name === "CA" && atom.elem === "C") ) ) { // clashed atoms are not counted as interactions
                        // store the clashed residues
                        if(!ic.chainid2clashedResidpair) ic.chainid2clashedResidpair = {};

                        ic.chainid2clashedResidpair[chainid1 + '_' + oriAtom.resi + '|' + chainid2 + '_' + atom.resi] = '0|0';
                   }
                   
                   if(atomDist < distance) {
                        ret[atom.serial] = atom;
                        let calpha = undefined, residName = undefined;
                        if(bInteraction) {
                            ret[oriAtom.serial] = oriAtom;
                        }

                        let resid = atom.structure + '_' + atom.chain + '_' + atom.resi;
                        for(let serial in ic.residues[resid]) {
                            if( (ic.atoms[serial].name === 'CA' && ic.atoms[serial].elem === 'C') || ic.atoms[serial].name === "O3'" || ic.atoms[serial].name === "O3*") {
                                calpha = ic.atoms[serial];
                                break;
                            }
                        }

                        if(calpha === undefined) calpha = atom;

                            // output contact lines
                        if(bInteraction) {
                            ic.contactpnts.push({'serial': calpha.serial, 'coord': calpha.coord});
                            ic.contactpnts.push({'serial': oriCalpha.serial, 'coord': oriCalpha.coord});
                        }

                        if(bGetPairs) {
            let chain_resi2 = atom.structure + '_' + atom.chain + '_' + atom.resi;

            let serialList = (atom.name.indexOf('pi') == 0 && atom.ring) ? atom.ring.join(',') : atom.serial;
            residName = atom.resn + ' $' + atom.structure + '.' + atom.chain + ':' + atom.resi + ' ' + serialList;
            //var dist = Math.sqrt(atomDistSq).toFixed(1);
            let dist1 = atomDist.toFixed(1);
            let dist2 = calpha.coord.distanceTo(oriCalpha.coord).toFixed(1);

            let resids = chain_resi + '_' + oriAtom.resn + ',' + chain_resi2 + '_' + atom.resn;
            let residNames = oriResidName + '|' + residName;
            if(ic.resids2interAll[resids] === undefined
                || ic.resids2interAll[resids]['contact'] === undefined
                || !ic.resids2interAll[resids]['contact'].hasOwnProperty(residNames)
                || (ic.resids2interAll[resids]['hbond'] !== undefined && !ic.resids2interAll[resids]['hbond'].hasOwnProperty(residNames))
                || (ic.resids2interAll[resids]['ionic'] !== undefined && !ic.resids2interAll[resids]['ionic'].hasOwnProperty(residNames))
                || (ic.resids2interAll[resids]['halogen'] !== undefined && !ic.resids2interAll[resids]['halogen'].hasOwnProperty(residNames))
                || (ic.resids2interAll[resids]['pi-cation'] !== undefined && !ic.resids2interAll[resids]['pi-cation'].hasOwnProperty(residNames))
                || (ic.resids2interAll[resids]['pi-stacking'] !== undefined && !ic.resids2interAll[resids]['pi-stacking'].hasOwnProperty(residNames))
                ) {
                  if(ic.resid2Residhash[oriResidName][residName] === undefined || dist1 < ic.resid2Residhash[oriResidName][residName].split('_')[0]) {
                      let cnt = (ic.resid2Residhash[oriResidName][residName] === undefined) ? 1 : parseInt(ic.resid2Residhash[oriResidName][residName].split('_')[4]) + 1;
                      ic.resid2Residhash[oriResidName][residName] = dist1 + '_' + dist2 + '_' + oriAtom.name + '_' + atom.name + '_' + cnt;

                      if(!bInternal) {
                          if(ic.resids2inter[resids] === undefined) ic.resids2inter[resids] = {};
                          if(ic.resids2inter[resids]['contact'] === undefined) ic.resids2inter[resids]['contact'] = {};
                          ic.resids2inter[resids]['contact'][oriResidName + '|' + residName] = dist1 + '_' + dist2 + '_' + oriAtom.name + '_' + atom.name + '_' + cnt;
                      }

                      if(ic.resids2interAll[resids] === undefined) ic.resids2interAll[resids] = {};
                      if(ic.resids2interAll[resids]['contact'] === undefined) ic.resids2interAll[resids]['contact'] = {};
                      ic.resids2interAll[resids]['contact'][oriResidName + '|' + residName] = dist1 + '_' + dist2 + '_' + oriAtom.name + '_' + atom.name + '_' + cnt;
                  }
            }
                        } // if(bGetPairs) {
                   }
                } // inner for
            } // outer for

            return ret;
         }

         getNeighboringAtoms(atomlist, atomlistTarget, distance, bIncludeTarget) { let ic = this.icn3d; ic.icn3dui;
            let extent = this.getExtent(atomlistTarget);

            let targetRadiusSq1 = (extent[2][0] - extent[0][0]) * (extent[2][0] - extent[0][0]) + (extent[2][1] - extent[0][1]) * (extent[2][1] - extent[0][1]) + (extent[2][2] - extent[0][2]) * (extent[2][2] - extent[0][2]);
            let targetRadiusSq2 = (extent[2][0] - extent[1][0]) * (extent[2][0] - extent[1][0]) + (extent[2][1] - extent[1][1]) * (extent[2][1] - extent[1][1]) + (extent[2][2] - extent[1][2]) * (extent[2][2] - extent[1][2]);
            let targetRadiusSq = (targetRadiusSq1 > targetRadiusSq2) ? targetRadiusSq1 : targetRadiusSq2;
            let targetRadius = Math.sqrt(targetRadiusSq);

            let maxDistSq = (targetRadius + distance) * (targetRadius + distance);

            let neighbors = {};
            for (let i in atomlist) {
               //var atom = atomlist[i];
               let atom = ic.atoms[i];

               // exclude the target atoms
               if(!bIncludeTarget && atomlistTarget.hasOwnProperty(atom.serial)) continue;

               if(this.bOpm && atom.resn === 'DUM') continue;

               if (atom.coord.x < extent[0][0] - distance || atom.coord.x > extent[1][0] + distance) continue;
               if (atom.coord.y < extent[0][1] - distance || atom.coord.y > extent[1][1] + distance) continue;
               if (atom.coord.z < extent[0][2] - distance || atom.coord.z > extent[1][2] + distance) continue;

               // only show protein or DNA/RNA
               //if(atom.serial in this.proteins || atom.serial in this.nucleotides) {
                   let atomDistSq = (atom.coord.x - extent[2][0]) * (atom.coord.x - extent[2][0]) + (atom.coord.y - extent[2][1]) * (atom.coord.y - extent[2][1]) + (atom.coord.z - extent[2][2]) * (atom.coord.z - extent[2][2]);

                   if(atomDistSq < maxDistSq) {
                       neighbors[atom.serial] = atom;
                   }
               //}
            }

            return neighbors;
         }

         // from iview (http://istar.cse.cuhk.edu.hk/iview/)
         //For a list of atoms, return an array containing three coordinates: minimum x- y- z- values,
         //maximum x- y- z- values, and average x- y- z- values.
         getExtent(atomlist) { let ic = this.icn3d; ic.icn3dui;
            let xmin, ymin, zmin;
            let xmax, ymax, zmax;
            let xsum, ysum, zsum, cnt;

            xmin = ymin = zmin = 9999;
            xmax = ymax = zmax = -9999;
            xsum = ysum = zsum = cnt = 0;
            let i;
            for (i in atomlist) {
               //var atom = atomlist[i];
               let atom = ic.atoms[i];
               cnt++;
               xsum += atom.coord.x; ysum += atom.coord.y; zsum += atom.coord.z;


               xmin = (xmin < atom.coord.x) ? xmin : atom.coord.x;

               ymin = (ymin < atom.coord.y) ? ymin : atom.coord.y;
               zmin = (zmin < atom.coord.z) ? zmin : atom.coord.z;
               xmax = (xmax > atom.coord.x) ? xmax : atom.coord.x;
               ymax = (ymax > atom.coord.y) ? ymax : atom.coord.y;
               zmax = (zmax > atom.coord.z) ? zmax : atom.coord.z;
            }

            return [[xmin, ymin, zmin], [xmax, ymax, zmax], [xsum / cnt, ysum / cnt, zsum / cnt]];
         }

        hideContact() { let ic = this.icn3d; ic.icn3dui;
            ic.opts["contact"] = "no";
            if(ic.lines === undefined) ic.lines = { };
            ic.lines['contact'] = [];
            ic.contactpnts = [];
        }

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class HBond {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //http://www.imgt.org/IMGTeducation/Aide-memoire/_UK/aminoacids/charge/#hydrogen
        // return: 'donor', 'acceptor', 'both', 'ring', 'none'
        isHbondDonorAcceptor(atom) { let ic = this.icn3d; ic.icn3dui;
          if( (atom.name == 'N' && !atom.het ) // backbone
            || (atom.elem == 'N' && atom.resn == 'Arg')
            || (atom.elem == 'N' && atom.resn == 'Asn')
            || (atom.elem == 'N' && atom.resn == 'Gln')
            || (atom.elem == 'N' && atom.resn == 'Lys')
            || (atom.elem == 'N' && atom.resn == 'Trp')
            ) {
              return 'donor';
          }
          else if( (atom.name == 'O' && !atom.het ) // backbone
            || (atom.elem == 'S' && atom.resn == 'Met')
            || (atom.elem == 'O' && atom.resn == 'Asn')
            || (atom.elem == 'O' && atom.resn == 'Asp')
            || (atom.elem == 'O' && atom.resn == 'Gln')
            || (atom.elem == 'O' && atom.resn == 'Glu')
            ) {
              return 'acceptor';
          }
          else if((atom.elem == 'S' && atom.resn == 'Cys')
            || (atom.elem == 'N' && atom.resn == 'His')
            || (atom.elem == 'O' && atom.resn == 'Ser')
            || (atom.elem == 'O' && atom.resn == 'Thr')
            || (atom.elem == 'O' && atom.resn == 'Tyr')
            ) {
              return 'both';
          }
          else if(atom.resn == 'Pro') {
              return 'none';
          }
          // if the Nitrogen has one or two non-hydrogen bonded atom, the nitrogen is a donor
          else if(atom.elem == 'N') {
              // X-ray can not differentiate N and O
              if(atom.resn == 'Asn' || atom.resn == 'Gln') return 'both';

              let cnt = 0, cntN = 0;
              for(let k = 0, kl = atom.bonds.length; k < kl; ++k) {
                  if(ic.atoms[atom.bonds[k]].elem == 'H') {
                      ++cnt;
                  }
              }

              if(cnt == 2) return 'donor';

              cnt = 0;
              for(let i = 0, il = atom.bonds.length; i < il; ++i) {
                  let nbAtom = ic.atoms[atom.bonds[i]];
                  if(nbAtom.elem != 'H') {
                      ++cnt;

                      for(let j = 0, jl = nbAtom.bonds.length; j < jl; ++j) {
                          if(ic.atoms[nbAtom.bonds[j]].elem == 'N') {
                              ++cntN;
                          }
                      }
                  }
              }

              if(cnt == 1) { // donor
                  return 'donor';
              }
              else if(cnt == 2) {
                  if(cntN > 1) {
                      return 'ring'; //'both'; // possible
                  }
                  else {
                    return 'donor';
                  }
              }
              else {
                  return 'none';
              }
          }
          // if the neighboring C of Oxygen has two or more bonds with O or N, the oxygen is an acceptor
          else if(atom.elem == 'O' && atom.bonds.length == 1) {
              // X-ray can not differentiate N and O
              if(atom.resn == 'Asn' || atom.resn == 'Gln') return 'both';

              for(let k = 0, kl = atom.bonds.length; k < kl; ++k) {
                  if(ic.atoms[atom.bonds[k]].elem == 'H') {
                      return 'donor';
                  }
              }

              let cAtom = ic.atoms[atom.bonds[0]];
              let cnt = 0;
              for(let k = 0, kl = cAtom.bonds.length; k < kl; ++k) {
                  if(ic.atoms[cAtom.bonds[k]].elem == 'O' || ic.atoms[cAtom.bonds[k]].elem == 'N' || ic.atoms[cAtom.bonds[k]].elem == 'S') {
                      ++cnt;
                  }
              }

              if(cnt >= 2) { // acceptor
                  return 'acceptor';
              }
              else {
                  return 'both'; // possible
              }
          }
          // if Oxygen has two bonds, the oxygen is an acceptor
          else if(atom.elem == 'O' && atom.bonds.length == 2) {
              for(let k = 0, kl = atom.bonds.length; k < kl; ++k) {
                  if(ic.atoms[atom.bonds[k]].elem == 'H') {
                      return 'donor';
                  }
              }
              return 'acceptor';
          }
          else {
              return 'both'; // possible
          }
        }

        /**
         * From ngl https://github.com/arose/ngl
         * Calculate the angles x-1-2 for all x where x is a heavy atom bonded to ap1.
         * @param  {AtomProxy} ap1 First atom (angle centre)
         * @param  {AtomProxy} ap2 Second atom
         * @return {number[]}        Angles in radians
         */
        calcAngles(ap1, ap2) { let ic = this.icn3d; ic.icn3dui;
          let angles = [];
          let d1 = new THREE.Vector3();
          let d2 = new THREE.Vector3();
          d1.subVectors(ap2.coord, ap1.coord);

          for(let k = 0, kl = ap1.bonds.length; k < kl; ++k) {
              if(ic.atoms[ap1.bonds[k]].elem != 'H') {
                  d2.subVectors(ic.atoms[ap1.bonds[k]].coord, ap1.coord);
                  angles.push(d1.angleTo(d2));
              }
          }

          return angles;
        }

        /**
         * From ngl https://github.com/arose/ngl
         * Find two neighbours of ap1 to define a plane (if possible) and
         * measure angle out of plane to ap2
         * @param  {AtomProxy} ap1 First atom (angle centre)
         * @param  {AtomProxy} ap2 Second atom (out-of-plane)
         * @return {number}        Angle from plane to second atom
         */
        calcPlaneAngle(ap1, ap2) { let ic = this.icn3d; ic.icn3dui;
          let x1 = ap1;

          let v12 = new THREE.Vector3();
          v12.subVectors(ap2.coord, ap1.coord);

          let neighbours = [new THREE.Vector3(), new THREE.Vector3()];

          let ni = 0;
          for(let k = 0, kl = ap1.bonds.length; k < kl; ++k) {
              if (ni > 1) { break; }
              if(ic.atoms[ap1.bonds[k]].elem != 'H') {
                  x1 = ic.atoms[ap1.bonds[k]];
                  neighbours[ni++].subVectors(ic.atoms[ap1.bonds[k]].coord, ap1.coord);
              }
          }

          if (ni === 1) {
              for(let k = 0, kl = x1.bonds.length; k < kl; ++k) {
                  if (ni > 1) { break; }
                  if(ic.atoms[x1.bonds[k]].elem != 'H' && ic.atoms[x1.bonds[k]].serial != ap1.serial) {
                      neighbours[ni++].subVectors(ic.atoms[x1.bonds[k]].coord, ap1.coord);
                  }
              }
          }

          if (ni !== 2) {
            return;
          }

          let cp = neighbours[0].cross(neighbours[1]);
          return Math.abs((Math.PI / 2) - cp.angleTo(v12));
        }

        // https://www.rcsb.org/pages/help/3dview#ligand-view
        // exclude pairs accordingto angles
        isValidHbond(atom, atomHbond, threshold) { let ic = this.icn3d; ic.icn3dui;
              // return: 'donor', 'acceptor', 'both', 'ring', 'none'
              let atomType = this.isHbondDonorAcceptor(atom);
              let atomHbondType = this.isHbondDonorAcceptor(atomHbond);

              let tolerance = 5;
              let maxHbondAccAngle = (45 + tolerance) * Math.PI / 180;
              let maxHbondDonAngle = (45 + tolerance) * Math.PI / 180;
              let maxHbondAccPlaneAngle = 90 * Math.PI / 180;
              let maxHbondDonPlaneAngle = 30 * Math.PI / 180;

              let donorAtom, acceptorAtom;

              if( (atomType == 'donor' &&  (atomHbondType == 'acceptor' || atomHbondType == 'both' || atomHbondType == 'ring'))
                || (atomHbondType == 'acceptor' && (atomType == 'donor' || atomType == 'both' || atomType == 'ring'))
                ) {
                  donorAtom = atom;
                  acceptorAtom = atomHbond;
              }
              else if( (atomType == 'acceptor' &&  (atomHbondType == 'donor' || atomHbondType == 'both' || atomHbondType == 'ring'))
                || (atomHbondType == 'donor' && (atomType == 'acceptor' || atomType == 'both' || atomType == 'ring'))
                ) {
                  acceptorAtom = atom;
                  donorAtom = atomHbond;
              }
              else if( (atomType == 'both' || atomType == 'ring') &&  (atomHbondType == 'both'  || atomHbondType == 'ring') ) {
                  donorAtom = atom;
                  acceptorAtom = atomHbond;
                  // or
                  //donorAtom = atomHbond;
                  //acceptorAtom = atom;

                  if( (ic.nucleotides.hasOwnProperty(atom.serial) && ic.nucleotides.hasOwnProperty(atomHbond.serial) && (atomType == 'ring' || atomHbondType == 'ring') ) // 1TUP
                      || ( (atom.het || atomHbond.het) && atomType == 'ring' && atomHbondType == 'ring')  // 3GVU
                      ) ;
                  else {
                      maxHbondDonPlaneAngle = 90 * Math.PI / 180;
                  }
              }
              else if(atomType == 'none' ||  atomHbondType == 'none') {
                  return false;
              }
              else {
                  return false;
              }

              let donorAngles = this.calcAngles(donorAtom, acceptorAtom);
              let idealDonorAngle = 90 * Math.PI / 180; // 90 for sp2, 60 for sp3
              for(let i = 0, il = donorAngles.length; i < il; ++i) {
                  if(Math.abs(idealDonorAngle - donorAngles[i]) > maxHbondDonAngle) {
    // commented out on Nov 19, 2021
    // uncommented on Sep 8, 2022 since these conditions should be used for nucleotides
                      return false;
                  }
              }

              //if (idealGeometry[donor.index] === AtomGeometry.Trigonal){ // 120
                let outOfPlane1 = this.calcPlaneAngle(donorAtom, acceptorAtom);

                if (outOfPlane1 !== undefined && outOfPlane1 > maxHbondDonPlaneAngle) {
                    return false;
                }
              //}

              let acceptorAngles = this.calcAngles(acceptorAtom, donorAtom);
              let idealAcceptorAngle = 90 * Math.PI / 180;
              for(let i = 0, il = acceptorAngles.length; i < il; ++i) {
                  if(Math.abs(idealAcceptorAngle - acceptorAngles[i]) > maxHbondAccAngle) {
    // commented out on Nov 19, 2021, but keep it for nucleotides
    // uncommented on Sep 8, 2022 since these conditions should be used for nucleotides
                      return false;
                  }
              }

              //if (idealGeometry[acceptor.index] === AtomGeometry.Trigonal){ // 120
                let outOfPlane2 = this.calcPlaneAngle(acceptorAtom, donorAtom);
                if (outOfPlane2 !== undefined && outOfPlane2 > maxHbondAccPlaneAngle) return false;
              //}

              return true;
        }

        //Set up hydrogen bonds between chemical and protein/nucleotide in the same structure.
        //"protein" and "chemicals" are hashes with atom indices as keys and 1 as values.
        //"threshold" is the maximum distance of hydrogen bonds and has the unit of angstrom.
        calculateChemicalHbonds(startAtoms, targetAtoms, threshold, bSaltbridge, type, bInternal) { let ic = this.icn3d, me = ic.icn3dui;
            if(Object.keys(startAtoms).length === 0 || Object.keys(targetAtoms).length === 0) return;
            ic.resid2Residhash = {};

            let atomHbond = {};
            let chain_resi, chain_resi_atom;

            let maxlengthSq = threshold * threshold;

            for (let i in startAtoms) {
              let atom = startAtoms[i];

              // salt bridge: calculate hydrogen bond between Lys/Arg and Glu/Asp
              // hbonds: calculate hydrogen bond
              let bAtomCond = (bSaltbridge) ? ( atom.resn === 'LYS' && atom.elem === "N" && atom.name !== "N")
                || ( atom.resn === 'ARG' && (atom.name === "NH1" || atom.name === "NH2"))
                || ( (atom.resn === 'GLU' || atom.resn === 'ASP') && atom.elem === "O" && atom.name !== "O")
                || (atom.het && (atom.elem === "N" || atom.elem === "O" || atom.elem === "S"))
                : atom.elem === "N" || atom.elem === "O" || (atom.elem === "S" && (atom.het || atom.resn === "Cys" || atom.resn === "Met"));

              bAtomCond = (ic.bOpm) ? bAtomCond && atom.resn !== 'DUM' : bAtomCond;

              if(bAtomCond) {
                chain_resi = atom.structure + "_" + atom.chain + "_" + atom.resi;
                chain_resi_atom = chain_resi + "_" + atom.name;

                atomHbond[chain_resi_atom] = atom;
              }
            } // end of for (let i in startAtoms) {

            let hbondsAtoms = {};
            let residueHash = {};

            // from DSSP C++ code
            //var kSSBridgeDistance = 3.0;
            let kMinimalDistance = 0.5;
            //var kMinimalCADistance = 9.0;
            let kMinHBondEnergy = -9.9;
            let kMaxHBondEnergy = -0.5;
            let kCouplingConstant = -27.888;    //  = -332 * 0.42 * 0.2
            //var kMaxPeptideBondLength = 2.5;

            let hbondCnt = {};

            for (let i in targetAtoms) {
              let atom = targetAtoms[i];

              // salt bridge: calculate hydrogen bond between Lys/Arg and Glu/Asp
              // hbonds: calculate hydrogen bond
              let bAtomCond = (bSaltbridge) ? ( atom.resn === 'LYS' && atom.elem === "N" && atom.name !== "N")
                || ( atom.resn === 'ARG' && (atom.name === "NH1" || atom.name === "NH2"))
                || ( (atom.resn === 'GLU' || atom.resn === 'ASP') && atom.elem === "O" && atom.name !== "O")
                || (atom.het && (atom.elem === "N" || atom.elem === "O" || atom.elem === "S") )
                : atom.elem === "N" || atom.elem === "O" || (atom.elem === "S" && (atom.het || atom.resn === "Cys" || atom.resn === "Met"));

              bAtomCond = (ic.bOpm) ? bAtomCond && atom.resn !== 'DUM' : bAtomCond;
              if(bAtomCond) {
                chain_resi = atom.structure + "_" + atom.chain + "_" + atom.resi;
                chain_resi_atom = chain_resi + "_" + atom.name;

                //var oriResidName = atom.resn + ' ' + chain_resi_atom;
                let serialList = (atom.name.indexOf('pi') == 0 && atom.ring) ? atom.ring.join(',') : atom.serial;
                let oriResidName = atom.resn + ' $' + atom.structure + '.' + atom.chain + ':' + atom.resi + '@' + atom.name + ' ' + serialList;
                if(ic.resid2Residhash[oriResidName] === undefined) ic.resid2Residhash[oriResidName] = {};

                for (let j in atomHbond) {
                  if(bSaltbridge) {
                      // skip both positive orboth negative cases
                      if( ( (atom.resn === 'LYS' || atom.resn === 'ARG') && (atomHbond[j].resn === 'LYS' || atomHbond[j].resn === 'ARG') ) ||
                        ( (atom.resn === 'GLU' || atom.resn === 'ASP') && (atomHbond[j].resn === 'GLU' || atomHbond[j].resn === 'ASP') ) ) {
                            continue;
                        }
                  }

                  if(!ic.crossstrucinter && atom.structure != atomHbond[j].structure) continue;

                  // skip same residue
                  if(chain_resi == j.substr(0, j.lastIndexOf('_') ) ) continue;

                  let xdiff = Math.abs(atom.coord.x - atomHbond[j].coord.x);
                  if(xdiff > threshold) continue;

                  let ydiff = Math.abs(atom.coord.y - atomHbond[j].coord.y);
                  if(ydiff > threshold) continue;

                  let zdiff = Math.abs(atom.coord.z - atomHbond[j].coord.z);
                  if(zdiff > threshold) continue;

                  let dist = xdiff * xdiff + ydiff * ydiff + zdiff * zdiff;
                  if(dist > maxlengthSq) continue;

                  if(ic.proteins.hasOwnProperty(atom.serial) && ic.proteins.hasOwnProperty(atomHbond[j].serial)
                    && (atom.name === 'N' || atom.name === 'O') && (atomHbond[j].name === 'O' || atomHbond[j].name === 'N') ) {

                    if(atom.name === atomHbond[j].name) continue;

                    if(atom.structure == atomHbond[j].structure && atom.chain == atomHbond[j].chain && Math.abs(atom.resi - atomHbond[j].resi) <= 1) continue; // peptide bond

                    // protein backbone hydrogen
                    // https://en.wikipedia.org/wiki/DSSP_(hydrogen_bond_estimation_algorithm)
                    let result;

                    let inDonor = (atom.name === 'N') ? atom : atomHbond[j];
                    let inAcceptor = (atom.name === 'O') ? atom : atomHbond[j];

                    if (inDonor.resn === 'Pro') {
                        continue;
                    }
                    else if (inDonor.hcoord === undefined) {
                        if(!this.isValidHbond(atom, atomHbond[j], threshold)) continue;
                    }
                    else {
                        let inDonorH = inDonor.hcoord;
                        let inDonorN = inDonor.coord;

                        let resid = inAcceptor.structure + "_" + inAcceptor.chain + "_" + inAcceptor.resi;
                        let C_atom;
                        for(let serial in ic.residues[resid]) {
                            if(ic.atoms[serial].name === 'C') {
                                C_atom = ic.atoms[serial];
                                break;
                            }
                        }

                        if(!C_atom) continue;

                        let inAcceptorC = C_atom.coord;
                        let inAcceptorO = inAcceptor.coord;

                        let distanceHO = inDonorH.distanceTo(inAcceptorO);
                        let distanceHC = inDonorH.distanceTo(inAcceptorC);
                        let distanceNC = inDonorN.distanceTo(inAcceptorC);
                        let distanceNO = inDonorN.distanceTo(inAcceptorO);

                        if (distanceHO < kMinimalDistance || distanceHC < kMinimalDistance || distanceNC < kMinimalDistance || distanceNO < kMinimalDistance) {
                            result = kMinHBondEnergy;
                        }
                        else {
                            result = kCouplingConstant / distanceHO - kCouplingConstant / distanceHC + kCouplingConstant / distanceNC - kCouplingConstant / distanceNO;
                        }

                        //if(result > kMaxHBondEnergy) {
                        if(atom.ss == 'helix' && atomHbond[j].ss == 'helix' && result > kMaxHBondEnergy) ;
                    }
                  }
                  else {
                      if(!this.isValidHbond(atom, atomHbond[j], threshold)) continue;
                  }

                  // too many hydrogen bonds for one atom
                  if(hbondCnt[atom.serial] > 2 || hbondCnt[atomHbond[j].serial] > 2) {
                      continue;
                  }

                  if(hbondCnt[atom.serial] === undefined) {
                      hbondCnt[atom.serial] = 1;
                  }
                  else {
                      ++hbondCnt[atom.serial];
                  }

                  if(hbondCnt[atomHbond[j].serial] === undefined) {
                      hbondCnt[atomHbond[j].serial] = 1;
                  }
                  else {
                      ++hbondCnt[atomHbond[j].serial];
                  }

                  // output hydrogen bonds
                  if(type !== 'graph') {
                      if(bSaltbridge) {
                          ic.saltbridgepnts.push({'serial': atom.serial, 'coord': atom.coord});
                          ic.saltbridgepnts.push({'serial': atomHbond[j].serial, 'coord': atomHbond[j].coord});
                      }
                      else {
                          ic.hbondpnts.push({'serial': atom.serial, 'coord': atom.coord});
                          ic.hbondpnts.push({'serial': atomHbond[j].serial, 'coord': atomHbond[j].coord});
                      }
                  }

                  let chain_resi2 = atomHbond[j].structure + "_" + atomHbond[j].chain + "_" + atomHbond[j].resi;
                  hbondsAtoms = me.hashUtilsCls.unionHash(hbondsAtoms, ic.residues[chain_resi]);
                  hbondsAtoms = me.hashUtilsCls.unionHash(hbondsAtoms, ic.residues[chain_resi2]);

                  residueHash[chain_resi] = 1;
                  residueHash[chain_resi2] = 1;

                  //var residName = atomHbond[j].resn + " " + atomHbond[j].structure + "_" + atomHbond[j].chain + "_" + atomHbond[j].resi + '_' + atomHbond[j].name;
                  let serialList = (atomHbond[j].name.indexOf('pi') == 0 && atomHbond[j].ring) ? atomHbond[j].ring.join(',') : atomHbond[j].serial;
                  let residName = atomHbond[j].resn + ' $' + atomHbond[j].structure + '.' + atomHbond[j].chain + ':' + atomHbond[j].resi + '@' + atomHbond[j].name  + ' ' + serialList;

                  let resids = chain_resi + '_' + atom.resn + ',' + chain_resi2 + '_' + atomHbond[j].resn;

                  if(ic.resids2interAll[resids] === undefined
                    || ic.resids2interAll[resids]['ionic'] === undefined
                    || !ic.resids2interAll[resids]['ionic'].hasOwnProperty(oriResidName + '|' + residName) ) {
                      ic.resid2Residhash[oriResidName][residName] = dist.toFixed(1);

                      if(!bInternal) {
                          if(ic.resids2inter[resids] === undefined) ic.resids2inter[resids] = {};
                          if(ic.resids2inter[resids]['hbond'] === undefined) ic.resids2inter[resids]['hbond'] = {};
                          ic.resids2inter[resids]['hbond'][oriResidName + '|' + residName] = dist.toFixed(1);
                      }

                      if(ic.resids2interAll[resids] === undefined) ic.resids2interAll[resids] = {};
                      if(ic.resids2interAll[resids]['hbond'] === undefined) ic.resids2interAll[resids]['hbond'] = {};
                      ic.resids2interAll[resids]['hbond'][oriResidName + '|' + residName] = dist.toFixed(1);
                  }
                } // end of for (let j in atomHbond) {
              }
            } // end of for (let i in targetAtoms) {

            let residueArray = Object.keys(residueHash);

            // draw sidec for these residues
            if(type !== 'graph') {
                for(let i = 0, il = residueArray.length; i < il; ++i) {
                    for(let j in ic.residues[residueArray[i]]) {
                        // all atoms should be shown for hbonds
                        ic.atoms[j].style2 = 'stick';
                    }
                }
            }

            return hbondsAtoms;
        }

        setHbondsContacts(options, type) { let ic = this.icn3d; ic.icn3dui;
            let hbond_contact = type;
            let hbonds_contact = (type == 'hbond') ? 'hbonds' : type;

            ic.lines[hbond_contact] = [];

            if (options[hbonds_contact].toLowerCase() === 'yes') {
                let color;
                let pnts;
                if(type == 'hbond') {
                    pnts = ic.hbondpnts;
                    color = '#0F0';
                }
                else if(type == 'saltbridge') {
                    pnts = ic.saltbridgepnts;
                    color = '#0FF';
                }
                else if(type == 'contact') {
                    pnts = ic.contactpnts;
                    color = '#888';
                }
                else if(type == 'halogen') {
                    pnts = ic.halogenpnts;
                    color = '#F0F';
                }
                else if(type == 'pi-cation') {
                    pnts = ic.picationpnts;
                    color = '#F00';
                }
                else if(type == 'pi-stacking') {
                    pnts = ic.pistackingpnts;
                    color = '#00F';
                }

                 for (let i = 0, lim = Math.floor(pnts.length / 2); i < lim; i++) {
                    let line = {    };
                    line.position1 = pnts[2 * i].coord;
                    line.serial1 = pnts[2 * i].serial;
                    line.position2 = pnts[2 * i + 1].coord;
                    line.serial2 = pnts[2 * i + 1].serial;
                    line.color = color;
                    line.dashed = true;

                    // only draw bonds connected with currently displayed atoms
                    if(line.serial1 !== undefined && line.serial2 !== undefined && !ic.dAtoms.hasOwnProperty(line.serial1) && !ic.dAtoms.hasOwnProperty(line.serial2)) continue;

                    //if(ic.lines[hbond_contact] === undefined) ic.lines[hbond_contact] = [];
                    ic.lines[hbond_contact].push(line);
                 }
            }
        }

        //Remove hydrogen bonds.
        hideHbonds() { let ic = this.icn3d; ic.icn3dui;
            ic.opts["hbonds"] = "no";
            if(ic.lines === undefined) ic.lines = { };
            ic.lines['hbond'] = [];
            ic.hbondpnts = [];
        }

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class PiHalogen {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        // get halogen, pi-cation,and pi-stacking
        calculateHalogenPiInteractions(startAtoms, targetAtoms, threshold, type, interactionType, bInternal) { let ic = this.icn3d, me = ic.icn3dui;
            if(Object.keys(startAtoms).length === 0 || Object.keys(targetAtoms).length === 0) return;

            let atoms1a = {}, atoms1b = {}, atoms2a = {}, atoms2b = {};
            if(interactionType == 'halogen') {
                for (let i in startAtoms) {
                  let atom = startAtoms[i];

                  atoms1a = me.hashUtilsCls.unionHash(atoms1a, this.getHalogenDonar(atom));
                  atoms2a = me.hashUtilsCls.unionHash(atoms2a, this.getHalogenAcceptor(atom));
                }

                for (let i in targetAtoms) {
                  let atom = targetAtoms[i];

                  atoms2b = me.hashUtilsCls.unionHash(atoms2b, this.getHalogenDonar(atom));
                  atoms1b = me.hashUtilsCls.unionHash(atoms1b, this.getHalogenAcceptor(atom));
                }
            }
            else if(interactionType == 'pi-cation') {
                ic.processedRes = {};
                for (let i in startAtoms) {
                  let atom = startAtoms[i];

                  atoms1a = me.hashUtilsCls.unionHash(atoms1a, this.getPi(atom, false));
                  atoms2a = me.hashUtilsCls.unionHash(atoms2a, this.getCation(atom));
                }

                ic.processedRes = {};
                for (let i in targetAtoms) {
                  let atom = targetAtoms[i];

                  atoms2b = me.hashUtilsCls.unionHash(atoms2b, this.getPi(atom, false));
                  atoms1b = me.hashUtilsCls.unionHash(atoms1b, this.getCation(atom));
                }
            }
            else if(interactionType == 'pi-stacking') {
                ic.processedRes = {};
                for (let i in startAtoms) {
                  let atom = startAtoms[i];
                  atoms1a = me.hashUtilsCls.unionHash(atoms1a, this.getPi(atom, true));
                }

                ic.processedRes = {};
                for (let i in targetAtoms) {
                  let atom = targetAtoms[i];

                  atoms1b = me.hashUtilsCls.unionHash(atoms1b, this.getPi(atom, true));
                } // for
            }

            let hbondsAtoms = {};
            let residueHash = {};

            ic.resid2Residhash = {};

            let maxlengthSq = threshold * threshold;

            for (let i in atoms1a) {
                let atom1 = atoms1a[i];
                let serialList = (atom1.name.indexOf('pi') == 0 && atom1.ring) ? atom1.ring.join(',') : atom1.serial;
                let oriResidName = atom1.resn + ' $' + atom1.structure + '.' + atom1.chain + ':' + atom1.resi + '@' + atom1.name + ' ' + serialList;
                if(ic.resid2Residhash[oriResidName] === undefined) ic.resid2Residhash[oriResidName] = {};

                for (let j in atoms1b) {
                  let atom2 = atoms1b[j];

                  if(!ic.crossstrucinter && atom1.structure != atom2.structure) continue;

                  // skip same residue
                  if(i.substr(0, i.lastIndexOf('_')) == j.substr(0, j.lastIndexOf('_')) ) continue;

                  // available in 1b and 2a
                  if(interactionType == 'pi-cation' && atom2.resn === 'ARG' && atom2.name === "NH1") {
                    let resid2 = atom2.structure + '_' + atom2.chain + '_' + atom2.resi;
                    let otherAtom = ic.firstAtomObjCls.getFirstAtomObjByName(ic.residues[resid2], 'NH2');

                    let coord = atom2.coord.clone().add(otherAtom.coord).multiplyScalar(0.5);
                    atom2 = me.hashUtilsCls.cloneHash(atom2);
                    atom2.coord = coord;
                  }

                  // available in 1a and 1b
                  // only parallel or perpendicular
                  if(interactionType == 'pi-stacking' && atom1.normal !== undefined && atom2.normal !== undefined) {
                      Math.abs(atom1.normal.dot(atom2.normal));
                      // perpendicular 30 degree || parallel, 30 degree
                      // remove this condition on Nov 19, 2021
                      //if(dotResult > 0.5 && dotResult < 0.866) continue;
                  }

                  let bResult = this.getHalogenPiInteractions(atom1, atom2, type, interactionType, threshold, maxlengthSq, oriResidName, bInternal);

                  if(bResult) {
                      hbondsAtoms = me.hashUtilsCls.unionHash(hbondsAtoms, ic.residues[atom1.structure + "_" + atom1.chain + "_" + atom1.resi]);
                      hbondsAtoms = me.hashUtilsCls.unionHash(hbondsAtoms, ic.residues[atom2.structure + "_" + atom2.chain + "_" + atom2.resi]);

                      residueHash[atom1.structure + "_" + atom1.chain + "_" + atom1.resi] = 1;
                      residueHash[atom2.structure + "_" + atom2.chain + "_" + atom2.resi] = 1;
                  }
                }
            }

            for (let i in atoms2a) {
                let atom1 = atoms2a[i];
                let serialList = (atom1.name.indexOf('pi') == 0 && atom1.ring) ? atom1.ring.join(',') : atom1.serial;
                let oriResidName = atom1.resn + ' $' + atom1.structure + '.' + atom1.chain + ':' + atom1.resi + '@' + atom1.name + ' ' + serialList;
                if(ic.resid2Residhash[oriResidName] === undefined) ic.resid2Residhash[oriResidName] = {};

                // available in 1b and 2a
                if(interactionType == 'pi-cation' && atom1.resn === 'ARG' && atom1.name === "NH1") {
                    let resid1 = atom1.structure + '_' + atom1.chain + '_' + atom1.resi;
                    let otherAtom = ic.firstAtomObjCls.getFirstAtomObjByName(ic.residues[resid1], 'NH2');

                    let coord = atom1.coord.clone().add(otherAtom.coord).multiplyScalar(0.5);
                    atom1 = me.hashUtilsCls.cloneHash(atom1);
                    atom1.coord = coord;
                }

                for (let j in atoms2b) {
                  let atom2 = atoms2b[j];

                  if(!ic.crossstrucinter && atom1.structure != atom2.structure) continue;

                  // skip same residue
                  if(i.substr(0, i.lastIndexOf('_')) == j.substr(0, j.lastIndexOf('_')) ) continue;

                  let bResult = this.getHalogenPiInteractions(atom1, atom2, type, interactionType, threshold, maxlengthSq, oriResidName, bInternal);

                  if(bResult) {
                      hbondsAtoms = me.hashUtilsCls.unionHash(hbondsAtoms, ic.residues[atom1.structure + "_" + atom1.chain + "_" + atom1.resi]);
                      hbondsAtoms = me.hashUtilsCls.unionHash(hbondsAtoms, ic.residues[atom2.structure + "_" + atom2.chain + "_" + atom2.resi]);

                      residueHash[atom1.structure + "_" + atom1.chain + "_" + atom1.resi] = 1;
                      residueHash[atom2.structure + "_" + atom2.chain + "_" + atom2.resi] = 1;
                  }
                }
            }

            let residueArray = Object.keys(residueHash);

            // draw sidec for these residues
            if(type !== 'graph') {
                for(let i = 0, il = residueArray.length; i < il; ++i) {
                    for(let j in ic.residues[residueArray[i]]) {
                        // all atoms should be shown for hbonds
                        ic.atoms[j].style2 = 'stick';
                        if(ic.ions.hasOwnProperty(j)) ic.atoms[j].style2 = 'sphere';
                    }
                }
            }

            return hbondsAtoms;
        }

        getHalogenDonar(atom) { let ic = this.icn3d; ic.icn3dui;
              let name2atom = {};
              //if(atom.elem === "F" || atom.elem === "CL" || atom.elem === "BR" || atom.elem === "I") {
              if(atom.elem === "CL" || atom.elem === "BR" || atom.elem === "I") {
                  let chain_resi_atom = atom.structure + "_" + atom.chain + "_" + atom.resi + "_" + atom.name;
                  name2atom[chain_resi_atom] = atom;
              }

              return name2atom;
        }

        getHalogenAcceptor(atom) { let ic = this.icn3d; ic.icn3dui;
              let name2atom = {};
              let bAtomCond = (atom.elem === "N" || atom.elem === "O" || atom.elem === "S");
              bAtomCond = (ic.bOpm) ? bAtomCond && atom.resn !== 'DUM' : bAtomCond;
              if(bAtomCond) {
                  let chain_resi_atom = atom.structure + "_" + atom.chain + "_" + atom.resi + "_" + atom.name;
                  name2atom[chain_resi_atom] = atom;
              }

              return name2atom;
        }

        getPi(atom, bStacking) { let ic = this.icn3d, me = ic.icn3dui;
              let name2atom = {};

              let chain_resi = atom.structure + "_" + atom.chain + "_" + atom.resi;

              let bAromatic = atom.het || ic.nucleotides.hasOwnProperty(atom.serial) || atom.resn === "PHE"
                || atom.resn === "TYR" || atom.resn === "TRP";
              if(bStacking) bAromatic = bAromatic || atom.resn === "HIS";

              if(bAromatic) {
                  if(!ic.processedRes.hasOwnProperty(chain_resi)) {

                      if(atom.het) { // get aromatic for ligands
                          let currName2atom = this.getAromaticPisLigand(chain_resi);
                          name2atom = me.hashUtilsCls.unionHash(name2atom, currName2atom);
                      }
                      else {
                          let piPosArray = undefined, normalArray = undefined, result = undefined;
                          if(ic.nucleotides.hasOwnProperty(atom.serial)) {
                              result = this.getAromaticRings(atom.resn, chain_resi, 'nucleotide');
                          }
                          else {
                              result = this.getAromaticRings(atom.resn, chain_resi, 'protein');
                          }

                          if(result !== undefined) {
                              piPosArray = result.piPosArray;
                              normalArray = result.normalArray;
                          }

                          for(let i = 0, il = piPosArray.length; i < il; ++i) {
                            name2atom[chain_resi + '_pi' + i] = {resn: atom.resn, name: 'pi' + i, coord: piPosArray[i], serial: atom.serial,
                            structure: atom.structure, chain: atom.chain, resi: atom.resi, normal: normalArray[i]};
                          }
                      }

                      ic.processedRes[chain_resi] = 1;
                  }
              }

              return name2atom;
        }

        getCation(atom) { let ic = this.icn3d, me = ic.icn3dui;
              let name2atom = {};

              // use of the two atoms
              if( atom.resn === 'ARG' && atom.name === "NH2") return;

              // remove HIS:  || atom.resn === 'HIS'
              // For ligands, "N" with one single bond only may be positively charged. => to be improved
              let bAtomCond = ( atom.resn === 'LYS' && atom.elem === "N" && atom.name !== "N")
                || ( atom.resn === 'ARG' && (atom.name === "NH1" || atom.name === "NH2"))
                || (atom.het && me.parasCls.cationsTrimArray.indexOf(atom.elem) !== -1)
                || (atom.het && atom.elem === "N" && (atom.bonds.length == 1 || atom.bonds.length == 4) ); // ligand in PDB 2ACE
              bAtomCond = (ic.bOpm) ? bAtomCond && atom.resn !== 'DUM' : bAtomCond;
              if(bAtomCond) {
                  let chain_resi_atom = atom.structure + "_" + atom.chain + "_" + atom.resi + "_" + atom.name;
                  name2atom[chain_resi_atom] = atom;
              }

              return name2atom;
        }

        getHalogenPiInteractions(atom1, atom2, type, interactionType, threshold, maxlengthSq, oriResidName, bInternal) { let ic = this.icn3d; ic.icn3dui;
              let xdiff = Math.abs(atom1.coord.x - atom2.coord.x);
              if(xdiff > threshold) return false;

              let ydiff = Math.abs(atom1.coord.y - atom2.coord.y);
              if(ydiff > threshold) return false;

              let zdiff = Math.abs(atom1.coord.z - atom2.coord.z);
              if(zdiff > threshold) return false;

              let dist = xdiff * xdiff + ydiff * ydiff + zdiff * zdiff;
              if(dist > maxlengthSq) return false;

              // output salt bridge
              if(type !== 'graph') {
                  if(interactionType == 'halogen') {
                      ic.halogenpnts.push({'serial': atom1.serial, 'coord': atom1.coord});
                      ic.halogenpnts.push({'serial': atom2.serial, 'coord': atom2.coord});
                  }
                  else if(interactionType == 'pi-cation') {
                      ic.picationpnts.push({'serial': atom1.serial, 'coord': atom1.coord});
                      ic.picationpnts.push({'serial': atom2.serial, 'coord': atom2.coord});
                  }
                  else if(interactionType == 'pi-stacking') {
                      ic.pistackingpnts.push({'serial': atom1.serial, 'coord': atom1.coord});
                      ic.pistackingpnts.push({'serial': atom2.serial, 'coord': atom2.coord});
                  }
              }

              let serialList = (atom2.name.indexOf('pi') == 0 && atom2.ring) ? atom2.ring.join(',') : atom2.serial;
              let residName = atom2.resn + ' $' + atom2.structure + '.' + atom2.chain + ':' + atom2.resi + '@' + atom2.name + ' ' + serialList;

              //if(ic.resid2Residhash[oriResidName][residName] === undefined || ic.resid2Residhash[oriResidName][residName] > dist) {
                  ic.resid2Residhash[oriResidName][residName] = dist.toFixed(1);
              //}

              let resids = atom1.structure + "_" + atom1.chain + "_" + atom1.resi + "_" + atom1.resn
                + ',' + atom2.structure + "_" + atom2.chain + "_" + atom2.resi + "_" + atom2.resn;

              if(!bInternal) {
                  if(ic.resids2inter[resids] === undefined) ic.resids2inter[resids] = {};
                  if(ic.resids2inter[resids][interactionType] === undefined) ic.resids2inter[resids][interactionType] = {};
                  ic.resids2inter[resids][interactionType][oriResidName + '|' + residName] = dist.toFixed(1);
              }

              if(ic.resids2interAll[resids] === undefined) ic.resids2interAll[resids] = {};
              if(ic.resids2interAll[resids][interactionType] === undefined) ic.resids2interAll[resids][interactionType] = {};
              ic.resids2interAll[resids][interactionType][oriResidName + '|' + residName] = dist.toFixed(1);

              return true;
        }

        getRingNormal(coordArray) { let ic = this.icn3d; ic.icn3dui;
            if(coordArray.length < 3) return undefined;

            let v1 = coordArray[0].clone().sub(coordArray[1]);
            let v2 = coordArray[1].clone().sub(coordArray[2]);

            return v1.cross(v2).normalize();
        }

        getAromaticRings(resn, resid, type) { let ic = this.icn3d; ic.icn3dui;
            let piPosArray = [];
            let normalArray = [];

            let coordArray1 = [];
            let coordArray2 = [];

            if(type == 'nucleotide') {
                let pos1 = new THREE.Vector3(), pos2 = new THREE.Vector3();
                if(resn.trim().toUpperCase() == 'A' || resn.trim().toUpperCase() == 'DA'
                  || resn.trim().toUpperCase() == 'G' || resn.trim().toUpperCase() == 'DG') {
                    for(let i in ic.residues[resid]) {
                        let atom = ic.atoms[i];
                        if(atom.name == 'N1' || atom.name == 'C2' || atom.name == 'N3' || atom.name == 'C6') {
                            pos1.add(atom.coord);

                            coordArray1.push(atom.coord);
                        }
                        else if(atom.name == 'C4' || atom.name == 'C5') {
                            pos1.add(atom.coord);
                            pos2.add(atom.coord);

                            coordArray1.push(atom.coord);
                            coordArray2.push(atom.coord);
                        }
                        else if(atom.name == 'N7' || atom.name == 'C8' || atom.name == 'N9') {
                            pos2.add(atom.coord);

                            coordArray2.push(atom.coord);
                        }
                    }

                    if(coordArray1.length == 6) {
                        pos1.multiplyScalar(1.0 / 6);
                        piPosArray.push(pos1);
                        normalArray.push(this.getRingNormal(coordArray1));
                    }

                    if(coordArray2.length == 5) {
                        pos2.multiplyScalar(1.0 / 5);
                        piPosArray.push(pos2);
                        normalArray.push(this.getRingNormal(coordArray2));
                    }
                }
                else if(resn.trim().toUpperCase() == 'C' || resn.trim().toUpperCase() == 'DC'
                  || resn.trim().toUpperCase() == 'T' || resn.trim().toUpperCase() == 'DT'
                  || resn.trim().toUpperCase() == 'U' || resn.trim().toUpperCase() == 'DU') {
                    for(let i in ic.residues[resid]) {
                        let atom = ic.atoms[i];
                        if(atom.name == 'N1' || atom.name == 'C2' || atom.name == 'N3' || atom.name == 'C6') {
                            pos1.add(atom.coord);

                            coordArray1.push(atom.coord);
                        }
                        else if(atom.name == 'C4' || atom.name == 'C5') {
                            pos1.add(atom.coord);

                            coordArray1.push(atom.coord);
                        }
                    }

                    if(coordArray1.length == 6) {
                        pos1.multiplyScalar(1.0 / 6);

                        piPosArray.push(pos1);

                        normalArray.push(this.getRingNormal(coordArray1));
                    }
                }
            }
            else if(type == 'protein') {
                let pos1 = new THREE.Vector3(), pos2 = new THREE.Vector3();

                if(resn.toUpperCase() == 'PHE' || resn.toUpperCase() == 'TYR') {
                    for(let i in ic.residues[resid]) {
                        let atom = ic.atoms[i];
                        if(atom.name == 'CG' || atom.name == 'CD1' || atom.name == 'CE1'
                          || atom.name == 'CZ' || atom.name == 'CE2' || atom.name == 'CD2') {
                            pos1.add(atom.coord);
                            coordArray1.push(atom.coord);
                        }
                    }

                    if(coordArray1.length == 6) {
                        pos1.multiplyScalar(1.0 / 6);

                        piPosArray.push(pos1);
                        normalArray.push(this.getRingNormal(coordArray1));
                    }
                }
                else if(resn.toUpperCase() == 'HIS') {
                    for(let i in ic.residues[resid]) {
                        let atom = ic.atoms[i];
                        if(atom.name == 'CG' || atom.name == 'ND1' || atom.name == 'CE1'
                          || atom.name == 'NE2' || atom.name == 'CD2') {
                            pos1.add(atom.coord);
                            coordArray1.push(atom.coord);
                        }
                    }

                    if(coordArray1.length == 5) {
                        pos1.multiplyScalar(1.0 / 5);

                        piPosArray.push(pos1);
                        normalArray.push(this.getRingNormal(coordArray1));
                    }
                }
                else if(resn.toUpperCase() == 'TRP') {
                    for(let i in ic.residues[resid]) {
                        let atom = ic.atoms[i];
                        if(atom.name == 'CZ2' || atom.name == 'CH2' || atom.name == 'CZ3' || atom.name == 'CE3') {
                            pos1.add(atom.coord);
                            coordArray1.push(atom.coord);
                        }
                        else if(atom.name == 'CD2' || atom.name == 'CE2') {
                            pos1.add(atom.coord);
                            pos2.add(atom.coord);
                            coordArray1.push(atom.coord);
                            coordArray2.push(atom.coord);
                        }
                        else if(atom.name == 'CG' || atom.name == 'CD1' || atom.name == 'NE1') {
                            pos2.add(atom.coord);
                            coordArray2.push(atom.coord);
                        }
                    }

                    if(coordArray1.length == 6) {
                        pos1.multiplyScalar(1.0 / 6);
                        piPosArray.push(pos1);
                        normalArray.push(this.getRingNormal(coordArray1));
                    }

                    if(coordArray2.length == 5) {
                        pos2.multiplyScalar(1.0 / 5);
                        piPosArray.push(pos2);
                        normalArray.push(this.getRingNormal(coordArray2));
                    }
                }
            }

            return {piPosArray: piPosArray, normalArray: normalArray} ;
        }

        // https://www.geeksforgeeks.org/print-all-the-cycles-in-an-undirected-graph/

        // Function to mark the vertex with
        // different colors for different cycles
        dfs_cycle(u, p, cyclenumber) { let ic = this.icn3d; ic.icn3dui;
            // already (completely) visited vertex.
            if (ic.ring_color[u] == 2) {
                return cyclenumber;
            }

            // seen vertex, but was not completely visited -> cycle detected.
            // backtrack based on parents to find the complete cycle.
            if (ic.ring_color[u] == 1) {

                cyclenumber++;
                let cur = p;
                ic.ring_mark[cur] = cyclenumber;

                // backtrack the vertex which are
                // in the current cycle that's found
                while (cur != u) {
                    cur = ic.ring_par[cur];
                    ic.ring_mark[cur] = cyclenumber;
                }
                return cyclenumber;
            }
            ic.ring_par[u] = p;

            // partially visited.
            ic.ring_color[u] = 1;

            // simple dfs on graph
            if(ic.atoms[u] !== undefined) {
                for(let k = 0, kl = ic.atoms[u].bonds.length; k < kl; ++k) {
                    let v = ic.atoms[u].bonds[k];

                    // if it has not been visited previously
                    if (v == ic.ring_par[u]) {
                        continue;
                    }
                    cyclenumber = this.dfs_cycle(v, u, cyclenumber);
                }
            }

            // completely visited.
            ic.ring_color[u] = 2;

            return cyclenumber;
        }

        getAromaticPisLigand(resid) { let ic = this.icn3d; ic.icn3dui;
            let name2atom = {};

            let serialArray = Object.keys(ic.residues[resid]);
            let n = serialArray.length;

            // arrays required to color the
            // graph, store the parent of node
            ic.ring_color = {};
            ic.ring_par = {};

            // mark with unique numbers
            ic.ring_mark = {};

            // store the numbers of cycle
            let cyclenumber = 0;
            //var edges = 13;

            // call DFS to mark the cycles
            //cyclenumber = this.dfs_cycle(1, 0, cyclenumber);
            cyclenumber = this.dfs_cycle(serialArray[1], serialArray[0], cyclenumber);

            let cycles = {};

            // push the edges that into the
            // cycle adjacency list
            for (let i = 0; i < n; i++) {
                let serial = serialArray[i];
                //if (ic.ring_mark[serial] != 0) {
                if (ic.ring_mark[serial]) {
                    if(cycles[ic.ring_mark[serial]] === undefined) cycles[ic.ring_mark[serial]] = [];
                    cycles[ic.ring_mark[serial]].push(serial);
                }
            }

            // print all the vertex with same cycle
            for (let i = 1; i <= cyclenumber; i++) {
                // Print the i-th cycle
                let coord = new THREE.Vector3();
                let cnt = 0, serial;
                let coordArray = [], ringArray = [];
                if(cycles.hasOwnProperty(i)) {
                    for (let j = 0, jl = cycles[i].length; j < jl; ++j) {
                        serial = cycles[i][j];
                        coord.add(ic.atoms[serial].coord);
                        coordArray.push(ic.atoms[serial].coord);
                        ringArray.push(serial);
                        ++cnt;
                    }
                }

                //if(cnt == 5 || cnt == 6) {
                if(cnt >= 3 && cnt <= 6 && coordArray[0] && coordArray[1] && coordArray[2] && coordArray[3]) { // two neighboring cycles 5 and 6 in caffeine (CID 2519) will get reported as 5 and 4 atoms. The shared two atoms are reported only once.
                    let v1 = coordArray[0].clone().sub(coordArray[1]).normalize();
                    let v2 = coordArray[1].clone().sub(coordArray[2]).normalize();
                    let v3 = coordArray[2].clone().sub(coordArray[3]).normalize();

                    let normal = v1.cross(v2).normalize();
                    let bPlane = normal.dot(v3);

                    //if(Math.abs(bPlane) < 0.017) { // same plane, 89-90 degree
                    if(Math.abs(bPlane) < 0.052) { // same plane, 87-90 degree
                        coord.multiplyScalar(1.0 / cnt);

                        let atom = ic.atoms[serial];
                        name2atom[resid + '_pi' + serial] = {resn: atom.resn, name: 'pi' + serial, coord: coord, serial: atom.serial,
                          structure: atom.structure, chain: atom.chain, resi: atom.resi, normal: normal, ring: ringArray};
                    }
                }
            }

            return name2atom;
        }

        hideHalogenPi() { let ic = this.icn3d; ic.icn3dui;
            ic.opts["halogen"] = "no";
            ic.opts["pi-cation"] = "no";
            ic.opts["pi-stacking"] = "no";
            if(ic.lines === undefined) ic.lines = { };
            ic.lines['halogen'] = [];
            ic.lines['pi-cation'] = [];
            ic.lines['pi-stacking'] = [];
            ic.halogenpnts = [];
            ic.picationpnts = [];
            ic.pistackingpnts = [];
        }

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Saltbridge {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        // get ionic interactions, including salt bridge (charged hydrogen bonds)
        calculateIonicInteractions(startAtoms, targetAtoms, threshold, bSaltbridge, type, bInternal) { let ic = this.icn3d, me = ic.icn3dui;
            if(Object.keys(startAtoms).length === 0 || Object.keys(targetAtoms).length === 0) return;

            ic.resid2Residhash = {};

            let atomCation = {}, atomAnion = {};
            let chain_resi, chain_resi_atom;

            let maxlengthSq = threshold * threshold;

            for (let i in startAtoms) {
              let atom = startAtoms[i];

              // only use one of the two atoms
              if( ( atom.resn === 'ARG' && atom.name === "NH2")
                || ( atom.resn === 'GLU' && atom.name === "OE2")
                || ( atom.resn === 'ASP' && atom.name === "OD2") ) {
                  continue;
              }

              // For ligand, "N" with one single bond only may be positively charged. => to be improved
              let bAtomCondCation = ( (atom.resn === 'LYS' || atom.resn === 'HIS') && atom.elem === "N" && atom.name !== "N")
                || ( atom.resn === 'ARG' && (atom.name === "NH1" || atom.name === "NH2"))
                || (atom.het && me.parasCls.cationsTrimArray.indexOf(atom.elem) !== -1)
                || (atom.het && atom.elem === "N" && atom.bonds.length == 1);

              let bAtomCondAnion = this.isAnion(atom);

              bAtomCondCation = (ic.bOpm) ? bAtomCondCation && atom.resn !== 'DUM' : bAtomCondCation;
              bAtomCondAnion = (ic.bOpm) ? bAtomCondAnion && atom.resn !== 'DUM' : bAtomCondAnion;

              if(bAtomCondCation || bAtomCondAnion) {
                chain_resi = atom.structure + "_" + atom.chain + "_" + atom.resi;
                chain_resi_atom = chain_resi + "_" + atom.name;

                if(bAtomCondCation) atomCation[chain_resi_atom] = atom;
                if(bAtomCondAnion) atomAnion[chain_resi_atom] = atom;
              }
            } // end of for (let i in startAtoms) {

            let hbondsAtoms = {};
            let residueHash = {};

            for (let i in targetAtoms) {
              let atom = targetAtoms[i];

              // only use one of the two atoms
              if( ( atom.resn === 'ARG' && atom.name === "NH2")
                || ( atom.resn === 'GLU' && atom.name === "OE2")
                || ( atom.resn === 'ASP' && atom.name === "OD2") ) {
                  continue;
              }

              let bAtomCondCation = ( (atom.resn === 'LYS' || atom.resn === 'HIS') && atom.elem === "N" && atom.name !== "N")
                || ( atom.resn === 'ARG' && (atom.name === "NH1" || atom.name === "NH2"))
                || (atom.het && me.parasCls.cationsTrimArray.indexOf(atom.elem) !== -1);

              let bAtomCondAnion = this.isAnion(atom);

              bAtomCondCation = (ic.bOpm) ? bAtomCondCation && atom.resn !== 'DUM' : bAtomCondCation;
              bAtomCondAnion = (ic.bOpm) ? bAtomCondAnion && atom.resn !== 'DUM' : bAtomCondAnion;
              if(bAtomCondCation || bAtomCondAnion) {
                chain_resi = atom.structure + "_" + atom.chain + "_" + atom.resi;
                chain_resi_atom = chain_resi + "_" + atom.name;

                let serialList = (atom.name.indexOf('pi') == 0 && atom.ring) ? atom.ring.join(',') : atom.serial;
                let oriResidName = atom.resn + ' $' + atom.structure + '.' + atom.chain + ':' + atom.resi + '@' + atom.name + ' ' + serialList;
                if(ic.resid2Residhash[oriResidName] === undefined) ic.resid2Residhash[oriResidName] = {};

                let atomHbond = {};
                if(bAtomCondCation) atomHbond = atomAnion;
                else if(bAtomCondAnion) atomHbond = atomCation;

                let otherAtom1 = undefined, resid1 = atom.structure + '_' + atom.chain + '_' + atom.resi;
                if( bAtomCondCation && atom.resn === 'ARG' && atom.name === "NH1") {
                    otherAtom1 = ic.firstAtomObjCls.getFirstAtomObjByName(ic.residues[resid1], 'NH2');
                }
                else if( bAtomCondAnion && atom.resn === 'GLU' && atom.name === "OE1") {
                    otherAtom1 = ic.firstAtomObjCls.getFirstAtomObjByName(ic.residues[resid1], 'OE2');
                }
                else if( bAtomCondAnion && atom.resn === 'ASP' && atom.name === "OD1") {
                    otherAtom1 = ic.firstAtomObjCls.getFirstAtomObjByName(ic.residues[resid1], 'OD2');
                }

                let coord1 = (otherAtom1 === undefined) ? atom.coord : atom.coord.clone().add(otherAtom1.coord).multiplyScalar(0.5);

                for (let j in atomHbond) {
                  // skip same residue
                  if(chain_resi == j.substr(0, j.lastIndexOf('_') )) continue;

                  if(!ic.crossstrucinter && atom.structure != atomHbond[j].structure) continue;

                    let otherAtom2 = undefined, resid2 = atomHbond[j].structure + '_' + atomHbond[j].chain + '_' + atomHbond[j].resi;
                    if( bAtomCondAnion && atomHbond[j].resn === 'ARG' && atomHbond[j].name === "NH1") {
                        otherAtom2 = ic.firstAtomObjCls.getFirstAtomObjByName(ic.residues[resid2], 'NH2');
                    }
                    else if( bAtomCondCation && atomHbond[j].resn === 'GLU' && atomHbond[j].name === "OE1") {
                        otherAtom2 = ic.firstAtomObjCls.getFirstAtomObjByName(ic.residues[resid2], 'OE2');
                    }
                    else if( bAtomCondCation && atomHbond[j].resn === 'ASP' && atomHbond[j].name === "OD1") {
                        otherAtom2 = ic.firstAtomObjCls.getFirstAtomObjByName(ic.residues[resid2], 'OD2');
                    }

                    let coord2 = (otherAtom2 === undefined) ? atomHbond[j].coord : atomHbond[j].coord.clone().add(otherAtom2.coord).multiplyScalar(0.5);

                  let xdiff = Math.abs(coord1.x - coord2.x);
                  if(xdiff > threshold) continue;

                  let ydiff = Math.abs(coord1.y - coord2.y);
                  if(ydiff > threshold) continue;

                  let zdiff = Math.abs(coord1.z - coord2.z);
                  if(zdiff > threshold) continue;

                  let dist = xdiff * xdiff + ydiff * ydiff + zdiff * zdiff;
                  if(dist > maxlengthSq) continue;

                  // output salt bridge
                  if(type !== 'graph') {
                      ic.saltbridgepnts.push({'serial': atom.serial, 'coord': coord1});
                      ic.saltbridgepnts.push({'serial': atomHbond[j].serial, 'coord': coord2});
                  }

                  let chain_resi2 = atomHbond[j].structure + "_" + atomHbond[j].chain + "_" + atomHbond[j].resi;

                  hbondsAtoms = me.hashUtilsCls.unionHash(hbondsAtoms, ic.residues[chain_resi]);
                  hbondsAtoms = me.hashUtilsCls.unionHash(hbondsAtoms, ic.residues[chain_resi2]);

                  residueHash[chain_resi] = 1;
                  residueHash[chain_resi2] = 1;

                  let serialList = (atomHbond[j].name.indexOf('pi') == 0 && atomHbond[j].ring) ? atomHbond[j].ring.join(',') : atomHbond[j].serial;
                  let residName = atomHbond[j].resn + ' $' + atomHbond[j].structure + '.' + atomHbond[j].chain + ':' + atomHbond[j].resi + '@' + atomHbond[j].name  + ' ' + serialList;

                  //if(ic.resid2Residhash[oriResidName][residName] === undefined || ic.resid2Residhash[oriResidName][residName] > dist) {
                      ic.resid2Residhash[oriResidName][residName] = dist.toFixed(1);
                  //}

                  let resids = chain_resi + '_' + atom.resn + ',' + chain_resi2 + '_' + atomHbond[j].resn;

                  if(!bInternal) {
                      if(ic.resids2inter[resids] === undefined) ic.resids2inter[resids] = {};
                      if(ic.resids2inter[resids]['ionic'] === undefined) ic.resids2inter[resids]['ionic'] = {};
                      ic.resids2inter[resids]['ionic'][oriResidName + '|' + residName] = dist.toFixed(1);
                  }

                  if(ic.resids2interAll[resids] === undefined) ic.resids2interAll[resids] = {};
                  if(ic.resids2interAll[resids]['ionic'] === undefined) ic.resids2interAll[resids]['ionic'] = {};
                  ic.resids2interAll[resids]['ionic'][oriResidName + '|' + residName] = dist.toFixed(1);

                } // end of for (let j in atomHbond) {
              }
            } // end of for (let i in targetAtoms) {

            let residueArray = Object.keys(residueHash);

            // draw sidec for these residues
            if(type !== 'graph') {
                for(let i = 0, il = residueArray.length; i < il; ++i) {
                    for(let j in ic.residues[residueArray[i]]) {
                        // all atoms should be shown for hbonds
                        ic.atoms[j].style2 = 'stick';
                        if(ic.ions.hasOwnProperty(j)) ic.atoms[j].style2 = 'sphere';
                    }
                }
            }

            return hbondsAtoms;
        }

        isAnion(atom) { let ic = this.icn3d, me = ic.icn3dui;
          // For ligand, "O" in carboxy group may be negatively charged. => to be improved
          let bLigNeg = undefined;
          if(atom.het && atom.elem === "O" && atom.bonds.length == 1) {
                let cAtom = ic.atoms[atom.bonds[0]];
                for(let j = 0; j < cAtom.bonds.length; ++j) {
                    let serial = cAtom.bonds[j];
                    if(ic.atoms[serial].elem == "O" && serial != atom.serial) {
                        bLigNeg = true;
                        break;
                    }
                }
          }

          // "O" in phosphae or sulfate group is neagatively charged
          if(atom.elem === "O" && atom.bonds.length == 1) {
            let pAtom = ic.atoms[atom.bonds[0]];
            if(pAtom.elem == "P" || pAtom.elem == "S") bLigNeg = true;      
          }          

          let bAtomCondAnion = ( atom.resn === 'GLU' && (atom.name === "OE1" || atom.name === "OE2") )
            || ( atom.resn === 'ASP' && (atom.name === "OD1" || atom.name === "OD2") )
            || ( ic.nucleotides.hasOwnProperty(atom.serial) && (atom.name === "OP1" || atom.name === "OP2" || atom.name === "O1P" || atom.name === "O2P"))
            || (atom.het && me.parasCls.anionsTrimArray.indexOf(atom.elem) !== -1)
            || bLigNeg;
              
          return bAtomCondAnion;
        }
        
        hideSaltbridge() { let ic = this.icn3d; ic.icn3dui;
            ic.opts["saltbridge"] = "no";
            if(ic.lines === undefined) ic.lines = { };
            ic.lines['saltbridge'] = [];
            ic.saltbridgepnts = [];
        }

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class SetStyle {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //For a list of atoms, set the hash with style as key and atom serial as value.
        setStyle2Atoms(atoms) { let ic = this.icn3d; ic.icn3dui;
              ic.style2atoms = {};

              for(let i in atoms) {
                // do not show water in assembly
                //if(ic.bAssembly && ic.water.hasOwnProperty(i)) {
                //    ic.atoms[i].style = 'nothing';
                //}

                if(ic.style2atoms[ic.atoms[i].style] === undefined) ic.style2atoms[ic.atoms[i].style] = {};

                ic.style2atoms[ic.atoms[i].style][i] = 1;

                // side chains
                if(ic.atoms[i].style2 !== undefined && ic.atoms[i].style2 !== 'nothing') {
                    if(ic.style2atoms[ic.atoms[i].style2] === undefined) ic.style2atoms[ic.atoms[i].style2] = {};

                    ic.style2atoms[ic.atoms[i].style2][i] = 1;
                }
              }
        }

        // set atom style when loading a structure
        //Set atom style according to the definition in options (options.secondaryStructure, etc).
        setAtomStyleByOptions(options) { let ic = this.icn3d, me = ic.icn3dui;
            if(options === undefined) options = ic.opts;

            let selectedAtoms;

            if (options.proteins !== undefined) {
                selectedAtoms = me.hashUtilsCls.intHash(ic.hAtoms, ic.proteins);
                for(let i in selectedAtoms) {
                  ic.atoms[i].style = options.proteins.toLowerCase();
                }
            }

            // side chain use style2
            if (options.sidec !== undefined && options.sidec !== 'nothing') {
                selectedAtoms = me.hashUtilsCls.intHash(ic.hAtoms, ic.sidec);
                //var sidec_calpha = me.hashUtilsCls.unionHash(ic.calphas, ic.sidec);
                //selectedAtoms = me.hashUtilsCls.intHash(ic.hAtoms, sidec_calpha);

                for(let i in selectedAtoms) {
                  ic.atoms[i].style2 = options.sidec.toLowerCase();
                }
            }

            if (options.ntbase !== undefined && options.ntbase !== 'nothing') {
              selectedAtoms = me.hashUtilsCls.intHash(ic.hAtoms, ic.ntbase);

              for(let i in selectedAtoms) {
                ic.atoms[i].style2 = options.ntbase.toLowerCase();
              }
            }

            if (options.chemicals !== undefined) {
                selectedAtoms = me.hashUtilsCls.intHash(ic.hAtoms, ic.chemicals);
                for(let i in selectedAtoms) {
                  ic.atoms[i].style = options.chemicals.toLowerCase();
                }
            }

            if (options.ions !== undefined) {
                selectedAtoms = me.hashUtilsCls.intHash(ic.hAtoms, ic.ions);
                for(let i in selectedAtoms) {
                  ic.atoms[i].style = options.ions.toLowerCase();
                }
            }

            if (options.water !== undefined) {
                selectedAtoms = me.hashUtilsCls.intHash(ic.hAtoms, ic.water);
                for(let i in selectedAtoms) {
                  ic.atoms[i].style = options.water.toLowerCase();
                }
            }

            if (options.nucleotides !== undefined) {
                selectedAtoms = me.hashUtilsCls.intHash(ic.hAtoms, ic.nucleotides);
                for(let i in selectedAtoms) {
                  ic.atoms[i].style = options.nucleotides.toLowerCase();
                }
            }
        }

        setBackground(color) {var ic = this.icn3d, me = ic.icn3dui;
          
           ic.setOptionCls.setOption('background', color);
           me.htmlCls.clickMenuCls.setLogCmd('set background ' + color, true);
           //let titleColor =(color == 'black' || color == 'transparent') ? me.htmlCls.GREYD : 'black';
           let titleColor = (color == 'black') ? me.htmlCls.GREYD : 'black';
           $("#" + ic.pre + "title").css("color", titleColor);
           $("#" + ic.pre + "titlelink").css("color", titleColor);
        }

        //Save the command history to session storage so that the viewer can show the previous state when refreshing the same page.
        saveCommandsToSession() {var ic = this.icn3d; ic.icn3dui;
            let dataStr = ic.commands.join('\n');
            let data = decodeURIComponent(dataStr);
            sessionStorage.setItem('commands', data);
        }

        //http://jasonjl.me/blog/2015/06/21/taking-action-on-browser-crashes/
        //Set the commands before the browser crashed. These commands are used to restore your previous
        //state by refreshing the crashed page. It works in Chrome, Firefox, and Internet Explorer in PC,
        //but neither Safari nor Mac.
        getCommandsBeforeCrash() {var ic = this.icn3d, me = ic.icn3dui;
           window.addEventListener('load', function() {
              sessionStorage.setItem('good_exit', 'pending');
           });
           window.addEventListener('beforeunload', function() {
              sessionStorage.setItem('good_exit', 'true');
           });
           if(sessionStorage.getItem('good_exit') && sessionStorage.getItem('good_exit') === 'pending') {
              if(!me.utilsCls.isMac()) ic.bCrashed = true;  // this doesn't work in mac
              ic.commandsBeforeCrash = sessionStorage.getItem('commands');
              if(!ic.commandsBeforeCrash) ic.commandsBeforeCrash = '';
           }
        }

        handleContextLost() {var ic = this.icn3d; ic.icn3dui;
            //https://www.khronos.org/webgl/wiki/HandlingContextLost
            // 1 add a lost context handler and tell it to prevent the default behavior

            let canvas = $("#" + ic.pre + "canvas")[0];
            canvas.addEventListener("webglcontextlost", function(event) {
                event.preventDefault();
            }, false);

            // 2 re-setup all your WebGL state and re-create all your WebGL resources when the context is restored.
            canvas.addEventListener("webglcontextrestored", function(event) {
                // IE11 error: WebGL content is taking too long to render on your GPU. Temporarily switching to software rendering.
                console.log("WebGL context was lost. Reset WebGLRenderer and launch iCn3D again.");

                ic.renderer = new THREE.WebGLRenderer({
                  canvas: ic.oriContainer.get(0), //this.container.get(0),
                  antialias: true,
                  preserveDrawingBuffer: true,
                  sortObjects: false,
                  alpha: true
                });
                // Enable VR
                ic.renderer.xr.enabled = true;

                ic.drawCls.draw();

            }, false);
        }

        adjustIcon() {var ic = this.icn3d; ic.icn3dui;
          if(ic.STATENUMBER === 1) {
            if($("#" + ic.pre + "back").hasClass('icn3d-middleIcon')) {
              $("#" + ic.pre + "back").toggleClass('icn3d-middleIcon');
              $("#" + ic.pre + "back").toggleClass('icn3d-endIcon');
            }
          }
          else {
            if($("#" + ic.pre + "back").hasClass('icn3d-endIcon')) {
              $("#" + ic.pre + "back").toggleClass('icn3d-middleIcon');
              $("#" + ic.pre + "back").toggleClass('icn3d-endIcon');
            }
          }
          if(ic.STATENUMBER === ic.commands.length) {
            if($("#" + ic.pre + "forward").hasClass('icn3d-middleIcon')) {
              $("#" + ic.pre + "forward").toggleClass('icn3d-middleIcon');
              $("#" + ic.pre + "forward").toggleClass('icn3d-endIcon');
            }
          }
          else {
            if($("#" + ic.pre + "forward").hasClass('icn3d-endIcon')) {
              $("#" + ic.pre + "forward").toggleClass('icn3d-middleIcon');
              $("#" + ic.pre + "forward").toggleClass('icn3d-endIcon');
            }
          }
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class SetColor {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        colorSpectrum(atoms) { let ic = this.icn3d, me = ic.icn3dui;
            let idx = 0;
            let cnt = 0;

            // for selected atoms
            atoms = me.hashUtilsCls.intHash(atoms, ic.hAtoms);

            for (let i in atoms) {
                ic.atoms[i];
                // if(!atom.het) ++cnt;
                ++cnt;
            }

            let lastTerSerialInv = (cnt > 1) ? 1 / (cnt - 1) : 1;
            for (let i in atoms) {
                let atom = ic.atoms[i];
                // atom.color = atom.het ? me.parasCls.atomColors[atom.elem] || me.parasCls.defaultAtomColor : me.parasCls.thr().setHSL(3 / 4 * (1 - idx++ * lastTerSerialInv), 1, 0.45);
                atom.color = me.parasCls.thr().setHSL(3 / 4 * (1 - idx++ * lastTerSerialInv), 1, 0.45);

                ic.atomPrevColors[i] = atom.color;
            }
        }

        colorRainbow(atoms) { let ic = this.icn3d, me = ic.icn3dui;
            let idx = 0;
            let cnt = 0;

            // for selected atoms
            atoms = me.hashUtilsCls.intHash(atoms, ic.hAtoms);

            for (let i in atoms) {
                ic.atoms[i];
                // if(!atom.het) ++cnt;
                ++cnt;
            }

            let lastTerSerialInv = (cnt > 1) ? 1 / (cnt - 1) : 1;
            for (let i in atoms) {
                let atom = ic.atoms[i];
                // atom.color = atom.het ? me.parasCls.atomColors[atom.elem] || me.parasCls.defaultAtomColor : me.parasCls.thr().setHSL(3 / 4 *  idx++ * lastTerSerialInv, 1, 0.45);
                atom.color = me.parasCls.thr().setHSL(3 / 4 *  idx++ * lastTerSerialInv, 1, 0.45);

                ic.atomPrevColors[i] = atom.color;
            }
        }

        setColorAcrossSets(nameArray, bSpectrum) { let ic = this.icn3d, me = ic.icn3dui;
            let idx = 0;
            let cnt = nameArray.length;

            let lastTerSerialInv = (cnt > 1) ? 1 / (cnt - 1) : 1;
            for(let i = 0, il = nameArray.length; i < il; ++i) {
                let atomSet = ic.definedSetsCls.getAtomsFromNameArray([nameArray[i]]);
                for (let serial in atomSet) {
                    let atom = ic.atoms[serial];

                    if(bSpectrum) {
                        atom.color = me.parasCls.thr().setHSL(3 / 4 * (1 - idx * lastTerSerialInv), 1, 0.45);
                    }
                    else { // rainbow
                        atom.color = me.parasCls.thr().setHSL(3 / 4 *  idx * lastTerSerialInv, 1, 0.45);
                    }

                    ic.atomPrevColors[serial] = atom.color;
                }
                ++idx;
            }

            ic.drawCls.draw();
        }

        setColorBySets(nameArray, bSpectrum) { let ic = this.icn3d; ic.icn3dui;
            for(let i = 0, il = nameArray.length; i < il; ++i) {
                let atoms = ic.definedSetsCls.getAtomsFromNameArray([nameArray[i]]);

                if(bSpectrum) {
                    this.colorSpectrum(atoms);
                }
                else { // rainbow
                    this.colorRainbow(atoms);
                }
            }

            ic.drawCls.draw();
        }

        //Set atom color according to the definition in options (options.color).
        setColorByOptions(options, atoms, bUseInputColor) { let ic = this.icn3d, me = ic.icn3dui;
         if(options !== undefined) {
          if(bUseInputColor) {
            for (let i in atoms) {
                let atom = ic.atoms[i];

                ic.atomPrevColors[i] = atom.color;
            }
          }
          else if(options.color.indexOf("#") === 0) {
            for (let i in atoms) {
                let atom = ic.atoms[i];
                atom.color = me.parasCls.thr().setStyle(options.color.toLowerCase());

                ic.atomPrevColors[i] = atom.color;
            }
          }
          else {
            let idx, cnt, lastTerSerialInv;
            let minB, maxB;

            if(options.color.toLowerCase() == 'confidence') {
                $("#" + me.pre + "legend").show();
            }
            else {
                $("#" + me.pre + "legend").hide();
            }

            switch (options.color.toLowerCase()) {
                case 'rainbow':
                    this.colorRainbow(atoms);
                    break;
                case 'rainbow for chains':
                    for(let chainid in ic.chains) {
                        this.colorRainbow(ic.chains[chainid]);
                    }
                    break;
                case 'spectrum':
                    this.colorSpectrum(atoms);
                    break;
                case 'spectrum for chains':
                    for(let chainid in ic.chains) {
                        this.colorSpectrum(ic.chains[chainid]);
                    }
                    break;

                case 'structure':
                    let colorArray = (ic.bAfMem) ? [me.parasCls.thr(0xFF00FF), me.parasCls.thr(0x00FF00)] : me.parasCls.stdChainColors;
                    let index = -1, prevStructure = '', colorLength = colorArray.length;
                    for (let i in atoms) {
                        let atom = ic.atoms[i];

                        if(atom.structure != prevStructure) {
                            ++index;

                            index = index % colorLength;
                        }

                        if(!atom.het) {
                            atom.color = colorArray[index];
                            ic.atomPrevColors[i] = atom.color;
                        }
                        else {
                            atom.color = me.parasCls.atomColors[atom.elem];
                            ic.atomPrevColors[i] = atom.color;
                        }

                        prevStructure = atom.structure;
                    }
                    break;

                case 'chain':
                    if(ic.chainsColor !== undefined && Object.keys(ic.chainsColor).length > 0) { // mmdb input   
                        this.setMmdbChainColor();
                    }
                    else {
                        let index = -1, prevChain = '', colorLength = me.parasCls.stdChainColors.length;
                        for (let i in atoms) {
                            let atom = ic.atoms[i];

                            if(atom.chain != prevChain) {
                                ++index;

                                index = index % colorLength;
                            }

                            //if(atom.color === undefined) atom.color = me.parasCls.stdChainColors[index];
                            if(!atom.het) {
                                atom.color = me.parasCls.stdChainColors[index];

                                if(Object.keys(ic.chainsColor).length > 0) this.updateChainsColor(atom);
                                ic.atomPrevColors[i] = atom.color;
                            }
                            else {
                                atom.color = me.parasCls.atomColors[atom.elem];
                                ic.atomPrevColors[i] = atom.color;
                            }

                            prevChain = atom.chain;
                        }
                    }
                    break;

                case 'domain':
                    idx = 0;
                    cnt = 0;
                    let domainArray = Object.keys(ic.tddomains);
                    cnt = domainArray.length;
                    lastTerSerialInv = (cnt > 1) ? 1 / (cnt - 1) : 1;
                    for (let i = 0, il = domainArray.length; i < il; ++i) {
                        let color = me.parasCls.thr().setHSL(3 / 4 * (1 - idx++ * lastTerSerialInv), 1, 0.45);

                        for(let resid in ic.tddomains[domainArray[i]]) {
                            for(let serial in ic.residues[resid]) {
                                let atom = ic.atoms[serial];
                                atom.color = color;
                                ic.atomPrevColors[serial] = atom.color;
                            }
                        }
                    }
                    break;

                case 'defined sets':
                    idx = 0;

                    if(!ic.nameArray || ic.nameArray.length == 0) {
                        alert('Please first select sets in "Analysis > Defined Sets", and try it again.');
                    }
                    else {
                        cnt = ic.nameArray.length;
                        lastTerSerialInv = (cnt > 1) ? 1 / (cnt - 1) : 1;
                        for (let i = 0; i < cnt; ++i) {
                            let definedSetName = ic.nameArray[i];
                            let definedSet = ic.definedSetsCls.getAtomsFromNameArray([definedSetName]);

                            let color = me.parasCls.thr().setHSL(3 / 4 * idx++ * lastTerSerialInv, 1, 0.45);

                            for(let serial in definedSet) {
                                let atom = ic.atoms[serial];
                                atom.color = color;
                                ic.atomPrevColors[serial] = atom.color;
                            }
                        }
                    }

                    break;

                case 'secondary structure green':
                case 'secondary structure':
                    ic.sheetcolor = 'green';
                    for (let i in atoms) {
                        let atom = ic.atoms[i];
                        // secondary color of nucleotide: blue (me.parasCls.thr(0x0000FF))
                        atom.color = atom.het ? me.parasCls.atomColors[atom.elem] || me.parasCls.defaultAtomColor : me.parasCls.ssColors[atom.ss] || me.parasCls.thr(0xFF00FF);

                        ic.atomPrevColors[i] = atom.color;
                    }

                    break;

                case 'secondary structure yellow':
                //case 'secondary structure':
                    ic.sheetcolor = 'yellow';
                    for (let i in atoms) {
                        let atom = ic.atoms[i];
                        // secondary color of nucleotide: blue (me.parasCls.thr(0x0000FF))
                        atom.color = atom.het ? me.parasCls.atomColors[atom.elem] || me.parasCls.defaultAtomColor : me.parasCls.ssColors2[atom.ss] || me.parasCls.thr(0xFF00FF);

                        ic.atomPrevColors[i] = atom.color;
                    }

                    break;

                case 'secondary structure spectrum':
                    idx = 0;
                    cnt = 0;

                    let ssArray = [];
                    let prevI = -9999, start;
                    let prevAtom;
                    for (let i in atoms) {
                        // only for proteins
                        if(!ic.proteins.hasOwnProperty(i)) continue;

                        let atom = ic.atoms[i];

                        if(prevI == -9999) start = parseInt(i);

                        if(prevI != -9999 && (atom.ss != prevAtom.ss || Math.abs(atom.resi - prevAtom.resi) > 1 || (atom.ssbegin && prevAtom.ssend) ) ) {
                            if(prevAtom.ss == 'coil') ;
                            else {
                                ssArray.push([start, prevI]);
                            }
                            start = i;
                        }

                        prevI = parseInt(i);
                        prevAtom = atom;
                    }

                    if(prevAtom.ss == 'coil') ;
                    else {
                        ssArray.push([start, prevI]);
                    }

                    cnt = ssArray.length;
                    lastTerSerialInv = (cnt > 1) ? 1 / (cnt - 1) : 1;
                    for (let i = 0, il = ssArray.length; i < il; ++i) {
                        //var color = me.parasCls.thr().setHSL(2 / 3 * (1 - idx++ * lastTerSerialInv), 1, 0.45);
                        let color = me.parasCls.thr().setHSL(3 / 4 * (1 - idx++ * lastTerSerialInv), 1, 0.45);

                        for(let serial = ssArray[i][0]; serial <= ssArray[i][1]; ++serial) {
                            let atom = ic.atoms[serial];
                            atom.color = color;
                            ic.atomPrevColors[serial] = atom.color;
                        }
                    }

                    // keep the color of coils untouched
    /*
                    let color = me.parasCls.ssColors2['coil']
                    for (let i = 0, il = coilArray.length; i < il; ++i) {
                        for(let serial = coilArray[i][0]; serial <= coilArray[i][1]; ++serial) {
                            let atom = ic.atoms[serial];
                            atom.color = color;
                            ic.atomPrevColors[serial] = atom.color;
                        }
                    }
    */
                    break;

                case 'residue':
                    for (let i in atoms) {
                        let atom = ic.atoms[i];
                        atom.color = atom.het ? me.parasCls.atomColors[atom.elem] || me.parasCls.defaultAtomColor : me.parasCls.residueColors[atom.resn] || me.parasCls.defaultResidueColor;

                        ic.atomPrevColors[i] = atom.color;
                    }

                    break;

                case 'ig strand':
                    if(ic.bShowRefnum) {
                        let color;
                        let residueHash = ic.firstAtomObjCls.getResiduesFromAtoms(atoms);

                        for(let resid in residueHash) {
                            if(!ic.resid2refnum[resid]) {              
                                color = me.parasCls.thr('#00FFFF'); //('#FFFFFF');
                            }
                            else {
                                let refnumLabel = ic.resid2refnum[resid];
                                
                                // if(!refnumLabel) {
                                //     color = me.parasCls.thr(me.htmlCls.GREYB);
                                // }
                                // else {
                                    let refnumStr = ic.refnumCls.rmStrandFromRefnumlabel(refnumLabel);
                                    let currStrand = refnumLabel.replace(new RegExp(refnumStr,'g'), '');
                                    color = ic.annoIgCls.getRefnumColor(currStrand);
                                    if(ic.residIgLoop.hasOwnProperty(resid)) {                            
                                        color = me.parasCls.thr(me.htmlCls.GREYB);
                                    }
                                // }
                            }
                                
                            for (let i in ic.residues[resid]) {
                                let atom = ic.atoms[i];
                                atom.color = me.parasCls.thr(color);
            
                                ic.atomPrevColors[i] = atom.color;
                            }
                        }
                    }

                    break;

                case 'ig protodomain':
                    if(ic.bShowRefnum) {
                        let color;
                        let residueHash = ic.firstAtomObjCls.getResiduesFromAtoms(atoms);
                        for(let resid in residueHash) {
                            if(!ic.resid2refnum[resid]) {
                                color = me.parasCls.thr('#00FFFF'); //('#FFFFFF');
                            }
                            else {
                                let refnumLabel = ic.resid2refnum[resid];

                                if(!refnumLabel) {
                                    color = me.parasCls.thr(me.htmlCls.GREYB);
                                }
                                else {
                                    let refnumStr = ic.refnumCls.rmStrandFromRefnumlabel(refnumLabel);
                                    let currStrand = refnumLabel.replace(new RegExp(refnumStr,'g'), '');
                                    color = ic.annoIgCls.getProtodomainColor(currStrand);

                                    if(ic.residIgLoop.hasOwnProperty(resid)) {
                                        color = me.parasCls.thr(me.htmlCls.GREYB);
                                    }
                                }
                            }
                            
                            for (let i in ic.residues[resid]) {
                                let atom = ic.atoms[i];
                                atom.color = me.parasCls.thr(color);
            
                                ic.atomPrevColors[i] = atom.color;
                            }
                        }
                    }

                    break;

                case 'residue custom':
                    for (let i in atoms) {
                        let atom = ic.atoms[i];
                        atom.color = atom.het ? me.parasCls.atomColors[atom.elem] || me.parasCls.defaultAtomColor : ic.customResidueColors[atom.resn] || me.parasCls.defaultResidueColor;

                        ic.atomPrevColors[i] = atom.color;
                    }
                    break;

                case 'align custom':
                    // http://proteopedia.org/wiki/index.php/Temperature_color_schemes
                    // Fixed: Middle (white): 50, red: >= 100, blue: 0
                    ic.middB = 50;
                    ic.spanBinv1 = 0.02;
                    ic.spanBinv2 = 0.02;

                    for(let serial in atoms) {
                        let chainid = ic.atoms[serial].structure + '_' + ic.atoms[serial].chain;
                        if(ic.queryresi2score === undefined || !ic.queryresi2score.hasOwnProperty(chainid)) continue;

                        //var resi = ic.atoms[serial].resi - 1;
                        let color;
                        //if(ic.target2queryHash.hasOwnProperty(resi) && ic.target2queryHash[resi] !== -1) { // -1 means gap
                            //var queryresi = ic.target2queryHash[resi] + 1;
                            //var queryresi = ic.atoms[serial].resi;
                        let queryresi = ic.atoms[serial].resi;

                        if(ic.queryresi2score[chainid].hasOwnProperty(queryresi)) {
                            let b = ic.queryresi2score[chainid][queryresi];

                            if(b > 100) b = 100;

                            let s1 = (ic.middB - b) * ic.spanBinv1;
                            let s2 = (b - ic.middB) * ic.spanBinv2;
                            if(b < ic.middB) {
                                if(ic.startColor == 'blue') {
                                    color = (ic.midColor == 'white') ? me.parasCls.thr().setRGB(1 - s1, 1 - s1, 1) : me.parasCls.thr().setRGB(0, 0, s1);
                                }
                                else if(ic.startColor == 'red') {
                                    color = (ic.midColor == 'white') ? me.parasCls.thr().setRGB(1, 1 - s1, 1 - s1) : me.parasCls.thr().setRGB(s1, 0, 0);
                                }
                                else if(ic.startColor == 'green') {
                                    color = (ic.midColor == 'white') ? me.parasCls.thr().setRGB(1 - s1, 1, 1 - s1) : me.parasCls.thr().setRGB(0, s1, 0);
                                }
                            }
                            else {
                                if(ic.endColor == 'red') {
                                    color = (ic.midColor == 'white') ? me.parasCls.thr().setRGB(1, 1 - s2, 1 - s2) : me.parasCls.thr().setRGB(s2, 0, 0);
                                }
                                else if(ic.endColor == 'green') {
                                    color = (ic.midColor == 'white') ? me.parasCls.thr().setRGB(1 - s2, 1, 1 - s2) : me.parasCls.thr().setRGB(0, s2, 0);
                                }
                                else if(ic.endColor == 'blue') {
                                    color = (ic.midColor == 'white') ? me.parasCls.thr().setRGB(1 - s2, 1 - s2, 1) : me.parasCls.thr().setRGB(0, 0, s2);
                                }
                            }
                        }
                        else {
                            color = me.parasCls.defaultAtomColor;
                        }
                        //}
                        //else {
                        //    color = me.parasCls.defaultAtomColor;
                        //}

                        ic.atoms[serial].color = color;
                        ic.atomPrevColors[serial] = color;
                    }

                    //ic.updateHlAll();
                    break;

                case 'charge':
                    for (let i in atoms) {
                        let atom = ic.atoms[i];

                        //atom.color = atom.het ? me.parasCls.atomColors[atom.elem] || me.parasCls.defaultAtomColor : me.parasCls.chargeColors[atom.resn] || me.parasCls.defaultResidueColor;
                        atom.color = atom.het ? me.parasCls.defaultAtomColor : me.parasCls.chargeColors[atom.resn] || me.parasCls.defaultResidueColor;

                        ic.atomPrevColors[i] = atom.color;
                    }

                    break;
                case 'hydrophobic':
                    for (let i in atoms) {
                        let atom = ic.atoms[i];

                        //atom.color = atom.het ? me.parasCls.atomColors[atom.elem] || me.parasCls.defaultAtomColor : me.parasCls.chargeColors[atom.resn] || me.parasCls.defaultResidueColor;
                        atom.color = atom.het ? me.parasCls.defaultAtomColor : me.parasCls.hydrophobicColors[atom.resn] || me.parasCls.defaultResidueColor;

                        ic.atomPrevColors[i] = atom.color;
                    }
                    break;
                case 'normalized hydrophobic':
                    for (let i in atoms) {
                        let atom = ic.atoms[i];

                        //atom.color = atom.het ? me.parasCls.atomColors[atom.elem] || me.parasCls.defaultAtomColor : me.parasCls.chargeColors[atom.resn] || me.parasCls.defaultResidueColor;
                        atom.color = atom.het ? me.parasCls.defaultAtomColor : me.parasCls.normalizedHPColors[atom.resn] || me.parasCls.defaultResidueColor;

                        ic.atomPrevColors[i] = atom.color;
                    }

                    break;
                case 'atom':
                    for (let i in atoms) {
                        let atom = ic.atoms[i];
                        atom.color = me.parasCls.atomColors[atom.elem] || me.parasCls.defaultAtomColor;

                        ic.atomPrevColors[i] = atom.color;
                    }

                    break;

                case 'confidence':
                    for (let i in atoms) {
                        let atom = ic.atoms[i];
                        if(atom.b === undefined || isNaN(atom.b) || parseInt(atom.b * 1000) == 0) { // invalid b-factor
                            atom.color =  me.parasCls.thr().setRGB(0, 1, 0);
                        }
                        else {
                            let b = atom.b;
                            
                            // PDB
                            b = (atom.structure.substr(0, 4) != ic.defaultPdbId && atom.structure.length < 6) ? 100 - b : b;

                            if(b >= 90) {
                                atom.color = me.parasCls.thr().setRGB(0, 0.325, 0.839);
                            }
                            else if(b >= 70 && b < 90) {
                                atom.color = me.parasCls.thr().setRGB(0.396, 0.572, 0.953);
                            }
                            else if(b >= 50 && b < 70) {
                                atom.color = me.parasCls.thr().setRGB(1, 0.859, 0.075);
                            }
                            else if(b < 50) {
                                atom.color = me.parasCls.thr().setRGB(1, 0.490, 0.271);
                            }
                        }

                        ic.atomPrevColors[i] = atom.color;
                    }

                    break;

                case 'b factor':
                    // http://proteopedia.org/wiki/index.php/Temperature_color_schemes
                    // Fixed: Middle (white): 50, red: >= 100, blue: 0
                    ic.middB = 50;
                    ic.spanBinv1 = 0.02;
                    ic.spanBinv2 = 0.02;

                    for (let i in atoms) {
                        let atom = ic.atoms[i];
                        if(atom.b === undefined || isNaN(atom.b) || parseInt(atom.b * 1000) == 0) { // invalid b-factor
                            atom.color =  me.parasCls.thr().setRGB(0, 1, 0);
                        }
                        else {
                            let b = atom.b;
                            if(b > 100) b = 100;

                            // AlphaFold
                            b = (atom.structure.substr(0, 4) != ic.defaultPdbId && atom.structure.length > 5) ? 100 - b : b;

                            let s1 = (ic.middB - b) * ic.spanBinv1;
                            let s2 = (b - ic.middB) * ic.spanBinv2;

                            atom.color = b < ic.middB ? me.parasCls.thr().setRGB(1 - s1, 1 - s1, 1) : me.parasCls.thr().setRGB(1, 1 - s2, 1 - s2);
                        }

                        if(ic.bOpm && atom.resn == 'DUM') atom.color = me.parasCls.atomColors[atom.elem];

                        ic.atomPrevColors[i] = atom.color;
                    }

                    break;

                case 'b factor percentile':
                    //http://proteopedia.org/wiki/index.php/Disorder
                    // percentile normalize B-factor values from 0 to 1
                    minB = 1000;
                    maxB = -1000;
                    if (!ic.bfactorArray) {
                        ic.bfactorArray = [];
                        for (let i in ic.atoms) {
                            let atom = ic.atoms[i];
                            if (minB > atom.b) minB = atom.b;
                            if (maxB < atom.b) maxB = atom.b;

                            ic.bfactorArray.push(atom.b);
                        }

                        ic.bfactorArray.sort(function(a, b) { return a - b; });
                    }

                    let totalCnt = ic.bfactorArray.length;
                    for (let i in atoms) {
                        let atom = ic.atoms[i];
                        if(atom.b === undefined || isNaN(atom.b) || parseInt(atom.b * 1000) == 0 || ic.bfactorArray.length == 0) { // invalid b-factor
                            atom.color =  me.parasCls.thr().setRGB(0, 1, 0);
                        }
                        else {
                            // AlphaFold
                            let b = (atom.structure > 5) ? 100 - atom.b : atom.b;

                            let percentile = ic.bfactorArray.indexOf(b) / totalCnt;

                            atom.color = percentile < 0.5 ? me.parasCls.thr().setRGB(percentile * 2, percentile * 2, 1) : me.parasCls.thr().setRGB(1, (1 - percentile) * 2, (1 - percentile) * 2);
                        }

                        ic.atomPrevColors[i] = atom.color;
                    }

                    break;

                case 'area':
                    if(ic.resid2area === undefined) {
                        // calculate area to set up ic.resid2area
                        let currHAtoms = me.hashUtilsCls.cloneHash(ic.hAtoms);

                        // calculate area for all
                        ic.hAtoms = me.hashUtilsCls.cloneHash(ic.atoms);

                        ic.bCalcArea = true;
                        ic.opts.surface = 'solvent accessible surface';
                        ic.applyMapCls.applySurfaceOptions();
                        ic.bCalcArea = false;

                        ic.hAtoms = me.hashUtilsCls.cloneHash(currHAtoms);
                    }

                    // http://proteopedia.org/wiki/index.php/Temperature_color_schemes
                    // Fixed: Middle (white): 50, red: >= 100, blue: 0
                    let middB = (ic.midpercent !== undefined) ? ic.midpercent : 35;
                    ic.spanBinv1 = 0.02;
                    ic.spanBinv2 = 0.02;

                    for (let i in atoms) {
                        let atom = ic.atoms[i];
                        let resid = atom.structure + '_' + atom.chain + '_' + atom.resi + '_' + atom.resn;

                        let b = (me.parasCls.residueArea.hasOwnProperty(atom.resn)) ? ic.resid2area[resid] / me.parasCls.residueArea[atom.resn] * 100 : middB;

                        if(b > 100) b = 100;

                        let s1 = (middB - b) * ic.spanBinv1;
                        let s2 = (b - middB) * ic.spanBinv2;

                        atom.color = b < middB ? me.parasCls.thr().setRGB(1 - s1, 1 - s1, 1) : me.parasCls.thr().setRGB(1, 1 - s2, 1 - s2);

                        if(ic.bOpm && atom.resn == 'DUM') atom.color = me.parasCls.atomColors[atom.elem];

                        ic.atomPrevColors[i] = atom.color;
                    }
                    break;

                case 'identity':
                    this.setConservationColor(atoms, true);
                    break;

                case 'conserved': // backward-compatible, "conserved" was changed to "identity"
                    this.setConservationColor(atoms, true);
                    break;

                case 'conservation':
                    this.setConservationColor(atoms, false);
                    break;

                case 'white':
                    this.setAtmClr(atoms, 0xFFFFFF);
                    break;

                case 'grey':
                    this.setAtmClr(atoms, 0x888888);
                    break;

                case 'red':
                    this.setAtmClr(atoms, 0xFF0000);
                    break;
                case 'green':
                    this.setAtmClr(atoms, 0x00FF00);
                    break;
                case 'blue':
                    this.setAtmClr(atoms, 0x0000FF);
                    break;
                case 'magenta':
                    this.setAtmClr(atoms, 0xFF00FF);
                    break;
                case 'yellow':
                    this.setAtmClr(atoms, 0xFFFF00);
                    break;
                case 'cyan':
                    this.setAtmClr(atoms, 0x00FFFF);
                    break;
                case 'custom':
                    // do the coloring separately
                    break;

                default: // the "#" was missed in order to make sharelink work
                    for (let i in atoms) {
                        let atom = ic.atoms[i];
                        atom.color = me.parasCls.thr().setStyle("#" + options.color.toLowerCase());

                        ic.atomPrevColors[i] = atom.color;
                    }

                    break;
            }

            ic.legendTableCls.showColorLegend(options.color.toLowerCase());
          }
         }
        }

        setAtmClr(atoms, hex) { let ic = this.icn3d, me = ic.icn3dui;
            for (let i in atoms) {
                let atom = ic.atoms[i];
                atom.color = me.parasCls.thr().setHex(hex);

                ic.atomPrevColors[i] = atom.color;
            }
        }

        updateChainsColor(atom) { let ic = this.icn3d; ic.icn3dui;
            let chainid = atom.structure + '_' + atom.chain;
            if(ic.chainsColor[chainid] !== undefined) {  // for mmdbid and align input
                ic.chainsColor[chainid] = atom.color;
            }
        }

        setMmdbChainColor(inAtoms) { let ic = this.icn3d, me = ic.icn3dui;
            let atoms = (inAtoms === undefined) ? ic.hAtoms : inAtoms;
            this.applyOriginalColor(me.hashUtilsCls.hash2Atoms(atoms, ic.atoms));

            // atom color
            let atomHash;
            atomHash = me.hashUtilsCls.unionHash(atomHash, ic.chemicals);
            atomHash = me.hashUtilsCls.unionHash(atomHash, ic.ions);

            for (let i in atomHash) {
                let atom = ic.atoms[i];
                atom.color = me.parasCls.atomColors[atom.elem] || me.parasCls.defaultAtomColor;

                ic.atomPrevColors[i] = atom.color;
            }
        }

        setConservationColor(atoms, bIdentity) { let ic = this.icn3d, me = ic.icn3dui;
            this.setMmdbChainColor(atoms);

            for(let chainid in ic.alnChainsSeq) {
                let resObjectArray = ic.alnChainsSeq[chainid];

                for(let i = 0, il = resObjectArray.length; i < il; ++i) {
                    let residueid = chainid + '_' + resObjectArray[i].resi;

                    for(let j in ic.residues[residueid]) {
                        if(atoms.hasOwnProperty(j)) {
                            let color = (bIdentity) ? me.parasCls.thr(resObjectArray[i].color) : me.parasCls.thr(resObjectArray[i].color2);
                            ic.atoms[j].color = color;
                            ic.atomPrevColors[j] = color;
                        }
                    }
                }
            }
        }

        applyOriginalColor(atoms) { let ic = this.icn3d, me = ic.icn3dui;
            if(atoms === undefined) atoms = ic.atoms;

            for (let i in atoms) {
                let atom = atoms[i];
                let chainid = atom.structure + '_' + atom.chain;

                if(ic.chainsColor.hasOwnProperty(chainid)) {
                    atom.color = ic.chainsColor[chainid];
                }
                else {
                    atom.color = me.parasCls.atomColors[atom.elem];
                    //break;
                }

                ic.atomPrevColors[i] = atom.color;
            }
        }

        applyPrevColor() { let ic = this.icn3d; ic.icn3dui;
            for (let i in ic.atoms) {
                let atom = ic.atoms[i];
                atom.color = ic.atomPrevColors[i];
            }
        }

        //Set the outline color when highlighting atoms. The available options are "yellow", "green", and "red".
        setOutlineColor(colorStr) { let ic = this.icn3d; ic.icn3dui;
            // outline using ShaderMaterial: http://jsfiddle.net/Eskel/g593q/9/
            let shader = {
                'outline' : {
                    vertex_shader: [
                        "uniform float offset;",
                        "void main() {",
                            "vec4 pos = modelViewMatrix * vec4( position + normal * offset, 1.0 );",
                            "gl_Position = projectionMatrix * pos;",
                        "}"
                    ].join("\n"),

                    fragment_shader: [
                        "void main(){",
                            "gl_FragColor = vec4( 1.0, 1.0, 0.0, 1.0 );",
                        "}"
                    ].join("\n")
                }
            };

            if(colorStr === 'yellow') {
               shader.outline.fragment_shader = [
                   "void main(){",
                       "gl_FragColor = vec4( 1.0, 1.0, 0.0, 1.0 );",
                   "}"
               ].join("\n");
            }
            else if(colorStr === 'green') {
               shader.outline.fragment_shader = [
                   "void main(){",
                       "gl_FragColor = vec4( 0.0, 1.0, 0.0, 1.0 );",
                   "}"
               ].join("\n");
            }
            else if(colorStr === 'red') {
               shader.outline.fragment_shader = [
                   "void main(){",
                       "gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );",
                   "}"
               ].join("\n");
            }

            // shader
            let uniforms = {offset: {
                type: "f",
                //value: 1
                value: 0.5
              }
            };

            let outShader = shader['outline'];

            let matShader = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: outShader.vertex_shader,
                fragmentShader: outShader.fragment_shader,
                depthTest: false,
                depthWrite: false,
                //needsUpdate: true
            });

            return matShader;
        }
    }

    /**
    * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
    */

    class SetOption {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Modify the display options, e.g., setOption('color', 'green')
        setOption(id, value) {var ic = this.icn3d; ic.icn3dui;
          //var options2 = {}
          //options2[id] = value;
          // remember the options
          ic.opts[id] = value;
          ic.selectionCls.saveSelectionIfSelected();
          if(id === 'color') {
              ic.setColorCls.setColorByOptions(ic.opts, ic.hAtoms);
              ic.drawCls.draw();
              //let residueHash = ic.firstAtomObjCls.getResiduesFromCalphaAtoms(ic.hAtoms);
              //ic.hlUpdateCls.changeSeqColor(Object.keys(residueHash));

              //ic.hlUpdateCls.updateHlAll(ic.nameArray);
              ic.hlUpdateCls.updateHlAll();

              // change graph color
              ic.getGraphCls.updateGraphColor();
          }
          else if(id === 'surface' || id === 'opacity' || id === 'wireframe') {
              if(id === 'opacity' || id === 'wireframe') {
                  ic.applyMapCls.removeLastSurface();
              }
              ic.applyMapCls.applySurfaceOptions();
              //if(ic.bRender) ic.drawCls.render();
              ic.drawCls.draw(); // to make surface work in assembly
          }
          else if(id === 'map' || id === 'mapwireframe') {
              if(id === 'mapwireframe') {
                  ic.applyMapCls.removeLastMap();
              }
              ic.applyMapCls.applyMapOptions();
              //if(ic.bRender) ic.drawCls.render();
              ic.drawCls.draw(); // to make surface work in assembly
          }
          else if(id === 'emmap' || id === 'emmapwireframe') {
              if(id === 'emmapwireframe') {
                  ic.applyMapCls.removeLastEmmap();
              }
              ic.applyMapCls.applyEmmapOptions();
              //if(ic.bRender) ic.drawCls.render();
              ic.drawCls.draw(); // to make surface work in assembly
          }
          else if(id === 'phimap' || id === 'phimapwireframe') {
              if(id === 'phimapwireframe') {
                  ic.applyMapCls.removeLastPhimap();
              }
              ic.applyMapCls.applyPhimapOptions();
              //if(ic.bRender) ic.drawCls.render();
              ic.drawCls.draw(); // to make surface work in assembly
          }
          else if(id === 'phisurface') {
              ic.applyMapCls.applyphisurfaceOptions();
              //if(ic.bRender) ic.drawCls.render();
              ic.drawCls.draw(); // to make surface work in assembly
          }
          else if(id === 'chemicalbinding') {
              ic.bSkipChemicalbinding = false;
              ic.drawCls.draw();
          }
          else {
              ic.drawCls.draw();
          }
        }

        //Set the styles of predefined "protein", "nucleotides", etc.
        setStyle(selectionType, style) {var ic = this.icn3d, me = ic.icn3dui;
          let atoms = {};
          switch(selectionType) {
              case 'proteins':
                  atoms = me.hashUtilsCls.intHash(ic.hAtoms, ic.proteins);
                  if(Object.keys(ic.hAtoms).length < Object.keys(ic.proteins).length) ;

                  // remove disulfide bonds
                  if(style == 'nothing') {
                    ic.opts["ssbonds"] = "no";
                    ic.lines['ssbond'] = [];
                    for(let i in atoms) {
                        ic.atoms[i].style2 = 'nothing';
                    }
                  }
                  else {
                    ic.opts["ssbonds"] = "yes";
                  }

                  break;
              case 'sidec':
                  atoms = me.hashUtilsCls.intHash(ic.hAtoms, ic.sidec);
                  //calpha_atoms = me.hashUtilsCls.intHash(ic.hAtoms, ic.calphas);
                  // include calphas
                  //atoms = me.hashUtilsCls.unionHash(atoms, calpha_atoms);
                  break;
              case 'nucleotides':
                  atoms = me.hashUtilsCls.intHash(ic.hAtoms, ic.nucleotides);
                  if(Object.keys(ic.hAtoms).length < Object.keys(ic.nucleotides).length) ;
                  break;
              case 'ntbase':
                  atoms = me.hashUtilsCls.intHash(ic.hAtoms, ic.ntbase);
                  break;
              case 'chemicals':
                  atoms = me.hashUtilsCls.intHash(ic.hAtoms, ic.chemicals);
                  break;
              case 'ions':
                  atoms = me.hashUtilsCls.intHash(ic.hAtoms, ic.ions);
                  break;
              case 'water':
                  atoms = me.hashUtilsCls.intHash(ic.hAtoms, ic.water);
                  break;
          }
          // draw sidec separately
          if(selectionType === 'sidec' || selectionType === 'ntbase') {
              for(let i in atoms) {
                ic.atoms[i].style2 = style;
              }
          }
          else {
              for(let i in atoms) {
                ic.atoms[i].style = style;
              }
          }
          ic.opts[selectionType] = style;
          ic.selectionCls.saveSelectionIfSelected();
          ic.drawCls.draw();
        }

        //Save the current style setting so that these styles can be restored later by clicking "Apply Saved Style" in the Style menu.
        saveStyle() {var ic = this.icn3d; ic.icn3dui;
           for(let i in ic.atoms) {
               let atom = ic.atoms[i];
               atom.styleSave = atom.style;
               if(atom.style2 !== undefined) atom.style2Save = atom.style2;
           }
        }

        //Restore the previously saved style.
        applySavedStyle() {var ic = this.icn3d; ic.icn3dui;
           for(let i in ic.atoms) {
               let atom = ic.atoms[i];
               if(atom.styleSave !== undefined) {
                   atom.style = atom.styleSave;
               }
               if(atom.style2Save !== undefined) {
                   atom.style2 = atom.style2Save;
               }
           }
           ic.drawCls.draw();
        }

        //Save the current color setting so that these colors can be restored later by clicking "Apply Saved Color" in the Color menu.
        saveColor() {var ic = this.icn3d; ic.icn3dui;
           for(let i in ic.atoms) {
               let atom = ic.atoms[i];
               atom.colorSave = atom.color.clone();
           }
        }

        //Restore the previously saved color.
        applySavedColor() {var ic = this.icn3d; ic.icn3dui;
           for(let i in ic.atoms) {
               let atom = ic.atoms[i];
               if(atom.colorSave !== undefined) {
                   atom.color = atom.colorSave.clone();
                   ic.atomPrevColors[i] = atom.color;
               }
           }
           
           ic.hlUpdateCls.changeSeqColor(Object.keys(ic.residues));
           ic.drawCls.draw();
        }
    }

    /**
     * @author Jack Lin <th3linja@yahoo.com> / https://github.com/ncbi/icn3d
     */

     class LegendTable {
         constructor(icn3d) {
             this.icn3d = icn3d;
         }

         showColorLegend(colorType) { let ic = this.icn3d, me = ic.icn3dui;

            let colorLabel = colorType.substr(0, 1).toUpperCase() + colorType.substr(1);
            if(colorType == 'confidence') {
                colorLabel = 'pLDDT';
            }
            else if(colorType == 'normalized hydrophobic') {
                colorLabel = 'Normalized Hydrophobicity';
            }
            else if(colorType == 'hydrophobic') {
                colorLabel = 'Hydrophobicity';
            }
            else if(colorType == 'ig strand') {
                colorLabel = 'Ig Strand';
            }
            else if(colorType == 'ig protodomain') {
                colorLabel = 'Ig Protodomain';
            }
            else if(colorType == 'exon') {
                colorLabel = 'Exon';
            }

            let html = "Color by <b>" + colorLabel + "</b><br><br>";
     
            //if (ic.legendClick == 1){
            if (colorType == 'atom'){  
                let categoryArray = ['proteins', 'nucleotides', 'chemicals', 'ions', 'water'];
                for(let i = 0, il = categoryArray.length; i < il; ++i) {
                    let category = categoryArray[i];
                    let atomHash = me.hashUtilsCls.intHash(ic[category], ic.hAtoms);
                    html += this.getColorLegendForElem(category, atomHash);
                }
            }
            //else if (ic.legendClick == 2){
            else if (colorType == 'residue'){
                html += this.getColorLegendForResidue(ic.hAtoms);
            }
            //else if (ic.legendClick == 3){
            else if (colorType == 'charge'){
                html += this.getColorLegendForCharge(ic.hAtoms);
            }
            else if (colorType == 'ig strand'){
                html += this.getColorLegendForIgstrand(ic.hAtoms);
            }
            else if (colorType == 'ig protodomain'){
                html += this.getColorLegendForIgproto(ic.hAtoms);
            }
            //else if (ic.legendClick == 4){
            else if (colorType == 'normalized hydrophobic' || colorType == 'hydrophobic') {
                let bOriResn = true;
                let resSet = this.getRes2color(ic.hAtoms, bOriResn);

                // polar first - most to least
                // create hydrophobic table
                var items = Object.keys(resSet).map(
                    //(key) => { return [key, Object.keys(resSet[key])[0]] 
                    (key) => { return [key, me.parasCls.hydrophobicValues[key]] 
                });

                // items.sort(
                //     (first, second) => { 
                //         return ((parseInt(second[1].substring(2,4), 16) - parseInt(second[1].substring(4,6), 16)) - (parseInt(first[1].substring(2,4), 16) - parseInt(first[1].substring(4,6), 16)));
                //     }
                // );

                items.sort(
                    (first, second) => { 
                        return parseFloat(first[1]) - parseFloat(second[1]);
                    }
                );

                var keys = items.map(
                    //(e) => { return [e[0], e[1]]
                    (e) => { return [e[0], Object.keys(resSet[e[0]])[0]]
                });

                html += "<div>";
                
                if(colorType == 'normalized hydrophobic') {
                    html += "Dark green (W, F, L, I, Y, M, V, C): Hydrophobic<br>";
                    html += "Light green (P, T, S, A, Q, N, G): Polar<br>";
                    html += "Grey: Charged, not hydrophobic<br><br>";
                }
                else {
                    html += "Green (W, F, L, I, Y, M, V, C): Hydrophobic<br>";
                    html += "Yellow (P, T, S, A, Q, N, G): Polar<br>";
                    html += "Red: Negatively Charged<br>";
                    html += "Blue: Positively Charged<br><br>";
                }

                let cnt = 0;
                for (let key of keys) {
                    if(!me.parasCls.residueAbbrev[key[0]]) continue;

                    html += "<div style='display:inline-block; width:100px'>";
                    html += "<div style='width: 10px; height: 10px; background-color:#" + key[1] + "; border: 0px;display:inline-block;' ></div> ";
                    html +=  me.parasCls.residueAbbrev[key[0]] + "</div>";

                    if(cnt % 4 == 3) html += "<br>";

                    ++cnt;
                }
                html += "</div>";
            }
            //else if (ic.legendClick == 5){
            else if (colorType == 'b factor') {
                html += "<div style='width:450px'>B factor quantitates the uncertainty for each atom. A high B factor reflects that the position is less certain.</div><br>";
                html += me.htmlCls.clickMenuCls.setLegendHtml();
            }
            //else if (ic.legendClick == 6){
            else if (colorType == 'confidence') {
                html += me.htmlCls.clickMenuCls.setLegendHtml(true);
            }
            else if (colorType == 'exon') {
                ic.startColor = 'red';
                ic.midColor = 'white';
                ic.endColor = 'blue';

                ic.startValue = 'Start';
                ic.midValue = 'Middle';
                ic.endValue = 'End';

                html += me.htmlCls.clickMenuCls.setLegendHtml();
            }
            else {
                html = '';
            }

            if(html) {
                $("#" + me.pre + "dl_legend_html").html(html);
                me.htmlCls.dialogCls.openDlg('dl_legend', 'Color Legend');
            }
            else {
                if($('#' + me.pre + 'dl_legend').hasClass('ui-dialog-content') && $('#' + me.pre + 'dl_legend').dialog( 'isOpen' )) $("#" + me.pre + "dl_legend").dialog("close");
            }

            // if(bClose) {
            //     if(window.dialog && window.dialog.hasClass('ui-dialog-content')) window.dialog.dialog( "close" );
            // }
         }

         getColorLegendForElem(category, atomHash) { let ic = this.icn3d, me = ic.icn3dui;
            let html = '';
            let elemSet = {};

            for (let serial in atomHash){
                // atom = ic.atoms[Object.keys(atomHash)[k]];
                let atom = ic.atoms[serial];
                let temp = (atom === undefined || atom.color === undefined || atom.color.getHexString().toUpperCase() === 'FFFFFF') ? 'DDDDDD' : atom.color.getHexString();
                if (elemSet[atom.elem] === undefined){
                    elemSet[atom.elem] = {};
                }
                elemSet[atom.elem][temp] = 1;
            }

            if(Object.keys(elemSet).length > 0) {
                //html += "<button value='" + category + "' display='block'>" + category + "</button><br>";
                html += "<b>" + category + "</b><br>";
                let elemArray = Object.keys(elemSet).sort();
                //for (let k in elemSet) {
                for(let i = 0, il = elemArray.length; i < il; ++i) {
                    let k = elemArray[i];

                    html += "<span>";
                    for (let v in elemSet[k]) {
                        html += "<div style='width: 10px; height: 10px; background-color:#" + v + "; border: 0px;display:inline-block;' ></div> ";
                    }
                    html +=  me.parasCls.atomnames[k.toUpperCase()] + "</span><br>";
                }
                html += "<br>";
            }

            return html;
         }

         getRes2color(atomHash, bOriResn) { let ic = this.icn3d, me = ic.icn3dui;
            let resSet = {};

            let residueHash = ic.firstAtomObjCls.getResiduesFromAtoms(atomHash);
            for(let resid in residueHash){
                let atomHash = ic.residues[resid];

                let atom = ic.firstAtomObjCls.getFirstAtomObj(atomHash);
                let resiLabel = (bOriResn) ? atom.resn : me.parasCls.residueAbbrev[atom.resn];
                let temp = (atom === undefined || atom.color === undefined || atom.color.getHexString().toUpperCase() === 'FFFFFF') ? 'DDDDDD' : atom.color.getHexString();
                
                if (resiLabel != undefined){
                    if (resSet[resiLabel] === undefined){
                        resSet[resiLabel] = {};
                    }
                    resSet[resiLabel][temp] = 1;
                }
            }

            return resSet;
         }

         getColorLegendForResidue(atomHash) { let ic = this.icn3d; ic.icn3dui;
            let html = '';

            let resSet = this.getRes2color(atomHash);

            if(Object.keys(resSet).length > 0) {
                //html += "<button value='" + pdbid + "' display='block'>" + pdbid + "</button><br>";
                html += "<div>";
                let residueArray = Object.keys(resSet).sort();
                //for (let k in resSet) {
                let dnaHtml = '';
                let cnt = 0;
                for(let i = 0, il = residueArray.length; i < il; ++i) {
                    let htmlTmp = '';
                    let k = residueArray[i];
                    htmlTmp += "<div style='display:inline-block; width:100px'>";
                    for (let v in resSet[k]) {
                        htmlTmp += "<div style='width: 10px; height: 10px; background-color:#" + v + "; border: 0px;display:inline-block;' ></div> ";
                    }
                    htmlTmp +=  k + "</div>";

                    if(cnt % 4 == 3) htmlTmp += "<br>";

                    if(k.indexOf('(') != -1) {
                        html += htmlTmp;
                        ++cnt;
                    }
                    else {
                        dnaHtml += htmlTmp;
                    }
                }

                if(dnaHtml) html += "<br>" + dnaHtml;

                html += "</div>";
            }

            return html;
         }

         getColorLegendForCharge(atomHash) { let ic = this.icn3d; ic.icn3dui;
            let html = '';

            let residueHash = ic.firstAtomObjCls.getResiduesFromAtoms(atomHash);

            let chargeHash = {};
            for(let resid in residueHash){
                let atomHash = ic.residues[resid];

                let atom = ic.firstAtomObjCls.getFirstAtomObj(atomHash);
                if(atom.resn == 'ARG' || atom.resn == 'LYS') {
                    chargeHash['Positive'] = 1;
                }
                else if(atom.resn == 'HIS') {
                    chargeHash['Partial-Positive'] = 1;
                }
                else if(atom.resn == 'ASP' || atom.resn == 'GLU' || ic.nucleotides[atom.serial]) {
                    chargeHash['Negative'] = 1;
                }
                else {
                    chargeHash['Neutral'] = 1;
                }
            }

            const charge2color = {
                "Positive": "0000ff",
                "Partial-Positive": "8080ff",
                "Negative": "ff0000",
                "Neutral": "888888"
            };

            let chargeOrder = ["Positive", "Partial-Positive", "Negative", "Neutral"];
     
            html += "<div>";
            for (let i = 0, il = chargeOrder.length; i < il; ++i) {
                let charge = chargeOrder[i];
                if (chargeHash[charge]){
                    html += "<span>";
                    html += "<div style='width: 10px; height: 10px; background-color:#" + charge2color[charge] + "; border: 0px;display:inline-block;' ></div> ";
                    html += charge;
                    html +=  "</span><br>";
                }
            }
            html += "<br>(Charges are at pH 7)";
            html += "</div>";

            return html;
         }

         getColorLegendForIgstrand(atomHash) { let ic = this.icn3d; ic.icn3dui;
            let html = '';

            const name2color = {
                //"A- Strand": "FF00FF", 
                "A Strand": "9400D3", //"663399",
                "B Strand": "ba55d3",
                "C Strand": "0000FF",
                "C' Strand": "6495ED",
                "C'' Strand": "006400",
                "D Strand": "00FF00",
                "E Strand": "FFD700", //"FFFF00", //"F0E68C",
                "F Strand": "FF8C00",
                "G Strand": "FF0000",
                //"G+ Strand": "8B0000",
                "Loop": "CCCCCC"
            };

            html += "<div>";
            for (let name in name2color) {
                let color = name2color[name];
                html += "<span>";
                html += "<div style='width: 10px; height: 10px; background-color:#" + color + "; border: 0px;display:inline-block;' ></div> ";
                html += name;
                html +=  "</span><br>";
            }

            html += "</div>";

            return html;
         }

         getColorLegendForIgproto(atomHash) { let ic = this.icn3d; ic.icn3dui;
            let html = '';

            const name2color = {
                "<b>Protodomain 1</b>": "",
                "A Strand": "0000FF",
                "B Strand": "006400",
                "C Strand": "FFD700", //"FFFF00", //"F0E68C",
                "C' Strand": "FF8C00",
                "<br><b>Linker</b>": "",
                "C'' Strand": "FF0000",
                "<br><b>Protodomain 2</b>": "",
                "D Strand": "0000FF",
                "E Strand": "006400",
                "F Strand": "FFD700", //"FFFF00", //"F0E68C",
                "G Strand": "FF8C00",
                "": "",
                "Loop": "CCCCCC"
            };

            html += "<div>A protodomain is a supersecondary structure <br>that by its duplication, symmetry operations <br>can generate a structural domain.<br><br>";
            for (let name in name2color) {
                let color = name2color[name];
                html += "<span>";
                if(color) html += "<div style='width: 10px; height: 10px; background-color:#" + color + "; border: 0px;display:inline-block;' ></div> ";
                html += name;
                html +=  "</span><br>";
            }

            html += "</div>";

            return html;
         }
     }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class AnnoCddSite {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Show the annotations of CDD domains and binding sites.
        async showCddSiteAll() { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            ic.chainid2pssmid = {};

            let chnidBaseArray = $.map(ic.protein_chainid, function(v) { return v; });
            let chnidArray = Object.keys(ic.protein_chainid);
            // show conserved domains and binding sites
            // live search
            let url = "https://www.ncbi.nlm.nih.gov/Structure/cdannots/cdannots.fcgi?fmt&frclive&live=lcl&queries=" + chnidBaseArray;     
            // precalculated
            //let url = "https://www.ncbi.nlm.nih.gov/Structure/cdannots/cdannots.fcgi?fmt&live=lcl&queries=" + chnidBaseArray;
            // live search for AlphaFold structures
            //if(me.cfg.afid) {

            // use precalculated CDD annotation if
            if( (Object.keys(ic.structures).length == 1 && !me.cfg.afid && (me.cfg.mmtfid || me.cfg.pdbid || me.cfg.opmid || me.cfg.mmdbid || me.cfg.gi || me.cfg.uniprotid || me.cfg.blast_rep_id || me.cfg.cid || me.cfg.mmcifid))
                || (Object.keys(ic.structures).length == 2 && me.cfg.align) ) {
                    let data = {};
                    try {
                        if(me.bNode) {
                            data = await me.getAjaxPromise(url, 'jsonp');
                        }
                        else {
                            data.value = await me.getAjaxPromise(url, 'jsonp');
                        }
                     
                        thisClass.parseCddData([data], chnidArray);
                        /// if(ic.deferredAnnoCddSite !== undefined) ic.deferredAnnoCddSite.resolve();
                    }
                    catch(err) {
                        thisClass.getNoCdd(chnidBaseArray);
                        /// if(ic.deferredAnnoCddSite !== undefined) ic.deferredAnnoCddSite.resolve();

                        return;
                    }
            }
            else {
                let ajaxArray = [];

                for(let i = 0, il = chnidArray.length; i < il; ++i) {
                    //let seq = Array.isArray(ic.giSeq[chnidArray[i]]) ? ic.giSeq[chnidArray[i]].join('') : ic.giSeq[chnidArray[i]];
                    let seq = Array.isArray(ic.giSeq[chnidArray[i]]) ? ic.giSeq[chnidArray[i]].join('').toUpperCase() : ic.giSeq[chnidArray[i]].toUpperCase();

                    // remove water molecules
                    seq = seq.replace(/O/g, '');

                    //url = "https://www.ncbi.nlm.nih.gov/Structure/cdannots/cdannots.fcgi?fmt&live=lcl&queries=" + ic.giSeq[chnidArray[0]].join('');
                    // live searchE
                    url = "https://www.ncbi.nlm.nih.gov/Structure/cdannots/cdannots.fcgi?fmt&frclive&live=lcl&queries=" + seq;             
                    // precalculated
                    //url = "https://www.ncbi.nlm.nih.gov/Structure/cdannots/cdannots.fcgi?fmt&live=lcl&queries=" + seq;

                    let cdd = me.getAjaxPromise(url, 'jsonp');

                    ajaxArray.push(cdd);
                }

                let allPromise = Promise.allSettled(ajaxArray);
                try {
                    let dataArray = await allPromise;

                    thisClass.parseCddData(dataArray, chnidArray, true);
                    /// if(ic.deferredAnnoCddSite !== undefined) ic.deferredAnnoCddSite.resolve();
                }
                catch(err) {
                    
                }            
            }
        }

        parseCddData(dataArray, chnidArray, bSeq) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            let chainWithData = {};

            if(me.bNode) {
                if(!ic.resid2cdd) ic.resid2cdd = {};
                if(!ic.resid2site) ic.resid2site = {};
                if(!ic.chainid2cdd) ic.chainid2cdd = {};
            }

            for(let i = 0, il = dataArray.length; i < il; ++i) {
                //let data = (bSeq) ? dataArray[i][0] : dataArray[i];
                // somehow Node.js returned data in dataArray[i]
                let data = (me.bNode) ? dataArray[i] : dataArray[i].value;

                if(!data) continue;

                for(let chainI = 0, chainLen = data.data.length; chainI < chainLen; ++chainI) {
                    let cddData = data.data[chainI];
                    cddData._id;
                    //var pos = chnidBaseArray.indexOf(chnidBase);
                    //var chnid = chnidArray[pos];
                    //let chnid = chnidArray[chainI];
                    let chnid = (bSeq) ? chnidArray[i] : chnidArray[chainI];
                    chainWithData[chnid] = 1;
                    let html = '<div id="' + ic.pre + chnid + '_cddseq_sequence" class="icn3d-cdd icn3d-dl_sequence">';
                    let html2 = html;
                    let html3 = html;
                    let domainArray = cddData.doms;
                    if(me.bNode && !ic.resid2cdd[chnid]) ic.resid2cdd[chnid] = [];
                    if(me.bNode && !ic.chainid2cdd[chnid]) ic.chainid2cdd[chnid] = [];

                    let result = thisClass.setDomainFeature(domainArray, chnid, 'domain', html, html2, html3);

                    ic.chainid2pssmid[chnid] = {pssmid2name: result.pssmid2name, pssmid2fromArray: result.pssmid2fromArray, pssmid2toArray: result.pssmid2toArray};

                    let acc2domain = result.acc2domain;
                    html = result.html + '</div>';
                    html2 = result.html2 + '</div>';
                    html3 = result.html3 + '</div>';
                    $("#" + ic.pre + "dt_cdd_" + chnid).html(html);
                    $("#" + ic.pre + "ov_cdd_" + chnid).html(html2);
                    $("#" + ic.pre + "tt_cdd_" + chnid).html(html3);

                    html = '<div id="' + ic.pre + chnid + '_siteseq_sequence" class="icn3d-dl_sequence">';
                    html2 = html;
                    html3 = html;

                    // features
                    let featuteArray = cddData.motifs;
                    if(me.bNode && !ic.resid2site[chnid]) ic.resid2site[chnid] = [];
                    result = thisClass.setDomainFeature(featuteArray, chnid, 'feat', html, html2, html3, acc2domain);

                    html = result.html; // + '</div>';
                    html2 = result.html2; // + '</div>';
                    html3 = result.html3; // + '</div>';

                    let siteArray = data.data[chainI].sites;
                    let indexl =(siteArray !== undefined) ? siteArray.length : 0;
                    for(let index = 0; index < indexl; ++index) {
                        siteArray[index].srcdom;
                        siteArray[index].type;
                        let resCnt = siteArray[index].sz;
                        let title = 'site: ' + siteArray[index].title;
                        if(title.length > 17) title = title.substr(0, 17) + '...';
                        //var fulltitle = "site: " + siteArray[index].title + "(domain: " + domain + ")";
                        let fulltitle = siteArray[index].title;
                        let resPosArray, adjustedResPosArray = [];
                        for(let i = 0, il = siteArray[index].locs.length; i < il; ++i) {
                            resPosArray = siteArray[index].locs[i].coords;
                            for(let j = 0, jl = resPosArray.length; j < jl; ++j) {
                                // if(ic.bNCBI) {
                                //     adjustedResPosArray.push(Math.round(resPosArray[j]));
                                // }
                                // else {
                                //     adjustedResPosArray.push(thisClass.getAdjustedResi(Math.round(resPosArray[j]), chnid, ic.matchedPos, ic.chainsSeq, ic.baseResi) - 1);
                                // }
                                adjustedResPosArray.push(ic.ParserUtilsCls.getResi(chnid, Math.round(resPosArray[j])) );
                            }
                        }

                        let bCoordinates = false;
                        for(let i = 0, il = adjustedResPosArray.length; i < il; ++i) {
                            let resid = chnid + "_" + adjustedResPosArray[i];
                            if(ic.residues.hasOwnProperty(resid)) {
                                bCoordinates = true;
                                break;
                            }
                        }
        
                        let linkStr = (bCoordinates) ? 'icn3d-link icn3d-blue' : '';

                        let htmlTmp2 = '<div class="icn3d-seqTitle ' + linkStr + '" site="site" posarray="' + resPosArray.toString() + '" shorttitle="' + title + '" setname="' + chnid + '_site_' + index + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + title + ' </div>';
                        let htmlTmp3 = '<span class="icn3d-residueNum" title="residue count">' + resCnt.toString() + ' Res</span>';
                        let htmlTmp = '<span class="icn3d-seqLine">';
                        html3 += htmlTmp2 + htmlTmp3 + '<br>';
                        html += htmlTmp2 + htmlTmp3 + htmlTmp;
                        html2 += htmlTmp2 + htmlTmp3 + htmlTmp;
                        let pre = 'site' + index.toString();
                        //var widthPerRes = ic.seqAnnWidth / ic.maxAnnoLength;
                        let prevEmptyWidth = 0;
                        let prevLineWidth = 0;
                        let widthPerRes = 1;

                        if(ic.seqStartLen && ic.seqStartLen[chnid]) html2 += ic.showSeqCls.insertMulGapOverview(chnid, ic.seqStartLen[chnid]);
                        if(ic.seqStartLen && ic.seqStartLen[chnid]) html += ic.showSeqCls.insertMulGap(ic.seqStartLen[chnid], '-');

                        for(let i = 0, il = ic.giSeq[chnid].length; i < il; ++i) {
                            html += ic.showSeqCls.insertGap(chnid, i, '-');
                            if(resPosArray.indexOf(i) != -1) {
                                let cFull = ic.giSeq[chnid][i];
                                let c = cFull;
                                if(cFull.length > 1) {
                                    c = cFull[0] + '..';
                                }
                                //let pos = thisClass.getAdjustedResi(i, chnid, ic.matchedPos, ic.chainsSeq, ic.baseResi);
                                let pos = ic.ParserUtilsCls.getResi(chnid, i);
                                
                                html += '<span id="' + pre + '_' + ic.pre + chnid + '_' + pos + '" title="' + c + pos + '" class="icn3d-residue">' + cFull + '</span>';
                                if(me.bNode) {
                                    let obj = {};
                                    obj[chnid + '_' + pos] = 'site: ' + siteArray[index].title;
                                    ic.resid2site[chnid].push(obj);
                                }

                                html2 += ic.showSeqCls.insertGapOverview(chnid, i);
                                let emptyWidth =(me.cfg.blast_rep_id == chnid) ? Math.round(ic.seqAnnWidth * i /(ic.maxAnnoLength + ic.nTotalGap) - prevEmptyWidth - prevLineWidth) : Math.round(ic.seqAnnWidth * i / ic.maxAnnoLength - prevEmptyWidth - prevLineWidth);
                                //if(emptyWidth < 0) emptyWidth = 0;
                                if(emptyWidth >= 0) {
                                    html2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';
                                    html2 += '<div style="display:inline-block; background-color:#000; width:' + widthPerRes + 'px;" title="' + c + pos + '">&nbsp;</div>';
                                    prevEmptyWidth += emptyWidth;
                                    prevLineWidth += widthPerRes;
                                }
                            }
                            else {
                                html += '<span>-</span>'; //'<span>-</span>';
                            }
                        }

                        if(ic.seqStartLen && ic.seqStartLen[chnid]) html += ic.showSeqCls.insertMulGap(ic.seqEndLen[chnid], '-');

                        htmlTmp = '<span class="icn3d-residueNum" title="residue count">&nbsp;' + resCnt.toString() + ' Residues</span>';
                        htmlTmp += '</span>';
                        htmlTmp += '<br>';
                        html += htmlTmp;
                        html2 += htmlTmp;
                    }
                    html += '</div>';
                    html2 += '</div>';
                    html3 += '</div>';
                    $("#" + ic.pre + "dt_site_" + chnid).html(html);
                    $("#" + ic.pre + "ov_site_" + chnid).html(html2);
                    $("#" + ic.pre + "tt_site_" + chnid).html(html3);
                }
            } // outer for loop

            // missing CDD data
            for(let chnid in ic.protein_chainid) {
                if(!chainWithData.hasOwnProperty(chnid)) {
                    $("#" + ic.pre + "dt_cdd_" + chnid).html('');
                    $("#" + ic.pre + "ov_cdd_" + chnid).html('');
                    $("#" + ic.pre + "tt_cdd_" + chnid).html('');
                    $("#" + ic.pre + "dt_site_" + chnid).html('');
                    $("#" + ic.pre + "ov_site_" + chnid).html('');
                    $("#" + ic.pre + "tt_site_" + chnid).html('');
                }
            }
            // add here after the ajax call
            ic.showAnnoCls.enableHlSeq();
            ic.bAjaxCddSite = true;
        }

        getNoCdd(chnidBaseArray) { let ic = this.icn3d; ic.icn3dui;
            console.log( "No CDD data were found for the protein " + chnidBaseArray + "..." );
            for(let chnid in ic.protein_chainid) {
                $("#" + ic.pre + "dt_cdd_" + chnid).html('');
                $("#" + ic.pre + "ov_cdd_" + chnid).html('');
                $("#" + ic.pre + "tt_cdd_" + chnid).html('');
                $("#" + ic.pre + "dt_site_" + chnid).html('');
                $("#" + ic.pre + "ov_site_" + chnid).html('');
                $("#" + ic.pre + "tt_site_" + chnid).html('');
            }
            // add here after the ajax call
            ic.showAnnoCls.enableHlSeq();
            ic.bAjaxCddSite = true;
        }

        getResiArrayStr(resiNCBIArray, chainid) { let ic = this.icn3d; ic.icn3dui;
            let resiArrayStr = '';
            for(let i = 0, il = resiNCBIArray.length; i < il; ++i) {
                let resiNCBI = resiNCBIArray[i] + 1; // zero-based
                let residNCBI = chainid + '_' + resiNCBI;
                let resid = ic.ncbi2resid[residNCBI];
                if(!resid) resid = residNCBI; // this happens sometimes, e.g., Q9Y4K1

                let resi = resid.split('_')[2];
                if(i > 0) resiArrayStr += ',';
                resiArrayStr += resi;
            }

            return resiArrayStr;
        }

        setDomainFeature(domainArray, chnid, type, html, html2, html3, acc2domain, titleArray, fullTitleArray) { let ic = this.icn3d, me = ic.icn3dui;

            let bNonDomainFeat = (type != 'domain' && type != 'feat') ? true : false;

            let pssmid2name, pssmid2fromArray, pssmid2toArray;
            if(type == 'domain') {
                acc2domain = {};
                pssmid2name = {};
                pssmid2fromArray = {};
                pssmid2toArray = {};
            }

            if(domainArray === undefined) domainArray = [];
            let indexl = domainArray.length;
            let maxTextLen =(type == 'domain') ? 14 : 19;
            let titleSpace =(type == 'domain') ? 100 : 120;

            // sort domainArray
            domainArray.sort(function(a, b) {
                let domainRepeatArray = a.locs;
                let segArray = (type == 'domain' || type == 'ig') ? domainRepeatArray[0].segs : [domainRepeatArray[0]];
                let domainFrom1 = Math.round(segArray[0].from);

                domainRepeatArray = b.locs;
                segArray = (type == 'domain' || type == 'ig') ? domainRepeatArray[0].segs : [domainRepeatArray[0]];
                let domainFrom2 = Math.round(segArray[0].from);

                return domainFrom1 - domainFrom2;
            });

            for(let index = 0; index < indexl; ++index) {
                let pssmid = (type == 'domain') ? domainArray[index].pssmid : 0;

                let acc =(type == 'domain') ? domainArray[index].acc : (type == 'feat' ? domainArray[index].srcdom : '');
                // let type = domainArray[index].type;
                // type = (type == 'domain') ? 'domain' : 'feat';
                let domain =(type == 'domain') ? domainArray[index].title.split(':')[0] : (type == 'feat' ? domainArray[index].title : titleArray[index]);
                // convert double quote
                domain = domain.replace(/\"/g, "``");
                // convert single quote
                domain = domain.replace(/'/g, "`");

                if(type == 'domain') acc2domain[acc] = domain;

                let defline =(type == 'domain') ? domainArray[index].defline : '';
                let title = (bNonDomainFeat) ? titleArray[index] : type + ': ' + domain;

                if(title.length > maxTextLen) title = title.substr(0, maxTextLen) + '...';
                let fulltitle = (bNonDomainFeat) ? fullTitleArray[index] : type + ": " + domain;

                if(type == 'domain') pssmid2name[pssmid] = domain;

                // each domain may have several repeat. Treat each repeat as a domain
                let domainRepeatArray = domainArray[index].locs;

                if(!domainRepeatArray) continue;

                for(let r = 0, rl = domainRepeatArray.length; r < rl; ++r) {
                    // each domain repeat or domain may have several segments, i.e., a domain may not be continuous
                    let fromArray = [], toArray = [];
                    let resiHash = {};
                    let resCnt = 0;
                    let segArray =(type == 'domain' || type == 'ig') ? domainRepeatArray[r].segs : [domainRepeatArray[r]];
                    for(let s = 0, sl = segArray.length; s < sl; ++s) {
                        let domainFrom = Math.round(segArray[s].from);
                        let domainTo = Math.round(segArray[s].to);

                        // if(ic.bNCBI) {
                        //     fromArray.push(domainFrom);
                        //     toArray.push(domainTo);
                        // }
                        // else {
                        //     fromArray.push(thisClass.getAdjustedResi(domainFrom, chnid, ic.matchedPos, ic.chainsSeq, ic.baseResi) - 1);
                        //     toArray.push(thisClass.getAdjustedResi(domainTo, chnid, ic.matchedPos, ic.chainsSeq, ic.baseResi) - 1);
                        // }

                        // fromArray.push(ic.ParserUtilsCls.getResi(chnid, domainFrom));
                        // toArray.push(ic.ParserUtilsCls.getResi(chnid, domainTo));

                        fromArray.push(domainFrom);
                        toArray.push(domainTo);

                        for(let i = domainFrom; i <= domainTo; ++i) {
                            resiHash[i] = 1;
                        }
                        resCnt += domainTo - domainFrom + 1;
                    }

                    //var setname = chnid + "_" + domain + "_" + index + "_" + r; //chnid + "_" + type + "_" + index + "_" + r;
                    let setname = chnid + "_" + domain;
                    // if(type != 'domain') setname += "_" + index + "_" + r; 
                    if(type != 'domain') setname = chnid + "_" + index + "_" + r  + "_" + domain; 

                    //remove space in setname
                    setname = setname.replace(/\s+/g, '');

                    if(type == 'domain') pssmid2fromArray[pssmid] = fromArray;
                    if(type == 'domain') pssmid2toArray[pssmid] = toArray;

                    let bCoordinates = false;
                    for(let i = 0, il = fromArray.length; i < il; ++i) {
                        let from = parseInt(fromArray[i]), to = parseInt(toArray[i]);
                                           
                        for(let j = from; j <= to; ++j) {
                            let resi = ic.ParserUtilsCls.getResi(chnid, j);
                            //let resid = chnid + "_" + j;
                            let resid = chnid + "_" + resi;
                            
                            if(ic.residues.hasOwnProperty(resid)) {
                                bCoordinates = true;
                                break;
                            }
                        }

                        if(bCoordinates) {
                            break;
                        }
                    }

                    let linkStr = (bCoordinates) ? 'icn3d-link icn3d-blue' : '';

                    let htmlTmp2 = '<div class="icn3d-seqTitle ' + linkStr + '" ' + type + '="' + acc + '" from="' + fromArray + '" to="' + toArray + '" shorttitle="' + title + '" setname="' + setname + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + title + ' </div>';
                    let htmlTmp3 = '<span class="icn3d-residueNum" title="residue count">' + resCnt.toString() + ' Res</span>';
                    html3 += htmlTmp2 + htmlTmp3 + '<br>';
                    let htmlTmp = '<span class="icn3d-seqLine">';
                    html += htmlTmp2 + htmlTmp3 + htmlTmp;
                    if(type == 'domain') {
                        html2 += '<div style="width:20px; display:inline-block;"><span id="' + ic.pre + chnid + '_' + acc + '_' + r + '_cddseq_expand" class="ui-icon ui-icon-plus icn3d-expand icn3d-link" style="width:15px;" title="Expand"></span><span id="' + ic.pre + chnid + '_' + acc + '_' + r + '_cddseq_shrink" class="ui-icon ui-icon-minus icn3d-shrink icn3d-link" style="display:none; width:15px;" title="Shrink"></span></div>';
                    }
                    html2 += '<div style="width:' + titleSpace + 'px!important;" class="icn3d-seqTitle ' + linkStr + '" ' + type + '="' + acc + '" from="' + fromArray + '" to="' + toArray + '" shorttitle="' + title + '" index="' + index + '" setname="' + setname + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + title + ' </div>';
                    html2 += htmlTmp3 + htmlTmp;
                    let pre = type + index.toString();

                    if(ic.seqStartLen && ic.seqStartLen[chnid]) html += ic.showSeqCls.insertMulGap(ic.seqStartLen[chnid], '-');

                    if(me.bNode && type == 'domain') {
                        let fromStr = this.getResiArrayStr(fromArray, chnid);
                        let toStr = this.getResiArrayStr(toArray, chnid);
                        ic.chainid2cdd[chnid].push(fulltitle + "_from_" + fromStr + "_to_" + toStr);
                    }

                    for(let i = 0, il = ic.giSeq[chnid].length; i < il; ++i) {
                      html += ic.showSeqCls.insertGap(chnid, i, '-');

                      if(resiHash.hasOwnProperty(i)) {
                          let cFull = ic.giSeq[chnid][i];
                          let c = cFull;
                          if(cFull.length > 1) {
                              c = cFull[0] + '..';
                          }
                          // let pos = thisClass.getAdjustedResi(i, chnid, ic.matchedPos, ic.chainsSeq, ic.baseResi);
                          let pos = ic.ParserUtilsCls.getResi(chnid, i);
                          html += '<span id="' + pre + '_' + ic.pre + chnid + '_' + pos + '" title="' + c + pos + '" class="icn3d-residue">' + cFull + '</span>';
                          if(me.bNode) {
                            let obj = {};
                            obj[chnid + '_' + pos] = fulltitle;
                            if(type == 'domain') {
                                ic.resid2cdd[chnid].push(obj);
                            }
                            else {
                                ic.resid2site[chnid].push(obj);
                            }
                          }
                      }
                      else {
                          html += '<span>-</span>'; //'<span>-</span>';
                      }
                    }

                    if(ic.seqStartLen && ic.seqStartLen[chnid]) html += ic.showSeqCls.insertMulGap(ic.seqEndLen[chnid], '-');

                    if(ic.seqStartLen && ic.seqStartLen[chnid]) html2 += ic.showSeqCls.insertMulGapOverview(chnid, ic.seqStartLen[chnid]);

                    if(me.cfg.blast_rep_id != chnid) { // regular
                        let color;
                        for(let i = 0, il = fromArray.length; i < il; ++i) {
                            if(i == 0) color = this.getColorFromPos(chnid, fromArray[i], titleArray);
            
                            let emptyWidth;
                            // if(titleArray) {
                                emptyWidth =(i == 0) ? Math.round(ic.seqAnnWidth *(fromArray[i]) / ic.maxAnnoLength) : Math.round(ic.seqAnnWidth *(fromArray[i] - toArray[i-1] - 1) / ic.maxAnnoLength);
                            // }
                            // else {
                            //     emptyWidth =(i == 0) ? Math.round(ic.seqAnnWidth *(fromArray[i] - ic.baseResi[chnid] - 1) / ic.maxAnnoLength) : Math.round(ic.seqAnnWidth *(fromArray[i] - toArray[i-1] - 1) / ic.maxAnnoLength);
                            // }

                            html2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';
                            html2 += '<div style="display:inline-block; color:white!important; font-weight:bold; background-color:#' + color + '; width:' + Math.round(ic.seqAnnWidth *(toArray[i] - fromArray[i] + 1) / ic.maxAnnoLength) + 'px;" class="icn3d-seqTitle ' + linkStr + '" ' + type + '="' +(index+1).toString() + '" from="' + fromArray + '" to="' + toArray + '" shorttitle="' + title + '" index="' + index + '" setname="' + setname + '" id="' + chnid + '_domain_' + index + '_' + r + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + domain + ' </div>';
                        }
                    }
                    else { // with potential gaps
                        let fromArray2 = [], toArray2 = [];
                        for(let i = 0, il = fromArray.length; i < il; ++i) {
                            fromArray2.push(fromArray[i]);
                            for(let j = parseInt(fromArray[i]); j <= parseInt(toArray[i]); ++j) {
                                if(ic.targetGapHash !== undefined && ic.targetGapHash.hasOwnProperty(j)) {
                                    toArray2.push(j - 1);
                                    fromArray2.push(j);
                                }
                            }
                            toArray2.push(toArray[i]);
                        }
                        for(let i = 0, il = fromArray2.length; i < il; ++i) {
                            let color = this.getColorFromPos(chnid, fromArray2[i], titleArray);
            
                            html2 += ic.showSeqCls.insertGapOverview(chnid, fromArray2[i]);
                            let emptyWidth =(i == 0) ? Math.round(ic.seqAnnWidth *(fromArray2[i] - ic.baseResi[chnid] - 1) /(ic.maxAnnoLength + ic.nTotalGap)) : Math.round(ic.seqAnnWidth *(fromArray2[i] - toArray2[i-1] - 1) /(ic.maxAnnoLength + ic.nTotalGap));
                            html2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';
                            html2 += '<div style="display:inline-block; color:white!important; font-weight:bold; background-color:#' + color + '; width:' + Math.round(ic.seqAnnWidth *(toArray2[i] - fromArray2[i] + 1) /(ic.maxAnnoLength + ic.nTotalGap)) + 'px;" class="icn3d-seqTitle ' + linkStr + '" ' + type + '="' +(index+1).toString() + '" from="' + fromArray2 + '" to="' + toArray2 + '" shorttitle="' + title + '" index="' + index + '" setname="' + setname + '" id="' + chnid + '_domain_' + index + '_' + r + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + domain + ' </div>';
                        }
                    }
                    htmlTmp = '<span class="icn3d-residueNum" title="residue count">&nbsp;' + resCnt.toString() + ' Residues</span>';
                    htmlTmp += '</span>';
                    htmlTmp += '<br>';
                    html += htmlTmp;
                    html2 += htmlTmp;
                    if(type == 'domain') {
                        html2 += '<div id="' + ic.pre + chnid + '_' + acc + '_' + r + '_cddseq" style="display:none; white-space:normal;" class="icn3d-box">' + defline + '(<a href="' + me.htmlCls.baseUrl + 'cdd/cddsrv.cgi?uid=' + acc + '" target="_blank" class="icn3d-blue">open details view...</a>)</div>';
                    }
                } // for(let r = 0,
            }

            return {html: html, html2: html2, html3: html3, acc2domain: acc2domain,
              pssmid2name: pssmid2name, pssmid2fromArray: pssmid2fromArray, pssmid2toArray: pssmid2toArray}
        }

        // getAdjustedResi(resi, chnid, matchedPos, chainsSeq, baseResi) { let ic = this.icn3d, me = ic.icn3dui;
        //     return (resi >= matchedPos[chnid] && resi - matchedPos[chnid] < ic.chainsSeq[chnid].length) ? ic.chainsSeq[chnid][resi - matchedPos[chnid]].resi : baseResi[chnid] + 1 + resi;
        // }
        getColorFromPos(chainid, pos, bIg) { let ic = this.icn3d; ic.icn3dui;
            let color;

            let resid =  chainid + '_' + ic.ParserUtilsCls.getResi(chainid, pos);
            // if(!bIg) {
                let atom = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid]);
                let colorStr =(!atom || atom.color === undefined || atom.color.getHexString() === 'FFFFFF') ? 'DDDDDD' : atom.color.getHexString();
                color =(atom && atom.color !== undefined) ? colorStr : "CCCCCC";
            // }
            // else {
                // let refnumLabel = ic.resid2refnum[resid];
                // let refnumStr_ori = ic.refnumCls.rmStrandFromRefnumlabel(refnumLabel);
                // let currStrand = refnumLabel.replace(new RegExp(refnumStr_ori,'g'), '');
                // color = ic.annoIgCls.getRefnumColor(currStrand, true).substr(1);
            // }

            return color;
        }

        showAnnoType(chnid, chnidBase, type, title, residueArray, resid2resids) { let ic = this.icn3d, me = ic.icn3dui;
            let html = '<div id="' + ic.pre + chnid + '_' + type + 'seq_sequence" class="icn3d-dl_sequence">';
            let html2 = html;
            let html3 = html;
            if(residueArray.length == 0) {
                $("#" + ic.pre + "dt_" + type + "_" + chnid).html('');
                $("#" + ic.pre + "ov_" + type + "_" + chnid).html('');
                $("#" + ic.pre + "tt_" + type + "_" + chnid).html('');
                return;
            }
            let fulltitle = title;
            if(title.length > 17) title = title.substr(0, 17) + '...';
            let resPosArray = [];
            for(let i = 0, il = residueArray.length; i < il; ++i) {
                let resid = residueArray[i];
                //let resi = Math.round(resid.substr(residueArray[i].lastIndexOf('_') + 1) );
                let resi = resid.substr(residueArray[i].lastIndexOf('_') + 1);
                resPosArray.push( resi );
            }
            let resCnt = resPosArray.length;
            let chainnameNospace = type;
            let htmlTmp2 = '<div class="icn3d-seqTitle icn3d-link icn3d-blue" ' + type + '="" posarray="' + resPosArray.toString() + '" shorttitle="' + title + '" setname="' + chnid + '_' + chainnameNospace + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + title + ' </div>';
            let htmlTmp3 = '<span class="icn3d-residueNum" title="residue count">' + resCnt.toString() + ' Res</span>';
            html3 += htmlTmp2 + htmlTmp3 + '<br>';
            let htmlTmp = '<span class="icn3d-seqLine">';
            html += htmlTmp2 + htmlTmp3 + htmlTmp;
            html2 += htmlTmp2 + htmlTmp3 + htmlTmp;
            let pre = type;
            let prevEmptyWidth = 0;
            let prevLineWidth = 0;
            let widthPerRes = 1;

            if(ic.seqStartLen && ic.seqStartLen[chnid]) html2 += ic.showSeqCls.insertMulGapOverview(chnid, ic.seqStartLen[chnid]);
            if(ic.seqStartLen && ic.seqStartLen[chnid]) html += ic.showSeqCls.insertMulGap(ic.seqStartLen[chnid], '-');

            for(let i = 0, il = ic.giSeq[chnid].length; i < il; ++i) {
              html += ic.showSeqCls.insertGap(chnid, i, '-');
              let resi = ic.ParserUtilsCls.getResi(chnid, i);
              //if(resPosArray.indexOf(i+1 + ic.baseResi[chnid]) != -1) {
              if(resPosArray.indexOf(resi) != -1) {
                  let cFull = ic.giSeq[chnid][i];
                  let c = cFull;
                  if(cFull.length > 1) {
                      c = cFull[0] + '..';
                  }
                //   let pos =(i >= ic.matchedPos[chnid] && i - ic.matchedPos[chnid] < ic.chainsSeq[chnid].length) ? ic.chainsSeq[chnid][i - ic.matchedPos[chnid]].resi : ic.baseResi[chnid] + 1 + i;
                //   let resid = chnid + '_' +(i+1 + ic.baseResi[chnid]).toString();
                //   let title = cFull +(i+1 + ic.baseResi[chnid]).toString();
                  let pos = resi;
                  let resid = chnid + '_' + resi;
                  let title = cFull + resi;
                  
                  if(type == 'ssbond') {
                      title = 'Residue ' + resid + ' has disulfide bond with';
                      let sstitle = '';
                      if(resid2resids[resid] !== undefined) {
                          for(let j = 0, jl = resid2resids[resid].length; j < jl; ++j) {
                            sstitle += ' residue ' + resid2resids[resid][j];
                          }
                      }
                      title += sstitle;

                      if(me.bNode) {
                        let obj = {};
                        obj[resid] = 'disulfide bond with' + sstitle;
                        ic.resid2ssbond[chnid].push(obj);
                      }
                  }
                  else if(type == 'crosslink') {
                      title = 'Residue ' + resid + ' has cross-linkage with';
                      let cltitle = '';
                      if(resid2resids[resid] !== undefined) {
                          for(let j = 0, jl = resid2resids[resid].length; j < jl; ++j) {
                            cltitle += ' residue ' + resid2resids[resid][j];
                          }
                      }
                      title += cltitle;

                      if(me.bNode) {
                        let obj = {};
                        obj[resid] = 'cross-linkage with' + cltitle;
                        ic.resid2crosslink[chnid].push(obj);
                      }
                  }
                  else {
                    title = 'Residue ' + resid + ' has connection with';
                    let cltitle = '';
                    if(resid2resids && resid2resids[resid] !== undefined) {
                        for(let j = 0, jl = resid2resids[resid].length; j < jl; ++j) {
                          cltitle += ' residue ' + resid2resids[resid][j];
                        }
                    }
                    title += cltitle;
                  }

                  html += '<span id="' + pre + '_' + ic.pre + chnid + '_' + pos + '" title="' + title + '" class="icn3d-residue">' + c + '</span>';
                  html2 += ic.showSeqCls.insertGapOverview(chnid, i);
                  let emptyWidth =(me.cfg.blast_rep_id == chnid) ? Math.round(ic.seqAnnWidth * i /(ic.maxAnnoLength + ic.nTotalGap) - prevEmptyWidth - prevLineWidth) : Math.round(ic.seqAnnWidth * i / ic.maxAnnoLength - prevEmptyWidth - prevLineWidth);
                    //if(emptyWidth < 0) emptyWidth = 0;
                    if(emptyWidth >= 0) {
                        html2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';
                        html2 += '<div style="display:inline-block; background-color:#000; width:' + widthPerRes + 'px;" title="' + title + '">&nbsp;</div>';
                        prevEmptyWidth += emptyWidth;
                        prevLineWidth += widthPerRes;
                    }
              }
              else {
                html += '<span>-</span>'; //'<span>-</span>';
              }
            }

            if(ic.seqStartLen && ic.seqStartLen[chnid]) html += ic.showSeqCls.insertMulGap(ic.seqEndLen[chnid], '-');

            htmlTmp = '<span class="icn3d-residueNum" title="residue count">&nbsp;' + resCnt.toString() + ' Residues</span>';
            htmlTmp += '</span>';
            htmlTmp += '<br>';
            html += htmlTmp;
            html2 += htmlTmp;
            html += '</div>';
            html2 += '</div>';
            html3 += '</div>';
            $("#" + ic.pre + "dt_" + type + "_" + chnid).html(html);
            $("#" + ic.pre + "ov_" + type + "_" + chnid).html(html2);
            $("#" + ic.pre + "tt_" + type + "_" + chnid).html(html3);
        }

        // jquery tooltip
        //https://stackoverflow.com/questions/18231315/jquery-ui-tooltip-html-with-links
        setToolTip() {  let ic = this.icn3d; ic.icn3dui;
          $("[id^=" + ic.pre + "snp]").add("[id^=" + ic.pre + "clinvar]").add("[id^=" + ic.pre + "ssbond]").add("[id^=" + ic.pre + "crosslink]").tooltip({
            content: function() {
                return $(this).prop('title');
            },
            show: null,
            close: function(event, ui) {
                ui.tooltip.hover(
                function() {
                    $(this).stop(true).fadeTo(400, 1);
                },
                function() {
                    $(this).fadeOut("400", function() {
                        $(this).remove();
                    });
                });
            }
          });
        }

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class AnnoContact {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Show the residues interacting with the chain.
        showInteraction(chnid, chnidBase) { let ic = this.icn3d; ic.icn3dui;
            // let thisClass = this;
            // if(ic.chainname2residues === undefined &&(me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined || me.cfg.blast_rep_id !== undefined || me.cfg.align !== undefined || me.cfg.chainalign !== undefined) ) {
            //     // 2d interaction didn't finish loading data yet
            //     setTimeout(function(){
            //       thisClass.showInteraction_base(chnid, chnidBase);
            //     }, 1000);
            // }
            // else {
            //     this.showInteraction_base(chnid, chnidBase);
            // }

            this.showInteraction_base(chnid, chnidBase);
        }
        showInteraction_base(chnid, chnidBase) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) {
                if(!ic.resid2contact) ic.resid2contact = {};
                if(!ic.resid2contact[chnid]) ic.resid2contact[chnid] = [];
            }
            // set interaction
            if(ic.chainname2residues === undefined) ic.chainname2residues = {};
            let radius = 4;
            let chainArray = Object.keys(ic.chains);
            let chainid = chnid;
            let pos = Math.round(chainid.indexOf('_'));
    //        if(pos > 4) return; // NMR structures with structure id such as 2K042,2K043, ...
            ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.chains[chainid]);
            if(ic.chainname2residues[chainid] === undefined) {
                ic.chainname2residues[chainid] = {};
                let jl = chainArray.length;
                if(jl > 100 && me.cfg.mmdbid === undefined && me.cfg.gi === undefined && me.cfg.blast_rep_id === undefined && me.cfg.align === undefined && me.cfg.chainalign === undefined) {
                //if(jl > 100) {
                    //console.log("Do not show interactions if there are more than 100 chains");
                    $("#" + ic.pre + "dt_interaction_" + chnid).html("");
                    $("#" + ic.pre + "ov_interaction_" + chnid).html("");
                    return; // skip interactions if there are more than 100 chains
                }
                for(let j = 0; j < jl; ++j) {
                    let chainid2 = chainArray[j];
                    if(chainid2 === chainid) continue;
                    // interactions should be on the same structure
                    if(chainid2.substr(0, chainid2.indexOf('_')) !== chainid.substr(0, chainid.indexOf('_'))) continue;
                    pos = Math.round(chainid.indexOf('_'));
                    if(pos > 4) continue; // NMR structures with structure id such as 2K042,2K043, ...
                    let atom2 = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.chains[chainid2]);
                    //if(ic.chainname2residues[chainid2] === undefined) ic.chainname2residues[chainid2] = {}
                    let type2;
                    if(ic.chemicals.hasOwnProperty(atom2.serial)) { // 1. chemical interacting with proteins
                        type2 = 'chemical';
                    }
                    else if(ic.nucleotides.hasOwnProperty(atom2.serial)) { // 2. DNA interacting with proteins
                        type2 = 'nucleotide';
                    }
                    else if(ic.ions.hasOwnProperty(atom2.serial)) { // 3. ions interacting with proteins
                        type2 = 'ion';
                    }
                    else if(ic.proteins.hasOwnProperty(atom2.serial)) { // 4. protein interacting with proteins
                        type2 = 'protein';
                    }
                    else if(ic.water.hasOwnProperty(atom2.serial)) { // 5. water interacting with proteins
                        type2 = 'water';
                    }
                    // find atoms in chainid1, which interact with chainid2
                    let atomsChainid1 = ic.contactCls.getAtomsWithinAtom(me.hashUtilsCls.hash2Atoms(ic.chains[chainid], ic.atoms), me.hashUtilsCls.hash2Atoms(ic.chains[chainid2], ic.atoms), radius);
                    if(Object.keys(atomsChainid1).length == 0) continue;
                    let residues = {};
                    for(let k in atomsChainid1) {
                        let atom = ic.atoms[k];
                        let residueid = atom.structure + '_' + atom.chain + '_' + atom.resi;
                        residues[residueid] = 1;
                    }
                    let name = chainid2.substr(chainid2.indexOf('_') + 1) + "(" + type2 + ")";
                    ic.chainname2residues[chainid][name] = Object.keys(residues);
                } // for
            }
            let html = '<div id="' + ic.pre + chnid + '_interseq_sequence" class="icn3d-dl_sequence">';
            let html2 = html;
            let html3 = html;
            let index = 0;
            for(let chainname in ic.chainname2residues[chnid]) {
                let residueArray = ic.chainname2residues[chnid][chainname];
                if(!residueArray) continue; // same chain

                let title = "Interact ." + chainname;
                if(title.length > 17) title = title.substr(0, 17) + '...';
                let fulltitle = "Interact ." + chainname;
                let resPosArray = [];
                for(let i = 0, il = residueArray.length; i < il; ++i) {
                    let resid = residueArray[i];
                    //let resi = Math.round(resid.substr(residueArray[i].lastIndexOf('_') + 1) );
                    let resi = resid.substr(residueArray[i].lastIndexOf('_') + 1);

    //                resid = chnid + '_' + (resiNcbi + ic.baseResi[chnid]).toString();

                    // exclude chemical, water and ions
                    if(ic.residues[resid]) {
                        let serial = Object.keys(ic.residues[resid])[0];
                        if(ic.proteins.hasOwnProperty(serial) || ic.nucleotides.hasOwnProperty(serial)) {
    //                        resPosArray.push( resiNcbi );
                            resPosArray.push( resi );
                        }
                    }
                }
                let resCnt = resPosArray.length;
                if(resCnt == 0) continue;
                let chainnameNospace = chainname.replace(/\s/g, '');
                let htmlTmp2 = '<div class="icn3d-seqTitle icn3d-link icn3d-blue" interaction="' +(index+1).toString() + '" posarray="' + resPosArray.toString() + '" shorttitle="' + title + '" setname="' + chnid + '_' + chainnameNospace + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + title + ' </div>';
                let htmlTmp3 = '<span class="icn3d-residueNum" title="residue count">' + resCnt.toString() + ' Res</span>';
                html3 += htmlTmp2 + htmlTmp3 + '<br>';
                let htmlTmp = '<span class="icn3d-seqLine">';
                html += htmlTmp2 + htmlTmp3 + htmlTmp;
                html2 += htmlTmp2 + htmlTmp3 + htmlTmp;
                let pre = 'inter' + index.toString();
                let prevEmptyWidth = 0;
                let prevLineWidth = 0;
                let widthPerRes = 1;

                if(ic.seqStartLen && ic.seqStartLen[chnid]) html2 += ic.showSeqCls.insertMulGapOverview(chnid, ic.seqStartLen[chnid]);
                if(ic.seqStartLen && ic.seqStartLen[chnid]) html += ic.showSeqCls.insertMulGap(ic.seqStartLen[chnid], '-');

                for(let i = 0, il = ic.giSeq[chnid].length; i < il; ++i) {
                  html += ic.showSeqCls.insertGap(chnid, i, '-');
                  let resi = ic.ParserUtilsCls.getResi(chnid, i);           
                //   if(resPosArray.indexOf(i+1 + ic.baseResi[chnid]) != -1) {
                  if(resPosArray.indexOf(resi) != -1) {
    //              if(resPosArray.indexOf(i+1) != -1) {
                      let cFull = ic.giSeq[chnid][i];
                      let c = cFull;
                      if(cFull.length > 1) {
                          c = cFull[0] + '..';
                      }
                      
                    //   let pos =(i >= ic.matchedPos[chnid] && i - ic.matchedPos[chnid] < ic.chainsSeq[chnid].length) ? ic.chainsSeq[chnid][i - ic.matchedPos[chnid]].resi : ic.baseResi[chnid] + 1 + i;
                      let pos = resi;
                      html += '<span id="' + pre + '_' + ic.pre + chnid + '_' + pos + '" title="' + cFull + pos + '" class="icn3d-residue">' + c + '</span>';
                      if(me.bNode) {
                          let obj = {};
                          obj[chnid + '_' + pos] = fulltitle;
                          ic.resid2contact[chnid].push(obj);
                      }
                      
                      html2 += ic.showSeqCls.insertGapOverview(chnid, i);
                      let emptyWidth =(me.cfg.blast_rep_id == chnid) ? Math.round(ic.seqAnnWidth * i /(ic.maxAnnoLength + ic.nTotalGap) - prevEmptyWidth - prevLineWidth) : Math.round(ic.seqAnnWidth * i / ic.maxAnnoLength - prevEmptyWidth - prevLineWidth);
                        //if(emptyWidth < 0) emptyWidth = 0;
                        if(emptyWidth >= 0) {
                        html2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';
                        html2 += '<div style="display:inline-block; background-color:#000; width:' + widthPerRes + 'px;" title="' + c + pos + '">&nbsp;</div>';
                        prevEmptyWidth += emptyWidth;
                        prevLineWidth += widthPerRes;
                        }
                  }
                  else {
                    html += '<span>-</span>'; //'<span>-</span>';
                  }
                }

                if(ic.seqStartLen && ic.seqStartLen[chnid]) html += ic.showSeqCls.insertMulGap(ic.seqEndLen[chnid], '-');

                htmlTmp = '<span class="icn3d-residueNum" title="residue count">&nbsp;' + resCnt.toString() + ' Residues</span>';
                htmlTmp += '</span>';
                htmlTmp += '<br>';
                html += htmlTmp;
                html2 += htmlTmp;
                ++index;
            }
            html += '</div>';
            html2 += '</div>';
            html3 += '</div>';
            $("#" + ic.pre + "dt_interaction_" + chnid).html(html);
            $("#" + ic.pre + "ov_interaction_" + chnid).html(html2);
            $("#" + ic.pre + "tt_interaction_" + chnid).html(html3);
            // add here after the ajax call
            if(! me.utilsCls.isMobile()) {
                ic.hlSeqCls.selectSequenceNonMobile();
            }
            else {
                ic.hlSeqCls.selectSequenceMobile();
                ic.hlSeqCls.selectChainMobile();
            }
        }

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class AnnoPTM {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Show the annotations of CDD domains and binding sites.
        async showPTM(chnid, chnidBase, type, begin, end) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            // UniProt ID
            let structure = chnid.substr(0, chnid.indexOf('_'));
            let chain = chnid.substr(chnid.indexOf('_') + 1);

            if(type == 'afmem') {
                let ptmHash = {'Transmembrane': [{'begin': begin, 'end': end}]};
                this.setAnnoPtmTransmem('transmem', ptmHash, chnid);        
            }
            // UniProt ID
            else if( structure.length > 5 ) {
                let url =  "https://www.ebi.ac.uk/proteins/api/features/" + structure; 
                let data;
                try {
                    data = await me.getAjaxPromise(url, 'json');

                    thisClass.parsePTM(data, chnid, type);
                    /// if(ic.deferredPTM !== undefined) ic.deferredPTM.resolve();
                }
                catch {
                    thisClass.getNoPTM(chnid, type);

                    return;
                }
            }
            else { // PDB
                // get PDB to UniProt mapping
                // https://www.ebi.ac.uk/pdbe/api/doc/sifts.html
                // https://www.ebi.ac.uk/pdbe/api/doc/
                let structLower = structure.substr(0, 4).toLowerCase();
                let urlMap = "https://www.ebi.ac.uk/pdbe/api/mappings/uniprot/" + structLower;

                let dataMap;
                try {
                    dataMap = await me.getAjaxPromise(urlMap, 'json');

                    let UniProtID = '';
                    if(!ic.UPResi2ResiPosPerChain) ic.UPResi2ResiPosPerChain = {};
                    ic.UPResi2ResiPosPerChain[chnid] = {};
                    let mapping = dataMap[structLower].UniProt;

                    let bFound = false;
                    for(let up in mapping) {
                        let chainArray = mapping[up].mappings;
                        //if(bFound) break;

                        for(let i = 0, il = chainArray.length; i < il; ++i) {
                        //"entity_id": 3, "end": { "author_residue_number": null, "author_insertion_code": "", "residue_number": 219 }, "chain_id": "A", "start": { "author_residue_number": 94, "author_insertion_code": "", "residue_number": 1 }, "unp_end": 312, "unp_start": 94, "struct_asym_id": "C"
                            let chainObj = chainArray[i];
                            if(chainObj.chain_id == chain) {
                                let start = chainObj.unp_start;
                                let end = chainObj.unp_end;
                                let posStart = chainObj.start.residue_number;
                                let posEnd = chainObj.end.residue_number;

                                if(posEnd - posStart != end - start) {
                                    console.log("There might be some issues in the PDB to UniProt residue mapping.");
                                }

                                for(let j = 0; j <= end - start; ++j) {
                                    ic.UPResi2ResiPosPerChain[chnid][j + start] = j + posStart - 1; // 0-based
                                }

                                if(UniProtID == '' || UniProtID.length != 6) UniProtID = up;
                                bFound = true;
                                //break;
                            }
                        }
                    }

                    if(!ic.annoPtmData) ic.annoPtmData = {};

                    if(UniProtID == '') {
                        thisClass.getNoPTM(chnid, type);
                    }
                    else {
                        // call just once for one UniProt ID
                        if(ic.annoPtmData.hasOwnProperty(UniProtID)) {
                            thisClass.parsePTM(ic.annoPtmData[UniProtID], chnid, type);
                        }
                        else {
                            
                            let url =  "https://www.ebi.ac.uk/proteins/api/features/" + UniProtID;     
                            let data;
                            try {
                                data = await me.getAjaxPromise(url, 'json');
                                ic.annoPtmData[UniProtID] = data;

                                thisClass.parsePTM(data, chnid, type);
                                /// if(ic.deferredPTM !== undefined) ic.deferredPTM.resolve();
                            }
                            catch(err) {
                                thisClass.getNoPTM(chnid, type);
                                return;
                            }
                        }
                    }
                }
                catch(err) {
                    thisClass.getNoPTM(chnid, type);
                    return;
                }
            }
        }

        parsePTM(data, chnid, type) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) {
                if(type == 'ptm') {
                    ic.resid2ptm = {};
                    ic.resid2ptm[chnid] = [];
                }
                else {
                    ic.resid2transmem = {};
                    ic.resid2transmem[chnid] = [];
                }
            }

            let ptmHash = {}, transmemHash = {};
            for(let i = 0, il = data.features.length; i < il; ++i) {
                let feature = data.features[i];

                if(type == 'ptm' && feature.category == 'PTM' && feature.type != 'DISULFID' && feature.type != 'CROSSLNK') {
                    let title = '';
                    if(feature.type == 'CARBOHYD') {
                        //title = 'Glycosylation, ' + feature.description;
                        title = 'Glycosylation';
                    }
                    else if(feature.type == 'LIPID') {
                        title = 'Lipidation, ' + feature.description;
                    }
                    else if(feature.description.indexOf('Phospho') == 0) {
                        title = 'Phosphorylation';
                    }
                    else if(feature.description) {
                        title = feature.description;
                    }
                    else {
                        title = feature.type;
                    }

                    if(!ptmHash[title]) ptmHash[title] = [];
                    ptmHash[title].push(feature);
                }
                else if(type == 'transmem' && feature.category == 'TOPOLOGY' && feature.type == 'TRANSMEM') {
                    let title = 'Transmembrane';
                    if(!transmemHash[title]) transmemHash[title] = [];
                    transmemHash[title].push(feature);
                }
            }

            if(type == 'ptm') {
                this.setAnnoPtmTransmem('ptm', ptmHash, chnid);
            }
            else {
                this.setAnnoPtmTransmem('transmem', transmemHash, chnid);
            }

            // add here after the ajax call
            ic.showAnnoCls.enableHlSeq();
            ic.bAjaxPTM = true;
        }

        setAnnoPtmTransmem(type, ptmHash, chnid) { let ic = this.icn3d, me = ic.icn3dui;
            let index = 0;
            let html = '', html2 = '', html3 = ''; 
            html += '<div id="' + ic.pre + chnid + '_' + type + 'seq_sequence" class="icn3d-cdd icn3d-dl_sequence">';
            html2 += html;
            html3 += html;
            chnid.substr(0, chnid.indexOf('_'));

            for(let ptm in ptmHash) {
                let ptmArray = ptmHash[ptm];
                //"type": "MOD_RES", "category": "PTM", "description": "4-hydroxyproline", "begin": "382", "end": "382",
                let resPosArray = [];
                let bCoordinates = false;
                for(let i = 0, il = ptmArray.length; i < il; ++i) {
                    let begin = parseInt(ptmArray[i].begin);
                    let end = parseInt(ptmArray[i].end);

                    for(let j = begin; j <= end; ++j) {
                        if(stucture.length > 5) { // UniProt
                            resPosArray.push(j - 1); // 0-based
                        } 
                        else { // PDB                       
                            if(ic.UPResi2ResiPosPerChain && ic.UPResi2ResiPosPerChain[chnid][j]) resPosArray.push(ic.UPResi2ResiPosPerChain[chnid][j]);
                        }
                        
                        if(!bCoordinates && ic.residues.hasOwnProperty(chnid + '_' + j)) {
                            bCoordinates = true;
                        }
                    }
                }

                if(resPosArray.length == 0) continue;

                let resCnt = resPosArray.length;
                let title = (type == 'ptm') ? 'PTM: ' + ptm : 'Transmembrane';
                if(title.length > 17) title = title.substr(0, 17) + '...';
                let fulltitle = ptm;

                let linkStr = (bCoordinates) ? 'icn3d-link icn3d-blue' : '';

                let htmlTmp2 = '<div class="icn3d-seqTitle ' + linkStr + '" ' + type + '="' + type + '" posarray="' 
                    + resPosArray.toString() + '" shorttitle="' + title + '" setname="' + chnid + '_' + type + '_' 
                    + index + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + title + ' </div>';
                let htmlTmp3 = '<span class="icn3d-residueNum" title="residue count">' + resCnt.toString() + ' Res</span>';
                let htmlTmp = '<span class="icn3d-seqLine">';
                html3 += htmlTmp2 + htmlTmp3 + '<br>';
                html += htmlTmp2 + htmlTmp3 + htmlTmp;
                html2 += htmlTmp2 + htmlTmp3 + htmlTmp;
                let pre = type + index.toString();
                //var widthPerRes = ic.seqAnnWidth / ic.maxAnnoLength;
                let prevEmptyWidth = 0;
                let prevLineWidth = 0;
                let widthPerRes = 1;

                if(ic.seqStartLen && ic.seqStartLen[chnid]) html2 += ic.showSeqCls.insertMulGapOverview(chnid, ic.seqStartLen[chnid]);
                if(ic.seqStartLen && ic.seqStartLen[chnid]) html += ic.showSeqCls.insertMulGap(ic.seqStartLen[chnid], '-');

                for(let i = 0, il = ic.giSeq[chnid].length; i < il; ++i) {
                    html += ic.showSeqCls.insertGap(chnid, i, '-');
                    if(resPosArray.indexOf(i) != -1) {
                        let cFull = ic.giSeq[chnid][i];
                        let c = cFull;
                        if(cFull.length > 1) {
                            c = cFull[0] + '..';
                        }
                        // let pos = ic.annoCddSiteCls.getAdjustedResi(i, chnid, ic.matchedPos, ic.chainsSeq, ic.baseResi);
                        let pos = ic.ParserUtilsCls.getResi(chnid, i);
                        
                        html += '<span id="' + pre + '_' + ic.pre + chnid + '_' + pos + '" title="' + c + pos + '" class="icn3d-residue">' + cFull + '</span>';
                        if(me.bNode) {
                            let obj = {};
                            obj[chnid + '_' + pos] = title;
                            ic.resid2ptm[chnid].push(obj);
                        }

                        html2 += ic.showSeqCls.insertGapOverview(chnid, i);
                        let emptyWidth =(me.cfg.blast_rep_id == chnid) ? Math.round(ic.seqAnnWidth * i /(ic.maxAnnoLength + ic.nTotalGap) - prevEmptyWidth - prevLineWidth) : Math.round(ic.seqAnnWidth * i / ic.maxAnnoLength - prevEmptyWidth - prevLineWidth);
                        //if(emptyWidth < 0) emptyWidth = 0;
                        if(emptyWidth >= 0) {
                            html2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';
                            html2 += '<div style="display:inline-block; background-color:#000; width:' + widthPerRes + 'px;" title="' + c + pos + '">&nbsp;</div>';
                            prevEmptyWidth += emptyWidth;
                            prevLineWidth += widthPerRes;
                        }
                    }
                    else {
                        html += '<span>-</span>'; //'<span>-</span>';
                    }
                }

                if(ic.seqStartLen && ic.seqStartLen[chnid]) html += ic.showSeqCls.insertMulGap(ic.seqEndLen[chnid], '-');

                htmlTmp = '<span class="icn3d-residueNum" title="residue count">&nbsp;' + resCnt.toString() + ' Residues</span>';
                htmlTmp += '</span>';
                htmlTmp += '<br>';
                html += htmlTmp;
                html2 += htmlTmp;

                ++index;
            }

            html += '</div>';
            html2 += '</div>';
            html3 += '</div>';

            $("#" + ic.pre + "dt_" + type + "_" + chnid).html(html);
            $("#" + ic.pre + "ov_" + type + "_" + chnid).html(html2);
            $("#" + ic.pre + "tt_" + type + "_" + chnid).html(html3);
        }

        getNoPTM(chnid, type) { let ic = this.icn3d; ic.icn3dui;
            console.log( "No PTM data were found for the chain " + chnid + "..." );

            let idStr = (type == 'ptm') ? 'ptm' : 'transmem';
       
            $("#" + ic.pre + "dt_" + idStr + "_" + chnid).html('');
            $("#" + ic.pre + "ov_" + idStr + "_" + chnid).html('');
            $("#" + ic.pre + "tt_" + idStr + "_" + chnid).html('');

            // add here after the ajax call
            ic.showAnnoCls.enableHlSeq();
            ic.bAjaxPTM = true;
            /// if(ic.deferredPTM !== undefined) ic.deferredPTM.resolve();
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class AnnoIg {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Show the annotations of CDD domains and binding sites.
        async showIg(chnid, template) { let ic = this.icn3d; ic.icn3dui;
            // if(!ic.bRunRefnum || Object.keys(ic.atoms).length > Object.keys(ic.hAtoms).length) {
            if(ic.bRunRefnumAgain) {
                // run for all chains
                await ic.refnumCls.showIgRefNum(template);
                // ic.bRunRefnum = true;    
            }

            let type = 'ig';
            let html = '', html2 = '', html3 = ''; 

            if(ic.bShowRefnum && ic.chainid2refpdbname.hasOwnProperty(chnid) && ic.chainid2refpdbname[chnid].length > 0) {  
                let giSeq = ic.showSeqCls.getSeq(chnid);                                     
                let result = ic.annoIgCls.showAllRefNum(giSeq, chnid);

                html += result.html;
                html2 += result.html2;
                html3 += result.html3;
            }

            $("#" + ic.pre + "dt_" + type + "_" + chnid).html(html);
            $("#" + ic.pre + "ov_" + type + "_" + chnid).html(html2);
            $("#" + ic.pre + "tt_" + type + "_" + chnid).html(html3);
        }

        showAllRefNum(giSeq, chnid) {  let ic = this.icn3d; ic.icn3dui;
            let html = '', html2 = '', html3 = '';

            //check if Kabat refnum available
            let bKabatFound = false;
            for(let i = 0, il = giSeq.length; i < il; ++i) {
                let currResi = ic.ParserUtilsCls.getResi(chnid, i);
                let residueid = chnid + '_' + currResi;
                let domainid = ic.resid2domainid[residueid];
                
                if(ic.domainid2ig2kabat[domainid] && Object.keys(ic.domainid2ig2kabat[domainid]).length > 0) {
                    bKabatFound = true;
                    break;
                }
            }

            //check if IMGT refnum available
            let bImgtFound = false;
            for(let i = 0, il = giSeq.length; i < il; ++i) {
                let currResi = ic.ParserUtilsCls.getResi(chnid, i);
                let residueid = chnid + '_' + currResi;
                let domainid = ic.resid2domainid[residueid];

                if(ic.domainid2ig2imgt[domainid] && Object.keys(ic.domainid2ig2imgt[domainid]).length > 0) {
                    bImgtFound = true;
                    break;
                }
            }

            let result = this.showRefNum(giSeq, chnid);
            html += result.html;
            html2 += result.html2;
            html3 += result.html3;

            let kabat_or_imgt = 1;
            if(bKabatFound) {
                result = this.showRefNum(giSeq, chnid, kabat_or_imgt);
                html += result.html;
                html2 += result.html2;
                html3 += result.html3;
            }

            kabat_or_imgt = 2;
            if(bImgtFound) {
                result = this.showRefNum(giSeq, chnid, kabat_or_imgt);
                html += result.html;
                html2 += result.html2;
                html3 += result.html3;
            }

            return {html: html, html2: html2, html3: html3};
        }

        showRefNum(giSeq, chnid, kabat_or_imgt, bCustom) {  let ic = this.icn3d; ic.icn3dui;
            if(ic.chainid2igtrack) {
                let bResult = ic.chainid2igtrack[chnid];
                if(!bResult) return {html: '', html2: '', html3: ''};
            }

            let html = this.getIgAnnoHtml(chnid, giSeq, bCustom, kabat_or_imgt);

            // add color to atoms
            if(ic.bShowRefnum) {
                ic.opts.color = 'ig strand';
                // ic.setColorCls.setColorByOptions(ic.opts, ic.dAtoms);
                ic.setColorCls.setColorByOptions(ic.opts, ic.chains[chnid]);
            }

            return html;
        }

        setChain2igArray(chnid, giSeq, bCustom) { let ic = this.icn3d; ic.icn3dui;
            let refnumLabel;

            let domainid2respos = {};
            for(let i = 0, il = giSeq.length; i < il; ++i) {
                let currResi = ic.ParserUtilsCls.getResi(chnid, i);
                let residueid = chnid + '_' + currResi;
                let domainid = (bCustom) ? 0 : ic.resid2domainid[residueid];

                refnumLabel = ic.resid2refnum[residueid];

                if(refnumLabel) {              
                    if(!domainid2respos[domainid]) domainid2respos[domainid] = [];
                    domainid2respos[domainid].push(i);
                }
            }

            for(let domainid in domainid2respos) {
                let posArray = domainid2respos[domainid];
                let pos, prevPos, startPosArray = [], endPosArray = [];
                for(let i = 0, il = posArray.length; i < il; ++i) {
                    pos = posArray[i];
                    if(i == 0) startPosArray.push(pos);

                    if(i > 0 && pos != prevPos + 1) { // a new range
                        endPosArray.push(prevPos);
                        startPosArray.push(pos);
                    }

                    prevPos = pos;
                }
                endPosArray.push(pos);

                let igElem = {};
                igElem.domainid = domainid;
                igElem.startPosArray = startPosArray;
                igElem.endPosArray = endPosArray;
                ic.chain2igArray[chnid].push(igElem);
            }
        }

        getIgAnnoHtml(chnid, giSeq, bCustom, kabat_or_imgt) { let ic = this.icn3d, me = ic.icn3dui;
            let html = '', html2 = '', html3 = '';
            let type = 'ig';

            if(!ic.chain2igArray) ic.chain2igArray = {};

            let bLoop = false, currStrand = '';
            let refnumLabel, refnumStr_ori, refnumStr;

            ic.chain2igArray[chnid] = [];
            this.setChain2igArray(chnid, giSeq, bCustom);

            // remove Igs without BCEF strands one more time
            let igArray = ic.chain2igArray[chnid];    

            for(let i = 0, il = igArray.length; i < il; ++i) {
                let domainid = igArray[i].domainid;

                if(!ic.domainid2info) continue;
                let info = ic.domainid2info[domainid];
                if(!info) continue;

                let bBStrand = false, bCStrand = false, bEStrand = false, bFStrand = false;

                let residHash = {};
                for(let j = 0, jl = igArray[i].startPosArray.length; j < jl; ++j) {
                    let startPos = igArray[i].startPosArray[j];
                    let endPos = igArray[i].endPosArray[j];
                    for(let k = startPos; k <= endPos; ++k) {
                        const resid = chnid + '_' + ic.chainsSeq[chnid][k].resi;
                        residHash[resid] = 1;
                        let refnum = ic.resid2refnum[resid];

                        if(refnum) {
                            if(refnum.indexOf('B2550') != -1) bBStrand = true;
                            if(refnum.indexOf('C3550') != -1) bCStrand = true;
                            if(refnum.indexOf('E7550') != -1) bEStrand = true;
                            if(refnum.indexOf('F8550') != -1) bFStrand = true;
                        }
                    }
                }

                if(!(bBStrand && bCStrand && bEStrand && bFStrand)) {
                    // reset for these residues
                    for(let resid in residHash) {
                        delete ic.resid2refnum[resid];
                        delete ic.residIgLoop[resid];
                        delete ic.resid2domainid[resid];
                    }

                    let residArray = Object.keys(residHash);

                    // delete the following loops
                    let lastPos = ic.setSeqAlignCls.getPosFromResi(chnid, residArray[residArray.length - 1].split('_')[2]);

                    for(let j = lastPos + 1, jl = ic.chainsSeq[chnid].length; j < jl; ++j) {
                        let resi = ic.chainsSeq[chnid][j].resi;
                        let resid = chnid + '_' + resi;
                        if(ic.residIgLoop.hasOwnProperty(resid)) {
                            delete ic.resid2refnum[resid];
                            delete ic.residIgLoop[resid];
                            delete ic.resid2domainid[resid]; 
                        }
                        else {
                            break;
                        }
                    }

                    // delete the previous loops
                    ic.setSeqAlignCls.getPosFromResi(chnid, residArray[0].split('_')[2]);

                    for(let j = lastPos - 1; j >= 0; --j) {
                        let resi = ic.chainsSeq[chnid][j].resi;
                        let resid = chnid + '_' + resi;
                        if(ic.residIgLoop.hasOwnProperty(resid)) {
                            delete ic.resid2refnum[resid];
                            delete ic.residIgLoop[resid];
                            delete ic.resid2domainid[resid]; 
                        }
                        else {
                            break;
                        }
                    }
                }
            }

            // reset ic.chain2igArray
            ic.chain2igArray[chnid] = [];
            this.setChain2igArray(chnid, giSeq, bCustom);

            // show tracks
            // let domainid2respos = {};
            let htmlIg = '';
            for(let i = 0, il = giSeq.length; i < il; ++i) {
                htmlIg += ic.showSeqCls.insertGap(chnid, i, '-');

                let currResi = ic.ParserUtilsCls.getResi(chnid, i);
                let residueid = chnid + '_' + currResi;
                let domainid = (bCustom) ? 0 : ic.resid2domainid[residueid];

                //if(!ic.residues.hasOwnProperty(residueid)) {
                //    htmlIg += '<span></span>';
                //}
                //else {
                    refnumLabel = (bCustom) ? ic.chainsMapping[chnid][residueid] : ic.resid2refnum[residueid];
                    let bHidelabel = false;

                    if(refnumLabel) {              
                        // if(!domainid2respos[domainid]) domainid2respos[domainid] = [];
                        // domainid2respos[domainid].push(i);
                
                        refnumStr_ori = ic.refnumCls.rmStrandFromRefnumlabel(refnumLabel);
                        currStrand = refnumLabel.replace(new RegExp(refnumStr_ori,'g'), '');

                        refnumStr_ori.substr(0, 1);

                        if(bCustom) {
                            refnumStr = refnumLabel;
                        }
                        else if(kabat_or_imgt == 1) {
                            refnumStr = (ic.domainid2ig2kabat[domainid]) ? ic.domainid2ig2kabat[domainid][refnumStr_ori] : undefined;                            
                        }
                        else if(kabat_or_imgt == 2) {
                            refnumStr = (ic.domainid2ig2imgt[domainid]) ? ic.domainid2ig2imgt[domainid][refnumStr_ori] : undefined;                            
                        }
                        else {
                            refnumStr = refnumStr_ori;
                        }
                    
                        if(bCustom) {
                            if(!refnumStr) {                               
                                htmlIg += '<span></span>';
                            }
                            else {
                                let refnum = parseInt(refnumStr);

                                if(refnum % 2 == 0) {
                                    htmlIg += '<span title="' + refnumStr + '">' + refnumStr + '</span>';
                                }
                                else {
                                    htmlIg += '<span title="' + refnumStr + '">&nbsp;</span>';
                                }
                            }
                        }
                        else if(kabat_or_imgt == 1 || kabat_or_imgt == 2) {
                            if(!refnumStr) {                               
                                htmlIg += '<span></span>';
                            }
                            else {
                                let refnum = parseInt(refnumStr).toString();
                                let color = this.getRefnumColor(currStrand, true);
                                let colorStr = 'style="color:' + color + '"';

                                let lastTwo = parseInt(refnum.substr(refnum.length - 2, 2));

                                if(lastTwo % 2 == 0) {
                                    htmlIg += '<span ' + colorStr + ' title="' + refnumStr + '">' + refnumStr + '</span>';
                                }
                                else {
                                    htmlIg += '<span ' + colorStr + ' title="' + refnumStr + '">&nbsp;</span>';
                                }
                            }
                        }
                        else {                       
                            if(currStrand != ' ') {
                                bLoop = ic.residIgLoop[residueid];
                                htmlIg += this.getRefnumHtml(residueid, refnumStr, refnumStr_ori, refnumLabel, currStrand, bLoop, bHidelabel);
                                // if(bLoop) ic.residIgLoop[residueid] = 1;
                            }
                            else {
                                htmlIg += '<span></span>';
                            }
                        }
                    }
                    else {
                        htmlIg += '<span></span>';
                    }
                //}
            }

            if(me.bNode) return {html: html, html2: html2, html3: html3}
            let titleSpace = 120;

            let linkStr = 'icn3d-link icn3d-blue';
            let title = 'IgStRAnD Ref. No.';

            let igCnt = ic.chain2igArray[chnid].length;
            let fromArray = [], toArray = [];
            let posindex2domainindex = {};
            if(!ic.igLabel2Pos) ic.igLabel2Pos = {};
            ic.igLabel2Pos[chnid] = {};
            for(let i = 0; i < igCnt; ++i) {
                let igElem = ic.chain2igArray[chnid][i];
                fromArray = fromArray.concat(igElem.startPosArray);
                toArray = toArray.concat(igElem.endPosArray);

                for(let j = 0, jl = igElem.startPosArray.length; j < jl; ++j) {
                    let pos = igElem.startPosArray[j];
                    posindex2domainindex[pos] = i;
                }

                let resi1 = ic.ParserUtilsCls.getResi(chnid, igElem.startPosArray[0]);
                let resid1 = chnid + "_" + resi1;
                let calpha1 = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[resid1]);

                let resi2 = ic.ParserUtilsCls.getResi(chnid, igElem.endPosArray[igElem.endPosArray.length - 1]);
                let resid2 = chnid + "_" + resi2;
                let calpha2 = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[resid2]);

                let label = chnid.substr(chnid.lastIndexOf('_') + 1) + '-Ig' + (i+1).toString();

                ic.igLabel2Pos[chnid][label] = calpha1.coord.clone().add(calpha2.coord).multiplyScalar(0.5);
            }

            // let htmlCnt = '<span class="icn3d-residueNum" title="Ig domain count">' + igCnt.toString() + ' Igs</span>';
            let htmlCnt = '<div style="display:inline-block" class="icn3d-residueNum" title="Ig domain count">' + igCnt.toString() + ' Ig(s)</div>';

            let htmlTmp = '<div id="' + ic.pre + chnid + '_' + type + 'seq_sequence" class="icn3d-ig icn3d-dl_sequence">';
            if(bCustom) htmlTmp = '<div class="icn3d-dl_sequence">';

            let htmlTitle = '<div style="width:' + titleSpace + 'px!important;" class="icn3d-seqTitle ' + linkStr + '" ig="0" from="' + fromArray + '" to="' + toArray + '" shorttitle="' + title + '" index="0" setname="' + chnid + '_Igs" anno="sequence" chain="' + chnid + '" title="IgStRAnD Reference Numbers">' + title + ' </div>';

            htmlTmp += '<div class="icn3d-residueLine" style="white-space:nowrap;">';
            if(bCustom) {
                htmlTmp += '<div class="icn3d-annoTitle" anno="0" title="Custom Reference Numbers">Custom Ref. No.</div>';
                htmlTmp += '<span class="icn3d-residueNum"></span>';
            }
            else if(kabat_or_imgt == 1) {
                htmlTmp += '<div class="icn3d-annoTitle" anno="0" title="Kabat Reference Numbers">Kabat Ref. No.</div>';
                htmlTmp += '<span class="icn3d-residueNum"></span>';
            }
            else if(kabat_or_imgt == 2) {
                htmlTmp += '<div class="icn3d-annoTitle" anno="0" title="IMGT Reference Numbers">IMGT Ref. No.</div>';
                htmlTmp += '<span class="icn3d-residueNum"></span>';
            }
            else {
                htmlTmp += htmlTitle;
                htmlTmp += htmlCnt;
            }
            
            html3 += htmlTmp + '<br>';
            html += htmlTmp + '<span class="icn3d-seqLine">';

            if(ic.seqStartLen && ic.seqStartLen[chnid]) html += ic.showSeqCls.insertMulGap(ic.seqStartLen[chnid], '-');
     
            html += htmlIg;

            if(ic.seqStartLen && ic.seqStartLen[chnid]) html += ic.showSeqCls.insertMulGap(ic.seqEndLen[chnid], '-');
            
            if(!bCustom) html += htmlCnt;

            html += '</span>';
            html += '<br>';
            html += '</div>';
            html += '</div>';

            // use the updated ic.chain2igArray
            igArray = ic.chain2igArray[chnid];      

            if(igArray.length == 0) return {html: html, html2: html2, html3: html3}
            let rangeArray = [], titleArray = [], fullTitleArray = [], domainArray = [];

            let chain = chnid.substr(chnid.lastIndexOf('_') + 1);
            for(let i = 0, il = igArray.length; i < il; ++i) {
                let domainid = igArray[i].domainid;
                if(!ic.domainid2info) continue;

                let info = ic.domainid2info[domainid];
                if(!info) continue;

                let tmscore = info.score;

                let igType = (parseFloat(tmscore) < ic.refnumCls.TMThresholdIgType ) ? 'Ig' : ic.ref2igtype[info.refpdbname];
                titleArray.push(igType + ' (TM:' + parseFloat(tmscore).toFixed(2) + ')');
                fullTitleArray.push(igType + ' (TM:' + parseFloat(tmscore).toFixed(2) + '), template: ' + info.refpdbname + ', type: ' + ic.ref2igtype[info.refpdbname] + ', Seq. identity: ' + parseFloat(info.seqid).toFixed(2) + ', aligned residues: ' + info.nresAlign + ', label in 3D: ' + chain + '-Ig' + (i+1).toString());

                domainArray.push(igType);

                let segs = [];
                for(let j = 0, jl = igArray[i].startPosArray.length; j < jl; ++j) {
                    segs.push({"from":igArray[i].startPosArray[j], "to":igArray[i].endPosArray[j]});
                }
                let range = {};
                range.locs = [{"segs": segs}];
                rangeArray.push(range);
            }

            if(rangeArray.length == 0) return {html: html, html2: html2, html3: html3}

            // add tracks for the summary view
            if(!kabat_or_imgt && !bCustom) {
                // summary html2
                html2 += htmlTitle; 
                html2 += htmlCnt + '<span class="icn3d-seqLine">';

                if(ic.seqStartLen && ic.seqStartLen[chnid]) html2 += ic.showSeqCls.insertMulGapOverview(chnid, ic.seqStartLen[chnid]);

                let prevDomainindex, color;
                for(let i = 0, il = fromArray.length; i < il; ++i) {
                    let resi = ic.ParserUtilsCls.getResi(chnid, fromArray[i]);
                    let resid = chnid + "_" + resi;

                    let domainindex = posindex2domainindex[fromArray[i]];
                    if(domainindex != prevDomainindex) {
                        let atom = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid]);
                        let colorStr =(!atom || atom.color === undefined || atom.color.getHexString() === 'FFFFFF') ? 'DDDDDD' : atom.color.getHexString();
                        color =(atom && atom.color !== undefined) ? colorStr : "CCCCCC";
                    }

                    let emptyWidth =(i == 0) ? Math.round(ic.seqAnnWidth *(fromArray[i]) / ic.maxAnnoLength) : 
                        Math.round(ic.seqAnnWidth *(fromArray[i] - toArray[i-1] - 1) / ic.maxAnnoLength);
                    html2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';
                    html2 += '<div style="display:inline-block; color:white!important; font-weight:bold; background-color:#' + color + '; width:' + Math.round(ic.seqAnnWidth *(toArray[i] - fromArray[i] + 1) / ic.maxAnnoLength) + 'px;" class="icn3d-seqTitle ' + linkStr + '" ig="0" from="' + fromArray + '" to="' + toArray + '" shorttitle="' + domainArray[domainindex] + '" index="0" setname="' + chnid + '_igs" id="' + chnid + '_igs" anno="sequence" chain="' + chnid + '" title="' + domainArray[domainindex] + '">' +  domainArray[domainindex] + ' </div>';

                    prevDomainindex = domainindex;
                }

                html2 += htmlCnt;

                html2 += '</div></div>';
                html3 += '</div></div>';

                // add tracks for each Ig domain
                htmlTmp = '<div id="' + ic.pre + chnid + '_igseq_sequence" class="icn3d-ig icn3d-dl_sequence">';
                let htmlTmp2 = htmlTmp;
                let htmlTmp3 = htmlTmp;

                let result = ic.annoCddSiteCls.setDomainFeature(rangeArray, chnid, 'ig', htmlTmp, htmlTmp2, htmlTmp3, undefined, titleArray, fullTitleArray);

                html += result.html + '</div>';
                html2 += result.html2 + '</div>';
                html3 += result.html3 + '</div>';
            }

            return {html: html, html2: html2, html3: html3}
        }

        getRefnumHtml(residueid, refnumStr, refnumStr_ori, refnumLabel, currStrand, bLoop, bHidelabel) { let ic = this.icn3d, me = ic.icn3dui;
            let refnum = parseInt(refnumStr).toString();

            let refnum3c = (refnum - parseInt(refnum/1000) * 1000).toString();
            let firstTwo = parseInt(refnum.toString().substr(0, 2)); // check extended strands
            let bExtendedStrand = refnum3c.substr(0,1) != '5' && firstTwo != '18'; // all strands and A' (18##)

            let color = this.getRefnumColor(currStrand, true);
            let colorStr = (!bLoop) ? 'style="color:' + color + '; text-decoration: underline overline;"' : 'style="color:' + color + '"';

            let lastTwoStr = refnum.substr(refnum.length - 2, 2);
            let lastTwo = parseInt(lastTwoStr);
            parseInt(refnum.substr(refnum.length - 3, 3));

            let html = '';

            if(refnumLabel && lastTwo == 50 && !bExtendedStrand && !bLoop) {
                // highlight the anchor residues
                ic.hAtomsRefnum = me.hashUtilsCls.unionHash(ic.hAtomsRefnum, ic.residues[residueid]);

                html += '<span ' + colorStr + ' title="' + refnumLabel + '"><b>' + refnumLabel.substr(0, 1) + '</b>' + refnumLabel.substr(1) + '</span>';
            }
            else if(refnumLabel && lastTwo % 2 == 0 && lastTwo != 52 && !bHidelabel) { // don't show label for the first, middle, and last loop residues
                // e.g., 2152a
                lastTwoStr = isNaN(refnumStr) ? lastTwoStr + refnumStr.substr(refnumStr.length - 1, 1) : lastTwoStr;
                html += '<span ' + colorStr + ' title="' + refnumLabel + '">' + lastTwoStr + '</span>';
            }
            else {
                html += '<span ' + colorStr + ' title="' + refnumLabel + '">&nbsp;</span>';
            }

            return html;
        }

        getRefnumColor(currStrand, bText) {  let ic = this.icn3d, me = ic.icn3dui;
            let strand = (currStrand) ? currStrand.substr(0,1) : '';
            
            if(currStrand == "C") { 
                return '#0000FF'; 
            }
            else if(currStrand == "C'") { 
                return '#6495ED'; 
            }
            else if(currStrand == "C''") { 
                return '#006400'; 
            }

            else if(strand == "A") { 
                return '#9400D3'; //'#663399'; 
            }
            else if(strand == "B") { 
                return '#ba55d3'; 
            }
            else if(strand == "D") { 
                return '#00FF00'; 
            }
            else if(strand == "E") {
                return "#FFD700"; 
            }
            else if(strand == "F") { 
                return '#FF8C00'; 
            }
            else if(strand == "G") { 
                return '#FF0000'; 
            }
            else {
                return me.htmlCls.GREYB;
            }
        }

        getProtodomainColor(currStrand) {  let ic = this.icn3d, me = ic.icn3dui;
            let strand = (currStrand) ? currStrand.substr(0,1) : '';

            if(strand == "A" || strand == "D") {
                return '#0000FF';
            }
            else if(strand == "B" || strand == "E") {
                return '#006400';
            }
            else if(currStrand == "C" || strand == "F") {
                return "#FFD700"; //"#FFFF00"; //'#F0E68C'; 
            }
            else if(currStrand == "C'" || strand == "G") {
                return '#FF8C00'; 
            }
            else if(currStrand == "C''") { //linker
                return '#FF0000'; 
            }
            else {
                return me.htmlCls.GREYB;
            }
        }    
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class AnnoCrossLink {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        showCrosslink(chnid, chnidBase) { let ic = this.icn3d; ic.icn3dui;
            let thisClass = this;
            if(ic.clbondpnts === undefined) {
                // didn't finish loading atom data yet
                setTimeout(function(){
                  thisClass.showCrosslink_base(chnid, chnidBase);
                }, 1000);
            }
            else {
                this.showCrosslink_base(chnid, chnidBase);
            }
        }
        showCrosslink_base(chnid, chnidBase) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) {
                if(!ic.resid2crosslink) ic.resid2crosslink = {};
                if(!ic.resid2crosslink[chnid]) ic.resid2crosslink[chnid] = [];
            }

            let chainid = chnidBase;
            let resid2resids = {};
            let structure = chainid.substr(0, chainid.indexOf('_'));
            let clbondArray = ic.clbondpnts[structure];

            if(clbondArray === undefined) {
                $("#" + ic.pre + "dt_crosslink_" + chnid).html('');
                $("#" + ic.pre + "ov_crosslink_" + chnid).html('');
                $("#" + ic.pre + "tt_crosslink_" + chnid).html('');
                return;
            }
            for(let i = 0, il = clbondArray.length; i < il; i = i + 2) {
                let resid1 = clbondArray[i]; // chemical
                let resid2 = clbondArray[i+1]; // protein or chemical
                resid1.substr(0, resid1.lastIndexOf('_'));
                let chainid2 = resid2.substr(0, resid2.lastIndexOf('_'));
                //if(chainid === chainid1) {
                //    if(resid2resids[resid1] === undefined) resid2resids[resid1] = [];
                //    resid2resids[resid1].push(resid2);
                //}
                if(chainid === chainid2) {
                    if(resid2resids[resid2] === undefined) resid2resids[resid2] = [];
                    resid2resids[resid2].push(resid1);
                }
            }
            let residueArray = Object.keys(resid2resids);
            let title = "Cross-Linkages";
            ic.annoCddSiteCls.showAnnoType(chnid, chnidBase, 'crosslink', title, residueArray, resid2resids);
        }

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class AnnoDomain {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        showDomainPerStructure(index, bNotShowDomain) { let ic = this.icn3d; ic.icn3dui;
            let thisClass = this;
            //var chnid = Object.keys(ic.protein_chainid)[0];
            //var pdbid = chnid.substr(0, chnid.indexOf('_'));
            let pdbArray = Object.keys(ic.structures);
            // show 3D domains
            let pdbid = pdbArray[index];
            //let url = me.htmlCls.baseUrl + "mmdb/mmdb_strview.cgi?v=2&program=icn3d&domain&molinfor&uid=" + pdbid;

    /*
            if(!ic.bResetAnno && index == 0 && ic.mmdb_data !== undefined) {      
                for(let chnid in ic.protein_chainid) {
                    if(chnid.indexOf(pdbid) !== -1) {
                        this.showDomainWithData(chnid, ic.mmdb_data);
                    }
                }
            }
            else if(!ic.bResetAnno && ic.mmdb_dataArray[index] !== undefined) {
                for(let chnid in ic.protein_chainid) {
                    if(chnid.indexOf(pdbid) !== -1) {
                       this.showDomainWithData(chnid, ic.mmdb_dataArray[index]);
                    }
                }
            }
            else {
    */
                // calculate 3D domains on-the-fly
                //ic.protein_chainid[chainArray[i]] 
                let data = {};
                data.domains = {};
                for(let chainid in ic.chains) {
                    let structure = chainid.substr(0, chainid.indexOf('_'));
                    // if(pdbid == structure && ic.protein_chainid.hasOwnProperty(chainid)) {
                    if(pdbid == structure) {
                        data.domains[chainid] = {};
                        data.domains[chainid].domains = [];

                        let atoms = ic.chains[chainid];

                        let result = ic.domain3dCls.c2b_NewSplitChain(atoms);
                        let subdomains = result.subdomains;
                        // let pos2resi = result.pos2resi;

                        for(let i = 0, il = subdomains.length; i < il; ++i) {
                            // domain item: {"sdid":1722375,"intervals":[[1,104],[269,323]]}
                            let domain = {};
                            domain.intervals = [];

                            for(let j = 0, jl = subdomains[i].length; j < jl; j += 2) {
                                domain.intervals.push([subdomains[i][j], subdomains[i][j+1]]);
                            }

                            data.domains[chainid].domains.push(domain);
                        }

                        // data.domains[chainid].pos2resi = pos2resi;
                    }
                }

                ic.mmdb_dataArray[index] = data;
                // for(let chnid in ic.protein_chainid) {
                for(let chnid in ic.chains) {
                    if(chnid.indexOf(pdbid) !== -1) {
                        thisClass.showDomainWithData(chnid, ic.mmdb_dataArray[index], bNotShowDomain);
                    }
                }

                ic.bAjax3ddomain = true;
                ic.bAjaxDoneArray[index] = true;          
            // }
        }

        //Show the annotations of 3D domains.
        showDomainAll(bNotShowDomain) { let ic = this.icn3d; ic.icn3dui;
            //var chnid = Object.keys(ic.protein_chainid)[0];
            //var pdbid = chnid.substr(0, chnid.indexOf('_'));
            let pdbArray = Object.keys(ic.structures);
            // show 3D domains
            ic.mmdb_dataArray = [];
            ic.bAjaxDoneArray = [];
            for(let i = 0, il = pdbArray.length; i < il; ++i) {
                ic.bAjaxDoneArray[i] = false;
            }

            for(let i = 0, il = pdbArray.length; i < il; ++i) {
                this.showDomainPerStructure(i, bNotShowDomain);
            }
        }

        getResiFromNnbiresid(ncbiresid) { let ic = this.icn3d; ic.icn3dui;
            let resid = (ic.ncbi2resid[ncbiresid]) ? ic.ncbi2resid[ncbiresid] : ncbiresid;
            let resi = resid.substr(resid.lastIndexOf('_') + 1);

            return resi;
        }

        getNcbiresiFromResid(resid) { let ic = this.icn3d; ic.icn3dui;
            let ncbiresid = (ic.resid2ncbi[resid]) ? ic.resid2ncbi[resid] : resid;
            let resi = ncbiresid.substr(ncbiresid.lastIndexOf('_') + 1);

            return resi;
        }

        showDomainWithData(chnid, data, bNotShowDomain) { let ic = this.icn3d, me = ic.icn3dui;
            let html = '<div id="' + ic.pre + chnid + '_domainseq_sequence" class="icn3d-dl_sequence">';
            let html2 = html;
            let html3 = html;
            let domainArray, proteinname;
            let pos = chnid.indexOf('_');
            let chain = chnid.substr(pos + 1);
            // MMDB symmetry chain has the form of 'A1'
            if(chain.length > 1 && chain.substr(chain.length - 1) == '1') {
                chain = chain.substr(0, chain.length - 1);
            }

            // if(bCalcDirect) {
                proteinname = chnid;
                domainArray = (data.domains[chnid]) ? data.domains[chnid].domains : [];
                // pos2resi = data.domains[chnid].pos2resi;
    /*            
            }
            else {
                let molinfo = data.moleculeInfor;
                let currMolid;
                for(let molid in molinfo) {
                    if(molinfo[molid].chain === chain) {
                    currMolid = molid;
                    proteinname = molinfo[molid].name;
                    break;
                    }
                }
                if(currMolid !== undefined && data.domains[currMolid] !== undefined) {
                    domainArray = data.domains[currMolid].domains;
                }
                if(domainArray === undefined) {
                    domainArray = [];
                }
            }
    */        

            for(let index = 0, indexl = domainArray.length; index < indexl; ++index) {
                //var fulltitle = '3D domain ' +(index+1).toString() + ' of ' + proteinname + '(PDB ID: ' + data.pdbId + ')';
                let fulltitle = '3D domain ' +(index+1).toString() + ' of ' + proteinname;
                let title =(fulltitle.length > 17) ? fulltitle.substr(0,17) + '...' : fulltitle;
                let subdomainArray = domainArray[index].intervals;
                // remove duplicate, e.g., at https://www.ncbi.nlm.nih.gov/Structure/mmdb/mmdb_strview.cgi?v=2&program=icn3d&domain&molinfor&uid=1itw
                // let domainFromHash = {}, domainToHash = {};
                let fromArray = [], toArray = []; // posFromArray = [], posToArray = [];
                let resiHash = {};
                let resCnt = 0;

                // subdomainArray contains NCBI residue number
                for(let i = 0, il = subdomainArray.length; i < il; ++i) {
                    // let domainFrom = Math.round(subdomainArray[i][0]) - 1; // convert 1-based to 0-based
                    // let domainTo = Math.round(subdomainArray[i][1]) - 1;

                    let domainFrom = parseInt(subdomainArray[i][0]);
                    let domainTo = parseInt(subdomainArray[i][1]);


                    // fromArray.push(pos2resi[domainFrom]);
                    // toArray.push(pos2resi[domainTo]);

                    fromArray.push(domainFrom);
                    toArray.push(domainTo);

                    // posFromArray.push(domainFrom);
                    // posToArray.push(domainTo);

                    resCnt += domainTo - domainFrom + 1;
                    for(let j = domainFrom; j <= domainTo; ++j) {
                        // let resi = pos2resi[j];
                        let resi = this.getResiFromNnbiresid(chnid + '_' + j);
                        resiHash[resi] = 1;
                    }
                }

                if(ic.chainid2clashedResidpair) { //assign domain size to each residue in the clashed residues
                    for(let residpair in ic.chainid2clashedResidpair) {
                        let residArray = residpair.split('|');
                        let valueArray = ic.chainid2clashedResidpair[residpair].split('|');

                        for(let i = 0, il = residArray.length; i < il; ++i) {
                            let chainid = residArray[i][0] + '_' + residArray[i][1];

                            if(chainid == chnid) {
                                let resi = residArray[i][3];
                                if(resiHash.hasOwnProperty(resi)) {
                                    ic.chainid2clashedResidpair[residpair] = (i == 0) ? resCnt + '|' + valueArray[1] : valueArray[1] + '|' + resCnt;
                                }
                            }
                        }
                    }
                }

                // save 3D domain info for node.js script
                if(me.bNode) {
                    let domainName = '3D domain ' +(index+1).toString();
                                
                    if(!ic.resid2domain) ic.resid2domain = {};
                    if(!ic.resid2domain[chnid]) ic.resid2domain[chnid] = [];
                    // for(let i = 0, il = posFromArray.length; i < il; ++i) {
                    for(let i = 0, il = fromArray.length; i < il; ++i) {
                        let from = fromArray[i];
                        let to = toArray[i];
                        for(let j = from; j <= to; ++j) {
                            // 0-based
                            let obj = {};
                            // let resi = ic.ParserUtilsCls.getResi(chnid, j);
                            let resid = ic.ncbi2resid[chnid + '_' + j];
                            obj[resid] = domainName;
                            ic.resid2domain[chnid].push(obj);
                        }
                    }
                }

                if(bNotShowDomain) continue;

                let htmlTmp2 = '<div class="icn3d-seqTitle icn3d-link icn3d-blue" 3ddomain="' +(index+1).toString() + '" from="' + fromArray + '" to="' + toArray + '" shorttitle="' + title + '" index="' + index + '" setname="' + chnid + '_3d_domain_' +(index+1).toString() + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + title + ' </div>';
                let htmlTmp3 = '<span class="icn3d-residueNum" title="residue count">' + resCnt.toString() + ' Res</span>';
                html3 += htmlTmp2 + htmlTmp3 + '<br>';
                let htmlTmp = '<span class="icn3d-seqLine">';
                html += htmlTmp2 + htmlTmp3 + htmlTmp;
                html2 += htmlTmp2 + htmlTmp3 + htmlTmp;
                let pre = 'domain3d' + index.toString();

                if(ic.seqStartLen && ic.seqStartLen[chnid]) html += ic.showSeqCls.insertMulGap(ic.seqStartLen[chnid], '-');

                for(let i = 0, il = ic.giSeq[chnid].length; i < il; ++i) {
                  html += ic.showSeqCls.insertGap(chnid, i, '-');
                  //if(i >= domainFrom && i <= domainTo) {
                  let resi = ic.ParserUtilsCls.getResi(chnid, i);
                //   if(resiHash.hasOwnProperty(i+1)) {
                  if(resiHash.hasOwnProperty(resi)) {
                      let cFull = ic.giSeq[chnid][i];
                      let c = cFull;
                      if(cFull.length > 1) {
                          c = cFull[0] + '..';
                      }
                      
                    //   let pos =(i >= ic.matchedPos[chnid] && i - ic.matchedPos[chnid] < ic.chainsSeq[chnid].length) ? ic.chainsSeq[chnid][i - ic.matchedPos[chnid]].resi : ic.baseResi[chnid] + 1 + i;
                      let pos = resi;
                      html += '<span id="' + pre + '_' + ic.pre + chnid + '_' + pos + '" title="' + c + pos + '" class="icn3d-residue">' + cFull + '</span>';
                  }
                  else {
                    html += '<span>-</span>'; //'<span>-</span>';
                  }
                }

                if(ic.seqStartLen && ic.seqStartLen[chnid]) html += ic.showSeqCls.insertMulGap(ic.seqEndLen[chnid], '-');

                let atom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.chains[chnid]);
                let colorStr =(atom.color === undefined || atom.color.getHexString() === 'FFFFFF') ? 'DDDDDD' : atom.color.getHexString();
                let color =(atom.color !== undefined) ? colorStr : "CCCCCC";

                if(ic.seqStartLen && ic.seqStartLen[chnid]) html2 += ic.showSeqCls.insertMulGapOverview(chnid, ic.seqStartLen[chnid]);

                if(me.cfg.blast_rep_id != chnid) { // regular             
                    for(let i = 0, il = fromArray.length; i < il; ++i) {
                        // let emptyWidth =(i == 0) ? Math.round(ic.seqAnnWidth *(fromArray[i] - ic.baseResi[chnid] - 1) / ic.maxAnnoLength) : Math.round(ic.seqAnnWidth *(fromArray[i] - toArray[i-1] - 1) / ic.maxAnnoLength);
                        let emptyWidth =(i == 0) ? Math.round(ic.seqAnnWidth *(fromArray[i]) / ic.maxAnnoLength) : Math.round(ic.seqAnnWidth *(fromArray[i] - toArray[i-1] - 1) / ic.maxAnnoLength);

                        html2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';
                        html2 += '<div style="display:inline-block; color:white!important; font-weight:bold; background-color:#' + color + '; width:' + Math.round(ic.seqAnnWidth *(toArray[i] - fromArray[i] + 1) / ic.maxAnnoLength) + 'px;" class="icn3d-seqTitle icn3d-link icn3d-blue" 3ddomain="' +(index+1).toString() + '" from="' + fromArray + '" to="' + toArray + '" shorttitle="' + title + '" index="' + index + '" setname="' + chnid + '_3d_domain_' +(index+1).toString() + '" id="' + chnid + '_3d_domain_' + index + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">3D domain ' +(index+1).toString() + '</div>';
                    }
                }
                else { // with potential gaps 
                    let fromArray2 = [], toArray2 = [];
                    for(let i = 0, il = fromArray.length; i < il; ++i) {
                        fromArray2.push(fromArray[i]);
                        for(let j = parseInt(fromArray[i]); j <= parseInt(toArray[i]); ++j) {
                            if(ic.targetGapHash !== undefined && ic.targetGapHash.hasOwnProperty(j)) {
                                toArray2.push(j - 1);
                                fromArray2.push(j);
                            }
                        }
                        toArray2.push(toArray[i]);
                    }
                    for(let i = 0, il = fromArray2.length; i < il; ++i) {
                        html2 += ic.showSeqCls.insertGapOverview(chnid, fromArray2[i]);
                        let emptyWidth =(i == 0) ? Math.round(ic.seqAnnWidth *(fromArray2[i] - ic.baseResi[chnid] - 1) /(ic.maxAnnoLength + ic.nTotalGap)) : Math.round(ic.seqAnnWidth *(fromArray2[i] - toArray2[i-1] - 1) /(ic.maxAnnoLength + ic.nTotalGap));
                        html2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';
                        html2 += '<div style="display:inline-block; color:white!important; font-weight:bold; background-color:#' + color + '; width:' + Math.round(ic.seqAnnWidth *(toArray2[i] - fromArray2[i] + 1) /(ic.maxAnnoLength + ic.nTotalGap)) + 'px;" class="icn3d-seqTitle icn3d-link icn3d-blue" 3ddomain="' +(index+1).toString() + '" from="' + fromArray2 + '" to="' + toArray2 + '" shorttitle="' + title + '" index="' + index + '" setname="' + chnid + '_3d_domain_' +(index+1).toString() + '" id="' + chnid + '_3d_domain_' + index + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">3D domain ' +(index+1).toString() + '</div>';
                    }
                }
                htmlTmp = '<span class="icn3d-residueNum" title="residue count">&nbsp;' + resCnt.toString() + ' Residues</span>';
                htmlTmp += '</span>';
                htmlTmp += '<br>';
                html += htmlTmp;
                html2 += htmlTmp;
            }

            if(!bNotShowDomain) {
                html += '</div>';
                html2 += '</div>';
                html3 += '</div>';
                $("#" + ic.pre + "dt_domain_" + chnid).html(html);
                $("#" + ic.pre + "ov_domain_" + chnid).html(html2);
                $("#" + ic.pre + "tt_domain_" + chnid).html(html3);
            }

            // hide clashed residues between two chains
            if(bNotShowDomain && ic.chainid2clashedResidpair) {
                ic.clashedResidHash = {};
                for(let residpair in ic.chainid2clashedResidpair) {
                    let residArray = residpair.split('|');
                    let valueArray = ic.chainid2clashedResidpair[residpair].split('|');
                    
                    if(parseInt(valueArray[0]) < parseInt(valueArray[1])) {
                        ic.clashedResidHash[residArray[0]] = 1;
                    }
                    else {
                        ic.clashedResidHash[residArray[1]] = 1;
                    }
                }

                // expand clashed residues to the SSE and the loops connecting the SSE
                let addResidHash = {}, tmpHash = {};
                for(let resid in ic.clashedResidHash) {
                    let pos = resid.lastIndexOf('_');
                    let resi = parseInt(resid.substr(pos + 1));
                    let chainid = resid.substr(0, pos);
                    let atom = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid]);
                    if(atom.ss == 'coil') {
                        tmpHash = this.getMoreResidues(resi, chainid, 1, 'not coil');
                        addResidHash = me.hashUtilsCls.unionHash(addResidHash, tmpHash);
                        tmpHash = this.getMoreResidues(resi, chainid, -1, 'not coil');
                        addResidHash = me.hashUtilsCls.unionHash(addResidHash, tmpHash);
                    }
                    else {
                        tmpHash = this.getMoreResidues(resi, chainid, 1, 'ssbegin');
                        addResidHash = me.hashUtilsCls.unionHash(addResidHash, tmpHash);
                        tmpHash = this.getMoreResidues(resi, chainid, -1, 'ssend');
                        addResidHash = me.hashUtilsCls.unionHash(addResidHash, tmpHash);
                    }
                }

                ic.clashedResidHash = me.hashUtilsCls.unionHash(ic.clashedResidHash, addResidHash);
            }
        }

        showHideClashedResidues() { let ic = this.icn3d, me = ic.icn3dui;
            // show or hide clashed residues
            if(ic.clashedResidHash && Object.keys(ic.clashedResidHash).length > 0) {
                let tmpHash = {};
                for(let resid in ic.clashedResidHash) {
                    tmpHash = me.hashUtilsCls.unionHash(tmpHash, ic.residues[resid]);
                }

                if(ic.bHideClashed) {
                    ic.hAtoms = me.hashUtilsCls.exclHash(ic.hAtoms, tmpHash);
                }
                else {
                    ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, tmpHash);
                }
            
                // if(ic.bHideClashed) ic.definedSetsCls.setMode('selection');
                ic.dAtoms = me.hashUtilsCls.cloneHash(ic.hAtoms);
            }
        }

        getMoreResidues(resi, chainid, direction, condition) { let ic = this.icn3d; ic.icn3dui;
            let addResidHash = {};
            for(let i = 1; i < 100; ++i) {
                let resid2 = chainid + '_' + (resi + direction * i).toString();
                let atom2 = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid2]);
                if(atom2) {
                    let bBreak = false;
                    if(condition == 'not coil') {
                        bBreak = (atom2.ss != 'coil');
                    }
                    else if(condition == 'ssbegin') {
                        bBreak = atom2.ssbegin;
                    }
                    else if(condition == 'ssend') {
                        bBreak = atom2.ssend;
                    }

                    if(bBreak) {
                        break;
                    }
                    else {
                        addResidHash[resid2] = 1;
                    }
                }
            }

            return addResidHash;
        }

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class AnnoSnpClinVar {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        async showSnp(chnid, chnidBase) { let ic = this.icn3d; ic.icn3dui;
            await this.showSnpClinvar(chnid, chnidBase, true);
        }
        async showClinvar(chnid, chnidBase) { let ic = this.icn3d; ic.icn3dui;
            await this.showSnpClinvar(chnid, chnidBase, false);
        }

        //Show the annotations of SNPs and ClinVar.
        async showSnpClinvar(chnid, chnidBase, bSnpOnly) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            // get gi from acc
            //var url2 = "https://www.ncbi.nlm.nih.gov/Structure/icn3d/chainid2repgi.txt";
            let url2 = me.htmlCls.baseUrl + "vastdyn/vastdyn.cgi?chainid=" + chnidBase;
            try {
                let data2 = await me.getAjaxPromise(url2, 'jsonp');

                //ic.chainid2repgi = JSON.parse(data2);
                //var gi = ic.chainid2repgi[chnidBase];
                let snpgi = data2.snpgi;
                let gi = data2.gi;
                if(bSnpOnly) {
                    await thisClass.showSnpPart2(chnid, chnidBase, snpgi);
                }
                else {
                    let specialGiArray = [6137708,1942289,224510717,2624886,253723219,2554905,75765331,3660278,312207882,319443632,342350956,1827805,109157826,1065265,40889086,6730307,163931185,494469,163931091,60594093,55669745,18655489,17942684,6980537,166235465,6435586,4139398,4389047,364506122,78101667,262118402,20664221,2624640,158430173,494395,28948777,34810587,13399647,3660342,261278854,342350965,384482350,378792570,15988303,213424334,4558333,2098365,10835631,3318817,374074330,332639529,122919696,4389286,319443573,2781341,67464020,194709238,210061039,364506106,28949044,40889076,161172338,17943181,4557976,62738484,365813173,6137343,350610552,17942703,576308,223674070,15826518,1310997,93279697,4139395,255311799,157837067,361132363,357380836,146387678,383280379,1127268,299856826,13786789,1311054,46015217,3402130,381353319,30750059,218766885,340707375,27065817,355333104,2624634,62738384,241913553,304446010];
                    let giUsed = snpgi;
                    if(specialGiArray.includes(gi)) giUsed = gi;
                    await thisClass.showClinvarPart2(chnid, chnidBase, giUsed);
                }
            }
            catch(err) {
                if(bSnpOnly) {
                    thisClass.processNoSnp(chnid);
                }
                else {             
                    thisClass.processNoClinvar(chnid);
                }
                return;
            }
        }

        navClinVar(chnid) { let ic = this.icn3d; ic.icn3dui;
            let thisClass = this;
            ic.currClin[chnid] = - 1;
            //me.myEventCls.onIds("#" + ic.pre + chnid + "_prevclin", "click", function(e) { let ic = thisClass.icn3d;
            $(document).on("click", "#" + ic.pre + chnid + "_prevclin", function(e) { let ic = thisClass.icn3d;
              e.stopImmediatePropagation();
              //e.preventDefault();
              let maxLen =(ic.resi2disease_nonempty[chnid] !== undefined) ? Object.keys(ic.resi2disease_nonempty[chnid]).length : 0;
              --ic.currClin[chnid];
              if(ic.currClin[chnid] < 0) ic.currClin[chnid] = maxLen - 1; // 0;
              thisClass.showClinVarLabelOn3D(chnid);
            });
            //me.myEventCls.onIds("#" + ic.pre + chnid + "_nextclin", "click", function(e) { let ic = thisClass.icn3d;
            $(document).on("click", "#" + ic.pre + chnid + "_nextclin", function(e) { let ic = thisClass.icn3d;
              e.stopImmediatePropagation();
              //e.preventDefault();
              let maxLen =(ic.resi2disease_nonempty[chnid] !== undefined) ? Object.keys(ic.resi2disease_nonempty[chnid]).length : 0;
              ++ic.currClin[chnid];

              if(ic.currClin[chnid] > maxLen - 1) ic.currClin[chnid] = 0; // ic.resi2disease_nonempty[chnid].length - 1;
              thisClass.showClinVarLabelOn3D(chnid);
            });
        }
        showClinVarLabelOn3D(chnid) { let ic = this.icn3d, me = ic.icn3dui;
              let resiArray = Object.keys(ic.resi2disease_nonempty[chnid]);

              let chainid, residueid;
              chainid = chnid;
              residueid = chainid + '_' + (parseInt(resiArray[ic.currClin[chnid]]) + ic.baseResi[chnid]).toString();
     
              let label = '';
              let diseaseArray = ic.resi2disease_nonempty[chnid][resiArray[ic.currClin[chnid]]];
              for(let k = 0, kl = diseaseArray.length; k < kl; ++k) {
                  if(diseaseArray[k] != '' && diseaseArray[k] != 'not specified' && diseaseArray[k] != 'not provided') {
                    label = diseaseArray[k];
                    break;
                  }
              }
              if(label == '') label = (diseaseArray.length > 0) ? diseaseArray[0] : "N/A";

              let position = ic.applyCenterCls.centerAtoms(me.hashUtilsCls.hash2Atoms(ic.residues[residueid], ic.atoms));
              //position.center.add(new THREE.Vector3(3.0, 3.0, 3.0)); // shift a little bit
              let maxlen = 30;
              if(label.length > maxlen) label = label.substr(0, maxlen) + '...';
              ic.selectionCls.removeSelection();
              if(ic.labels == undefined) ic.labels = {};
              ic.labels['clinvar'] = [];
              //var size = Math.round(ic.LABELSIZE * 10 / label.length);
              let size = ic.LABELSIZE;
              let color = (ic.opts.background != 'black') ? ic.colorWhitebkgd : ic.colorBlackbkgd; //"#FFFF00";
              ic.analysisCls.addLabel(label, position.center.x + 1, position.center.y + 1, position.center.z + 1, size, color, undefined, 'clinvar');
              ic.hAtoms = {};
              for(let j in ic.residues[residueid]) {
                  ic.hAtoms[j] = 1;
              }
              //ic.residueLabelsCls.addResidueLabels(ic.hAtoms);
              $("#clinvar_" + ic.pre + residueid).addClass('icn3d-highlightSeq');
              if($("#" + ic.pre + "modeswitch")[0] !== undefined && !$("#" + ic.pre + "modeswitch")[0].checked) {
                  ic.definedSetsCls.setMode('selection');
              }
              ic.drawCls.draw();
        }

       //getSnpLine(2, 2, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 0, chnid, false, bClinvar, undefined, bSnpOnly);
     
        getSnpLine(line, totalLineNum, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, bStartEndRes, chnid, bOverview, bClinvar, bTitleOnly, bSnpOnly) { let ic = this.icn3d, me = ic.icn3dui;
            let html = '';
            let altName = bClinvar ? 'clinvar' : 'snp';
            // determine whether the SNPis from virus directly
            let bVirus = false;

            for(let resi in resi2rsnum) {
                for(let i = 0, il = resi2rsnum[resi].length; i < il; ++i) {
                    if(resi2rsnum[resi][i] == 0) {
                        bVirus = true;
                        break;
                    }
                }
                if(bVirus) break;
            }
               
            if(bStartEndRes) {
                let title1 = 'ClinVar', title2 = 'SNP', warning = "", warning2 = "";

                if(!bVirus && ic.organism !== undefined && ic.organism.toLowerCase() !== 'human' && ic.organism.toLowerCase() !== 'homo sapiens') {
                    warning = " <span style='color:#FFA500'>(from human)</span>";
                    warning2 = " <span style='color:#FFA500'>(based on human sequences and mapped to this structure by sequence similarity)</span>";
                }
                if(bClinvar) {
                    html += '<div class="icn3d-seqTitle icn3d-link icn3d-blue icn3d-clinvar-path" clinvar="clinvar" posarray="' + posClinArray + '" shorttitle="' + title1 + '" setname="' + chnid + '_' + title1 + '" anno="sequence" chain="' + chnid + '" title="' + title1 + warning2 + '">' + title1 + warning + '</div>';
                }
                else {
                    html += '<div class="icn3d-seqTitle icn3d-link icn3d-blue" clinvar="clinvar" posarray="' + posarray + '" shorttitle="' + title2 + '" setname="' + chnid + '_' + title2 + '" anno="sequence" chain="' + chnid + '" title="' + title2 + warning2 + '">' + title2 + warning + '</div>';
                }
            }
            else if(line == 2 && bClinvar) {
                let buttonStyle = me.utilsCls.isMobile() ? 'none' : 'button';
                html += '<div id="' + ic.pre + chnid + '_prevclin" style="display:inline-block; font-size:11px; font-weight:bold; width:60px!important;"><button class="link" style="-webkit-appearance:' + buttonStyle + '; height:18px; width:55px;"><span style="white-space:nowrap; margin-left:-40px;" title="Show the previous ClinVar on structure">&lt; ClinVar</span></button></div>';
                html += '<div id="' + ic.pre + chnid + '_nextclin" style="display:inline-block; font-size:11px; font-weight:bold; width:60px!important;"><button class="link" style="-webkit-appearance:' + buttonStyle + '; height:18px; width:55px;"><span style="white-space:nowrap; margin-left:-40px;" title="Show the next ClinVar on structure">ClinVar &gt;</span></button></div>';
            }
            else {
                html += '<div class="icn3d-seqTitle"></div>';
            }
            
            let pre = altName;
            let snpCnt = 0, clinvarCnt = 0;
            let snpTypeHash = {}, currSnpTypeHash = {};
            let residHash = ic.firstAtomObjCls.getResiduesFromAtoms(ic.chains[chnid]);
            // for(let i = 1, il = ic.giSeq[chnid].length; i <= il; ++i) {
            for(let resid in residHash) {
                let i = resid.split('_')[2];
                
                if(resi2index[i] !== undefined) {            
                    ++snpCnt;
                    let allDiseaseTitle = '';
                    for(let j = 0, jl = resi2snp[i].length; j < jl && !bSnpOnly; ++j) {
                        let diseaseArray = resi2disease[i][j].split('; ');
                        let sigArray = resi2sig[i][j].split('; ');
                        let diseaseTitle = '';
                        for(let k = 0, kl = diseaseArray.length; k < kl; ++k) {   
                            // relax the restriction to show all clinvar    
                            //if(diseaseArray[k] != '' && diseaseArray[k] != 'not specified' && diseaseArray[k] != 'not provided') {
                                diseaseTitle += diseaseArray[k];
                                if(sigArray[k] != '') {
                                    diseaseTitle += '(' + sigArray[k] + ')';
                                }
                                diseaseTitle += '; ';
                            //}
                        }
                        
                        if(diseaseTitle != '') {
                            snpTypeHash[i] = 'icn3d-clinvar';
                            if(j == line - 2) { // just check the current line, "line = 2" means the first SNP
                                currSnpTypeHash[i] = 'icn3d-clinvar';
                                if(diseaseTitle.indexOf('Pathogenic') != -1) {
                                    currSnpTypeHash[i] = 'icn3d-clinvar-path';
                                }
                            }
                        }
                        
                        allDiseaseTitle += diseaseTitle + ' | ';
                    }
                    if(allDiseaseTitle.indexOf('Pathogenic') != -1) {
                        snpTypeHash[i] = 'icn3d-clinvar-path';
                    }
                   
                    if(snpTypeHash[i] == 'icn3d-clinvar' || snpTypeHash[i] == 'icn3d-clinvar-path') {
                        ++clinvarCnt;
                    }
                }
            }
            
            if(snpCnt == 0 && !bClinvar) {
                $("#" + ic.pre + 'dt_clinvar_' + chnid).html('');
                $("#" + ic.pre + 'ov_clinvar_' + chnid).html('');
                $("#" + ic.pre + 'tt_clinvar_' + chnid).html('');
                $("#" + ic.pre + 'dt_snp_' + chnid).html('');
                $("#" + ic.pre + 'ov_snp_' + chnid).html('');
                $("#" + ic.pre + 'tt_snp_' + chnid).html('');
                return '';
            }
                
            if(clinvarCnt == 0 && bClinvar) {
                $("#" + ic.pre + 'dt_clinvar_' + chnid).html('');
                $("#" + ic.pre + 'ov_clinvar_' + chnid).html('');
                $("#" + ic.pre + 'tt_clinvar_' + chnid).html('');
                return '';
            }
            let cnt = bClinvar ? clinvarCnt : snpCnt;
            if(line == 1) {
                html += '<span class="icn3d-residueNum" title="residue count">' + cnt + ' Res</span>';
            }
            else {
                html += '<span class="icn3d-residueNum"></span>';
            }
            if(bTitleOnly) {
                return html + '<br>';
            }
            html += '<span class="icn3d-seqLine">';
            
            let diseaseStr = '';
            let prevEmptyWidth = 0;
            let prevLineWidth = 0;
            let widthPerRes = 1;

            if(bOverview) {
                if(ic.seqStartLen && ic.seqStartLen[chnid]) html += ic.showSeqCls.insertMulGapOverview(chnid, ic.seqStartLen[chnid]);
            }
            else {
                if(ic.seqStartLen && ic.seqStartLen[chnid]) html += ic.showSeqCls.insertMulGap(ic.seqStartLen[chnid], '-');
            }

            for(let index = 1, indexl = ic.giSeq[chnid].length; index <= indexl; ++index) {
                let pos = ic.ParserUtilsCls.getResi(chnid, index - 1);
                let i = pos;

                if(bOverview) {
                    if(resi2index[i] !== undefined) {
                        
                        // get the mouse over text
                        let cFull = ic.giSeq[chnid][index-1];
                        let c = cFull;
                        if(cFull.length > 1) {
                            c = cFull[0] + '..';
                        }
                        // let pos =(i >= ic.matchedPos[chnid] && i-1 - ic.matchedPos[chnid] < ic.chainsSeq[chnid].length) ? ic.chainsSeq[chnid][i-1 - ic.matchedPos[chnid]].resi : ic.baseResi[chnid] + 1 + i-1;

                        let snpTitle = pos + c + '>';
                        for(let j = 0, jl = resi2snp[i].length; j < jl; ++j) {
                            snpTitle += resi2snp[i][j];
                            if(!bSnpOnly) {
                                let diseaseArray = resi2disease[i][j].split('; ');
                                let sigArray = resi2sig[i][j].split('; ');
                                let diseaseTitle = '';
                                for(let k = 0, kl = diseaseArray.length; k < kl; ++k) {
                                    // relax the restriction to show all clinvar
                                    //if(diseaseArray[k] != '' && diseaseArray[k] != 'not specified' && diseaseArray[k] != 'not provided') {
                                        diseaseTitle += diseaseArray[k];
                                        if(sigArray[k] != '') {
                                            diseaseTitle += '(' + sigArray[k] + ')';
                                        }
                                        diseaseTitle += '; ';
                                    //}
                                }
                            }
                        }
                        html += ic.showSeqCls.insertGapOverview(chnid, index-1);
                        let emptyWidth = Math.round(ic.seqAnnWidth *(index-1) /(ic.maxAnnoLength + ic.nTotalGap) - prevEmptyWidth - prevLineWidth);
                        //let emptyWidth =(me.cfg.blast_rep_id == chnid) ? Math.round(ic.seqAnnWidth *(i-1) /(ic.maxAnnoLength + ic.nTotalGap) - prevEmptyWidth - prevLineWidth) : Math.round(ic.seqAnnWidth *(i-1) / ic.maxAnnoLength - prevEmptyWidth - prevLineWidth);
                        //if(emptyWidth < 0) emptyWidth = 0;
                        if(bClinvar) {
                            // if(snpTypeHash[i] == 'icn3d-clinvar' || snpTypeHash[i] == 'icn3d-clinvar-path') {
                                if(emptyWidth >= 0) {
                                    html += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';
                                    html += '<div style="display:inline-block; background-color:#000; width:' + widthPerRes + 'px;" title="' + snpTitle + '">&nbsp;</div>';
                                    prevEmptyWidth += emptyWidth;
                                    prevLineWidth += widthPerRes;
                                }
                            // }
                        }
                        else {
                            if(emptyWidth > 0) {
                                html += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';
                                html += '<div style="display:inline-block; background-color:#000; width:' + widthPerRes + 'px;" title="' + snpTitle + '">&nbsp;</div>';
                                prevEmptyWidth += emptyWidth;
                                prevLineWidth += widthPerRes;
                            }
                        }
                    }
                }
                else { // detailed view
                  html += ic.showSeqCls.insertGap(chnid, index-1, '-');

                  if(resi2index[i] !== undefined) {
                      if(!bClinvar && line == 1) {
                          html += '<span>&dArr;</span>'; // or down triangle &#9660;
                      }
                      else {
                        let cFull = ic.giSeq[chnid][index-1];
                        let c = cFull;
                        if(cFull.length > 1) {
                          c = cFull[0] + '..';
                        }
                        // let pos =(i >= ic.matchedPos[chnid] && i-1 - ic.matchedPos[chnid] < ic.chainsSeq[chnid].length) ? ic.chainsSeq[chnid][i-1 - ic.matchedPos[chnid]].resi : ic.baseResi[chnid] + 1 + i-1;
                        // let pos = ic.ParserUtilsCls.getResi(chnid, index - 1);
                        let snpStr = "", snpTitle = "<div class='snptip'>";
                        //var snpType = '';
                        let jl = resi2snp[i].length;
                        let start = 0, end = 0;
                        let shownResCnt;
                        if(line == 2) {
                            start = 0;
                            //end = 1;
                            end = jl;
                        }
                        //else if(line == 3) {
                        //    start = 1;
                        //    end = jl;
                        //}
                        if(!bClinvar) {
                            //shownResCnt = 2;
                            shownResCnt = 1;
                            for(let j = start; j < jl && j < end; ++j) {
                                let snpTmpStr = chnid + "_" + pos + "_" + resi2snp[i][j];
                                let buttonStyle = me.utilsCls.isMobile() ? 'none' : 'button';

                                let bCoord = true;
                                if( !ic.residues.hasOwnProperty(chnid + '_' + pos) ) {
                                    bCoord = false;
                                }

                                if(j < shownResCnt) snpStr += resi2snp[i][j];
                                snpTitle += pos + c + '>' + resi2snp[i][j];

                                if(!bSnpOnly) {
                                    // disease and significance
                                    let diseaseArray = resi2disease[i][j].split('; ');
                                    let sigArray = resi2sig[i][j].split('; ');
                                    let diseaseTitle = '';
                                    let index = 0;
                                    for(let k = 0, kl = diseaseArray.length; k < kl; ++k) {
                                        // relax the restriction to show all clinvar
                                        //if(diseaseArray[k] != '' && diseaseArray[k] != 'not specified' && diseaseArray[k] != 'not provided') {
                                            if(index > 0) {
                                                diseaseTitle += '; ';
                                            }
                                            else {
                                                if( j === 0 || j === 1) diseaseStr = 'disease="' + diseaseArray[k] + '"';
                                            }
                                            diseaseTitle += diseaseArray[k];
                                            if(sigArray[k] != '') {
                                                diseaseTitle += '(' + sigArray[k] + ')';
                                            }
                                            ++index;
                                        //}
                                    }

                                    //resi2rsnum, resi2clinAllele,
                                    if(diseaseTitle != '') {
                                        //snpType = 'icn3d-clinvar';
                                        snpTitle += ': ' + diseaseTitle;

                                        if(bCoord && !me.cfg.hidelicense) {
                                            snpTitle += '<br>' + ic.showAnnoCls.addSnpButton(snpTmpStr, 'snpin3d', '3D with scap', 'SNP in 3D with scap', 70, buttonStyle) + '&nbsp;&nbsp;';
                                            snpTitle += ic.showAnnoCls.addSnpButton(snpTmpStr, 'snpinter', 'Interactions', 'SNP Interactions in 3D', 70, buttonStyle) + '&nbsp;&nbsp;';
                                            snpTitle += ic.showAnnoCls.addSnpButton(snpTmpStr, 'snppdb', 'PDB', 'Download SNP PDB', 35, buttonStyle);
                                        }

                                        //snpTitle += "<br>Links: <span class='" + ic.pre + "snpin3d icn3d-snplink' snp='" + chnid + "_" + pos + "_" + resi2snp[i][j] + "'>SNP in 3D with scap</span>, <span class='" + ic.pre + "snpinter icn3d-snplink' snp='" + chnid + "_" + pos + "_" + resi2snp[i][j] + "'>SNP Interactions in 3D</span>, <span class='" + ic.pre + "snppdb icn3d-snplink' snp='" + chnid + "_" + pos + "_" + resi2snp[i][j] + "'>SNP PDB</span>, <a href='https://www.ncbi.nlm.nih.gov/clinvar/?term=" + resi2clinAllele[i][j] + "[AlleleID]' target='_blank'>ClinVar</a>, <a href='https://www.ncbi.nlm.nih.gov/snp/?term=" + resi2rsnum[i][j] + "' target='_blank'>dbSNP(rs" + resi2rsnum[i][j] + ")</a>";
                                        snpTitle += "<br>Links: <a href='https://www.ncbi.nlm.nih.gov/clinvar/?term=" + resi2clinAllele[i][j] + "[AlleleID]' style='color:blue' target='_blank'>ClinVar</a>, <a href='https://www.ncbi.nlm.nih.gov/snp/?term=" + resi2rsnum[i][j] + "' style='color:blue' target='_blank'>dbSNP(rs" + resi2rsnum[i][j] + ")</a>";
                                    }
                                    else {
                                        if(bCoord && !me.cfg.hidelicense) {
                                            snpTitle += '<br>' + ic.showAnnoCls.addSnpButton(snpTmpStr, 'snpin3d', '3D with scap', 'SNP in 3D with scap', 70, buttonStyle) + '&nbsp;&nbsp;';
                                            snpTitle += ic.showAnnoCls.addSnpButton(snpTmpStr, 'snpinter', 'Interactions', 'SNP Interactions in 3D', 70, buttonStyle) + '&nbsp;&nbsp;';
                                            snpTitle += ic.showAnnoCls.addSnpButton(snpTmpStr, 'snppdb', 'PDB', 'Download SNP PDB', 35, buttonStyle);
                                        }

                                        //snpTitle += "<br>Links: <span class='" + ic.pre + "snpin3d icn3d-snplink' snp='" + chnid + "_" + pos + "_" + resi2snp[i][j] + "'>SNP in 3D with scap</span>, <span class='" + ic.pre + "snpinter icn3d-snplink' snp='" + chnid + "_" + pos + "_" + resi2snp[i][j] + "'>SNP Interactions in 3D</span>, <span class='" + ic.pre + "snppdb icn3d-snplink' snp='" + chnid + "_" + pos + "_" + resi2snp[i][j] + "'>SNP PDB</span>, <a href='https://www.ncbi.nlm.nih.gov/snp/?term=" + resi2rsnum[i][j] + "' target='_blank'>dbSNP(rs" + resi2rsnum[i][j] + ")</a>"
                                        snpTitle += "<br>Link: <a href='https://www.ncbi.nlm.nih.gov/snp/?term=" + resi2rsnum[i][j] + "' target='_blank'>dbSNP(rs" + resi2rsnum[i][j] + ")</a>";
                                    }
                                    if(j < jl - 1) {
                                        //if(j < 1) snpStr += ';';
                                        snpTitle += '<br><br>';
                                    }
                                }
                                else { //if(bSnpOnly) {
                                    if(bCoord && !me.cfg.hidelicense) {
                                        snpTitle += '<br>' + ic.showAnnoCls.addSnpButton(snpTmpStr, 'snpin3d', '3D with scap', 'SNP in 3D with scap', 70, buttonStyle) + '&nbsp;&nbsp;';
                                        snpTitle += ic.showAnnoCls.addSnpButton(snpTmpStr, 'snpinter', 'Interactions', 'SNP Interactions in 3D', 70, buttonStyle) + '&nbsp;&nbsp;';
                                        snpTitle += ic.showAnnoCls.addSnpButton(snpTmpStr, 'snppdb', 'PDB', 'Download SNP PDB', 35, buttonStyle);
                                    }

                                    if(resi2rsnum[i][j] != 0) {
                                        //snpTitle += "<br>Links: <span class='" + ic.pre + "snpin3d icn3d-snplink' snp='" + chnid + "_" + pos + "_" + resi2snp[i][j] + "'>SNP in 3D with scap</span>, <span class='" + ic.pre + "snpinter icn3d-snplink' snp='" + chnid + "_" + pos + "_" + resi2snp[i][j] + "'>SNP Interactions in 3D</span>, <span class='" + ic.pre + "snppdb icn3d-snplink' snp='" + chnid + "_" + pos + "_" + resi2snp[i][j] + "'>SNP PDB</span>, <a href='https://www.ncbi.nlm.nih.gov/snp/?term=" + resi2rsnum[i][j] + "' target='_blank'>dbSNP(rs" + resi2rsnum[i][j] + ")</a>";
                                        snpTitle += "<br>Link: <a href='https://www.ncbi.nlm.nih.gov/snp/?term=" + resi2rsnum[i][j] + "' target='_blank'>dbSNP(rs" + resi2rsnum[i][j] + ")</a>";
                                    }

                                    if(j < jl - 1) {
                                        snpTitle += '<br><br>';
                                    }
                                }
                            }
                            //if(jl > shownResCnt && line == 3) snpStr += '..';
                            if(jl > shownResCnt && line == 2) snpStr += '..';
                        }
                        else { // if(bClinvar)       
                            shownResCnt = 1;
                            let diseaseCnt = 0;
                            for(let j = start; j < jl && j < end; ++j) {
                                let snpTmpStr = chnid + "_" + pos + "_" + resi2snp[i][j];
                                let buttonStyle = me.utilsCls.isMobile() ? 'none' : 'button';

                                let bCoord = true;
                                if( !ic.residues.hasOwnProperty(chnid + '_' + pos) ) {
                                    bCoord = false;
                                }

                                // disease and significance
                                let diseaseArray = resi2disease[i][j].split('; ');
                                let sigArray = resi2sig[i][j].split('; ');
                                let diseaseTitle = '';
                                let indexTmp = 0;
                                
                                for(let k = 0, kl = diseaseArray.length; k < kl; ++k) {
                                    // relax the restriction to show all clinvar
                                    //if(diseaseArray[k] != '' && diseaseArray[k] != 'not specified' && diseaseArray[k] != 'not provided') {
                                        if(indexTmp > 0) {
                                            diseaseTitle += '; ';
                                        }
                                        else {
                                            if( j === 0 || j === 1) diseaseStr = 'disease="' + diseaseArray[k] + '"';
                                        }
                                        diseaseTitle += diseaseArray[k];
                                        if(sigArray[k] != '') {
                                            diseaseTitle += '(' + sigArray[k] + ')';
                                        }
                                        ++indexTmp;
                                    //}
                                }

                                // if(diseaseTitle != '') {
                                    if(diseaseCnt < shownResCnt) snpStr += resi2snp[i][j];
                                    snpTitle += pos + c + '>' + resi2snp[i][j];
                                    //snpType = 'icn3d-clinvar';
                                    snpTitle += ': ' + diseaseTitle;

                                    if(bCoord && !me.cfg.hidelicense) {
                                        snpTitle += '<br>' + ic.showAnnoCls.addSnpButton(snpTmpStr, 'snpin3d', '3D with scap', 'SNP in 3D with scap', 70, buttonStyle) + '&nbsp;&nbsp;';
                                        snpTitle += ic.showAnnoCls.addSnpButton(snpTmpStr, 'snpinter', 'Interactions', 'SNP Interactions in 3D', 70, buttonStyle) + '&nbsp;&nbsp;';
                                        snpTitle += ic.showAnnoCls.addSnpButton(snpTmpStr, 'snppdb', 'PDB', 'Download SNP PDB', 35, buttonStyle);
                                    }

                                    //snpTitle += "<br>Links: <span class='" + ic.pre + "snpin3d icn3d-snplink' snp='" + chnid + "_" + pos + "_" + resi2snp[i][j] + "'>SNP in 3D with scap</span>, <span class='" + ic.pre + "snpinter icn3d-snplink' snp='" + chnid + "_" + pos + "_" + resi2snp[i][j] + "'>SNP Interactions in 3D</span>, <span class='" + ic.pre + "snppdb icn3d-snplink' snp='" + chnid + "_" + pos + "_" + resi2snp[i][j] + "'>SNP PDB</span>, <a href='https://www.ncbi.nlm.nih.gov/clinvar/?term=" + resi2clinAllele[i][j] + "[AlleleID]' target='_blank'>ClinVar</a>, <a href='https://www.ncbi.nlm.nih.gov/snp/?term=" + resi2rsnum[i][j] + "' target='_blank'>dbSNP(rs" + resi2rsnum[i][j] + ")</a>";
                                    snpTitle += "<br>Links: <a href='https://www.ncbi.nlm.nih.gov/clinvar/?term=" + resi2clinAllele[i][j] + "[AlleleID]' style='color:blue' target='_blank'>ClinVar</a>";
                                    if(resi2rsnum[i][j] != 0) {
                                        snpTitle += ", <a href='https://www.ncbi.nlm.nih.gov/snp/?term=" + resi2rsnum[i][j] + "' style='color:blue' target='_blank'>dbSNP(rs" + resi2rsnum[i][j] + ")</a>";
                                    }
                                    if(j < jl - 1) {
                                        snpTitle += '<br><br>';
                                    }
                                    ++diseaseCnt;
                                // } // if(diseaseTitle != '') {
                            } // for(let j = start; j < jl && j < end; ++j) {
                            //if(diseaseCnt > shownResCnt && line == 3) snpStr += '..';
                            if(diseaseCnt > shownResCnt && line == 2) snpStr += '..';
                        } // else { // if(bClinvar)
                        snpTitle += '</div>';
                        if(bClinvar) {                
                            // if(snpTypeHash[i] == 'icn3d-clinvar' || snpTypeHash[i] == 'icn3d-clinvar-path') {
                                if(line == 1) {
                                    html += '<span>&dArr;</span>'; // or down triangle &#9660;
                                }
                                else {
                                    if(snpStr == '' || snpStr == ' ') {
                                        html += '<span>-</span>';
                                    }
                                    else {
                                        // html += '<span id="' + pre + '_' + ic.pre + chnid + '_' + pos + '" label title="' + snpTitle + '" ' + diseaseStr + ' class="icn3d-tooltip icn3d-residue ' + currSnpTypeHash[i] + '">' + snpStr + '</span>';
                                        html += '<span id="' + pre + '_' + ic.pre + chnid + '_' + pos + '" label title="' + snpTitle + '" ' + diseaseStr + ' class="icn3d-tooltip icn3d-residue ' + snpTypeHash[i] + '">' + snpStr + '</span>';
                                    }
                                }
                            // }
                            // else {
                            //     html += '<span>-</span>';
                            // }
                        }
                        else {
                            if(snpStr == '' || snpStr == ' ') {
                                html += '<span>-</span>';
                            }
                            else {
                                if(!bSnpOnly) {
                                    // html += '<span id="' + pre + '_' + ic.pre + chnid + '_' + pos + '" label title="' + snpTitle + '" ' + diseaseStr + ' class="icn3d-tooltip icn3d-residue ' + currSnpTypeHash[i] + '">' + snpStr + '</span>';
                                    html += '<span id="' + pre + '_' + ic.pre + chnid + '_' + pos + '" label title="' + snpTitle + '" ' + diseaseStr + ' class="icn3d-tooltip icn3d-residue ' + snpTypeHash[i] + '">' + snpStr + '</span>';
                                }
                                else {
                                    // html += '<span id="' + pre + '_' + ic.pre + chnid + '_' + pos + '" label title="' + snpTitle + '" class="icn3d-tooltip icn3d-residue ' + currSnpTypeHash[i] + '">' + snpStr + '</span>';
                                    html += '<span id="' + pre + '_' + ic.pre + chnid + '_' + pos + '" label title="' + snpTitle + '" class="icn3d-tooltip icn3d-residue ' + snpTypeHash[i] + '">' + snpStr + '</span>';
                                }
                            }
                        }
                      } // if(!bClinvar && line == 1) {
                  }
                  else {
                    html += '<span>-</span>'; //'<span>-</span>';
                  }
                } // if(bOverview) {
            } // for

            if(!bOverview) {
                if(ic.seqStartLen && ic.seqStartLen[chnid]) html += ic.showSeqCls.insertMulGap(ic.seqEndLen[chnid], '-');
            }
            
            //var end = bStartEndRes ? ic.chainsSeq[chnid][ic.giSeq[chnid].length - 1 - ic.matchedPos[chnid] ].resi : '';
            if(line == 1) {
                html += '<span class="icn3d-residueNum" title="residue count">&nbsp;' + cnt + ' Residues</span>';
            }
            else {
                html += '<span class="icn3d-residueNum"></span>';
            }
            html += '</span>';
            html += '<br>';

            return html;
        }
        processSnpClinvar(data, chnid, chnidBase, bSnpOnly, bVirus) { let ic = this.icn3d, me = ic.icn3dui;    
            let html = '<div id="' + ic.pre + chnid + '_snpseq_sequence" class="icn3d-dl_sequence">';
            let html2 = html;
            let html3 = html;
            let htmlClinvar = '<div id="' + ic.pre + chnid + '_clinvarseq_sequence" class="icn3d-dl_sequence">';
            let htmlClinvar2 = htmlClinvar;
            let htmlClinvar3 = htmlClinvar;
            let lineArray =(!bSnpOnly || bVirus) ? data.data : data.split('\n');
            let resi2snp = {};
            let resi2index = {};
            let resi2disease = {};
            if(ic.resi2disease_nonempty[chnid] === undefined) ic.resi2disease_nonempty[chnid] = {};
            let resi2sig = {};
            let resi2rsnum = {};
            let resi2clinAllele = {};
            let posHash = {}, posClinHash = {};
            let prevSnpStr = '';
            if(me.bNode) {
                if(bSnpOnly) {
                    if(!ic.resid2snp) ic.resid2snp = {};
                    if(!ic.resid2snp[chnid]) ic.resid2snp[chnid] = [];
                }
                else {
                    if(!ic.resid2clinvar) ic.resid2clinvar = {};
                    if(!ic.resid2clinvar[chnid]) ic.resid2clinvar[chnid] = [];
                }
            }

            let foundRealSnp = {};
            for(let i = 0, il = lineArray.length; i < il; ++i) {
             //bSnpOnly: false
             //1310770    13    14    14Y>H    368771578    150500    Hereditary cancer-predisposing syndrome; Li-Fraumeni syndrome; not specified; Li-Fraumeni syndrome 1    Likely benign; Uncertain significance; Uncertain significance; Uncertain significance   0 
             //Pdb_gi, Pos from, Pos to, Pos & Amino acid change, rs#, ClinVar Allele ID, Disease name, Clinical significance, [whether data is directly from ClinVar database, 0 or 1]
             //bSnpOnly: true
             //1310770    13    14    14Y>H    1111111 0
             if(lineArray[i] != '') {
              let fieldArray =(!bSnpOnly || bVirus) ? lineArray[i] : lineArray[i].split('\t');
              let snpStr = fieldArray[3];
              let rsnum = fieldArray[4];
              let bFromClinVarDb = false;
              
              if(bSnpOnly) {
                if(fieldArray.length > 5) bFromClinVarDb =  parseInt(fieldArray[5]);
              }
              else {
                if(fieldArray.length > 8) bFromClinVarDb =  parseInt(fieldArray[8]);
              }
              if(snpStr == prevSnpStr) continue;
              prevSnpStr = snpStr;

              let posSymbol = snpStr.indexOf('>');
            //   let resiStr = snpStr.substr(0, snpStr.length - 3);
              let resiStr = snpStr.substr(0, posSymbol - 1);
              let resi = Math.round(resiStr);

              // if the data is From ClinVar Db directly, the residue numbers are PDB residue numbers. Otherwise, the residue numbers are NCBI residue numbers.
              let realResi = (bFromClinVarDb) ? resi : ic.ParserUtilsCls.getResi(chnid, resi - 1);

              let realSnp = realResi + snpStr.substr(posSymbol - 1);
              if(foundRealSnp.hasOwnProperty(realSnp)) {
                continue;
              }
              else {
                foundRealSnp[realSnp] = 1;
              }

              let snpResn = snpStr.substr(posSymbol - 1, 1);
              let atom = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[chnid + '_' + realResi]);
              let oneLetterRes = (atom) ? me.utilsCls.residueName2Abbr(atom.resn.substr(0, 3)) : '';
              if(!bFromClinVarDb) {
                oneLetterRes = ic.chainsSeq[chnid][resi - 1].name;
              }

              if(snpResn != oneLetterRes) {
                // console.error("The snp " + snpStr + " didn't match the residue name " + oneLetterRes);
                continue;
              }

              if(me.bNode) {
                  let obj = {};
                //   obj[chnid + '_' + resi] = snpStr;
                  obj[chnid + '_' + realResi] = realSnp;
                    
                  if(bSnpOnly) {
                    ic.resid2snp[chnid].push(obj);
                  }
                  else {
                    ic.resid2clinvar[chnid].push(obj);
                  }
              }

            //   let currRes = snpStr.substr(snpStr.length - 3, 1);
            //   let snpRes = snpStr.substr(snpStr.indexOf('>') + 1); //snpStr.substr(snpStr.length - 1, 1);
              let snpRes = realSnp.substr(realSnp.indexOf('>') + 1); //realSnp.substr(realSnp.length - 1, 1);
              //var rsnum = bSnpOnly ? '' : fieldArray[4];
              
              let clinAllele = bSnpOnly ? '' : fieldArray[5];
              let disease = bSnpOnly ? '' : fieldArray[6];  // When more than 2+ diseases, they are separated by "; "
                                            // Some are "not specified", "not provided"
              let clinSig = bSnpOnly ? '' : fieldArray[7];     // Clinical significance, When more than 2+ diseases, they are separated by "; "
              // "*" means terminating codon, "-" means deleted codon
              //if(currRes !== '-' && currRes !== '*' && snpRes !== '-' && snpRes !== '*') {
                    
                    // posHash[resi + ic.baseResi[chnid]] = 1;
                    // if(disease != '') posClinHash[resi + ic.baseResi[chnid]] = 1;
                    posHash[realResi] = 1;
                    if(disease != '') posClinHash[realResi] = 1;
                    resi2index[realResi] = i + 1;
                    if(resi2snp[realResi] === undefined) {
                        resi2snp[realResi] = [];
                    }
                    resi2snp[realResi].push(snpRes);
                    if(resi2rsnum[realResi] === undefined) {
                        resi2rsnum[realResi] = [];
                    }
                    resi2rsnum[realResi].push(rsnum);
                    if(resi2clinAllele[realResi] === undefined) {
                        resi2clinAllele[realResi] = [];
                    }
                    resi2clinAllele[realResi].push(clinAllele);
                    if(resi2disease[realResi] === undefined) {
                        resi2disease[realResi] = [];
                    }
                    resi2disease[realResi].push(disease);
                    if(disease != '') {
                        if(ic.resi2disease_nonempty[chnid][realResi] === undefined) {
                            ic.resi2disease_nonempty[chnid][realResi] = [];
                        }
                        ic.resi2disease_nonempty[chnid][realResi].push(disease);
                    }
                    if(resi2sig[realResi] === undefined) {
                        resi2sig[realResi] = [];
                    }
                    resi2sig[realResi].push(clinSig);
              //}
             }
            }

            let posarray = Object.keys(posHash);
            let posClinArray = Object.keys(posClinHash);
            if(bSnpOnly) {
                let bClinvar = false;
                html += this.getSnpLine(1, 2, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 1, chnid, false, bClinvar, undefined, bSnpOnly);
                html += this.getSnpLine(2, 2, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 0, chnid, false, bClinvar, undefined, bSnpOnly);
                //html += this.getSnpLine(3, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 0, chnid, false, bClinvar, undefined, bSnpOnly);
                html3 += this.getSnpLine(1, 2, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 1, chnid, false, bClinvar, true, bSnpOnly);
                html3 += this.getSnpLine(2, 2, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 0, chnid, false, bClinvar, true, bSnpOnly);
                //html3 += this.getSnpLine(3, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 0, chnid, false, bClinvar, true, bSnpOnly);
                html2 += this.getSnpLine(1, 2, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 1, chnid, true, bClinvar, undefined, bSnpOnly);
                html += '</div>';
                html2 += '</div>';
                html3 += '</div>';
                $("#" + ic.pre + 'dt_snp_' + chnid).html(html);
                $("#" + ic.pre + 'ov_snp_' + chnid).html(html2);
                $("#" + ic.pre + 'tt_snp_' + chnid).html(html3);
            }
            else {
            //if(!bSnpOnly && ic.bClinvarCnt) {
                let bClinvar = true;
                htmlClinvar += this.getSnpLine(1, 2, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 1, chnid, false, bClinvar, undefined, bSnpOnly);
                htmlClinvar += this.getSnpLine(2, 2, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 0, chnid, false, bClinvar, undefined, bSnpOnly);
                //htmlClinvar += this.getSnpLine(3, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 0, chnid, false, bClinvar, undefined, bSnpOnly);
                htmlClinvar3 += this.getSnpLine(1, 2, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 1, chnid, false, bClinvar, true, bSnpOnly);
                htmlClinvar3 += this.getSnpLine(2, 2, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 0, chnid, false, bClinvar, true, bSnpOnly);
                //htmlClinvar3 += this.getSnpLine(3, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 0, chnid, false, bClinvar, true, bSnpOnly);
                htmlClinvar2 += this.getSnpLine(1, 2, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 1, chnid, true, bClinvar, undefined, bSnpOnly);
                htmlClinvar += '</div>';
                htmlClinvar2 += '</div>';
                htmlClinvar3 += '</div>';    
                              
                $("#" + ic.pre + 'dt_clinvar_' + chnid).html(htmlClinvar);
                $("#" + ic.pre + 'ov_clinvar_' + chnid).html(htmlClinvar2);
                $("#" + ic.pre + 'tt_clinvar_' + chnid).html(htmlClinvar3);
                this.navClinVar(chnid, chnidBase);
            }
                       
            // add here after the ajax call
            ic.showAnnoCls.enableHlSeq();
            if(bSnpOnly) {
                ic.bAjaxSnp = true;
                /// if(ic.deferredSnp !== undefined) ic.deferredSnp.resolve();
            }
            else {
                ic.bAjaxClinvar = true;
                /// if(ic.deferredClinvar !== undefined) ic.deferredClinvar.resolve();
            }
        }
        async showClinvarPart2(chnid, chnidBase, gi) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            if(!ic.chainid2uniport) await this.getUniprotForAllStructures();

            //var url = "https://www.ncbi.nlm.nih.gov/projects/SNP/beVarSearch_mt.cgi?appname=iCn3D&format=bed&report=pdb2bed&acc=" + chnidBase;
            //var url = "https://www.ncbi.nlm.nih.gov/Structure/icn3d/clinvar.txt";
            let url = me.htmlCls.baseUrl + "vastdyn/vastdyn.cgi?chainid_clinvar=" + chnidBase + "&uniprot=" + ic.chainid2uniport[chnidBase];
            if(ic.chainsGene[chnid] && ic.chainsGene[chnid].geneSymbol) {
                url += "&gene=" + ic.chainsGene[chnid].geneSymbol;
            }

            try {
                let indata = await me.getAjaxPromise(url, 'jsonp');

                if(indata && indata.data && indata.data.length > 0) {
                    let bSnpOnly = false;
                    let data = indata;         
                    
                    thisClass.processSnpClinvar(data, chnid, chnidBase, bSnpOnly);
                }
                else {               
                    thisClass.processNoClinvar(chnid);
                }
            }
            catch(err) {            
                thisClass.processNoClinvar(chnid);
                return;
            }
        }

        async getUniprotForAllStructures() { let ic = this.icn3d, me = ic.icn3dui;
            ic.chainid2uniport = {};

            // get UniProt ID ffrom chainid
            for(let structure in ic.structures) {
                if(structure.length > 5) {
                    let chainidArray = ic.structures[structure];
                    for(let i = 0, il = chainidArray.length; i < il; ++i) {
                        ic.chainid2uniport[chainidArray[i]] = structure;
                    }
                }
                else {
                    let structLower = structure.toLowerCase();
                    let url = "https://www.ebi.ac.uk/pdbe/api/mappings/uniprot/" + structLower;
                    let dataJson = await me.getAjaxPromise(url, 'json');
                    let data= dataJson[structLower]['UniProt']; 
                    for(let uniprot in data) {
                        let chainDataArray = data[uniprot].mappings;
                        for(let i = 0, il = chainDataArray.length; i < il; ++i) {
                            let chain = chainDataArray[i].chain_id;
                            ic.chainid2uniport[structure + '_' + chain] = uniprot;
                        }
                    }
                }
            }
        }

        async showSnpPart2(chnid, chnidBase, gi) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;
            if(!ic.chainid2uniport) await this.getUniprotForAllStructures();

            if(gi !== undefined) {          
                let url4 = me.htmlCls.baseUrl + "vastdyn/vastdyn.cgi?chainid_snp=" + chnidBase + "&uniprot=" + ic.chainid2uniport[chnidBase];
                if(ic.chainsGene[chnid] && ic.chainsGene[chnid].geneSymbol) {
                    url4 += "&gene=" + ic.chainsGene[chnid].geneSymbol;
                }

                try {
                    let data4 = await me.getAjaxPromise(url4, 'jsonp');

                    if(data4 && data4.data && data4.data.length > 0) {
                        let bSnpOnly = true;
                        let bVirus = true;
                        
                        thisClass.processSnpClinvar(data4, chnid, chnidBase, bSnpOnly, bVirus);
                    } //if(data4 != "") {
                    else {
                        thisClass.processNoSnp(chnid);
                    }
                    ///// if(ic.deferredSnp !== undefined) ic.deferredSnp.resolve();
                }
                catch(err) {
                    thisClass.processNoSnp(chnid);
                    ///// if(ic.deferredSnp !== undefined) ic.deferredSnp.resolve();
                    return;
                }
            }
            else {
                this.processNoSnp(chnid);
                console.log( "No gi was found for the chain " + chnidBase + "..." );
            }
        }
        processNoClinvar(chnid) { let ic = this.icn3d; ic.icn3dui;
                console.log( "No ClinVar data were found for the protein " + chnid + "..." );
                $("#" + ic.pre + 'dt_clinvar_' + chnid).html('');
                $("#" + ic.pre + 'ov_clinvar_' + chnid).html('');
                ic.showAnnoCls.enableHlSeq();
                ic.bAjaxClinvar = true;
                /// if(ic.deferredClinvar !== undefined) ic.deferredClinvar.resolve();
        }
        processNoSnp(chnid) { let ic = this.icn3d; ic.icn3dui;
                console.log( "No SNP data were found for the protein " + chnid + "..." );
                $("#" + ic.pre + 'dt_snp_' + chnid).html('');
                $("#" + ic.pre + 'ov_snp_' + chnid).html('');
                ic.showAnnoCls.enableHlSeq();
                ic.bAjaxSnp = true;
                /// if(ic.deferredSnp !== undefined) ic.deferredSnp.resolve();
        }

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class AnnoSsbond {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Show the disulfide bonds and show the side chain in the style of "stick".
        showSsbond(chnid, chnidBase) { let ic = this.icn3d; ic.icn3dui;
            let thisClass = this;
            if(ic.ssbondpnts === undefined) {
                // didn't finish loading atom data yet
                setTimeout(function(){
                  thisClass.showSsbond_base(chnid, chnidBase);
                }, 1000);
            }
            else {
                this.showSsbond_base(chnid, chnidBase);
            }
        }
        showSsbond_base(chnid, chnidBase) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) {
                if(!ic.resid2ssbond) ic.resid2ssbond = {};
                if(!ic.resid2ssbond[chnid]) ic.resid2ssbond[chnid] = [];
            }

            let chainid = chnidBase;
            let resid2resids = {};
            let structure = chainid.substr(0, chainid.indexOf('_'));

            let ssbondArray = ic.ssbondpnts[structure];
            if(ssbondArray === undefined) {
                $("#" + ic.pre + "dt_ssbond_" + chnid).html('');
                $("#" + ic.pre + "ov_ssbond_" + chnid).html('');
                $("#" + ic.pre + "tt_ssbond_" + chnid).html('');
                return;
            }
            for(let i = 0, il = ssbondArray.length; i < il; i = i + 2) {
                let resid1 = ssbondArray[i];
                let resid2 = ssbondArray[i+1];
                let chainid1 = resid1.substr(0, resid1.lastIndexOf('_'));
                let chainid2 = resid2.substr(0, resid2.lastIndexOf('_'));
                if(chainid === chainid1) {
                    if(resid2resids[resid1] === undefined) resid2resids[resid1] = [];
                    resid2resids[resid1].push(resid2);
                }
                if(chainid === chainid2) {
                    if(resid2resids[resid2] === undefined) resid2resids[resid2] = [];
                    resid2resids[resid2].push(resid1);
                }
            }
            let residueArray = Object.keys(resid2resids);
            let title = "Disulfide Bonds";
            ic.annoCddSiteCls.showAnnoType(chnid, chnidBase, 'ssbond', title, residueArray, resid2resids);
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class AnnoTransMem {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        showTransmem(chnid, chnidBase) { let ic = this.icn3d; ic.icn3dui;
            let thisClass = this;
            if(ic.ssbondpnts === undefined) {
                // didn't finish loading atom data yet
                setTimeout(function(){
                  thisClass.showTransmem_base(chnid, chnidBase);
                }, 1000);
            }
            else {
                this.showTransmem_base(chnid, chnidBase);
            }
        }
        showTransmem_base(chnid, chnidBase) { let ic = this.icn3d; ic.icn3dui;
            let residHash = {};
            for(let serial in ic.chains[chnidBase]) {
                let atom = ic.atoms[serial];
                if(atom.coord.z < ic.halfBilayerSize && atom.coord.z > -ic.halfBilayerSize) {
                    let resid = atom.structure + '_' + atom.chain + '_' + atom.resi;
                    residHash[resid] = 1;
                }
            }
            let residueArray = Object.keys(residHash);
            let title = "Transmembrane"; //"Transmembrane domain";
            ic.annoCddSiteCls.showAnnoType(chnid, chnidBase, 'transmem', title, residueArray);
        }

    }

    /*
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     * Modified from Tom Madej's C++ code
    */

    class Domain3d {
        constructor(icn3d) {
    		this.icn3d = icn3d;

    		this.init3ddomain();
    	}

    	init3ddomain() { let ic = this.icn3d; ic.icn3dui;
            //this.dcut = 8; // threshold for C-alpha interactions

    		this.dcut = 8; // threshold for C-alpha interactions

    		// added by Jiyao
    		// Ig domain should not be separated into two parts, set min as 2
    		this.min_contacts = 2; //3;			// minimum number of contacts to be considered as neighbors

    		this.MAX_SSE = 512;

            //let this.ctc_cnt[this.MAX_SSE][this.MAX_SSE];		// contact count matrix
            this.ctc_cnt = [];
            for(let i = 0; i < this.MAX_SSE; ++i) {
                this.ctc_cnt[i] = [];
            }

            //let this.elt_size[this.MAX_SSE];			// element sizes in residues
            this.elt_size = [];

            this.elt_size.length = this.MAX_SSE;

            //let this.group_num[this.MAX_SSE];			// indicates required element groupings
            this.group_num = [];
            this.group_num.length = this.MAX_SSE;

            // this.split_ratio = 0.0;			//let // splitting ratio
            // this.min_size = 0;				// min required size of a domain
            // this.min_sse = 0;				// min number of SSEs required in a domain
            // this.max_csz = 0;				// max size of a cut, i.e. number of points
            // this.mean_cts = 0.0;				// mean number of contacts in a domain
            // this.c_delta = 0;				// cut set parameter
            // this.nc_fact = 0.0;				// size factor for internal contacts

    		this.split_ratio = 0.25;			//let // splitting ratio
            this.min_size = 25;				// min required size of a domain
            this.min_sse = 3;				// min number of SSEs required in a domain
            this.max_csz = 4;				// max size of a cut, i.e. number of points
            this.mean_cts = 0.0;				// mean number of contacts in a domain
            this.c_delta = 3;				// cut set parameter
            this.nc_fact = 0.0;				// size factor for internal contacts

            //let this.elements[2*this.MAX_SSE];			// sets of this.elements to be split
            this.elements = [];
            this.elements.length = 2*this.MAX_SSE;

            //let this.stack[this.MAX_SSE];			// this.stack of sets (subdomains) to split
            this.stack = [];
            this.stack.length = this.MAX_SSE;

            this.top = 0;					// this.top of this.stack
            //let this.curr_prt0[this.MAX_SSE];			// current part 0 this.elements
            this.curr_prt0 = [];
            this.curr_prt0.length = this.MAX_SSE;

            //let this.curr_prt1[this.MAX_SSE];			// current part 1 this.elements
            this.curr_prt1 = [];
            this.curr_prt1.length = this.MAX_SSE;

            this.curr_ne0 = 0;				// no. of this.elements in current part 0
            this.curr_ne1 = 0;				// no. of this.elements in current part 1
            this.curr_ratio = 0.0;			// current splitting ratio
            this.curr_msize = 0;				// min of current part sizes
            //let this.parts[2*this.MAX_SSE];			// final partition into domains
            this.parts = [];
            this.parts.length = 2*this.MAX_SSE;

            this.np = 0;					// next free location in this.parts[]
            this.n_doms = 0;				// number of domains
            //let this.save_ratios[this.MAX_SSE];		// this.saved splitting ratios
            this.save_ratios = [];
            this.save_ratios.length = this.MAX_SSE;

            this.saved = 0;				// number of this.saved ratios
    	}

    	// Partition the set of this.elements on this.top of the this.stack based on the input cut.
    	// If the partition is valid and the ratio is smaller than the current one, then
    	// save it as the best partition so far encountered.  Various criteria are
    	// employed for valid partitions, as described below.
    	//

    	//update_partition(int* cut, let k, let n) { let ic = this.icn3d, me = ic.icn3dui;
    	update_partition(cut, k, n) { let ic = this.icn3d; ic.icn3dui;
    		let i, il, j, t, nc0, nc1, ncx, ne, ne0, ne1, elts = [], prt = []; //int
    		let size0, size1, prt0 = [], prt1 = []; // int
            prt0.length = this.MAX_SSE;
            prt1.length = this.MAX_SSE;
    		let f, r0; //let

    		// this.elements from the this.top of the this.stack 
    		//elts = &this.elements[this.stack[this.top - 1]];
    		
    		for(i = this.stack[this.top - 1], il = this.elements.length; i < il; ++i) {
    			elts.push(this.elements[i]);
    		}

    		// generate the partition based on the cut //
    		// for (i = ne = ne0 = ne1 = 0, prt = prt0, t = -1; i < k; i++) {
    		let bAtZero = true;
    		prt = prt0;
    		for (i = ne = ne0 = ne1 = 0, t = -1; i < k; i++) {
    			// write the this.elements into prt //
    			for (j = t + 1; j <= cut[i]; j++)
    				prt[ne++] = elts[j];

    			t = cut[i];

    			// switch the partition //
    			// if (prt == prt0) {
    			if (bAtZero) {
    				ne0 = ne;
    				prt = prt1;
    				ne = ne1;

    				bAtZero = false;
    			}
    			else {
    				ne1 = ne;
    				prt = prt0;
    				ne = ne0;

    				bAtZero = true;
    			}
    		}

    		// finish with the last part //
    		for (j = t + 1; j < n; j++)
    			prt[ne++] = elts[j];

    		// if (prt == prt0)
    		if (bAtZero)
    			ne0 = ne;
    		else
    			ne1 = ne;

    		// don't split into two teeny this.parts! //
    		if ((ne0 < this.min_sse) && (ne1 < this.min_sse))
    			return cut;

    		// check to see if the partition splits any required groups //
    		for (i = 0; i < ne0; i++) {
    			t = this.group_num[prt0[i]];

    			for (j = 0; j < ne1; j++) {
    				if (t == this.group_num[prt1[j]])
    					return cut;
    			}
    		}

    		// compute the sizes of the this.parts //
    		for (i = size0 = 0; i < ne0; i++)
    			size0 += this.elt_size[prt0[i]];

    		for (i = size1 = 0; i < ne1; i++)
    			size1 += this.elt_size[prt1[i]];

    		// count internal contacts for part 0 //
    		for (i = nc0 = 0; i < ne0; i++) {
    			for (j = i; j < ne0; j++)
    				nc0 += this.ctc_cnt[prt0[i]][prt0[j]];
    		}

    		// count internal contacts for part 1 //
    		for (i = nc1 = 0; i < ne1; i++) {
    			for (j = i; j < ne1; j++)
    				nc1 += this.ctc_cnt[prt1[i]][prt1[j]];
    		}

    		// check globularity condition //
    		if ((1.0 * nc0 / size0 < this.mean_cts) ||
    			(1.0 * nc1 / size1 < this.mean_cts))
    			return cut;

    		// to handle non-globular pieces make sure nc0, nc1, are large enough //
    		nc0 = Math.max(nc0, this.nc_fact*size0);
    		nc1 = Math.max(nc1, this.nc_fact*size1);

    		// count inter-part contacts //
    		for (i = ncx = 0; i < ne0; i++) {
    			t = prt0[i];

    			for (j = 0; j < ne1; j++)
    				ncx += this.ctc_cnt[t][prt1[j]];
    		}

    		// compute the splitting ratio //
    		f = Math.min(nc0, nc1);
    		r0 = 1.0 * ncx / (f + 1.0);

    		if ((r0 >= this.curr_ratio + 0.01) || (r0 > this.split_ratio))
    			return cut;

    		// If the difference in the ratios is insignificant then take the split
    		// that most evenly partitions the domain.

    		if ((r0 > this.curr_ratio - 0.01) && (Math.min(size0, size1) < this.curr_msize))
    				return cut;

    		// if we get to here then keep this split //
    		for (i = 0; i < ne0; i++)
    			this.curr_prt0[i] = prt0[i];

    		for (i = 0; i < ne1; i++)
    			this.curr_prt1[i] = prt1[i];

    		this.curr_ne0 = ne0;
    		this.curr_ne1 = ne1;
    		this.curr_ratio = r0;
    		this.curr_msize = Math.min(size0, size1);

    		return cut;

    	} // end update_partition //



    	// // Run through the possible cuts of size k for a set of this.elements of size n.
    	//  *
    	//  * To avoid small protrusions, no blocks of consecutive this.elements of length <= this.c_delta
    	//  * are allowed.  An example where this is desirable is as follows.  Let's say you
    	//  * have a protein with 2 subdomains, one of them an alpha-beta-alpha sandwich.  It
    	//  * could then happen that one of the helices in the sandwich domain might make more
    	//  * contacts with the other subdomain than with the sandwich.  The correct thing to
    	//  * do is to keep the helix with the rest of the sandwich, and the "this.c_delta rule"
    	//  * enforces this.
    	//  //

    	cut_size(k, n) { let ic = this.icn3d; ic.icn3dui;
    		let i, j, cok, cut0 = []; //int
    		cut0.length = this.MAX_SSE;

    		for (i = 0; i < k; i++)
    			cut0[i] = i;

    		// enumerate cuts of length k //
    		while (1) {
    			// check block sizes in the cut //
    			for (i = cok = 1; i < k; i++) {
    				if (cut0[i] - cut0[i - 1] <= this.c_delta) {
    					cok = 0;
    					break;
    				}
    			}
    			if (cok && (cut0[k - 1] < n - 1))
    				cut0 = this.update_partition(cut0, k, n);

    			// generate the next k-tuple of positions //
    			for (j = k - 1; (j >= 0) && (cut0[j] == n - k + j); j--);

    			if (j < 0) break;

    			cut0[j]++;

    			for (i = j + 1; i < k; i++)
    				cut0[i] = cut0[i - 1] + 1;
    		}

    	} // end cut_size //



    	// // Process the set of this.elements on this.top of the this.stack.  We generate cut sets in
    	//  * a limited size range, generally from 1 to 5.  For each cut the induced
    	//  * partition is considered and its splitting parameters computed.  The cut
    	//  * that yields the smallest splitting ratio is chosen as the correct one, if
    	//  * the ratio is low enough.  The subdomains are then placed on the this.stack for
    	//  * further consideration.
    	//  *
    	//  * Subdomains with < this.min_sse SSEs are not allowed to split further, however,
    	//  * it is possible to trim fewer than this.min_sse SSEs from a larger domain.  E.g.
    	//  * a chain with 7 SSEs can be split into a subdomain with 5 SSEs and another
    	//  * with 2 SSEs, but the one with 2 SSEs cannot be split further.
    	//  *
    	//  * Note that the invariant is, that this.stack[top] always points to the next free
    	//  * location in this.elements[].
    	//  //

    	process_set() { let ic = this.icn3d; ic.icn3dui;
    		let i, il, k, n, t, k0, elts = []; //int

    		// count the this.elements //
    		//elts = &this.elements[this.stack[this.top - 1]];
    		for(i = this.stack[this.top - 1], il = this.elements.length; i < il; ++i) {
    			elts.push(this.elements[i]);
    		}

    		//for (n = 0; *elts > -1; n++, elts++);
    		for (n = 0; n < elts.length && elts[n] > -1; n++);

    		// try various cut sizes //
    		k0 = Math.min(n - 1, this.max_csz);
    		this.curr_ne0 = this.curr_ne1 = 0;
    		this.curr_ratio = 100.0;

    		for (k = 1; k <= k0; k++)
    			this.cut_size(k, n);

    		// pop this.stack //
    		this.top--;

    		if (this.curr_ne0 == 0) {
    			// no split took place, save part //
    			t = this.stack[this.top];

    			//for (elts = &this.elements[t]; *elts > -1; elts++)
    			//	parts[np++] = *elts;

    			for (i = t; i < this.elements.length && this.elements[i] > -1; i++)
    				this.parts[this.np++] = this.elements[i];

    			this.parts[this.np++] = -1;
    			this.n_doms++;
    		}
    		else {
    			this.save_ratios[this.saved++] = this.curr_ratio;

    			if (this.curr_ne0 > this.min_sse) {
    				// push on part 0 //
    				t = this.stack[this.top];

    				for (i = 0; i < this.curr_ne0; i++)
    					this.elements[t++] = this.curr_prt0[i];

    				this.elements[t++] = -1;
    				this.stack[++this.top] = t;
    			}
    			else {
    				// save part 0 //
    				for (i = 0; i < this.curr_ne0; i++)
    					this.parts[this.np++] = this.curr_prt0[i];

    				this.parts[this.np++] = -1;
    				this.n_doms++;
    			}

    			if (this.curr_ne1 > this.min_sse) {
    				// push on part 1 //
    				t = this.stack[this.top];

    				for (i = 0; i < this.curr_ne1; i++)
    					this.elements[t++] = this.curr_prt1[i];

    				this.elements[t++] = -1;
    				this.stack[++this.top] = t;
    			}
    			else {
    				// save part 1 //
    				for (i = 0; i < this.curr_ne1; i++)
    					this.parts[this.np++] = this.curr_prt1[i];

    				this.parts[this.np++] = -1;
    				this.n_doms++;
    			}
    		}
    	} // end process_set //



    	// Main driver for chain splitting. //
    	//process_all(let n) { let ic = this.icn3d, me = ic.icn3dui;
    	process_all(n) { let ic = this.icn3d; ic.icn3dui;
    		let i; //int

    		// initialize the this.stack //
    		this.top = 1;
    		this.stack[0] = this.np = this.n_doms = 0;
    		this.saved = 0;

    		for (i = 0; i < n; i++)
    			this.elements[i] = i;

    		this.elements[n] = -1;

    		// recursively split the chain into domains //
    		while (this.top > 0) {
    			this.process_set();
    		}
    	} // end process_all //

    	// Output the domains.  For S we number the this.elements 1, 2, ..., n. //
    	//output(let n, int* prts) { let ic = this.icn3d, me = ic.icn3dui;
    	output(n) { let ic = this.icn3d; ic.icn3dui;
    		let i, k; //int
    		
    		let prts = [];

    		// zap the output array //
    		for (i = 0; i < 2*n; i++)
    			prts.push(0);

    		// now write out the subdomains //
    		for (i = k = 0; k < this.n_doms; i++) {
    			prts[i] = this.parts[i] + 1;

    			if (this.parts[i] < 0)
    				k++;
    		}

    		return prts;
    	} // end output //



    	// // S-interface to the chain-splitting program.
    	//  *
    	//  * Explanation of parameters:
    	//  *
    	//  *	ne - number of secondary structure this.elements (SSEs)
    	//  *	cts - contact count matrix
    	//  *	elt_sz - sizes of SSEs
    	//  *	grps - element group indicators
    	//  *	sratio - splitting ratio
    	//  *	msize - min size of a split domain
    	//  *	m_sse - min number of SSEs required in a split part
    	//  *	mcsz - max cut size, i.e. max number of split points
    	//  *	avg_cts - mean number of internal contacts for a domain
    	//  *	c_delt - cut set parameter
    	//  *	ncf0 - size factor for number of internal contacts
    	//  *	prts - output listing of domains
    	//  *	n_saved - number of this.saved splitting ratios
    	//  *	ratios - splitting ratios
    	//  *	ret - success/failure indicator
    	//  *	verb - flag to turn off/on splitting information
    	//  //

    	//new_split_chain(let ne, let sratio, let msize, let m_sse, let mcsz, let avg_cts,
    	//	let c_delt, let ncf0, int* prts, int* n_saved, let* ratios) { let ic = this.icn3d, me = ic.icn3dui;
    	new_split_chain(ne, sratio, msize, m_sse, mcsz, avg_cts,
    		c_delt, ncf0, prts, n_saved, ratios) { let ic = this.icn3d; ic.icn3dui;
    		let i; //int

    		this.split_ratio = sratio;
    		this.min_size = msize;
    		this.min_sse = m_sse;
    		this.max_csz = mcsz;
    		this.mean_cts = avg_cts;
    		this.c_delta = c_delt;
    		this.nc_fact = ncf0;
    		
    		this.process_all(ne);
    		//this.output(ne, prts);
    		this.parts = this.output(ne);
    		n_saved = this.saved;
    		for (i = 0; i < this.saved; i++)
    			ratios[i] = this.save_ratios[i];

    		return n_saved;

    	} // end new_split_chain //

    	//
    	// Actually, here is a better method that is also simple!
    	//
    	// If there are N atoms (residues) this algorithm should usually run in
    	// time O(N^4/3), and usually even much faster!  In very unusual cases
    	// it could take quadratic time.  The key idea is that atoms are not
    	// infinitely compressible, i.e. only a fixed number will fit in a given
    	// region of space.  So if the protein is roughly spherical, there will
    	// only be O(N^1/3) atoms close to any given diameter.  Therefore, a
    	// bound on the number of iterations of the inner loop is O(N^1/3).
    	//
    	// For an elongated protein that happens to have the x-axis normal to
    	// the long axis, then it is possible for the inner loop to take time
    	// O(N), in which case the whole takes O(N^2).  But this should rarely,
    	// if ever, occur in practice.  It would also be possible beforehand to
    	// choose the axis with the largest variance.
    	//

    	// typedef struct res_struct {
    	// 	let rnum;
    	// 	let x, y, z;
    	// } ResRec;

    	//list< pair< pair< int, let >, let > >
    	//c2b_AlphaContacts(let n0, let* x0, let* y0, let* z0,
    	//	const let incr = 4, const let dcut = 8.0) { let ic = this.icn3d, me = ic.icn3dui;
    	c2b_AlphaContacts(n0, x0, y0, z0, dcut, resiArray) { let ic = this.icn3d; ic.icn3dui;
    		//if(!incr) incr = 4;
    		if(!dcut) dcut = this.dcut;

    		let list_cts = [], list_rr = [];

    		for (let i = 0; i < n0; i++) {
    			// don't include residues with missing coordinates
    			//if ((x0[i] == MissingCoord) || (y0[i] == MissingCoord) || (z0[i] == MissingCoord))
    			if (!x0[i]|| !y0[i] || !z0[i])
    				continue;

    			//ResRec rr0;
    			let rr0 = {};
    			//rr0.rnum = i + 1;
    			rr0.rnum = resiArray[i];
    			rr0.x = x0[i];
    			rr0.y = y0[i];
    			rr0.z = z0[i];
    			list_rr.push(rr0);
    		}
    		
    		list_rr.sort(function(rr1, rr2) {
    				return rr1.x - rr2.x;
    			});
    					
    		//let rrit1, rrit2, rrbeg;
    		let i, j, len = list_rr.length;

    		//for (rrit1 = list_rr.begin(); rrit1 != list_rr.end(); rrit1++) {
    		for (i = 0; i < len; ++i) {	
    			//ResRec rr1 = *rrit1;
    			let rr1 = list_rr[i];
    			let x1 = rr1.x;
    			let y1 = rr1.y;
    			let z1 = rr1.z;
    			//rrbeg = rrit1;
    			//rrbeg++;

    			//for (rrit2 = rrbeg; rrit2 != list_rr.end(); rrit2++) {
    			for (j = i + 1; j < len; ++j) {	
    				//ResRec rr2 = *rrit2;
    				let rr2 = list_rr[j];
    				if ((parseInt(rr1.rnum) - parseInt(rr2.rnum) <= 3) && (parseInt(rr2.rnum) - parseInt(rr1.rnum) <= 3)) continue;
    				let x2 = rr2.x;
    				let y2 = rr2.y;
    				let z2 = rr2.z;

    				if (x2 > x1 + dcut)
    					break;

    				// x1 <= x2 <= x1 + dcut so compare
    				let sum = (x1 - x2)*(x1 - x2);
    				sum += (y1 - y2)*(y1 - y2);
    				sum += (z1 - z2)*(z1 - z2);
    				let d0 = Math.sqrt(sum);
    				if (d0 > dcut) continue;
    				//pair< pair< int, let >, let > lpair;
    				//pair< int, let > rpair;
    				let lpair = {}, rpair = {};

    				if (parseInt(rr1.rnum) < parseInt(rr2.rnum)) {
    					rpair.first = rr1.rnum;
    					rpair.second = rr2.rnum;
    				}
    				else {
    					rpair.first = rr2.rnum;
    					rpair.second = rr1.rnum;
    				}

    				lpair.first = rpair;
    				lpair.second = d0;
    				list_cts.push(lpair);
    			}
    		}

    		return list_cts;

    	} // end c2b_AlphaContacts



    	//
    	// Creates a table, actually a graph, of the contacts between SSEs.
    	//

    	//static map< pair< int, let >, let >
    	//c2b_ContactTable(vector<int>& v1, vector<int>& v2) { let ic = this.icn3d, me = ic.icn3dui;
    	c2b_ContactTable(v1, v2) { let ic = this.icn3d; ic.icn3dui;
    		let cmap = {};
    		let n0 = v1.length; //unsigned int

    		if (n0 != v2.length) {
    			// problem!

    			return cmap;
    		}

    		for (let i = 0; i < n0; i++) {
    			let e1 = v1[i];
    			let e2 = v2[i];
    			//pair<int, int> epr;
    			//let epr = {};
    			//epr.first = e1;
    			//epr.second = e2;
    			let epr = e1 + '_' + e2;

    			//if (cmap.count(epr) == 0) {
    			if (!cmap[epr]) {	
    				cmap[epr] = 1;
    			}
    			else
    				cmap[epr]++;
    		}

    		return cmap;

    	} // end c2b_ContactTable

    	
    	//https://www.geeksforgeeks.org/number-groups-formed-graph-friends/
    	countUtil(ss1, sheetNeighbor, existing_groups) {
    		this.visited[ss1] = true;

    		if(!this.groupnum2sheet[existing_groups]) this.groupnum2sheet[existing_groups] = [];
    		this.groupnum2sheet[existing_groups].push(parseInt(ss1));

    		for(let ss2 in sheetNeighbor[ss1]) {
    			if (!this.visited[ss2]) {
    				this.countUtil(ss2, sheetNeighbor, existing_groups);  
    			}
    		}  
    	}

    	//
    	// Residue ranges of the Vast domains, per protein chain.
    	//

    	//
    	// Subdomain definition rules are as follows; let m0 = minSSE:
    	//
    	//     1. A subdomain with <= m0 SSEs cannot be split.
    	//
    	//     2. A subdomain cannot be split into two this.parts, both with < m0 SSEs.
    	//
    	//     3. However, a subdomain can be trimmed, i.e. split into two this.parts,
    	//        one with < m0 SSEs.
    	//
    	//c2b_NewSplitChain(string asymId, let seqLen, let* x0, let* y0, let* z0) { let ic = this.icn3d, me = ic.icn3dui;
    	// x0, y0, z0: array of x,y,z coordinates of C-alpha atoms
    	//c2b_NewSplitChain(chnid, dcut) { let ic = this.icn3d, me = ic.icn3dui;
    	// this function works for a single chain
    	c2b_NewSplitChain(atoms, dcut) { let ic = this.icn3d; ic.icn3dui;
    		this.init3ddomain();

    		let x0 = [], y0 = [], z0 = [], resiArray = [];

    		//substruct: array of secondary structures, each of which has the keys: From (1-based), To (1-based), Sheet (0 or 1), also add these paras: x1, y1, z1, x2, y2, z2
    		let substruct = [];
    		// determine residue position ranges for each subdomain
    		let subdomains = [];

    		// sheets: array of sheets, each of which has the key: sheet_num (beta sandwich has two sheets, e.g., 0 and 1), adj_strand1 (not used), adj_strand2
    		let sheets = [];

    		let residueHash = ic.firstAtomObjCls.getResiduesFromAtoms(atoms);
    		let residueArray = Object.keys(residueHash);
    		let chnid = residueArray[0].substr(0, residueArray[0].lastIndexOf('_'));

    		if(!ic.posid2resid) ic.posid2resid = {};

    		let substructItem = {};
    		let pos2resi = {}; // 0-based
    		for(let i = 0; i < residueArray.length; ++i) {
    			let resid = residueArray[i];

                let resi = resid.substr(resid.lastIndexOf('_') + 1);

    			//let resid = chnid + "_" + resi;
    			let atom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[resid]);

    			if(atom) {
    				x0.push(atom.coord.x);
    				y0.push(atom.coord.y);
    				z0.push(atom.coord.z);
    			}
    			else {
    				// x0.push(dummyCoord);
    				// y0.push(dummyCoord);
    				// z0.push(dummyCoord);

    				continue;
    			}
    	
    			// if(!atom) {
    			// 	// continue;    
    			// }

    			// x0.push(atom.coord.x);
    			// y0.push(atom.coord.y);
    			// z0.push(atom.coord.z);

    			//resiArray.push(resi);
    			resiArray.push(i+1);
    			// pos2resi[i+1] = resi;
    			pos2resi[i] = resi;

    			// ic.posid2resid[atom.structure + '_' + atom.chain + '_' + (i+1).toString()]  = resid;
    			if(atom.ssend) {
    				//substructItem.To = parseInt(resi);
    				substructItem.To = i + 1;
    				// substructItem.To = ic.annoDomainCls.getNcbiresiFromResid(resid);
    				substructItem.x2 = atom.coord.x;
    				substructItem.y2 = atom.coord.y;
    				substructItem.z2 = atom.coord.z;

    				substructItem.Sheet = (atom.ss == 'sheet') ? true : false;

    				substruct.push(substructItem);
    				substructItem = {};		
    			}

    			// a residue could be both start and end. check ssend first, then check ssbegin 
    			if(atom.ssbegin) {
    				//substructItem.From = parseInt(resi);
    				substructItem.From = i + 1;
    				// substructItem.From = ic.annoDomainCls.getNcbiresiFromResid(resid);
    				substructItem.x1 = atom.coord.x;
    				substructItem.y1 = atom.coord.y;
    				substructItem.z1 = atom.coord.z;
    			}
            }

    		let nsse = substruct.length;
    		
    		if (nsse <= 3) {
    			// too small, can't split or trim
    			substruct = this.standardizeSubstruct(chnid, substruct, pos2resi);
    			return {subdomains: subdomains, substruct: substruct};
            }

    		if (nsse > this.MAX_SSE) {
    			// we have a problem...
    			substruct = this.standardizeSubstruct(chnid, substruct, pos2resi);
    			return {subdomains: subdomains, substruct: substruct};
    		}
    		
    		let seqLen = residueArray.length; // + resiOffset;
    		//let lastResi = resiArray[seqLen - 1];
    		let lastResi = seqLen;

    		// get a list of Calpha-Calpha contacts
    		///list< pair< pair< int, let >, let > >
    		let cts = this.c2b_AlphaContacts(seqLen, x0, y0, z0, dcut, resiArray);

    		//
    		// Produce a "map" of the SSEs, i.e. vec_sse[i] = 0 means residue i + 1
    		// is in a loop, and vec_sse[i] = k means residue i + 1 belongs to SSE
    		// number k.
    		//
    		let vec_sse = []; //vector<int>

    		for (let i = 0; i < seqLen; i++)
    			vec_sse.push(0);
    			
    		let hasSheets = false;

    		//substruct: array of secondary structures, each of which has the keys: From, To, Sheet (0, 1)
    		for (let i = 0; i < substruct.length; i++) {
    			//SSE_Rec sserec = substruct[i];
    			let sserec = substruct[i];
    			let From = sserec.From;
    			let To = sserec.To;
    			this.elt_size[i] = To - From + 1;

    			// double-check indexing OK???
    			for (let j = From; j <= To; j++)
    				vec_sse[j - 1] = i + 1;

    			//if (sserec.Sheet > 0)
    			if (sserec.Sheet)
    				hasSheets = true;
    		}

    		// produce the SSE contact lists
    		let vec_cts1 = [], vec_cts2 = [], vec_cts1a = [], vec_cts2a = [];

    		//for (ctsit = cts.begin(); ctsit != cts.end(); ctsit++) {
    		for (let i = 0, il = cts.length; i < il; ++i) {
    			//pair< pair< int, let >, let > epr = *ctsit;
    			//pair< int, let > respair = epr.first;
    			let epr = cts[i];
    			let respair = epr.first;
    			let sse1 = vec_sse[respair.first - 1];
    			let sse2 = vec_sse[respair.second - 1];
    			// could be 0 or null
    			if ((sse1 <= 0) || (sse2 <= 0) || !sse1 || !sse2) continue;
    			vec_cts1.push(sse1);
    			vec_cts2.push(sse2);
    			if (sse1 == sse2) continue;
    			vec_cts1a.push(sse1);
    			vec_cts2a.push(sse2);
    		}

    		// this symmetrizes the contact data
    		for (let i = 0; i < vec_cts1a.length; i++) {
    			vec_cts1.push(vec_cts2a[i]);
    			vec_cts2.push(vec_cts1a[i]);
    		}

    		// add dummy contacts
    		for (let i = 0; i < nsse; i++) {
    			vec_cts1.push(i + 1);
    			vec_cts2.push(i + 1);
    		}

    		// create contact counts from the contacts/interactions
    		//map< pair< int, let >, let > ctable = this.c2b_ContactTable(vec_cts1, vec_cts2);
    		let ctable = this.c2b_ContactTable(vec_cts1, vec_cts2);

    		// neighbor list of each sheet
    		let sheetNeighbor = {};
    		for(let pair in ctable) {
    			let ssPair = pair.split('_'); // 1-based
    			let ss1 = parseInt(ssPair[0]);
    			let ss2 = parseInt(ssPair[1]);

    			if(ctable[pair] < this.min_contacts) ctable[pair] = 0;

    			// both are sheets
    			// min number of contacts: this.min_contacts
    			if(substruct[ss1 - 1].Sheet && substruct[ss2 - 1].Sheet && ctable[pair] >= this.min_contacts ) {
    				if(!sheetNeighbor[ss1]) sheetNeighbor[ss1] = {};
    				if(!sheetNeighbor[ss2]) sheetNeighbor[ss2] = {};

    				sheetNeighbor[ss1][ss2] = 1;
    				sheetNeighbor[ss2][ss1] = 1;
    			}
    		}

    		//https://www.geeksforgeeks.org/number-groups-formed-graph-friends/
    		let existing_groups = 0;
    		let sheet2sheetnum = {};
    		this.groupnum2sheet = {};
    		this.visited = {};
    		for (let ss1 in sheetNeighbor) {
    			this.visited[ss1] = false;
    		}

    		// get this.groupnum2sheet
    		for (let ss1 in sheetNeighbor) {
    			// If not in any group.
    			if (this.visited[ss1] == false) {
    				existing_groups++;
    					
    				this.countUtil(ss1, sheetNeighbor, existing_groups);
    			}
    		}

    		// get sheet2sheetnum
    		// each neighboring sheet will be represented by the sheet with the smallest sse 
    		for(let groupnum in this.groupnum2sheet) {
    			let ssArray = this.groupnum2sheet[groupnum].sort(function(a, b){return a-b});
    			for(let i = 0, il = ssArray.length; i < il; ++i) {
    				sheet2sheetnum[ssArray[i]] = ssArray[0];
    			}
    		}

    		let invalidSheethash = {};	
    		for (let i = 0; i < nsse; i++) {
    			if(substruct[i].Sheet) {				
    				let sheetsItem = {};
    				if(sheet2sheetnum[i+1]) {
    					sheetsItem.sheet_num = sheet2sheetnum[i+1];
    					sheetsItem.adj_strand2 = 1; 
    					sheetsItem.sse = i + 1; 
    				}
    				else {
    					sheetsItem.sheet_num = 0;
    					sheetsItem.adj_strand2 = 0; 
    					sheetsItem.sse = i + 1; 

    					invalidSheethash[sheetsItem.sse] = 1;
    				}

    				sheets.push(sheetsItem);
    			}
    		}

    		//
    		// Correct for dummy contacts; they're present to ensure that the
    		// table gives the right result in the possible case there is an
    		// element with no contacts.
    		//
    		for (let i = 0; i < nsse; i++) {
    			for (let j = 0; j < nsse; j++) {
    				//pair<int, int> epr;
    				//let epr = {};
    				//epr.first = i + 1;
    				//epr.second = j + 1;
    				let epr = (i+1).toString() + '_' + (j+1).toString();

    				//if (ctable.count(epr) == 0)
    				if (!ctable[epr])
    					this.ctc_cnt[i][j] = 0;
    				else {
    					let cnt = ctable[epr];
    					if (i == j) cnt--; // subtract dummy contact
    					this.ctc_cnt[i][j] = cnt;
    					this.ctc_cnt[j][i] = cnt;
    				}
    			}
    		}

    		let minStrand = 6; // number of residues in a strand

    		if (hasSheets) {
    			//sheets: array of sheets, each of which has the key: sheet_num (number of strands), adj_strand1, adj_strand2

    			let cnt = 0;

    			for (let i = 0; i < sheets.length; i++) {
    				//BetaSheet_Rec bsrec = sheets[i];
    				let bsrec = sheets[i];

    				//if ((bsrec.sheet_num > 0) && (this.elt_size[i] >= minStrand) && (bsrec.adj_strand2 != 0))
    				if ((bsrec.sheet_num > 0) && (this.elt_size[bsrec.sse - 1] >= minStrand) && (bsrec.adj_strand2 != 0))
    					cnt++;
    			}

    			for (let i = 0; i < nsse; i++) {
    				//this.group_num[i] = (cnt == 0) ? i + 1 : 0;
    				this.group_num[i] = i + 1;
    			}

    			if (cnt> 0) {
    				for (let i = 0; i < sheets.length; i++) {
    					let bsrec = sheets[i];
    					// this.group_num[bsrec.sse - 1] = bsrec.sheet_num;
    					if(bsrec.sheet_num != 0) this.group_num[bsrec.sse - 1] = bsrec.sheet_num;
    				}
    			}
    		}
    		else {
    			for (let i = 0; i < nsse; i++)
    				this.group_num[i] = i + 1;
    		}

    		let sratio = 0.25;
    		let minSize = 25;
    		let maxCsz = 4;
    		let avgCts = 0.0;
    		let ncFact = 0.0;
    		let cDelta = 3;
    		let minSSE = 3;

    		// call the domain splitter
    		this.parts = [];
    		this.parts.length = 2*this.MAX_SSE;
    		let ratios = [];
    		ratios.length = this.MAX_SSE;
    		let n_saved = 0;

    		for (let i = 0; i < nsse; i++) {
    			this.parts[2*i] = this.parts[2*i + 1] = 0;
    			ratios[i] = 0.0;
    		}

    		n_saved = this.new_split_chain(nsse, sratio, minSize, minSSE, maxCsz, avgCts, cDelta, ncFact, this.parts, n_saved, ratios);

    		// save domain data
    		//list< vector< let > > list_parts;
    		let list_parts = [];

    		if (n_saved > 0) {
    			// splits occurred...
    			let j = 0;
    			
    			for (let i = 0; i <= n_saved; i++) {
    				//vector<int> sselst;
    				let sselst = [];
    				//sselst.clear();

    				while (j < 2*nsse) {
    					let sse0 = this.parts[j++];

    					if (sse0 == 0) {
    						list_parts.push(sselst);
    						break;
    					}
    					else
    						sselst.push(sse0);
    				}
    			}
    		}

    		list_parts.sort(function(v1, v2) {
    				return v1[0] - v2[0];
    			});

    		// remove sheets less than 3 residues
    		let list_partsTmp = [];
    		for(let i = 0, il = list_parts.length; i < il; ++i) {
    			let list_parts_item = [];
    			for(let j = 0, jl = list_parts[i].length; j < jl; ++j) {
    				let sse = list_parts[i][j];
    				if(!invalidSheethash.hasOwnProperty(sse)) {
    					list_parts_item.push(sse);
    				}
    			}
    			if(list_parts_item.length >= this.min_sse) list_partsTmp.push(list_parts[i]);
    		}
    		
    		list_parts = list_partsTmp;

    		// if there is only one domain, add all
    		if(list_parts.length == 0) {
    			let groupnum2cnt = {}, groupnum2sseList = {}, chosenGroupnum = 0;
    			for(let i = 0, il = this.group_num.length; i < il; ++i) {
    				let groupnum = this.group_num[i];
    				let sse = i + 1;
    				if(groupnum && groupnum != i + 1) {
    					if(!groupnum2sseList[groupnum]) groupnum2sseList[groupnum] = [];
    					// collect all sse for this groupnum
    					groupnum2sseList[groupnum].push(sse);

    					if(!groupnum2cnt[groupnum]) {
    						groupnum2cnt[groupnum] = 1;
    					}
    					else {
    						++groupnum2cnt[groupnum];
    						if(groupnum2cnt[groupnum] >= 3) { // minimum 3 sse
    							chosenGroupnum = groupnum;
    						}
    					}
    				}
    			}

    			if(chosenGroupnum != 0) { // found a domain
    				let sseArray = [chosenGroupnum].concat(groupnum2sseList[chosenGroupnum]);

    				list_parts.push(sseArray);
    			}
    		}

    		//for (lplet = list_parts.begin(); lplet != list_parts.end(); lpint++) {
    		for (let index = 0, indexl = list_parts.length; index < indexl; ++index) {
    			//vector<int> prts = *lpint;
    			let prts = list_parts[index];
    			//vector<int> resflags;
    			//resflags.clear();

    			//let resflags = [];
    			let resflags = {}; // keys are 1-based positions

    			// a domain must have at least 3 SSEs...
    			if (prts.length <= 2) continue;

    			for (let i = 0; i < seqLen; i++) {
    				//resflags.push(0);
    				resflags[i + 1] = 0;
    			}

    			for (let i = 0; i < prts.length; i++) {
    				let k = prts[i] - 1;

    				if ((k < 0) || (k >= substruct.length)) {
    					substruct = this.standardizeSubstruct(chnid, substruct, pos2resi);
    					return {subdomains: subdomains, substruct: substruct};
    				}

    				//SSE_Rec sserec = substruct[k];
    				let sserec = substruct[k];
    				let From = sserec.From;
    				let To = sserec.To;

    				for (let j = From; j <= To; j++) {
    					resflags[j] = 1;
    				}

    				if ((k == 0) && (From > 1)) {
    					// residues with negative residue numbers will not be included
    					for (let j = 1; j < From; j++) {
    						// include at most 10 residues
    						if(From - j <= 10) {
    							resflags[j] = 1;
    						}
    					}
    				}

    				//if ((k == substruct.length - 1) && (To < seqLen)) {
    				if ((k == substruct.length - 1) && (To < parseInt(lastResi))) {
    					//for (let j = To + 1; j <= seqLen; j++) {
    					for (let j = To + 1; j <= parseInt(lastResi); j++) {
    						// include at most 10 residues
    						if(j - To <= 10) {
    							resflags[j] = 1;
    						}
    					}
    				}

    				// left side
    				if (k > 0) {
    					//SSE_Rec sserec1 = substruct[k - 1];
    					let sserec1 = substruct[k - 1];
    					let To1 = sserec1.To;
    					//let ll = (int) floor(0.5*((let) (From - To1 - 1)));
    					let ll = parseInt(0.5 * (From - To1 - 1));

    					if (ll > 0) {
    						for (let j = From - ll; j <= From - 1; j++) {
    							resflags[j] = 1;
    						}
    					}
    				}

    				// right side
    				if (k < substruct.length - 1) {
    					//SSE_Rec sserec1 = substruct[k + 1];
    					let sserec1 = substruct[k + 1];
    					let From1 = sserec1.From;
    					//let ll = (int) ceil(0.5*((let) (From1 - To - 1)));
    					// let ft = From1 - To - 1;
    					// let ll = parseInt(ft/2);
    					// if (ft % 2 == 1) ll++;
    					let ll = parseInt(0.5 * (From1 - To - 1) + 0.5);

    					if (ll > 0) {
    						for (let j = To + 1; j <= To + ll; j++) {
    							resflags[j] = 1;
    						}
    					}
    				}
    			}

    			// extract the continuous segments
    			let inseg = false;
    			let startseg;
    			//vector<int> segments;
    			//segments.clear();
    			let segments = []; //use position instead of residue number

    			for (let i = 0; i < seqLen; i++) {
    				//let rf = resflags[i];
    				let rf = resflags[i + 1];

    				if (!inseg && (rf == 1)) {
    					// new segment starts here
    					startseg = i + 1;
    					inseg = true;
    					continue;
    				}

    				if (inseg && (rf == 0)) {
    					// segment ends
    					// segments.push(startseg);
    					// segments.push(i);

    					let resiRangeArray = this.getNcbiresiRangeFromPos(chnid, startseg, i, pos2resi);
    					segments = segments.concat(resiRangeArray);

    					inseg = false;
    				}
    			}

    			// check for the last segment
    			if (inseg) {
    				// segments.push(startseg);
    				// segments.push(lastResi);

    				let resiRangeArray = this.getNcbiresiRangeFromPos(chnid, startseg, lastResi, pos2resi);
    				segments = segments.concat(resiRangeArray);
    			}

    			subdomains.push(segments);
    		}

    		// update ic.tddomains
    		if(!ic.tddomains) ic.tddomains = {};
    		for(let i = 0, il = subdomains.length; i < il; ++i) {
    			// domain item: {"sdid":1722375,"intervals":[[1,104],[269,323]]}
    			let domainName = 'domain3d-' + Object.keys(ic.tddomains).length;
    			ic.tddomains[domainName] = {};

    			for(let j = 0, jl = subdomains[i].length; j < jl; j += 2) {
    				for(let k = subdomains[i][j]; k <= subdomains[i][j+1]; ++k) {
    					let resid = chnid + '_' + k;
    					ic.tddomains[domainName][resid] = 1;
    				}
    			}
    		}

    		substruct = this.standardizeSubstruct(chnid, substruct, pos2resi);

    		// return {subdomains: subdomains, substruct: substruct};
    		//subdomains contains NCBI residue numbers
    		return {subdomains: subdomains, substruct: substruct};
    	} // end c2b_NewSplitChain

    	standardizeSubstruct(chnid, substruct, pos2resi) { let ic = this.icn3d; ic.icn3dui;
    		// adjust substruct to use NCBI residue number
    		for (let i = 0; i < substruct.length; i++) {
    			//SSE_Rec sserec = substruct[i];
    			let sserec = substruct[i];
    			let FromPos = sserec.From;
    			let ToPos = sserec.To;
    			
    			let FromResi = pos2resi[FromPos - 1];
    			let ToResi = pos2resi[ToPos - 1];

    			let FromNcbiResid = ic.annoDomainCls.getNcbiresiFromResid(chnid + '_' + FromResi);
    			let ToNcbiResid = ic.annoDomainCls.getNcbiresiFromResid(chnid + '_' + ToResi);

    			substruct[i].From = FromNcbiResid.substr(FromNcbiResid.lastIndexOf('_') + 1);
    			substruct[i].To = ToNcbiResid.substr(ToNcbiResid.lastIndexOf('_') + 1);

    			substruct[i].From = parseInt(substruct[i].From);
    			substruct[i].To = parseInt(substruct[i].To);
    		}

    		return substruct;
    	}

    	getNcbiresiRangeFromPos(chnid, startPos, endPos, pos2resi) { let ic = this.icn3d; ic.icn3dui;
    		let resiArray = [];
    		for(let i = startPos; i <= endPos; ++i) {
    			let resi = pos2resi[i - 1];
    			let residNCBI = (ic.resid2ncbi[chnid + '_' + resi]) ? ic.resid2ncbi[chnid + '_' + resi] : chnid + '_' + resi;
    			let ncbiresi = residNCBI.substr(residNCBI.lastIndexOf('_') + 1);
    			resiArray.push(parseInt(ncbiresi));
    		}

    		let resiRangeArray = ic.resid2specCls.resi2range(resiArray);
    	
    		return resiRangeArray;
    	}

    	/*
    	// this function works for atoms in a single chain
    	// getDomainJsonForAlign(atoms, bForceOneDomain) { let ic = this.icn3d, me = ic.icn3dui;
    	getDomainJsonForAlign(atoms) { let ic = this.icn3d, me = ic.icn3dui;
    		let result = this.c2b_NewSplitChain(atoms);

    		let subdomains = result.subdomains;
    		let substruct = result.substruct;
    		// let pos2resi = result.pos2resi;


    		let residueHash = ic.firstAtomObjCls.getResiduesFromAtoms(atoms);
    		// let residueArray = Object.keys(residueHash);
    		// let chnid = residueArray[0].substr(0, residueArray[0].lastIndexOf('_'));

    		let firstAtom = ic.firstAtomObjCls.getFirstAtomObj(atoms);
    		let chnid = firstAtom.structure + '_' + firstAtom.chain;

    		// if(bForceOneDomain) subdomains = [];

    		//the whole structure is also considered as a large domain
    		if(subdomains.length == 0) {
    			let resid1 = residueArray[0];
    			let resid2 = residueArray[residueArray.length - 1];
    			let ncbiresid1 = (ic.resid2ncbi[resid1]) ? ic.resid2ncbi[resid1] : resid1;
    			let ncbiresid2 = (ic.resid2ncbi[resid2]) ? ic.resid2ncbi[resid2] : resid2;
    			subdomains.push([parseInt(ncbiresid1.substr(ncbiresid1.lastIndexOf('_') + 1)), parseInt(ncbiresid2.substr(ncbiresid2.lastIndexOf('_') + 1))]);	
    		}	

    		// m_domains1: {"data": [ {"ss": [[1,20,30,x,y,z,x,y,z], [2,50,60,x,y,z,x,y,z]], "domain": [[1,43,x,y,z],[2,58,x,y,z], ...]}, {"ss": [[1,20,30,x,y,z,x,y,z], [2,50,60,x,y,z,x,y,z]],"domain": [[1,43,x,y,z],[2,58,x,y,z], ...]} ] }
    		let jsonStr = '{"data": [';
    		//merge all subdomains into one domain
    		jsonStr += '{"ss": ['; //secondary structure

    		let ssCnt = 0, startAll = 999, endAll = -999;
    		for(let i = 0, il = subdomains.length; i < il; ++i) {
    			// if(i > 0) jsonStr += ', ';
    			// jsonStr += '{"ss": ['; //secondary structure
    			
    			for(let j = 0, jl = subdomains[i].length; j < jl; j += 2) {
    				let start = subdomains[i][j];
    				let end = subdomains[i][j + 1];
    				
    				if(start < startAll) startAll = start;
    				if(end > endAll) endAll = end;
    				
    				for(let k = 0, kl = substruct.length; k < kl; ++k) {
    					//ss: sstype	ss_start	ss_end	x1	y1	z1	x2	y2	z2
    						//sstype: 1 (helix), 2 (sheet)
    					let sstype = (substruct[k].Sheet) ? 2 : 1;
    					// let from = pos2resi[substruct[k].From - 1]; // 1-based to 0-based
    					// let to = pos2resi[substruct[k].To - 1];

    					// 1-based residue numbers
    					let fromPos = substruct[k].From;
    					let toPos = substruct[k].To;

    					let residFrom = ic.ncbi2resid[chnid + "_" + fromPos];
    					let atomFrom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[residFrom]);

    					if(!atomFrom || !ic.hAtoms.hasOwnProperty(atomFrom.serial)) continue;

    					let residTo = ic.ncbi2resid[chnid + "_" + toPos];
    					let atomTo = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[residTo]);
    					if(!atomTo || !ic.hAtoms.hasOwnProperty(atomTo.serial)) continue;

    					if(fromPos >= start && toPos <= end) {
    						if(ssCnt > 0) jsonStr += ', ';
    						jsonStr += '[' + sstype + ',' + fromPos + ',' + toPos + ',' + substruct[k].x1.toFixed(2) + ',' + substruct[k].y1.toFixed(2) + ',' 
    							+ substruct[k].z1.toFixed(2) + ',' + substruct[k].x2.toFixed(2) + ',' + substruct[k].y2.toFixed(2) + ',' + substruct[k].z2.toFixed(2) + ']';
    						++ssCnt;
    					}
    				}				
    			}
    		}
    		jsonStr += ']';
    		
    		// domain
    		jsonStr += ', "domain": [';
    		let domainCnt = 0;
    		let fakeCoord = 0; //-100000;  // the fake corrd is not read anyway

    		// resi should be the continuous number starting from 1. make this correction in the backend
    		for(let j = startAll; j <= endAll; ++j) {
    			let ncbiResid = chnid + '_' + j;
    			let resid = ic.ncbi2resid[ncbiResid];

    			let pos = j;

    			if(domainCnt > 0) jsonStr += ', ';

    			if(!residueHash.hasOwnProperty(resid)) {
    				jsonStr += '[' + pos + ',' + 0 + ',' + fakeCoord + ',' + fakeCoord + ',' + fakeCoord + ']';
    			}
    			else {
    				let atom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[resid]);

    				//domain: resi, restype, x, y, z
    				let restype = (me.parasCls.resn2restype[atom.resn]) ? me.parasCls.resn2restype[atom.resn] : 0;
    				
    				jsonStr += '[' + pos + ',' + restype + ',' + atom.coord.x.toFixed(2) + ',' + atom.coord.y.toFixed(2) + ',' + atom.coord.z.toFixed(2) + ']';
    			}

    			++domainCnt;		
    		}
    		jsonStr += ']}';

    		jsonStr += ']}';

    		return jsonStr;
    	} 
    */
    	// this function works for atoms in a single chain
    	getDomainJsonForAlign(atoms) { let ic = this.icn3d, me = ic.icn3dui;
    		// let result = this.c2b_NewSplitChain(atoms);

    		// let subdomains = result.subdomains;
    		// let substruct = result.substruct;

    		let residueHash = ic.firstAtomObjCls.getResiduesFromAtoms(atoms);
    		let residueArray = Object.keys(residueHash);
    		let chnid = residueArray[0].substr(0, residueArray[0].lastIndexOf('_'));

    		// let resid1 = residueArray[0];
    		// let resid2 = residueArray[residueArray.length - 1];
    		// let ncbiresid1 = (ic.resid2ncbi[resid1]) ? ic.resid2ncbi[resid1] : resid1;
    		// let ncbiresid2 = (ic.resid2ncbi[resid2]) ? ic.resid2ncbi[resid2] : resid2;
    		// let startAll = parseInt(ncbiresid1.substr(ncbiresid1.lastIndexOf('_') + 1));
    		// let endAll = parseInt(ncbiresid2.substr(ncbiresid2.lastIndexOf('_') + 1));	

    		let substruct = [];
    		let substructItem = {};
    		let pos2resi = {}; // 0-based
    		let startAll = 999, endAll = -999;
    		for(let i = 0; i < residueArray.length; ++i) {
    			let resid = residueArray[i];
    			let atom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[resid]);

    			let resi = resid.substr(resid.lastIndexOf('_') + 1);
    			pos2resi[i] = resi;

    			let ncbiresid = (ic.resid2ncbi[resid]) ? ic.resid2ncbi[resid] : resid;
    			let ncbiresi = parseInt(ncbiresid.substr(ncbiresid.lastIndexOf('_') + 1));

    			if(ncbiresi < startAll) startAll = ncbiresi;
    			if(ncbiresi > endAll) endAll = ncbiresi;

    			if(atom.ssend) {
    				substructItem.To = i + 1;
    				substructItem.x2 = atom.coord.x;
    				substructItem.y2 = atom.coord.y;
    				substructItem.z2 = atom.coord.z;

    				substructItem.Sheet = (atom.ss == 'sheet') ? true : false;

    				substruct.push(substructItem);
    				substructItem = {};		
    			}

    			// a residue could be both start and end. check ssend first, then check ssbegin 
    			if(atom.ssbegin) {
    				substructItem.From = i + 1;
    				substructItem.x1 = atom.coord.x;
    				substructItem.y1 = atom.coord.y;
    				substructItem.z1 = atom.coord.z;
    			}
            }

    		substruct = this.standardizeSubstruct(chnid, substruct, pos2resi);

    		// m_domains1: {"data": [ {"ss": [[1,20,30,x,y,z,x,y,z], [2,50,60,x,y,z,x,y,z]], "domain": [[1,43,x,y,z],[2,58,x,y,z], ...]}, {"ss": [[1,20,30,x,y,z,x,y,z], [2,50,60,x,y,z,x,y,z]],"domain": [[1,43,x,y,z],[2,58,x,y,z], ...]} ] }
    		let jsonStr = '{"data": [';
    		//merge all subdomains into one domain
    		jsonStr += '{"ss": ['; //secondary structure

    		let ssCnt = 0;
    		for(let k = 0, kl = substruct.length; k < kl; ++k) {
    			//ss: sstype	ss_start	ss_end	x1	y1	z1	x2	y2	z2
    			//sstype: 1 (helix), 2 (sheet)
    			let sstype = (substruct[k].Sheet) ? 2 : 1;

    			// 1-based residue numbers
    			let fromPos = substruct[k].From;
    			let toPos = substruct[k].To;

    			let residFrom = ic.ncbi2resid[chnid + "_" + fromPos];
    			let atomFrom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[residFrom]);
    			if(!atomFrom || !ic.hAtoms.hasOwnProperty(atomFrom.serial)) continue;

    			let residTo = ic.ncbi2resid[chnid + "_" + toPos];
    			let atomTo = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[residTo]);
    			if(!atomTo || !ic.hAtoms.hasOwnProperty(atomTo.serial)) continue;

    			// if(fromPos >= start && toPos <= end) {
    				if(ssCnt > 0) jsonStr += ', ';
    				jsonStr += '[' + sstype + ',' + fromPos + ',' + toPos + ',' + substruct[k].x1.toFixed(2) + ',' + substruct[k].y1.toFixed(2) + ',';
    				// jsonStr += '[' + sstype + ',' + residFrom.split('_')[2] + ',' + residTo.split('_')[2] + ',' + substruct[k].x1.toFixed(2) + ',' + substruct[k].y1.toFixed(2) + ',';
    				jsonStr += substruct[k].z1.toFixed(2) + ',' + substruct[k].x2.toFixed(2) + ',' + substruct[k].y2.toFixed(2) + ',' + substruct[k].z2.toFixed(2) + ']';
    				++ssCnt;
    			// }
    		}				

    		jsonStr += ']';
    		
    		// domain
    		jsonStr += ', "domain": [';
    		let domainCnt = 0;
    		let fakeCoord = 0; //-100000;  // the fake corrd is not read anyway

    		// resi should be the continuous number starting from 1. make this correction in the backend
    		for(let j = startAll; j <= endAll; ++j) {
    			let ncbiResid = chnid + '_' + j;
    			let resid = ic.ncbi2resid[ncbiResid];
    			resid.split('_')[2];

    			let pos = j;

    			if(domainCnt > 0) jsonStr += ', ';

    			if(!residueHash.hasOwnProperty(resid)) {
    				jsonStr += '[' + pos + ',' + 0 + ',' + fakeCoord + ',' + fakeCoord + ',' + fakeCoord + ']';
    				// jsonStr += '[' + resi + ',' + 0 + ',' + fakeCoord + ',' + fakeCoord + ',' + fakeCoord + ']';
    			}
    			else {
    				let atom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[resid]);

    				//domain: resi, restype, x, y, z
    				let restype = (me.parasCls.resn2restype[atom.resn]) ? me.parasCls.resn2restype[atom.resn] : 0;
    				
    				jsonStr += '[' + pos + ',' + restype + ',' + atom.coord.x.toFixed(2) + ',' + atom.coord.y.toFixed(2) + ',' + atom.coord.z.toFixed(2) + ']';
    				// jsonStr += '[' + resi + ',' + restype + ',' + atom.coord.x.toFixed(2) + ',' + atom.coord.y.toFixed(2) + ',' + atom.coord.z.toFixed(2) + ']';
    			}

    			++domainCnt;		
    		}
    		jsonStr += ']}';

    		jsonStr += ']}';

    		return jsonStr;
    	} 

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class AddTrack {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        clickAddTrackButton() { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;
            // ncbi gi/accession
            me.myEventCls.onIds("#" + ic.pre + "addtrack_button1", "click", async function(e) { let ic = thisClass.icn3d;
               e.stopImmediatePropagation();

               //e.preventDefault();
               dialog.dialog( "close" );

               let chainid = $("#" + ic.pre + "track_chainid").val();

               //var gi = $("#" + ic.pre + "track_gi").val().toUpperCase();
               let gi = $("#" + ic.pre + "track_gi").val();
               let title =(isNaN(gi)) ? 'Acc ' + gi : 'gi ' + gi;

               //var text = $("#" + ic.pre + "track_text").val();
               let url = me.htmlCls.baseUrl + 'pwaln/pwaln.fcgi?from=track';

               let dataObj = {'targets': chainid, 'queries': gi};
               let data = await me.getAjaxPostPromise(url, dataObj);

               thisClass.alignSequenceToStructure(chainid, data, title);
            });

            // FASTA
            me.myEventCls.onIds("#" + ic.pre + "addtrack_button2", "click", async function(e) { let ic = thisClass.icn3d;
               e.stopImmediatePropagation();
               //e.preventDefault();
               dialog.dialog( "close" );

               let chainid = $("#" + ic.pre + "track_chainid").val();

               let fasta = $("#" + ic.pre + "track_fasta").val();
               //var title = 'fasta ' + fasta.substr(0, 5);
               let title = $("#" + ic.pre + "fasta_title").val();

               let structure = chainid.substr(0, chainid.indexOf('_'));
               let targets = chainid;
               if(structure.length == 5) { // e.g., 1TUP2
                  targets = targets.substr(0,4);
               }
               else if(structure.length > 5) { // AlphaFold UniProt
                  targets = '';
                  for(let i = 0, il = ic.chainsSeq[chainid].length; i < il; ++i) {
                    targets += ic.chainsSeq[chainid][i].name;
                  }
               }

               //var text = $("#" + ic.pre + "track_text").val();
               let url = me.htmlCls.baseUrl + 'pwaln/pwaln.fcgi?from=track';
               let dataObj = {'targets': targets, 'queries': fasta};
               let data = await me.getAjaxPostPromise(url, dataObj);

               thisClass.alignSequenceToStructure(chainid, data, title);
            });

            // MSA 
            me.myEventCls.onIds("#" + ic.pre + "addtrack_button2b", "click", async function(e) { let ic = thisClass.icn3d;
               e.stopImmediatePropagation();
               //e.preventDefault();
               dialog.dialog( "close" );

               let chainid = $("#" + ic.pre + "track_chainid").val();
               let startpos = $("#" + ic.pre + "fasta_startpos").val();
               if(!startpos) startpos = 1;

               let colorseqby = $("#" + ic.pre + "colorseqby").val();
               let type =(colorseqby == 'identity') ? 'identity' : 'custom';

               let fastaList = $("#" + ic.pre + "track_fastaalign").val();

               if(fastaList) {
                    await thisClass.addMsaTracks(chainid, startpos, type, fastaList);
                }
            });

            // Gene table
            me.myEventCls.onIds("#" + ic.pre + "exons_table", "click", async function(e) { let ic = thisClass.icn3d;
                e.stopImmediatePropagation();
                //dialog.dialog( "close" );

                let geneid = $("#" + ic.pre + "track_geneid").val().trim();
                window.open('https://www.ncbi.nlm.nih.gov/gene/' + geneid + '?report=gene_table', '_blank');
            });

            // Isoform Alignment
            me.myEventCls.onIds("#" + ic.pre + "addtrack_button2c", "click", async function(e) { thisClass.icn3d;
                e.stopImmediatePropagation();
                //e.preventDefault();
                dialog.dialog( "close" );

                await thisClass.addExonTracksWrap();
            });

            // BED file
            me.myEventCls.onIds("#" + ic.pre + "addtrack_button3", "click", function(e) { let ic = thisClass.icn3d;
               e.stopImmediatePropagation();
               //e.preventDefault();
               dialog.dialog( "close" );

               let chainid = $("#" + ic.pre + "track_chainid").val();


               let file = $("#" + ic.pre + "track_bed")[0].files[0];

               if(!file) {
                 alert("Please select a file...");
               }
               else {
                 if(!window.File || !window.FileReader || !window.FileList || !window.Blob) {
                    alert('The File APIs are not fully supported in this browser.');
                 }

                 let reader = new FileReader();
                 reader.onload = function(e) {
                   let dataStr = e.target.result; // or = reader.result;

                   let lineArray = dataStr.split('\n');

                   let bItemRgb = false, bColorByStrand = false;
                   let strandRgbArray;
                   for(let i = 0, il = lineArray.length; i < il; ++i) {
                       if(lineArray[i].substr(0, 7) == 'browser') continue;

                       if(lineArray[i].substr(0, 5) == 'track') {
                           if(lineArray[i].toLowerCase().indexOf('itemrgb') != -1) bItemRgb = true;
                           if(lineArray[i].toLowerCase().indexOf('colorbystrand=') != -1) {
                               bColorByStrand = true;

                               //e.g., colorByStrand="255,0,0 0,0,255"
                               let pos = lineArray[i].toLowerCase().indexOf('colorbystrand=');
                               let restStr = lineArray[i].substr(pos);
                               let quotePos = restStr.indexOf('"');
                               if(quotePos != -1) {
                                 let quoteStr = restStr.substr(quotePos + 1);
                                 let quotePos2 = quoteStr.indexOf('"');
                                 if(quotePos != -1) {
                                   let colorList = quoteStr.substr(0, quotePos2);
                                   strandRgbArray = colorList.split(' ');
                                 }
                               }

                           }
                       }
                       else { // tracks
                              if(lineArray[i] == '') continue;
                              let fieldArray = lineArray[i].replace(/\s+/g, ' ').split(' ');

                              if(fieldArray.length > 8 || fieldArray.length < 6) bColorByStrand = false;
                              if(fieldArray.length < 9) bItemRgb = false;

                              //https://genoic.ucsc.edu/FAQ/FAQformat.html#format1
                              fieldArray[0];
                              let chromStart = fieldArray[1];
                              let chromEnd = fieldArray[2];
                              let trackName = fieldArray[3];

                              let strand, itemRgb;

                              if(fieldArray.length > 4) ;
                              if(fieldArray.length > 5) strand = fieldArray[5]; // ., +, or -
                              if(fieldArray.length > 6) ;
                              if(fieldArray.length > 7) ;
                              if(fieldArray.length > 8) itemRgb = fieldArray[8];
                              if(fieldArray.length > 9) ;
                              if(fieldArray.length > 10) ;
                              if(fieldArray.length > 11) ;

                           let title = trackName;

                           let rgbColor = '51,51,51';
                           if(bItemRgb) {
                               rgbColor = itemRgb;
                           }
                           else if(bColorByStrand) {
                               if(strand == '+' && strandRgbArray.length > 0) {
                                   rgbColor = strandRgbArray[0];
                               }
                               else if(strand == '-' && strandRgbArray.length > 1) {
                                   rgbColor = strandRgbArray[1];
                               }
                               else if(strand == '.' && strandRgbArray.length > 2) {
                                   rgbColor = strandRgbArray[2];
                               }
                           }

                           let text = '';
                           let cssColorArray = [];
                           for(let j = 0, jl = chromEnd; j < jl; ++j) {
                               if(j < chromStart) {
                                   text += '-';
                                   cssColorArray.push('');
                               }
                               else {
                                   text += ic.giSeq[chainid][j];
                                   cssColorArray.push('rgb(' + rgbColor + ')');
                               }
                           }

                           thisClass.showNewTrack(chainid, title, text, cssColorArray, undefined, undefined, rgbColor);

                           me.htmlCls.clickMenuCls.setLogCmd("add track | chainid " + chainid + " | title " + title + " | text " + thisClass.simplifyText(text) + " | type bed | color " + rgbColor, true);
                       }
                   }
                 };

                 reader.readAsText(file);
               }
            });

            // custom
            me.myEventCls.onIds("#" + ic.pre + "addtrack_button4", "click", function(e) { let ic = thisClass.icn3d;
               e.stopImmediatePropagation();
               //e.preventDefault();
               dialog.dialog( "close" );

               let chainid = $("#" + ic.pre + "track_chainid").val();
               let title = $("#" + ic.pre + "track_title").val();
               let text = $("#" + ic.pre + "track_text").val(); // input simplifyText

               //this.showNewTrack(chainid, title, text);
               //me.htmlCls.clickMenuCls.setLogCmd("add track | chainid " + chainid + " | title " + title + " | text " + this.simplifyText(text), true);
               let result = thisClass.getFullText(text);

               thisClass.showNewTrack(chainid, title,  result.text, undefined, undefined, 'custom', undefined, undefined, result.fromArray, result.toArray);

               me.htmlCls.clickMenuCls.setLogCmd("add track | chainid " + chainid + " | title " + title + " | text " + thisClass.simplifyText(text) + " | type custom", true);
            });

            // current selection
            me.myEventCls.onIds("#" + ic.pre + "addtrack_button5", "click", function(e) { let ic = thisClass.icn3d;
               e.stopImmediatePropagation();
               //e.preventDefault();
               dialog.dialog( "close" );

               let chainid = $("#" + ic.pre + "track_chainid").val();
               let title = $("#" + ic.pre + "track_selection").val();
               let text = '';

               let selectedAtoms = me.hashUtilsCls.intHash(ic.hAtoms, ic.chains[chainid]);

               let residueHash = ic.firstAtomObjCls.getResiduesFromCalphaAtoms(selectedAtoms);

               let cssColorArray = [];
               for(let i = 0, il = ic.giSeq[chainid].length; i < il; ++i) {
                  let cFull = ic.giSeq[chainid][i];

                  let c = cFull;
                  if(cFull.length > 1) {
                      //c = cFull[0] + '..';
                      c = cFull[0]; // one letter for each residue
                  }

                  //let pos =(i >= ic.matchedPos[chainid] && i - ic.matchedPos[chainid] < ic.chainsSeq[chainid].length) ? ic.chainsSeq[chainid][i - ic.matchedPos[chainid]].resi : ic.baseResi[chainid] + 1 + i;
                  let pos = ic.ParserUtilsCls.getResi(chainid, i);

                  if( residueHash.hasOwnProperty(chainid + '_' + pos) ) {
                      let atom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[chainid + '_' + pos]);
                      let colorStr =(atom.color === undefined || atom.color.getHexString().toUpperCase() === 'FFFFFF') ? 'DDDDDD' : atom.color.getHexString();
                      let color =(atom.color !== undefined) ? colorStr : "CCCCCC";

                      text += c;
                      cssColorArray.push('#' + color);
                  }
                  else {
                      text += '-';
                      cssColorArray.push('');
                  }
               }

               thisClass.showNewTrack(chainid, title, text, cssColorArray, undefined, 'selection', undefined);

               me.htmlCls.clickMenuCls.setLogCmd("add track | chainid " + chainid + " | title " + title + " | text " + thisClass.simplifyText(text) + " | type selection", true);
            });

        }

        showNewTrack(chnid, title, text, cssColorArray, inTarget2queryHash, type, color, bMsa, fromArray, toArray, seqStartLen, exonArray, offsetArray) {  let ic = this.icn3d, me = ic.icn3dui;
            //if(ic.customTracks[chnid] === undefined) {
            //    ic.customTracks[chnid] = {}
            //}

            let bErrorMess = false;
            if(text == 'cannot be aligned') {
                bErrorMess = true;
            }

            let textForCnt = text.replace(/-/g, '');
            let resCnt = textForCnt.length;
            //if(resCnt > ic.giSeq[chnid].length) {
            //    resCnt = ic.giSeq[chnid].length;
            //}

            if(!bMsa) {
                if(text.length > ic.giSeq[chnid].length) {
                    text = text.substr(0, ic.giSeq[chnid].length);
                }
                else if(text.length < ic.giSeq[chnid].length && !bErrorMess) {
                    // .fill is not supported in IE
                    //var extra = Array(ic.giSeq[chnid].length - text.length).fill(' ').join('');
                    let extra = '';
                    for(let i = 0, il = ic.giSeq[chnid].length - text.length; i < il; ++i) {
                        extra += '-';
                    }

                    text += extra;
                }
            }

            let simpTitle = title.replace(/\s/g, '_').replace(/\./g, 'dot').replace(/\W/g, '');
            if(simpTitle.length > 20) simpTitle = simpTitle.substr(0, 20);

            //ic.customTracks[chnid][simpTitle] = text;

            let divLength = me.htmlCls.RESIDUE_WIDTH * text.length + 200;

            $("#" + ic.pre + "dt_custom_" + chnid).append("<div id='" + ic.pre + "dt_custom_" + chnid + "_" + simpTitle + "'></div>");
            $("#" + ic.pre + "dt_custom_" + chnid + "_" + simpTitle).width(divLength);

            $("#" + ic.pre + "ov_custom_" + chnid).append("<div id='" + ic.pre + "ov_custom_" + chnid + "_" + simpTitle + "'></div>");
            $("#" + ic.pre + "ov_custom_" + chnid + "_" + simpTitle).width(divLength);

            $("#" + ic.pre + "tt_custom_" + chnid).append("<div id='" + ic.pre + "tt_custom_" + chnid + "_" + simpTitle + "'></div>");
            $("#" + ic.pre + "tt_custom_" + chnid + "_" + simpTitle).width(divLength);

            // let html = '<div id="' + ic.pre + 'giseq_sequence" class="icn3d-dl_sequence">';
            let html = '<div class="icn3d-dl_sequence">';
            let htmlExon = html;
            let html2 = html;
            let html3 = html;
            let html3Exon = html;

            //var htmlTmp2 = '<div class="icn3d-seqTitle icn3d-link icn3d-blue" gi="' + chnid + '" anno="sequence" chain="' + chnid + '"><span style="white-space:nowrap;">' + title + '</span></div>';
            //var htmlTmp2 = '<div class="icn3d-seqTitle" gi="' + chnid + '" anno="sequence" chain="' + chnid + '"><span style="white-space:nowrap;">' + title + '</span></div>';
            let index = parseInt(Math.random()*10);
            let htmlTmp2 = '<div class="icn3d-seqTitle icn3d-link icn3d-blue" custom="' +(index+1).toString() + '" from="' + fromArray + '" to="' + toArray + '" shorttitle="' + simpTitle + '" index="' + index + '" setname="' + chnid + '_custom_' +(index+1).toString() + '" anno="sequence" chain="' + chnid + '" title="' + title + '">' + simpTitle + ' </div>';
            let htmlTmp2Exon = '<div class="icn3d-seqTitle" chain="' + chnid + '" title="Exons of ' + title + '">Exons </div>';

            let htmlTmp3 = '<span class="icn3d-residueNum" title="residue count">' + resCnt.toString() + ' Pos</span>';

            html3 += htmlTmp2 + htmlTmp3 + '<br>';
            html3Exon += htmlTmp2Exon + htmlTmp3 + '<br>';

            let htmlTmp = '<span class="icn3d-seqLine">';

            html += htmlTmp2 + htmlTmp3 + htmlTmp;
            htmlExon += htmlTmp2Exon + htmlTmp3 + htmlTmp;
            html2 += htmlTmp2 + htmlTmp3 + htmlTmp;
            
            //var pre ='cst' + ic.customTracks[chnid].length;
            let posTmp = chnid.indexOf('_');
            //var pre ='cst' + chnid.substr(posTmp);
            let pre ='cst' + chnid.substr(posTmp + 1);

            let prevEmptyWidth = 0;
            let prevLineWidth = 0;
            let widthPerRes = 1;

            let bAlignColor =(type === undefined || type === 'seq' || type === 'custom') && text.indexOf('cannot-be-aligned') == -1 && text.indexOf('cannot be aligned') == -1 ? true : false;

            let bIdentityColor =(type === 'identity') && text.indexOf('cannot-be-aligned') == -1 && text.indexOf('cannot be aligned') == -1 ? true : false;

            let parsedResn = {};
            let gapCnt = 0;
            htmlTmp2 = '';

            // if(ic.seqStartLen && ic.seqStartLen[chnid]) html2 += ic.showSeqCls.insertMulGapOverview(chnid, ic.seqStartLen[chnid]);
            // if(ic.seqStartLen && ic.seqStartLen[chnid]) html += ic.showSeqCls.insertMulGap(ic.seqStartLen[chnid], '-');

            let pos2exonColor = {}, pos2genome = {}, pos2exonIndex = {};
            let cnt = 0;
            if(exonArray) {
                for(let j = 0, jl = exonArray.length; j < jl; ++j) {
                    let start = exonArray[j].resStart, end = exonArray[j].resEnd;
                    let genStart = parseInt(exonArray[j].genomeRange.split('-')[0]);

                    for(let k = 0, kl = end - start + 1; k < kl; ++k) {
                        let colorStr = this.getExonColor(start, end, cnt);

                        pos2exonColor[cnt] = colorStr;
                        pos2genome[cnt] = (genStart + ic.exonOrder * k*3) + '-' + (genStart + ic.exonOrder * k*3 + ic.exonOrder * 2); // reverse order from large to small
                        pos2exonIndex[cnt] = j;

                        ++cnt;
                    }
                }
            }

            cnt = 0;
            for(let i = 0, il = text.length; i < il; ++i) {
              let resNum = i - gapCnt - ((ic.seqStartLen && ic.seqStartLen[chnid]) ? ic.seqStartLen[chnid] : 0);

              if(!bMsa) {
                  html += ic.showSeqCls.insertGap(chnid, i, '-');
              }
              else {
                  if(ic.targetGapHash.hasOwnProperty(resNum) && !parsedResn.hasOwnProperty(resNum)) {
                      gapCnt += ic.targetGapHash[resNum].to - ic.targetGapHash[resNum].from + 1;

                      parsedResn[resNum] = 1;
                  }
              }

              let c = text.charAt(i);

              if(c != ' ' && c != '-') {
                  let resName =(ic.chainsSeq[chnid][resNum]) ? ic.chainsSeq[chnid][resNum].name : ' ';
                  let colorHexStr = ic.showAnnoCls.getColorhexFromBlosum62(c, resName);
                  let identityColorStr =(c == resName) ? 'FF0000' : '0000FF';

                  //var pos =(resNum >= ic.matchedPos[chnid] && resNum - ic.matchedPos[chnid] < ic.chainsSeq[chnid].length) ? ic.chainsSeq[chnid][resNum - ic.matchedPos[chnid]].resi : ic.baseResi[chnid] + 1 + resNum;
                  //   let pos = ic.baseResi[chnid] + currResi;
                  let pos = ic.baseResi[chnid] + (i+1) - ((ic.seqStartLen && ic.seqStartLen[chnid]) ? ic.seqStartLen[chnid] : 0);

                  if(inTarget2queryHash !== undefined) pos = ic.baseResi[chnid] + inTarget2queryHash[i] + 1; // 0-based

                  let tmpStr;
                  if(cssColorArray !== undefined && cssColorArray[i] != '') {
                      tmpStr = 'style="color:' + cssColorArray[i] + '"';
                  }
                  else if(color) {
                      tmpStr = 'style="color:rgb(' + color + ')"';
                  }
                  else if(bAlignColor || type == 'seq') {
                      tmpStr = 'style="color:#' + colorHexStr + '"';

                      if(type == 'seq') { // reset the color of atoms
                          for(let serial in ic.residues[chnid + '_' + pos]) {
                              let color2 = me.parasCls.thr("#" + colorHexStr);
                              ic.atoms[serial].color = color2;
                              ic.atomPrevColors[serial] = color2;
                          }
                      }
                  }
                  else if(bIdentityColor) {
                      tmpStr = 'style="color:#' + identityColorStr + '"';
                  }
                  else {
                      tmpStr = '';
                  }

                  html += '<span id="' + pre + '_' + ic.pre + chnid + '_' + pos + '" title="' + c + pos + '" class="icn3d-residue" ' + tmpStr + '>' + c + '</span>';

                  if(exonArray) {
                    let tmpStrExon = 'style="background-color:' + pos2exonColor[cnt] + '"';
                    htmlExon += '<span id="' + pre + '_' + ic.pre + chnid + '_' + pos + '" title="' + c + pos + ', Exon ' + (pos2exonIndex[cnt] + 1) + ': ' + pos2genome[cnt] + '" class="icn3d-residue" ' + tmpStrExon + '>&nbsp;</span>';

                    // set atom color
                    for(let serial in ic.residues[chnid + '_' + pos]) {
                        let atom = ic.atoms[serial];
                        atom.color = me.parasCls.thr(pos2exonColor[cnt]);
                        ic.atomPrevColors[serial] = atom.color;
                    }
                  }

                  htmlTmp2 += ic.showSeqCls.insertGapOverview(chnid, i);

                //   let emptyWidth =(me.cfg.blast_rep_id == chnid) ? Math.round(ic.seqAnnWidth * i /(ic.maxAnnoLength + ic.nTotalGap) - prevEmptyWidth - prevLineWidth) : Math.round(ic.seqAnnWidth * i / ic.maxAnnoLength - prevEmptyWidth - prevLineWidth);
                  let emptyWidth = Math.round(ic.seqAnnWidth * i /(ic.maxAnnoLength + ic.nTotalGap) - prevEmptyWidth - prevLineWidth);
                  if(emptyWidth < 0) emptyWidth = 0;

                  htmlTmp2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';
                  if(cssColorArray !== undefined && cssColorArray[i] != '') {
                      tmpStr = cssColorArray[i];
                  }
                  else if(color) {
                      tmpStr = 'rgb(' + color + ')';
                  }
                  else if(bAlignColor) {
                      tmpStr = '#' + colorHexStr;
                  }
                  else {
                      tmpStr = '#333';
                  }

                  htmlTmp2 += '<div style="display:inline-block; background-color:' + tmpStr + '; width:' + widthPerRes + 'px;" title="' + c +(i+1).toString() + '">&nbsp;</div>';

                  prevEmptyWidth += emptyWidth;
                  prevLineWidth += widthPerRes;
                  ++cnt;
              }
              else {
                  if(bErrorMess) {
                    html += '<span>' + c + '</span>';
                  }
                  else {
                    html += '<span>-</span>';
                    htmlExon += '<span></span>';
                  }
              }
            }

            // if(ic.seqStartLen && ic.seqStartLen[chnid]) html += ic.showSeqCls.insertMulGap(ic.seqEndLen[chnid], '-');

            if(fromArray !== undefined) {
                htmlTmp2 = '';
                let fromArray2 = [], toArray2 = [], offsetArray2 = [];
                for(let i = 0, il = fromArray.length; i < il; ++i) {
                    fromArray2.push(fromArray[i]);
                    offsetArray2.push(offsetArray[i]);

                    for(let j = parseInt(fromArray[i]); j <= parseInt(toArray[i]); ++j) {
                        if(ic.targetGapHash !== undefined && ic.targetGapHash.hasOwnProperty(j)) {
                            toArray2.push(j - 1);
                            fromArray2.push(j);
                            offsetArray2.push(offsetArray[i]);
                        }
                    }

                    toArray2.push(toArray[i]);
                }

                ic.nTotalGap = 0;
                for(let i in ic.targetGapHash) {
                    ic.nTotalGap += ic.targetGapHash[i].to - ic.targetGapHash[i].from + 1;
                }

                let atom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.chains[chnid]);
                let colorStr =(atom.color === undefined || atom.color.getHexString() === 'FFFFFF') ? 'DDDDDD' : atom.color.getHexString();
                let color =(atom.color !== undefined) ? colorStr : "CCCCCC";

                let cnt, prevCntTotal = 0;
                for(let i = 0, il = fromArray2.length; i < il; ++i) {
                    htmlTmp2 += ic.showSeqCls.insertGapOverview(chnid, fromArray2[i]);

                    let initialPos = (seqStartLen) ? fromArray2[i] : fromArray2[i] - ic.baseResi[chnid] - 1;

                    let emptyWidth =(i == 0) ? Math.round(ic.seqAnnWidth * initialPos /(ic.maxAnnoLength + ic.nTotalGap)) : Math.round(ic.seqAnnWidth *(fromArray2[i] - toArray2[i-1] - 1) /(ic.maxAnnoLength + ic.nTotalGap));
                    if(emptyWidth < 0) emptyWidth = 0;

                    htmlTmp2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';

                    if(!exonArray) {
                        htmlTmp2 += '<div style="display:inline-block; color:white!important; font-weight:bold; background-color:#' + color + '; width:' + Math.round(ic.seqAnnWidth *(toArray2[i] - fromArray2[i] + 1) /(ic.maxAnnoLength + ic.nTotalGap)) + 'px;" class="icn3d-seqTitle icn3d-link icn3d-blue" custom="' +(index+1).toString() + '" from="' + fromArray2 + '" to="' + toArray2 + '" shorttitle="' + simpTitle + '" index="' + index + '" setname="' + chnid + '_custom_' +(index+1).toString() + '" id="' + chnid + '_custom_' + index + '" anno="sequence" chain="' + chnid + '" title="' + title + '">' + title + '</div>';
                    }
                    else {
                        // determine how this range sits in the exon ranges in exonArray
                        let startExon, endExon;
                        
                        let offset = offsetArray2[i];
                        cnt = toArray[i] - fromArray[i] + 1;
                        let from = prevCntTotal, to = prevCntTotal + cnt - 1;

                        prevCntTotal += cnt;

                        // fromArray2 was adjusted with gaps, no gaps in this case
                        // let offset = fromArray2[i] - fromArray[i];
                        // let emptyWidth = Math.round(ic.seqAnnWidth * offset /(ic.maxAnnoLength + ic.nTotalGap));
                        // htmlTmp2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';

                        for(let j = 0, jl = exonArray.length; j < jl; ++j) {
                            let start = exonArray[j].resStart, end = exonArray[j].resEnd;

                            if(from >= start && from <= end) {
                                startExon = {exonIndex: j, rangeStart: start, rangeEnd: end, from: from, genomeRange: exonArray[j].genomeRange};
                            }

                            if(to >= start && to <= end) {
                                endExon = {exonIndex: j, rangeStart: start, rangeEnd: end, to: to, genomeRange: exonArray[j].genomeRange};
                            }
                        }

                        let startColorStr, endColorStr, colorGradient;
                        if(startExon && endExon && startExon.exonIndex == endExon.exonIndex) { // 
                            startColorStr = this.getExonColor(startExon.rangeStart, startExon.rangeEnd, from);
                            endColorStr = this.getExonColor(startExon.rangeStart, startExon.rangeEnd, to);

                            colorGradient = startColorStr + ' 0%, #FFF 50%, ' + endColorStr + ' 100%';
                            htmlTmp2 += this.getExonHtml(startExon.exonIndex, colorGradient, startExon.from, endExon.to, startExon.genomeRange, chnid, simpTitle, offset);
                        }
                        else {
                            if(startExon) {
                                startColorStr = this.getExonColor(startExon.rangeStart, startExon.rangeEnd, from);

                                colorGradient = startColorStr + ' 0%, #FFF 50%, #00F 100%';
                                htmlTmp2 += this.getExonHtml(startExon.exonIndex, colorGradient, startExon.from, startExon.rangeEnd, startExon.genomeRange, chnid, simpTitle, offset);
                            }

                            if(startExon && endExon) {
                                for(let j = startExon.exonIndex + 1; j < endExon.exonIndex; ++j) {
                                    colorGradient = '#F00 0%, #FFF 50%, #00F 100%';
                                    htmlTmp2 += this.getExonHtml(j, colorGradient, exonArray[j].resStart, exonArray[j].resEnd, exonArray[j].genomeRange, chnid, simpTitle, offset);
                                }

                                endColorStr = this.getExonColor(endExon.rangeStart, endExon.rangeEnd, to);

                                colorGradient = '#F00 0%, #FFF 50%, ' + endColorStr + ' 100%';
                                htmlTmp2 += this.getExonHtml(endExon.exonIndex, colorGradient, endExon.rangeStart, endExon.to, endExon.genomeRange, chnid, simpTitle, offset);
                            }
                        }

                        //htmlTmp2 += '<div style="display:inline-block; color:white!important; font-weight:bold; background-color:#' + color + '; width:' + Math.round(ic.seqAnnWidth *(toArray2[i] - fromArray2[i] + 1) /(ic.maxAnnoLength + ic.nTotalGap)) + 'px;" class="icn3d-seqTitle icn3d-link icn3d-blue" custom="' +(index+1).toString() + '" from="' + fromArray2 + '" to="' + toArray2 + '" shorttitle="' + simpTitle + '" index="' + index + '" setname="' + chnid + '_custom_' +(index+1).toString() + '" id="' + chnid + '_custom_' + index + '" anno="sequence" chain="' + chnid + '" title="' + title + '">' + title + '</div>';
                    }
                }
            }

            htmlTmp = '<span class="icn3d-residueNum" title="residue count">' + resCnt.toString() + ' Pos</span>';
            htmlTmp += '</span>';
            htmlTmp += '<br>';

            htmlTmp += '</div>';

            html += htmlTmp;
            html2 += htmlTmp2 + htmlTmp;
            htmlExon += htmlTmp;

            html3 += '</div>';
            html3Exon += '</div>';

            if(!exonArray) {
                $("#" + ic.pre + "dt_custom_" + chnid + "_" + simpTitle).html(html);
                $("#" + ic.pre + "ov_custom_" + chnid + "_" + simpTitle).html(html2);
                $("#" + ic.pre + "tt_custom_" + chnid + "_" + simpTitle).html(html3);
            }
            else {
                $("#" + ic.pre + "dt_custom_" + chnid + "_" + simpTitle).html(htmlExon + html);
                $("#" + ic.pre + "ov_custom_" + chnid + "_" + simpTitle).html(html2);
                $("#" + ic.pre + "tt_custom_" + chnid + "_" + simpTitle).html(html3Exon + html3);      
            }
        }

        getExonHtml(exonIndex, colorGradient, from, to, genomeRange, chainid, simpTitle, offset) { let ic = this.icn3d; ic.icn3dui;
            return '<div style="display:inline-block; color:white!important; width:' + Math.round(ic.seqAnnWidth *(to - from + 1) /(ic.maxAnnoLength + ic.nTotalGap)) + 'px;" class="icn3d-seqTitle icn3d-link icn3d-blue" domain="' + (exonIndex + 1) + '" from="' + (from + offset) + '" to="' + (to + offset) + '" setname="' + simpTitle + ', ' + (exonIndex + 1) + '" title="Exon: ' + genomeRange + ' genomic interval" anno="sequence" chain="' + chainid + '"><div style="height: 12px; border: 1px solid #000; background: linear-gradient(to right, ' + colorGradient + ');"></div></div>';
        }

        getExonColor(start, end, pos) { let ic = this.icn3d; ic.icn3dui;
            let middle = ( start + end) * 0.5;
            if(pos < middle) {
                let gb = parseInt((pos - start) / (middle - start) * 255);
                return "rgb(255, " + gb + ", " + gb + ")";
            }
            else {
                let rg = parseInt((end - pos) / (end - middle) * 255);
                return "rgb(" + rg + ", " + rg + ", 255)";
            }
        }

        alignSequenceToStructure(chainid, data, title) { let ic = this.icn3d, me = ic.icn3dui;
          let query, target, firstKey;

          if(data.data !== undefined) {
              query = data.data[0].query;
              //target = data.data[0].targets[chainid.replace(/_/g, '')];
              //target = data.data[0].targets[chainid];
              firstKey = Object.keys(data.data[0].targets)[0];
              target = data.data[0].targets[firstKey];

              target = target.hsps[0];
          }

          let text = '';

          let cssColorArray = [];
          let target2queryHash = {};
          if(query !== undefined && target !== undefined) {
              let evalue = target.scores.e_value.toPrecision(2);
              if(evalue > 1e-200) evalue = parseFloat(evalue).toExponential();

              target.scores.bit_score;

              //var targetSeq = data.targets[chainid.replace(/_/g, '')].seqdata;
              //let targetSeq = data.targets[chainid].seqdata;
              let targetSeq = data.targets[firstKey].seqdata;
              let querySeq = query.seqdata;

              let segArray = target.segs;
              for(let i = 0, il = segArray.length; i < il; ++i) {
                  let seg = segArray[i];
                  for(let j = 0; j <= seg.orito - seg.orifrom; ++j) {
                      target2queryHash[j + seg.orifrom] = j + seg.from;
                  }
              }

              // the missing residues at the end of the seq will be filled up in the API showNewTrack()
              for(let i = 0, il = targetSeq.length; i < il; ++i) {
                  if(target2queryHash.hasOwnProperty(i)) {
                      text += querySeq[target2queryHash[i]];

                      let colorHexStr = ic.showAnnoCls.getColorhexFromBlosum62(targetSeq[i], querySeq[target2queryHash[i]]);
                      cssColorArray.push("#" + colorHexStr);

                    //   let resi =  ic.baseResi[chainid] + 1 + i; //i + 1;
                      let resi =  ic.ParserUtilsCls.getResi(chainid, i);
                      for(let serial in ic.residues[chainid + '_' + resi]) {
                          let color = me.parasCls.thr("#" + colorHexStr);
                          ic.atoms[serial].color = color;
                          ic.atomPrevColors[serial] = color;
                      }
                  }
                  else {
                      text += '-';
                      cssColorArray.push("");
                  }
              }

              title += ', E: ' + evalue;
          }
          else {
              text += "cannot be aligned";
          }

          this.showNewTrack(chainid, title, text, cssColorArray, target2queryHash, 'seq');

          ic.hlUpdateCls.updateHlAll();
          ic.drawCls.draw();

          me.htmlCls.clickMenuCls.setLogCmd("add track | chainid " + chainid + " | title " + title + " | text " + this.simplifyText(text) + " | type seq", true);
        }

        defineSecondary(chainid, type) { let ic = this.icn3d, me = ic.icn3dui;
            if(!$('#' + ic.pre + 'dl_definedsets').hasClass('ui-dialog-content') || !$('#' + ic.pre + 'dl_definedsets').dialog( 'isOpen' )) {
                me.htmlCls.dialogCls.openDlg('dl_definedsets', 'Select sets');
                $("#" + ic.pre + "atomsCustom").resizable();
            }

            let selectedResidues = {};
            let bUnion = false, bUpdateHighlight = true;

            let helixCnt = 0, sheetCnt = 0;
            //var prevName = chainid + zero + index + '_L(N', currName, setName;
            let prevName = chainid + '_C(Nterm', currName, setName;

            // clear selection
            ic.hAtoms = {};

            for(let i = 0, il = ic.chainsSeq[chainid].length; i < il; ++i) {
              let currResi = ic.chainsSeq[chainid][i].resi;

              // name of secondary structures
              let residueid = chainid + '_' + currResi;

              if( ic.residues.hasOwnProperty(residueid) ) {
                let atom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[residueid]);
                let currSS = ic.secondaries[residueid];

                if(currSS == 'H') {
                    if(atom.ssbegin) {
                        ++helixCnt;

                        if(Object.keys(selectedResidues).length > 0) {
                            setName = currName + 'H' + helixCnt.toString().padStart(2, '0') + ')';
                            if(type == 'coil') {
                                ic.selectionCls.selectResidueList(selectedResidues, setName, setName, bUnion, bUpdateHighlight);
                                if(!bUnion) bUnion = true;
                            }
                            selectedResidues = {};
                        }
                    }

                    //zero =(index < 10) ? '0' : '';
                    //currName = chainid + zero + index + '_H' + helixCnt;
                    currName = chainid + '_H' + helixCnt.toString().padStart(2, '0');
                    selectedResidues[residueid] = 1;

                    if(atom.ssend) {
                        //zero =(index < 9) ? '0' : '';
                        //prevName = chainid + zero +(index+1) + '_L(H' + helixCnt;
                        prevName = chainid + '_C(H' + helixCnt.toString().padStart(2, '0');
                        if(type == 'helix') {
                            ic.selectionCls.selectResidueList(selectedResidues, currName, currName, bUnion, bUpdateHighlight);
                            if(!bUnion) bUnion = true;
                        }
                        selectedResidues = {};
                    }
                }
                else if(currSS == 'E') {
                    if(atom.ssbegin) {
                        ++sheetCnt;

                        if(Object.keys(selectedResidues).length > 0) {
                            setName = currName + 'S' + sheetCnt.toString().padStart(2, '0') + ')';
                            if(type == 'coil') {
                                ic.selectionCls.selectResidueList(selectedResidues, setName, setName, bUnion, bUpdateHighlight);
                                if(!bUnion) bUnion = true;
                            }
                            selectedResidues = {};
                        }
                    }

                    //zero =(index < 10) ? '0' : '';
                    //currName = chainid + zero + index + '_S' + sheetCnt;
                    currName = chainid + '_S' + sheetCnt.toString().padStart(2, '0');
                    selectedResidues[residueid] = 1;

                    if(atom.ssend) {
                        //zero =(index < 9) ? '0' : '';
                        //prevName = chainid + zero +(index+1) + '_L(S' + sheetCnt;
                        prevName = chainid + '_C(S' + sheetCnt.toString().padStart(2, '0');
                        if(type == 'sheet') {
                            ic.selectionCls.selectResidueList(selectedResidues, currName, currName, bUnion, bUpdateHighlight);
                            if(!bUnion) bUnion = true;
                        }
                        selectedResidues = {};
                    }
                }
                else {
                    currName = prevName + '-';
                    selectedResidues[residueid] = 1;
                }
              } // end if( ic.residues.hasOwnProperty(residueid) ) {
            } // for loop

            if(Object.keys(selectedResidues).length > 0) {
                setName = currName + 'Cterm)';
                if(type == 'coil') {
                    ic.selectionCls.selectResidueList(selectedResidues, setName, setName, bUnion, bUpdateHighlight);
                }
            }
        }

        // type: igstrand, igloop
        defineIgstrand(chainid, type) { let ic = this.icn3d, me = ic.icn3dui;       
            if(!$('#' + ic.pre + 'dl_definedsets').hasClass('ui-dialog-content') || !$('#' + ic.pre + 'dl_definedsets').dialog( 'isOpen' )) {
                me.htmlCls.dialogCls.openDlg('dl_definedsets', 'Select sets');
                $("#" + ic.pre + "atomsCustom").resizable();
            }

            let selectedResidues = {};
            let bUnion = false, bUpdateHighlight = true;

            // clear selection
            ic.hAtoms = {};

            if(type == 'igdomain') {
                let igArray = ic.chain2igArray[chainid];

                if(igArray && igArray.length > 0) {
                    
                    for(let i = 0, il = igArray.length; i < il; ++i) {
                        let startPos = igArray[i].startPos;
                        let endPos = igArray[i].endPos;
                        let domainid = igArray[i].domainid;

                        selectedResidues = {};
                        for(let j = parseInt(startPos); j <= parseInt(endPos); ++j) {
                            let currResi = ic.chainsSeq[chainid][j].resi;
                            let resid = chainid + '_' + currResi;
                            selectedResidues[resid] = 1;
                        }

                        let setName = domainid;
                        ic.selectionCls.selectResidueList(selectedResidues, setName, setName, bUnion, bUpdateHighlight);
                    }
                }
            }
            else {
                let strandCnt = 0, loopCnt = 0;
                let setName, currStrand, prevStrand, prevStrandReal = 'NT', currType, prevType;

                let bStart = false;

                for(let i = 0, il = ic.chainsSeq[chainid].length; i < il; ++i) {
                    let currResi = ic.chainsSeq[chainid][i].resi;
                    let resid = chainid + '_' + currResi;

                    if(!ic.residues.hasOwnProperty(resid) ) continue;
                
                    let refnumLabel, refnumStr, refnum;
                    refnumLabel = ic.resid2refnum[resid];
                    if(!refnumLabel) continue;

                    refnumStr = ic.refnumCls.rmStrandFromRefnumlabel(refnumLabel);
                    currStrand = refnumLabel.replace(refnumStr, '');
                    refnum = parseInt(refnumStr);

                    if(type == 'iganchor') {
                        if(refnum > 1000 && refnumStr.substr(refnumStr.length - 2, 2) == '50') {
                            selectedResidues[resid] = 1;
                        }
                    } 
                    else {
                        if(ic.residIgLoop.hasOwnProperty(resid)) {
                            currType = 'igloop';
                        }
                        else {
                            currType = 'igstrand';
                        }

                        if(bStart && currType != prevType && Object.keys(selectedResidues).length > 0) {
                            if(prevType == 'igstrand') {
                                ++strandCnt;
                                setName = 'Strand-' + prevStrand + '-' + chainid + '-' + strandCnt.toString().padStart(3, '0');
                                setName = setName.replace(/'/g, '`');
                                if(type == 'igstrand') {
                                    ic.selectionCls.selectResidueList(selectedResidues, setName, setName, bUnion, bUpdateHighlight);
                                    if(!bUnion) bUnion = true;
                                }
                                prevStrandReal = prevStrand;
                            }
                            else if(prevType == 'igloop') {
                                ++loopCnt;
                                setName = 'Loop-' + prevStrandReal + '_' + currStrand + '-' + chainid + '-' + loopCnt.toString().padStart(3, '0');
                                setName = setName.replace(/'/g, '`');
                                if(type == 'igloop') {
                                    ic.selectionCls.selectResidueList(selectedResidues, setName, setName, bUnion, bUpdateHighlight);
                                    if(!bUnion) bUnion = true;
                                }
                            }

                            selectedResidues = {};
                        }

                        selectedResidues[resid] = 1;

                        prevStrand = currStrand;
                        prevType = currType;

                        bStart = true;
                    }
                } // for loop

                if(type == 'iganchor') {
                    setName = 'Anchor-' + chainid;
                    ic.selectionCls.selectResidueList(selectedResidues, setName, setName, bUnion, bUpdateHighlight);
                }
                else {
                    if(prevType == 'igstrand') {
                        ++strandCnt;
                        setName = 'Strand-' + prevStrand + '-' + chainid + '-' + strandCnt.toString().padStart(3, '0');
                        setName = setName.replace(/'/g, '`');
                        if(type == 'igstrand') ic.selectionCls.selectResidueList(selectedResidues, setName, setName, bUnion, bUpdateHighlight);
                    }
                    else if(prevType == 'igloop') {
                        ++loopCnt;
                        currStrand = 'CT';
                        setName = 'Loop-' + prevStrandReal + '_' + currStrand + '-' + chainid + '-' + loopCnt.toString().padStart(3, '0');
                        setName = setName.replace(/'/g, '`');
                        if(type == 'igloop') ic.selectionCls.selectResidueList(selectedResidues, setName, setName, bUnion, bUpdateHighlight);
                    }
                }
            }
        }

        simplifyText(text) { let ic = this.icn3d; ic.icn3dui;
            let out = ''; // 1-based text positions
            let bFoundText = false;

            // replace 'undefined' to space
            text = text.replace(/undefined/g, ' ');

            let i, il, prevEmptyPos = -1;
            for(i = 0, il = text.length; i < il; ++i) {
                if(text[i] == '-' || text[i] == ' ') {
                    if(bFoundText && i !== prevEmptyPos) {
                        if(prevEmptyPos+1 == i-1) {
                            out +=(prevEmptyPos+1 + 1).toString() + ' ' + text.substr(prevEmptyPos+1, i - 1 - prevEmptyPos) + ', ';
                       }
                        else {
                            out +=(prevEmptyPos+1 + 1).toString() + '-' +(i-1 + 1).toString() + ' ' + text.substr(prevEmptyPos+1, i - 1 - prevEmptyPos) + ', ';
                        }
                        bFoundText = false;
                    }

                    prevEmptyPos = i;
                }
                else {
                    bFoundText = true;
                }
            }

            if(bFoundText && i == il) {
                if(prevEmptyPos+1 == i-1) {
                    out +=(prevEmptyPos+1 + 1).toString() + ' ' + text.substr(prevEmptyPos+1, i - 1 - prevEmptyPos) + ', ';
                }
                else {
                    out +=(prevEmptyPos+1 + 1).toString() + '-' +(i-1 + 1).toString() + ' ' + text.substr(prevEmptyPos+1, i - 1 - prevEmptyPos) + ', ';
                }
            }

            return out;
        }

        checkGiSeq(chainid, title, text, type, color, bMsa, index) { let ic = this.icn3d; ic.icn3dui;
            let thisClass = this;
            if(index > 20) return false;

            if(ic.giSeq !== undefined && ic.giSeq[chainid] !== undefined) {
                let result = this.getFullText(text);
                text = result.text;
                this.showNewTrack(chainid, title, text, undefined, undefined, type, color, bMsa);

                return false;
            }

            // wait for ic.giSeq to be available
            setTimeout(function(){ thisClass.checkGiSeq(chainid, title, text, type, color, bMsa, index + 1); }, 100);
        }

        getFullText(text) { let ic = this.icn3d; ic.icn3dui;
            let out = '', fromArray = [], toArray = [];

            let textArray = text.split(',');
            let lastTextPos = -1;
            for(let i = 0, il = textArray.length; i < il; ++i) {
                let eachText = textArray[i].trim();
                if(eachText.length == 0) continue;

                let range_text = eachText.split(' ');
                if(range_text.length !== 2) continue;

                let rangeText = range_text[1];
                let start_end = range_text[0].split('-');

                let start, end;
                if(start_end.length == 2) {
                    start = start_end[0] - 1; // 1-based
                    end = start_end[1] - 1;
                }
                else if(start_end.length == 1) {
                    start = start_end[0] - 1;
                    end = start;
                }
                else {
                    continue;
                }

                fromArray.push(start);
                toArray.push(end);

                // previous empty text
                for(let j = 0; j < start - lastTextPos - 1; ++j) {
                    out += '-';
                }

                let range = end - start + 1;

                if(rangeText.length > range) {
                     out += rangeText.substr(0, range);
                }
                else {
                     out += rangeText;
                }

                // fill up rangeText
                for(let j = 0; j < range - rangeText.length; ++j) {
                    out += '-';
                }

                lastTextPos = end;
            }

            return {"text": out, "fromArray": fromArray, "toArray": toArray}
        }

        setCustomFile(type, startColor, midColor, endColor) {var ic = this.icn3d, me = ic.icn3dui;
           let thisClass = this;

           let chainid = $("#" + ic.pre + "customcolor_chainid").val();
           let file = $("#" + ic.pre + "cstcolorfile")[0].files[0];
           if(!file) {
             alert("Please select a file before clicking 'Load'");
           }
           else {
             me.utilsCls.checkFileAPI();
             let reader = new FileReader();
             reader.onload = function(e) { let ic = thisClass.icn3d;
                let dataStr = e.target.result; // or = reader.result;
                let lineArray = dataStr.split('\n');
                if(ic.queryresi2score === undefined) ic.queryresi2score = {};
                //if(ic.queryresi2score[chainid] === undefined) ic.queryresi2score[chainid] = {}
                ic.queryresi2score[chainid] = {};
                for(let i = 0, il = lineArray.length; i < il; ++i) {
                    if(lineArray[i].trim() !== '') {
                        let columnArray = lineArray[i].split(/\s+/);
                        ic.queryresi2score[chainid][columnArray[0]] = columnArray[1];
                    }
                }
                let resiArray = Object.keys(ic.queryresi2score[chainid]);
                let start = Math.min.apply(null, resiArray);
                let end = Math.max.apply(null, resiArray);
                let resiScoreStr = '';
                for(let resi = start; resi <= end; ++resi) {
                    if(ic.queryresi2score[chainid].hasOwnProperty(resi)) {
                        resiScoreStr += Math.round(ic.queryresi2score[chainid][resi]/11); // max 9
                    }
                    else {
                        resiScoreStr += '_';
                    }
                }

                if(type == 'color') {
                    ic.opts['color'] = 'align custom';

                    ic.setColorCls.setColorByOptions(ic.opts, ic.hAtoms);
                    ic.hlUpdateCls.updateHlAll();
                    me.htmlCls.clickMenuCls.setLogCmd('color align custom | ' + chainid + ' | range ' + start + '_' + end + ' | ' + resiScoreStr + ' | colorrange ' + startColor + ' ' + midColor + ' ' + endColor, true);

                    let legendHtml = me.htmlCls.clickMenuCls.setLegendHtml();

                    //$("#" + me.pre + "legend").html(legendHtml);
                    $("#" + me.pre + "dl_legend_html").html(legendHtml);
                    me.htmlCls.dialogCls.openDlg('dl_legend', 'Color range');
                }
                else if(type == 'tube') {
                    ic.setOptionCls.setStyle('proteins', 'custom tube');
                    me.htmlCls.clickMenuCls.setLogCmd('color tube | ' + chainid + ' | range ' + start + '_' + end + ' | ' + resiScoreStr, true);
                }
                ic.drawCls.draw();
             };
             reader.readAsText(file);
           }
        }

        async getMsa(acclist, firstAcc, chainSeq) { let ic = this.icn3d, me = ic.icn3dui;
            let trackTitleArray = [firstAcc], trackSeqArray = [];
            // get all seq
            let url = me.htmlCls.baseUrl + "/vastdyn/vastdyn.cgi?chainlist=" + acclist;
            let data = await me.getAjaxPromise(url, 'jsonp');
            let maxLen = 0, maxIndex = 0, index = 0;
            //let seqArray = [];
            for(let acc in data) {
                let seq = data[acc];
                //seqArray.push(seq);

                let pos = acc.indexOf('.');
                if(pos != -1) {
                    acc = acc.substr(0, pos);
                }
                trackTitleArray.push(acc);

                if(seq.length > maxLen) {
                    maxLen = seq.length;
                    maxIndex = index;
                }
                ++index;
            }
            
            // pairwise align each seq to the one with maxIndex
            url = me.htmlCls.baseUrl + 'pwaln/pwaln.fcgi?from=msa';

            let accArray = acclist.split(',');
            // oroginal index, chain as the first one
            let acc2index = {};
            acc2index[firstAcc] = 0;
            for(let i = 0, il = accArray.length; i < il; ++i) {
                acc2index[accArray[i]] = i + 1;
            }
            let targetId = accArray[maxIndex];
            accArray.splice(maxIndex, 1);

            let queries = (chainSeq) ? chainSeq : firstAcc;
            if(accArray.length > 0) queries += ',' + accArray.join(',');

            let dataObj = {'targets': targetId, 'queries': queries};
            let alignData = await me.getAjaxPostPromise(url, dataObj);

            if(!alignData.data) {
                console.log("The protein accessions " + targetId + "," + queries + " can not be aligned...");
                return;
            }

            // get aligned length for each pair
            let index_alignLen = [];
            ic.qt_start_end = {};
            // target: targetId
            // queries: accArray
            let accArrayFound = [], querySeqArray = [];
            let firstKey = Object.keys(alignData.targets)[0];
            let targetSeq = alignData.targets[firstKey].seqdata;

            //add firstAcc to accArray
            accArray.splice(0, 0, firstAcc);
            
            for(let index = 0, indexl = accArray.length; index < indexl; ++index) {
                let query, target;

                if(!alignData.data[index]) {
                    continue;
                }
            
                query = alignData.data[index].query;
                let acc;
                if(query.acc.length <= 5) { // PDB
                    acc = query.acc.substr(0, 4) + '_' + query.acc.substr(4, 1);
                }
                else {
                    acc = query.acc;
                }

                if(index == 0) acc = firstAcc;

                accArrayFound.push(acc);

                firstKey = Object.keys(alignData.data[index].targets)[0];
                target = alignData.data[index].targets[firstKey];

                target = target.hsps[0];

                querySeqArray.push(query.seqdata);
                let alignLen = target.scores.num_ident * 100 + query.sz; // order by aligned seq length, then seq length

                ic.qt_start_end[index] = [];

                let segArray = target.segs;
                for(let i = 0, il = segArray.length; i < il; ++i) {
                    let seg = segArray[i];
                    let qt_start_end = {t_start: seg.orifrom, t_end: seg.orito, q_start: seg.from, q_end: seg.to};
                    ic.qt_start_end[index].push(qt_start_end);
                }

                index_alignLen.push({index: index, alignLen: alignLen});
            }

            accArray = accArrayFound;

            index_alignLen.sort(function(a,b){
                return b.alignLen - a.alignLen;
            });

            // start and end of MSA
            let start_t = 9999, end_t = -1;
            for(let index = 0, indexl = accArray.length; index < indexl; ++index) { 
                if(!ic.qt_start_end[index]) continue;

                for(let i = 0, il = ic.qt_start_end[index].length; i < il; ++i) {
                    let start1, end1;
                    
                    start1 = ic.qt_start_end[index][i].t_start;
                    end1 = ic.qt_start_end[index][i].t_end;

                    for(let j = start1; j <= end1; ++j) {
                        if(j < start_t) start_t = j;
                        if(j > end_t) end_t = j;
                    }
                }
            }

            // N- and C-terminal residues
            let maxNtermLen = start_t, maxCtermLen = targetSeq.length - (end_t + 1);
            let startArray = [], endArray = [];
            for(let index = 0, indexl = accArray.length; index < indexl; ++index) { 
                if(!ic.qt_start_end[index]) continue;

                let qPos = ic.qt_start_end[index][0].q_start;
                startArray.push(qPos);
                if(maxNtermLen < qPos) maxNtermLen = qPos;

                let lastIndex = ic.qt_start_end[index].length - 1;
                qPos = ic.qt_start_end[index][lastIndex].q_end;
                endArray.push(qPos);
                let dist = querySeqArray[index].length - (qPos + 1);
                if(maxCtermLen < dist) maxCtermLen = dist;
            }

            ic.msaSeq = {};
            // assign the template
            ic.msaSeq[targetId] = '';
            
            for(let i = start_t; i <= end_t; ++i) {
                ic.msaSeq[targetId] += targetSeq[i];           
            }    

            // progressively merge sequences, starting from most similar to least similar
            let alignedChainIndice = [0];
            for(let arrayIndex = 0, arrayIndexl = index_alignLen.length; arrayIndex < arrayIndexl; ++arrayIndex) { 
                let index = index_alignLen[arrayIndex].index;
                alignedChainIndice.push(index);

                ic.msaSeq[accArray[index]] = '';

                // some proteins may not be aligned
                if(!querySeqArray[index]) continue;

                ic.setSeqAlignCls.mergeTwoSeqForAllSimple(targetId, accArray, index, alignedChainIndice, start_t, end_t, querySeqArray);
            }  

            // add N-terminal seq
            let seqN = '', cnt;
            for(let i = 0; i < maxNtermLen - start_t; ++i) {
                seqN += '-';
            }
            for(let i = 0; i < start_t; ++i) {
                seqN += targetSeq[i];
            }
            ic.msaSeq[targetId] = seqN + ic.msaSeq[targetId];

            for(let index = 0, indexl = accArray.length; index < indexl; ++index) { 
                seqN = '';
                for(let i = 0; i < maxNtermLen - startArray[index]; ++i) {
                    seqN += '-';
                }
                for(let i = 0; i < startArray[index]; ++i) {
                    seqN += querySeqArray[index][i];
                }

                ic.msaSeq[accArray[index]] = seqN + ic.msaSeq[accArray[index]];
            }

            // add C-terminal seq
            for(let i = end_t + 1; i < targetSeq.length; ++i) {
                ic.msaSeq[targetId] += targetSeq[i];
            }

            cnt = targetSeq.length - (end_t + 1);
            for(let i = 0; i < maxCtermLen - cnt; ++i) {
                ic.msaSeq[targetId] += '-';
            }

            for(let index = 0, indexl = accArray.length; index < indexl; ++index) {
                for(let i = endArray[index] + 1; i < querySeqArray[index].length; ++i) {
                    ic.msaSeq[accArray[index]] += querySeqArray[index][i];
                }

                cnt = querySeqArray[index].length - (endArray[index] + 1);
                for(let i = 0; i < maxCtermLen - cnt; ++i) {
                    ic.msaSeq[accArray[index]] += '-';
                }
            }

            for(let acc in ic.msaSeq) {
                let index = acc2index[acc];
                trackSeqArray[index] = ic.msaSeq[acc];
                trackTitleArray[index] = acc;
            }

            // some of the protein may not be aligned
            let trackTitleArrayFinal = [], trackSeqArrayFinal = [];
            for(let i = 0, il = trackSeqArray.length; i < il; ++i) {
                if(trackSeqArray[i]) {
                    trackSeqArrayFinal.push(trackSeqArray[i]);
                    trackTitleArrayFinal.push(trackTitleArray[i]);
                }
            }

            let seqFirst = trackSeqArrayFinal[0];

            trackSeqArrayFinal.splice(0, 1);
            trackTitleArrayFinal.splice(0, 1);

            return {trackTitleArray: trackTitleArrayFinal, trackSeqArray: trackSeqArrayFinal, seqFirst: seqFirst};
        }

        async getIsoformMsa(acclist, acc2exons) { let ic = this.icn3d, me = ic.icn3dui;
            let trackTitleArray = [], trackSeqArray = [];
            // get all seq
            let url = me.htmlCls.baseUrl + "/vastdyn/vastdyn.cgi?chainlist=" + acclist;
            let data = await me.getAjaxPromise(url, 'jsonp');
            let maxLen = 0, maxIndex = 0, index = 0;
            let accArray = [], querySeqArray = [];
            for(let acc in data) {
                let seq = data[acc];
                querySeqArray.push(seq);

                let pos = acc.indexOf('.');
                if(pos != -1) {
                    acc = acc.substr(0, pos);
                }
                accArray.push(acc);

                if(seq.length > maxLen) {
                    maxLen = seq.length;
                    maxIndex = index;
                }
                ++index;
            }

            // get aligned length for each pair
            ic.qt_start_end = {};

            // use the genomic interval as the alignment template
            let targetId = 'genomeRes';

            let acc2index = {};

            for(let index = 0, indexl = accArray.length; index < indexl; ++index) {
                let acc = accArray[index];

                acc2index[acc] = index;

                ic.qt_start_end[index] = [];

                let segArray = acc2exons[acc];     

                for(let i = 0, il = segArray.length; i < il; ++i) {
                    let seg = segArray[i];
                    
                    // mRNA has the reverse order, use negative to make the order right, then minus the offset
                    let qt_start_end = {t_start: ic.exonOrder * seg.genResStart, t_end: ic.exonOrder * seg.genResEnd, q_start: seg.resStart, q_end: seg.resEnd};
                    ic.qt_start_end[index].push(qt_start_end);
                }
            }

            // start and end of MSA
            let start_t = 999999999, end_t = -999999999;
            for(let index = 0, indexl = accArray.length; index < indexl; ++index) { 
                if(!ic.qt_start_end[index]) continue;

                for(let i = 0, il = ic.qt_start_end[index].length; i < il; ++i) {
                    let start1, end1;
                    
                    start1 = ic.qt_start_end[index][i].t_start;
                    end1 = ic.qt_start_end[index][i].t_end;

                    for(let j = start1; j <= end1; ++j) {
                        if(j < start_t) start_t = j;
                        if(j > end_t) end_t = j;
                    }
                }
            }

            // minus the offset start_t
            for(let index = 0, indexl = accArray.length; index < indexl; ++index) {
                let segArray = ic.qt_start_end[index];
                for(let i = 0, il = segArray.length; i < il; ++i) {
                    let seg = segArray[i];
                    seg.t_start -= start_t;
                    seg.t_end -= start_t;
                }
            }

            ic.msaSeq = {};
            // assign the template
            ic.msaSeq[targetId] = '';

            let start_tFinal = 0;
            let end_tFinal = end_t - start_t;

            for(let i = start_tFinal; i <= end_tFinal; ++i) {
                ic.msaSeq[targetId] += 'X';   // fake seq        
            }    

            // progressively merge sequences, starting from most similar to least similar
            let alignedChainIndice = [0];
            for(let index = 0, indexl = accArray.length; index < indexl; ++index) { 
                alignedChainIndice.push(index);

                ic.msaSeq[accArray[index]] = '';

                // some proteins may not be aligned
                if(!querySeqArray[index]) continue;
                ic.setSeqAlignCls.mergeTwoSeqForAllSimple(targetId, accArray, index, alignedChainIndice, start_tFinal, end_tFinal, querySeqArray);
            }  

            for(let acc in ic.msaSeq) {
                let index = acc2index[acc];

                if(index !== undefined) {
                    trackSeqArray[index] = ic.msaSeq[acc];
                    trackTitleArray[index] = acc;
                }
            }

            // remove introns in trackSeqArray
            let trackSeqArrayFinal = [];
            for(let i = 0, il = trackSeqArray.length; i < il; ++i) {
                trackSeqArrayFinal[i] = '';
            }

            if(trackSeqArray[maxIndex]) {
                for(let j = 0, jl = trackSeqArray[maxIndex].length; j < jl; ++j) {
                    let seq = trackSeqArray[maxIndex][j];

                    let bExon = (seq != '-') ? true : false;
                    if(!bExon) {
                        for(let i = 0, il = trackSeqArray.length; i < il; ++i) {
                            if(trackSeqArray[i][j] != '-') {
                                bExon = true;
                                break;
                            }
                        }
                    }
                    
                    if(bExon) {
                        for(let i = 0, il = trackSeqArray.length; i < il; ++i) {
                            trackSeqArrayFinal[i] += trackSeqArray[i][j];
                        }
                    }
                }
            }

            return {trackTitleArray: trackTitleArray, trackSeqArray: trackSeqArrayFinal, maxIndex: maxIndex};
        }

        async showMsaTracks(chainid, seqFirst, trackTitleArray, trackSeqArray, startpos, type, acc2exons) { let ic = this.icn3d; ic.icn3dui;
            //ic.startposGiSeq = undefined;
            for(let i = 0, il = ic.chainsSeq[chainid].length; i < il; ++i) {
                //let pos =(i >= ic.matchedPos[chainid] && i - ic.matchedPos[chainid] < ic.chainsSeq, [chainid].length) ? ic.chainsSeq[chainid][i - ic.matchedPos[chainid]].resi : ic.baseResi[chainid] + 1 + i;
                let pos = ic.ParserUtilsCls.getResi(chainid, i);

                if(pos != startpos) {
                    continue;
                }
                else {
                    ic.startposGiSeq = i;
                }
            }

            if(ic.startposGiSeq === undefined) {
                alert("Please double check the start position before clicking \"Add Track\"");
                return;
            }

            // set up gap for the master seq
            // don't count gaps in both ends
            ic.targetGapHash = {};
            let prevSeq = '-', prevPos = 0, from, to, cnt = 0, dashCnt = 0;
            let bFound = false, seqStart = 0, seqEnd = 0, seqLength = seqFirst.length;
            // add gaps to the N- and C-terminal
            if(!ic.seqStartLen) ic.seqStartLen = {};
            if(!ic.seqEndLen) ic.seqEndLen = {};
            for(let i = 0, il = seqFirst.length; i < il; ++i) {
                if(seqFirst[i] == '-' && seqFirst[i] != prevSeq) { // start of gap
                    from = cnt;
                    dashCnt = 0;
                }

                if(prevSeq == '-' && seqFirst[i] != prevSeq && cnt > 0) { // end of gap
                    to = prevPos;
                    ic.targetGapHash[from + ic.startposGiSeq] = {'from': from + ic.startposGiSeq, 'to': to + dashCnt - 1 + ic.startposGiSeq};
                }

                prevSeq = seqFirst[i];
                prevPos = cnt;

                if(seqFirst[i] != '-') {
                    ++cnt;
                    seqEnd = i;
                    ic.seqEndLen[chainid] = seqLength - 1 - seqEnd;

                    if(!bFound) {
                        seqStart = i;
                        ic.seqStartLen[chainid] = seqStart;

                        bFound = true;
                    }
                }
                else {
                    ++dashCnt;
                }
            }

            // adjust the total length
            if(ic.maxAnnoLength < ic.maxAnnoLengthOri + ic.seqStartLen[chainid] + ic.seqEndLen[chainid]) {
                    ic.maxAnnoLength = ic.maxAnnoLengthOri + ic.seqStartLen[chainid] + ic.seqEndLen[chainid];
            }

            // do not remove other tracks
            // await ic.annotationCls.resetAnnoAll();
            await ic.showAnnoCls.processSeqData(ic.chainid_seq);

            let targetGapHashStr = '';
            let cntTmp = 0;
            for(let i in ic.targetGapHash) {
                if(cntTmp > 0) targetGapHashStr += ' ';
                targetGapHashStr += i + '_' + ic.targetGapHash[i].from + '_' + ic.targetGapHash[i].to;
                ++cntTmp;
            }

            //me.htmlCls.clickMenuCls.setLogCmd("msa | " + targetGapHashStr, true);

            // add tracks
            let resi2cntSameRes = {}; // count of same residue at each position
            for(let j = 0, jl = trackSeqArray.length; j < jl; ++j) {
                let resi = startpos;
                let text = '';
                for(let k = 0; k < ic.startposGiSeq; ++k) {
                    if(ic.targetGapHash.hasOwnProperty(k)) {
                        for(let m = 0; m < ic.targetGapHash[k].to - ic.targetGapHash[k].from + 1; ++m) {
                            text += '-';
                        }
                    }

                    text += '-';
                }

                let resn, prevResn = '-';
                let fromArray = [], toArray = [];
                let bFound = false;
                let seqStartLen = 0;
                let offset = 0, offsetArray = [];
                //    for(let k = seqStart; k <= seqEnd; ++k) {
                for(let k = 0; k < seqLength; ++k) {
                    //if(seqFirst[k] == '-') continue;

                    if(j == 0) resi2cntSameRes[resi] = 0;

                    resn = trackSeqArray[j][k];

                    if(resn != '-') {
                        if(!bFound) {
                            seqStartLen = k;
                            bFound = true;
                            
                            offset = ic.startposGiSeq - ic.seqStartLen[chainid] + seqStartLen;
                        }
                    }

                    if(prevResn == '-' && resn != '-') {
                        fromArray.push(k);
                        offsetArray.push(offset);
                    }

                    if(prevResn != '-' && resn == '-') {
                        toArray.push(k - 1);
                    }

                    // use "offset" to adjut the residue numbers, e.g., P20138
                    // some isoforms starts residues before the first residue in the template sequence
                    if(k >= ic.seqStartLen[chainid]) {
                        if(seqFirst[k] == '-') offset--;
                        if(resn == '-') offset++;
                    }

                    text += resn; //ic.giSeq[chainid][i];

                    if(seqFirst[k] != '-') {
                        if(seqFirst[k] == trackSeqArray[j][k]) ++resi2cntSameRes[resi];
                        ++resi;
                    }

                    prevResn = resn;
                }

                // last one
                if(prevResn != '-') {
                    toArray.push(seqLength - 1);
                }

                let title =(trackTitleArray[j].length < 20) ? trackTitleArray[j] : trackTitleArray[j].substr(0, 20) + '...';
                let bMsa = true;
                let exonArray = (acc2exons) ? acc2exons[trackTitleArray[j]] : undefined;

                this.showNewTrack(chainid, title, text, undefined, undefined, type, undefined, bMsa, fromArray, toArray, seqStartLen, exonArray, offsetArray);
            }

            // update exon color
            ic.opts['color'] = 'exon';
            ic.legendTableCls.showColorLegend(ic.opts['color']);

            ic.hlUpdateCls.updateHlAll();
            ic.drawCls.draw();

    /*
            // set color for the master seq
            if(trackSeqArray.length > 0) {
                if(ic.queryresi2score === undefined) ic.queryresi2score = {}
                if(ic.queryresi2score[chainid] === undefined) ic.queryresi2score[chainid] = {}

                let nSeq = trackSeqArray.length;
                for(let resi in resi2cntSameRes) {
                    let score = parseInt(resi2cntSameRes[resi] / nSeq * 100);
                    ic.queryresi2score[chainid][resi] = score;
                }

                let resiArray = Object.keys(resi2cntSameRes);
                let start = Math.min.apply(null, resiArray);
                let end = Math.max.apply(null, resiArray);

                let resiScoreStr = '';
                for(let resi = start; resi <= end; ++resi) {
                    if(resi2cntSameRes.hasOwnProperty(resi)) {
                        resiScoreStr += Math.round(resi2cntSameRes[resi] / nSeq * 9); // max 9
                    }
                    else {
                        resiScoreStr += '_';
                    }
                }

                ic.opts['color'] = 'align custom';
                ic.setColorCls.setColorByOptions(ic.opts, ic.hAtoms);

                ic.hlUpdateCls.updateHlAll();

                ic.drawCls.draw();

                //me.htmlCls.clickMenuCls.setLogCmd('color align custom | ' + chainid + ' | range ' + start + '_' + end + ' | ' + resiScoreStr, true);
            }
            */
        }

        processAccList(acclist) { let ic = this.icn3d; ic.icn3dui;
            // remove version from acc
            let accArray = acclist.split(',');
            let accHash = {};
            let acclistTmp = '';
            for(let i = 0, il = accArray.length; i < il; ++i) {
                let acc = accArray[i];

                if(accHash.hasOwnProperty(acc)) {
                    continue;
                }
                else {
                    accHash[acc] = 1;
                }
                
                let pos = acc.indexOf('.');
                if(pos != -1) {
                    acclistTmp += acc.substr(0, pos);
                }
                else {
                    acclistTmp += acc;
                }

                if(i < accArray.length - 1) {
                    acclistTmp += ',';
                }
            }

            return acclistTmp;
        }

        async addExonTracksWrap() { let ic = this.icn3d; ic.icn3dui;
            let chainid = $("#" + ic.pre + "track_chainid").val();    
            let geneid = $("#" + ic.pre + "track_geneid").val();
            if(!geneid) {
                alert("Please fill in the Gene ID...");
                return;
            }

            let startpos = $("#" + ic.pre + "fasta_startpos2").val();
            if(!startpos) startpos = 1;

            //let colorseqby = $("#" + ic.pre + "colorseqby2").val();
            //let type =(colorseqby == 'identity') ? 'identity' : 'custom';

            let type = 'identity';

            await this.addExonTracks(chainid, geneid, startpos, type);
        }

        async addExonTracks(chainid, geneid, startpos, type) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            let seqFirst, trackTitleArray = [], trackSeqArray = [];

            // get acclist from geneid
            let url = me.htmlCls.baseUrl + "/vastdyn/vastdyn.cgi?geneid2isoforms=" + geneid;
            let data = await me.getAjaxPromise(url, 'jsonp');
            let accArray = data.acclist;
            let exons = data.exons;
            let acc2exons = {};

            let acclist = '';
            ic.exonOrder = 1; // 1: increasing bp order; -1 decreasing bp order
            for(let i = 0, il = accArray.length; i < il; ++i) {
                let accOri = accArray[i];
                let pos = accOri.indexOf('.');
                let acc = (pos != -1) ? accOri.substr(0, pos) : accOri;

                let cntTotal = 0, prevCntTotal = 0, rangeArray = [];
                for(let j = 0, jl = exons[accOri].length; j < jl; ++j) {
                    let itemArray = exons[accOri][j].split('-');
                    itemArray[0] = parseInt(itemArray[0]);
                    itemArray[1] = parseInt(itemArray[1]);
                    itemArray[2] = parseInt(itemArray[2]);

                    ic.exonOrder = (itemArray[0] < itemArray[1]) ? 1 : -1;

                    let genomeRange = itemArray[0] + '-' + itemArray[1];
                    let cnt = (j == jl - 1) ? itemArray[2] - 3 : itemArray[2]; // The last one is stop codeon
                    cntTotal += cnt;

                    let resStart = parseInt((prevCntTotal+2)/3.0); // 0-based
                    let resEnd = parseInt((cntTotal+2)/3.0) - 1; // 0-based

                    let genResEnd = parseInt((itemArray[1]+2) / 3.0);
                    // let genResStart = parseInt((itemArray[0]+2) / 3.0); // some difference due to round
                    let genResStart = genResEnd - ic.exonOrder * (resEnd - resStart);

                    rangeArray.push({genomeRange: genomeRange, genResStart: genResStart, genResEnd: genResEnd, resStart: resStart, resEnd: resEnd});

                    prevCntTotal = cntTotal;
                }
                acc2exons[acc] = rangeArray;

                acclist += acc;
                if(i < il - 1) {
                    acclist += ',';
                }
            }

            let result = await this.getIsoformMsa(acclist, acc2exons);
            trackTitleArray = result.trackTitleArray;
            trackSeqArray = result.trackSeqArray;
            //seqFirst = result.seqFirst;
            let maxIndex = result.maxIndex;

            let acclist2 = trackTitleArray[maxIndex];
            let structure = chainid.substr(0, chainid.indexOf('_'));
            let firstAcc;
            if(structure.length > 5) {
                if(ic.uniprot2acc && ic.uniprot2acc[structure]) structure = ic.uniprot2acc[structure];
                firstAcc = structure;
            }
            else {
                firstAcc = chainid;
            }

            // get the sequence from iCn3D because a uniProt ID can not be retrieved in pwaln.fcgi
            if(structure.length > 5) {
                let chainSeq = '';
                for(let i = 0, il = ic.chainsSeq.length; i < il; ++i) {
                    chainSeq += ic.chainsSeq[i].resn;
                }

                result = await this.getMsa(acclist2, firstAcc, chainSeq);
            }
            else {
                result = await this.getMsa(acclist2, firstAcc);
            }

            result.trackTitleArray;
            let trackSeqArray2 = result.trackSeqArray;
            seqFirst = result.seqFirst;

            // merge trackTitleArray2[0] with trackSeqArray[maxIndex]
            let A = trackSeqArray[maxIndex], B = trackSeqArray2[0];
            let i = 0, j = 0;

            let ALen = trackSeqArray.length;

            while (A && B && i < A.length && j < B.length) {
                if(A[i] != B[j]) {
                    if(A[i] == '-') { 
                        // insert "-" in B
                        B = B.substr(0, j) + '-' + B.substr(j);
                        seqFirst = seqFirst.substr(0, j) + '-' + seqFirst.substr(j);
                    }
                    else { //if(B[j] == '-') { 
                        // insert "-" in A
                        for(let k = 0; k < ALen; ++k) {
                            trackSeqArray[k] = trackSeqArray[k].substr(0, i) + '-' + trackSeqArray[k].substr(i);
                        }
                    }
                }

                ++i;
                ++j;
            }

            await thisClass.showMsaTracks(chainid, seqFirst, trackTitleArray, trackSeqArray, startpos, type, acc2exons);

            me.htmlCls.clickMenuCls.setLogCmd("add exon track | chainid " + chainid + " | geneid " + geneid + " | startpos " + startpos + " | type " + type, true);
            me.htmlCls.clickMenuCls.setLogCmd("set annotation custom", true);
        }

        async addMsaTracks(chainid, startpos, type, fastaList) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            let seqFirst, trackTitleArray = [], trackSeqArray = [];

            let fastaArray = fastaList.split('>');

            // the first array item is empty
            // the second array item is the sequence of the structure, start with i = 2
            let posFirst = fastaArray[1].indexOf('\n');
            //let titleFirst = fastaArray[1].substr(0, posFirst);
            seqFirst = fastaArray[1].substr(posFirst + 1).replace(/\n/g, '');

            for(let i = 2, il = fastaArray.length; i < il; ++i) {
                let pos = fastaArray[i].indexOf('\n');
                let title = fastaArray[i].substr(0, pos);
                if(title.indexOf('|') != -1) {
                    title = title.split('|')[1];
                    //   if(title.indexOf('.') != -1) {
                    //     title = title.split('.')[0];
                    //   }
                }
                trackTitleArray.push(title);
                let seq = fastaArray[i].substr(pos + 1).replace(/\n/g, '');
                trackSeqArray.push(seq);
            }

            await thisClass.showMsaTracks(chainid, seqFirst, trackTitleArray, trackSeqArray, startpos, type);
            
            me.htmlCls.clickMenuCls.setLogCmd("add msa track | chainid " + chainid + " | startpos " + startpos + " | type " + type + " | fastaList " + fastaList , true);
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Annotation {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        hideAllAnno() { let ic = this.icn3d; ic.icn3dui;
            this.setAnnoSeqBase(false);
            $("[id^=" + ic.pre + "custom]").hide();
        }
        setAnnoSeqBase(bShow) {  let ic = this.icn3d; ic.icn3dui;
            //let itemArray = ['site', 'ptm', 'snp', 'clinvar', 'cdd', 'domain', 'interaction', 'ssbond', 'crosslink', 'transmem'];
            let itemArray = ['cdd', 'clinvar', 'snp', 'site', 'ptm', 'ssbond', 'crosslink', 'transmem', 'domain', 'interaction', 'ig'];
            for(let i in itemArray) {
                let item = itemArray[i];
                if(bShow) {
                    $("[id^=" + ic.pre + item + "]").show();
                }
                else {
                    $("[id^=" + ic.pre + item + "]").hide();
                }
            }
        }
        setAnnoTabBase(bChecked) {  let ic = this.icn3d; ic.icn3dui;
            //let itemArray = ['all', 'binding', 'ptm', 'snp', 'clinvar', 'cdd', '3dd', 'interact', 'custom', 'ssbond', 'crosslink', 'transmem'];
            let itemArray = ['all', 'cdd', 'clinvar', 'snp', 'binding', 'ptm', 'ssbond', 'crosslink', 'transmem', '3dd', 'custom', 'interact', 'ig'];
            for(let i in itemArray) {
                let item = itemArray[i];
                if($("#" + ic.pre + "anno_" + item).length) $("#" + ic.pre + "anno_" + item)[0].checked = bChecked;
            }
        }
        async setAnnoTabAll() {  let ic = this.icn3d; ic.icn3dui;
            this.setAnnoTabBase(true);
            this.setAnnoSeqBase(true);
            await this.updateClinvar();
            await this.updateSnp();
            this.updateDomain();
            await this.updatePTM();
            this.updateSsbond();
            this.updateCrosslink();
            await this.updateTransmem();

            ic.bRunRefnumAgain = true;
            await this.updateIg();
            ic.bRunRefnumAgain = false;

            this.updateInteraction();
        }
        hideAnnoTabAll() {  let ic = this.icn3d; ic.icn3dui;
            this.setAnnoTabBase(false);
            this.hideAllAnno();
        }
        async resetAnnoAll() {  let ic = this.icn3d; ic.icn3dui;
           // reset annotations
           //$("#" + ic.pre + "dl_annotations").html("");
           //ic.bAnnoShown = false;
           //ic.showAnnoCls.showAnnotations();

           $("[id^=" + ic.pre + "dt_]").html("");
           $("[id^=" + ic.pre + "tt_]").html("");
           $("[id^=" + ic.pre + "ov_]").html("");
           await ic.showAnnoCls.processSeqData(ic.chainid_seq);

           //if($("#" + ic.pre + "dt_giseq_" + chainid).css("display") != 'block') {
           //    this.setAnnoViewAndDisplay('overview');
           //}
           //else {
               this.setAnnoViewAndDisplay('detailed view');
           //}
           await this.resetAnnoTabAll();
        }

        async resetAnnoTabAll() {  let ic = this.icn3d; ic.icn3dui;
            if($("#" + ic.pre + "anno_binding").length && $("#" + ic.pre + "anno_binding")[0].checked) {
                $("[id^=" + ic.pre + "site]").show();
            }
            if($("#" + ic.pre + "anno_snp").length && $("#" + ic.pre + "anno_snp")[0].checked) {
                ic.bSnpShown = false;
                await this.updateSnp();

                $("[id^=" + ic.pre + "snp]").show();
            }
            if($("#" + ic.pre + "anno_clinvar").length && $("#" + ic.pre + "anno_clinvar")[0].checked) {
                ic.bClinvarShown = false;
                await this.updateClinvar();

                $("[id^=" + ic.pre + "clinvar]").show();
            }
            if($("#" + ic.pre + "anno_cdd").length && $("#" + ic.pre + "anno_cdd")[0].checked) {
                $("[id^=" + ic.pre + "cdd]").show();
            }
            if($("#" + ic.pre + "anno_3dd").length && $("#" + ic.pre + "anno_3dd")[0].checked) {
                $("[id^=" + ic.pre + "domain]").show();
                ic.bDomainShown = false;
                this.updateDomain();
            }
            if($("#" + ic.pre + "anno_interact").length && $("#" + ic.pre + "anno_interact")[0].checked) {
                $("[id^=" + ic.pre + "interaction]").show();
                ic.bInteractionShown = false;
                this.updateInteraction();
            }
            if($("#" + ic.pre + "anno_ptm").length && $("#" + ic.pre + "anno_ptm")[0].checked) {
                ic.bPTMShown = false;
                await this.updatePTM();

                $("[id^=" + ic.pre + "ptm]").show();
            }
            if($("#" + ic.pre + "anno_custom").length && $("#" + ic.pre + "anno_custom")[0].checked) {
                $("[id^=" + ic.pre + "custom]").show();
            }
            if($("#" + ic.pre + "anno_ssbond").length && $("#" + ic.pre + "anno_ssbond")[0].checked) {
                $("[id^=" + ic.pre + "ssbond]").show();
                ic.bSSbondShown = false;
                this.updateSsbond();
            }
            if($("#" + ic.pre + "anno_crosslink").length && $("#" + ic.pre + "anno_crosslink")[0].checked) {
                $("[id^=" + ic.pre + "crosslink]").show();
                ic.bCrosslinkShown = false;
                this.updateCrosslink();
            }
            if($("#" + ic.pre + "anno_transmem").length && $("#" + ic.pre + "anno_transmem")[0].checked) {
                ic.bTranememShown = false;
                await this.updateTransmem();

                $("[id^=" + ic.pre + "transmem]").show();
            }
            if($("#" + ic.pre + "anno_ig").length && $("#" + ic.pre + "anno_ig")[0].checked || ic.bShowRefnum) {
                // no need to redo ref num calculation
                ic.bRunRefnumAgain = false;

                await this.updateIg();

                $("[id^=" + ic.pre + "ig]").show();

                // ic.bRunRefnumAgain = false;
            }
        }
        setAnnoTabCustom() {  let ic = this.icn3d; ic.icn3dui;
            $("[id^=" + ic.pre + "custom]").show();
            if($("#" + ic.pre + "anno_custom").length) $("#" + ic.pre + "anno_custom")[0].checked = true;
        }
        hideAnnoTabCustom() {  let ic = this.icn3d; ic.icn3dui;
            $("[id^=" + ic.pre + "custom]").hide();
            if($("#" + ic.pre + "anno_custom").length) $("#" + ic.pre + "anno_custom")[0].checked = false;
        }
        async setAnnoTabClinvar() {  let ic = this.icn3d; ic.icn3dui;
            await this.updateClinvar();

            $("[id^=" + ic.pre + "clinvar]").show();
            if($("#" + ic.pre + "anno_clinvar").length) $("#" + ic.pre + "anno_clinvar")[0].checked = true;
        }
        hideAnnoTabClinvar() {  let ic = this.icn3d; ic.icn3dui;
            $("[id^=" + ic.pre + "clinvar]").hide();
            if($("#" + ic.pre + "anno_clinvar").length) $("#" + ic.pre + "anno_clinvar")[0].checked = false;
        }
        async setAnnoTabSnp() {  let ic = this.icn3d; ic.icn3dui;
            await this.updateSnp();

            $("[id^=" + ic.pre + "snp]").show();
            if($("#" + ic.pre + "anno_snp").length) $("#" + ic.pre + "anno_snp")[0].checked = true;
        }
        hideAnnoTabSnp() {  let ic = this.icn3d; ic.icn3dui;
            $("[id^=" + ic.pre + "snp]").hide();
            if($("#" + ic.pre + "anno_snp").length) $("#" + ic.pre + "anno_snp")[0].checked = false;
        }
        setAnnoTabCdd() {  let ic = this.icn3d; ic.icn3dui;
            $("[id^=" + ic.pre + "cdd]").show();
            if($("#" + ic.pre + "anno_cdd").length) $("#" + ic.pre + "anno_cdd")[0].checked = true;
        }
        hideAnnoTabCdd() {  let ic = this.icn3d; ic.icn3dui;
            $("[id^=" + ic.pre + "cdd]").hide();
            if($("#" + ic.pre + "anno_cdd").length) $("#" + ic.pre + "anno_cdd")[0].checked = false;
        }
        setAnnoTab3ddomain() {  let ic = this.icn3d; ic.icn3dui;
            this.updateDomain();

            $("[id^=" + ic.pre + "domain]").show();
            if($("#" + ic.pre + "anno_3dd").length) $("#" + ic.pre + "anno_3dd")[0].checked = true;
        }
        hideAnnoTab3ddomain() {  let ic = this.icn3d; ic.icn3dui;
            $("[id^=" + ic.pre + "domain]").hide();
            if($("#" + ic.pre + "anno_3dd").length) $("#" + ic.pre + "anno_3dd")[0].checked = false;
        }
        setAnnoTabSite() {  let ic = this.icn3d; ic.icn3dui;
            $("[id^=" + ic.pre + "site]").show();
            $("[id^=" + ic.pre + "feat]").show();
            if($("#" + ic.pre + "anno_binding").length) $("#" + ic.pre + "anno_binding")[0].checked = true;
        }
        hideAnnoTabSite() {  let ic = this.icn3d; ic.icn3dui;
            $("[id^=" + ic.pre + "site]").hide();
            $("[id^=" + ic.pre + "feat]").hide();
            if($("#" + ic.pre + "anno_binding").length) $("#" + ic.pre + "anno_binding")[0].checked = false;
        }
        setAnnoTabInteraction() {  let ic = this.icn3d; ic.icn3dui;
            $("[id^=" + ic.pre + "interaction]").show();
            if($("#" + ic.pre + "anno_interact").length) $("#" + ic.pre + "anno_interact")[0].checked = true;
            this.updateInteraction();
        }
        hideAnnoTabInteraction() {  let ic = this.icn3d; ic.icn3dui;
            $("[id^=" + ic.pre + "interaction]").hide();
            if($("#" + ic.pre + "anno_interact").length) $("#" + ic.pre + "anno_interact")[0].checked = false;
        }
        async setAnnoTabPTM() {  let ic = this.icn3d; ic.icn3dui;
            await this.updatePTM();

            $("[id^=" + ic.pre + "ptm]").show();
            if($("#" + ic.pre + "anno_ptm").length) $("#" + ic.pre + "anno_ptm")[0].checked = true;
        }
        hideAnnoTabPTM() {  let ic = this.icn3d; ic.icn3dui;
            $("[id^=" + ic.pre + "ptm]").hide();
            if($("#" + ic.pre + "anno_ptm").length) $("#" + ic.pre + "anno_ptm")[0].checked = false;
        }
        setAnnoTabSsbond() {  let ic = this.icn3d; ic.icn3dui;
            $("[id^=" + ic.pre + "ssbond]").show();
            if($("#" + ic.pre + "anno_ssbond").length) $("#" + ic.pre + "anno_ssbond")[0].checked = true;
            this.updateSsbond();
        }
        hideAnnoTabSsbond() {  let ic = this.icn3d; ic.icn3dui;
            $("[id^=" + ic.pre + "ssbond]").hide();
            if($("#" + ic.pre + "anno_ssbond").length) $("#" + ic.pre + "anno_ssbond")[0].checked = false;
        }
        setAnnoTabCrosslink() {  let ic = this.icn3d; ic.icn3dui;
            $("[id^=" + ic.pre + "crosslink]").show();
            if($("#" + ic.pre + "anno_crosslink").length) $("#" + ic.pre + "anno_crosslink")[0].checked = true;
            this.updateCrosslink();
        }
        hideAnnoTabCrosslink() {  let ic = this.icn3d; ic.icn3dui;
            $("[id^=" + ic.pre + "crosslink]").hide();
            if($("#" + ic.pre + "anno_crosslink").length) $("#" + ic.pre + "anno_crosslink")[0].checked = false;
        }
        async setAnnoTabTransmem() {  let ic = this.icn3d; ic.icn3dui;
            await this.updateTransmem();

            $("[id^=" + ic.pre + "transmem]").show();
            if($("#" + ic.pre + "anno_transmem").length) $("#" + ic.pre + "anno_transmem")[0].checked = true;
        }
        hideAnnoTabTransmem() {  let ic = this.icn3d; ic.icn3dui;
            $("[id^=" + ic.pre + "transmem]").hide();
            if($("#" + ic.pre + "anno_transmem").length) $("#" + ic.pre + "anno_transmem")[0].checked = false;
        }
        async setAnnoTabIg(bSelection, template) {  let ic = this.icn3d; ic.icn3dui;
            await this.updateIg(bSelection, template);

            $("[id^=" + ic.pre + "ig]").show();
            if($("#" + ic.pre + "anno_ig").length) $("#" + ic.pre + "anno_ig")[0].checked = true;
        }
        hideAnnoTabIg() {  let ic = this.icn3d; ic.icn3dui;
            $("[id^=" + ic.pre + "ig]").hide();
            if($("#" + ic.pre + "anno_ig").length) $("#" + ic.pre + "anno_ig")[0].checked = false;
        }
        setTabs() {  let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

        //        $("#" + ic.pre + "dl_annotations_tabs").tabs();
            $("#" + ic.pre + "dl_addtrack_tabs").tabs();
            $("#" + ic.pre + "dl_anno_view_tabs").tabs();
            //$("#" + ic.pre + "anno_all", "click", function(e) {
            me.myEventCls.onIds("#" + ic.pre + "anno_all", "click", async function(e) {

            if($("#" + ic.pre + "anno_all")[0].checked) {
                await thisClass.setAnnoTabAll();
                me.htmlCls.clickMenuCls.setLogCmd("set annotation all", true);
            }
            else {
                thisClass.hideAnnoTabAll();
                me.htmlCls.clickMenuCls.setLogCmd("hide annotation all", true);
            }
            });

            //$("#" + ic.pre + "anno_binding", "click", function(e) {
            me.myEventCls.onIds("#" + ic.pre + "anno_binding", "click", function(e) {
            if($("#" + ic.pre + "anno_binding")[0].checked) {
                thisClass.setAnnoTabSite();
                me.htmlCls.clickMenuCls.setLogCmd("set annotation site", true);
            }
            else {
                thisClass.hideAnnoTabSite();
                me.htmlCls.clickMenuCls.setLogCmd("hide annotation site", true);
            }
            });

            //$("#" + ic.pre + "anno_snp", "click", function(e) {
            me.myEventCls.onIds("#" + ic.pre + "anno_snp", "click", async function(e) {
            if($("#" + ic.pre + "anno_snp")[0].checked) {
                await thisClass.setAnnoTabSnp();
                me.htmlCls.clickMenuCls.setLogCmd("set annotation snp", true);
            }
            else {
                thisClass.hideAnnoTabSnp();
                me.htmlCls.clickMenuCls.setLogCmd("hide annotation snp", true);
            }
            });

            //$("#" + ic.pre + "anno_clinvar", "click", function(e) {
            me.myEventCls.onIds("#" + ic.pre + "anno_clinvar", "click", async function(e) {
            if($("#" + ic.pre + "anno_clinvar")[0].checked) {
                await thisClass.setAnnoTabClinvar();
                me.htmlCls.clickMenuCls.setLogCmd("set annotation clinvar", true);
            }
            else {
                thisClass.hideAnnoTabClinvar();
                me.htmlCls.clickMenuCls.setLogCmd("hide annotation clinvar", true);
            }
            });

            //$("#" + ic.pre + "anno_cdd", "click", function(e) {
            me.myEventCls.onIds("#" + ic.pre + "anno_cdd", "click", function(e) {
                thisClass.clickCdd();
            });

            //$("#" + ic.pre + "anno_3dd", "click", function(e) {
            me.myEventCls.onIds("#" + ic.pre + "anno_3dd", "click", function(e) {
            if($("#" + ic.pre + "anno_3dd")[0].checked) {
                thisClass.setAnnoTab3ddomain();
                me.htmlCls.clickMenuCls.setLogCmd("set annotation 3ddomain", true);
            }
            else {
                thisClass.hideAnnoTab3ddomain();
                me.htmlCls.clickMenuCls.setLogCmd("hide annotation 3ddomain", true);
            }
            });

            //$("#" + ic.pre + "anno_interact", "click", function(e) {
            me.myEventCls.onIds("#" + ic.pre + "anno_interact", "click", function(e) {
            if($("#" + ic.pre + "anno_interact")[0].checked) {
                thisClass.setAnnoTabInteraction();
                me.htmlCls.clickMenuCls.setLogCmd("set annotation interaction", true);
            }
            else {
                thisClass.hideAnnoTabInteraction();
                me.htmlCls.clickMenuCls.setLogCmd("hide annotation interaction", true);
            }
            });

            me.myEventCls.onIds("#" + ic.pre + "anno_ptm", "click", async function(e) {
                if($("#" + ic.pre + "anno_ptm")[0].checked) {
                    await thisClass.setAnnoTabPTM();
                    me.htmlCls.clickMenuCls.setLogCmd("set annotation ptm", true);
                }
                else {
                    thisClass.hideAnnoTabPTM();
                    me.htmlCls.clickMenuCls.setLogCmd("hide annotation ptm", true);
                }
            });

            //$("#" + ic.pre + "anno_custom", "click", function(e) {
            me.myEventCls.onIds("#" + ic.pre + "anno_custom", "click", function(e) {
            if($("#" + ic.pre + "anno_custom")[0].checked) {
                thisClass.setAnnoTabCustom();
                me.htmlCls.clickMenuCls.setLogCmd("set annotation custom", true);
            }
            else {
                thisClass.hideAnnoTabCustom();
                me.htmlCls.clickMenuCls.setLogCmd("hide annotation custom", true);
            }
            });

            //$("#" + ic.pre + "anno_ssbond", "click", function(e) {
            me.myEventCls.onIds("#" + ic.pre + "anno_ssbond", "click", function(e) {
            if($("#" + ic.pre + "anno_ssbond")[0].checked) {
                thisClass.setAnnoTabSsbond();
                me.htmlCls.clickMenuCls.setLogCmd("set annotation ssbond", true);
            }
            else {
                thisClass.hideAnnoTabSsbond();
                me.htmlCls.clickMenuCls.setLogCmd("hide annotation ssbond", true);
            }
            });

            //$("#" + ic.pre + "anno_crosslink", "click", function(e) {
            me.myEventCls.onIds("#" + ic.pre + "anno_crosslink", "click", function(e) {
            if($("#" + ic.pre + "anno_crosslink")[0].checked) {
                thisClass.setAnnoTabCrosslink();
                me.htmlCls.clickMenuCls.setLogCmd("set annotation crosslink", true);
            }
            else {
                thisClass.hideAnnoTabCrosslink();
                me.htmlCls.clickMenuCls.setLogCmd("hide annotation crosslink", true);
            }
            });

            //$("#" + ic.pre + "anno_transmem", "click", function(e) {
            me.myEventCls.onIds("#" + ic.pre + "anno_transmem", "click", async function(e) {
            if($("#" + ic.pre + "anno_transmem").length && $("#" + ic.pre + "anno_transmem")[0].checked) {
                await thisClass.setAnnoTabTransmem();
                me.htmlCls.clickMenuCls.setLogCmd("set annotation transmembrane", true);
            }
            else {
                thisClass.hideAnnoTabTransmem();
                me.htmlCls.clickMenuCls.setLogCmd("hide annotation transmembrane", true);
            }
            });

            me.myEventCls.onIds("#" + ic.pre + "anno_ig", "click", async function(e) {
                if($("#" + ic.pre + "anno_ig").length && $("#" + ic.pre + "anno_ig")[0].checked) {
                    // if(Object.keys(ic.atoms).length > Object.keys(ic.hAtoms).length) {
                    //     ic.bRunRefnum = false;
                    // }

                    ic.bRunRefnumAgain = true;
                    await thisClass.setAnnoTabIg();
                    me.htmlCls.clickMenuCls.setLogCmd("set annotation ig", true);

                    ic.bRunRefnumAgain = false;
                }
                else {
                    thisClass.hideAnnoTabIg();
                    me.htmlCls.clickMenuCls.setLogCmd("hide annotation ig", true);
                }
                });
        }
        clickCdd() { let ic = this.icn3d, me = ic.icn3dui;
          if($("[id^=" + ic.pre + "cdd]").length > 0) {
            if($("#" + ic.pre + "anno_cdd")[0].checked) {
                this.setAnnoTabCdd();
                me.htmlCls.clickMenuCls.setLogCmd("set annotation cdd", true);
            }
            else {
                this.hideAnnoTabCdd();
                me.htmlCls.clickMenuCls.setLogCmd("hide annotation cdd", true);
            }
          }
        }

        showAnnoSelectedChains() {   let ic = this.icn3d, me = ic.icn3dui;
            // show selected chains in annotation window
            let chainHash = {};
            for(let i in ic.hAtoms) {
                let atom = ic.atoms[i];
                let chainid = atom.structure + '_' + atom.chain;
                chainHash[chainid] = 1;
            }
            $("#" + ic.pre + "dl_annotations > .icn3d-annotation").hide();

            for(let chainid in chainHash) {
                if($("#" + ic.pre + "anno_" + chainid).length) {
                    $("#" + ic.pre + "anno_" + chainid).show();
                }
                
                let atom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.chains[chainid]);
                if(atom && atom.resn !== undefined) {
                    let oneLetterRes = me.utilsCls.residueName2Abbr(atom.resn.substr(0, 3));
                    $("#" + ic.pre + "anno_" + oneLetterRes).show();
                }
            }
        }
        showAnnoAllChains() {   let ic = this.icn3d; ic.icn3dui;
            $("#" + ic.pre + "dl_annotations > .icn3d-annotation").show();
        }
        setAnnoView(view) { let ic = this.icn3d, me = ic.icn3dui;
            if(!me.bNode) {
                if(view === 'detailed view') {
                    ic.view = 'detailed view';
                    $( "#" + ic.pre + "dl_anno_view_tabs" ).tabs( "option", "active", 1 );
                }
                else { // overview
                    ic.view = 'overview';
                    $( "#" + ic.pre + "dl_anno_view_tabs" ).tabs( "option", "active", 0 );
                }
            }
        }
        setAnnoDisplay(display, prefix) { let ic = this.icn3d; ic.icn3dui;
            let itemArray = ['giseq', 'custom', 'site', 'ptm', 'snp', 'clinvar', 'cdd', 'domain', 'interaction', 'ssbond', 'crosslink', 'transmem', 'ig'];
            for(let i in itemArray) {
                let item = itemArray[i];
                $("[id^=" + ic.pre + prefix + "_" + item + "]").attr('style', display);
            }
        }
        showFixedTitle() { let ic = this.icn3d; ic.icn3dui;
                let style = 'display:block;';
                this.setAnnoDisplay(style, 'tt');
        }
        hideFixedTitle() { let ic = this.icn3d; ic.icn3dui;
                let style = 'display:none!important;';
                this.setAnnoDisplay(style, 'tt');
        }
        setAnnoViewAndDisplay(view) { let ic = this.icn3d; ic.icn3dui;
            if(view === 'detailed view') {
                this.setAnnoView('detailed view');
                let style = 'display:block;';
                this.setAnnoDisplay(style, 'dt');
                $("#" + ic.pre + "seqguide_wrapper").attr('style', style);
                style = 'display:none;';
                this.setAnnoDisplay(style, 'ov');
            }
            else { // overview
                this.setAnnoView('overview');
                this.hideFixedTitle();
                let style = 'display:none;';
                this.setAnnoDisplay(style, 'dt');
                $("#" + ic.pre + "seqguide_wrapper").attr('style', style);
                style = 'display:block;';
                this.setAnnoDisplay(style, 'ov');
            }
        }

        // by default, showSeq and showCddSite are called at showAnnotations
        // the following will be called only when the annotation is selected: showSnpClinvar, showDomain, showInteraction
        // showSnpClinvar and showDomain will loop through ic.protein_chainid
        // showInteraction will loop through ic.interactChainbase
        async updateClinvar() { let ic = this.icn3d; ic.icn3dui;
            if(ic.bClinvarShown === undefined || !ic.bClinvarShown) {
                for(let chainid in ic.protein_chainid) {
                    let chainidBase = ic.protein_chainid[chainid];
                    await ic.annoSnpClinVarCls.showClinvar(chainid, chainidBase);
                }
            }
            ic.bClinvarShown = true;
        }
        async updateSnp() { let ic = this.icn3d; ic.icn3dui;
            if(ic.bSnpShown === undefined || !ic.bSnpShown) {
                for(let chainid in ic.protein_chainid) {
                    let chainidBase = ic.protein_chainid[chainid];
                    await ic.annoSnpClinVarCls.showSnp(chainid, chainidBase);
                }
            }
            ic.bSnpShown = true;
        }
        updateDomain() { let ic = this.icn3d; ic.icn3dui;
            if(ic.bDomainShown === undefined || !ic.bDomainShown) {
                ic.annoDomainCls.showDomainAll();
            }
            ic.bDomainShown = true;
        }
        updateInteraction() { let ic = this.icn3d; ic.icn3dui;
            if(ic.bInteractionShown === undefined || !ic.bInteractionShown) {
                for(let chainid in ic.interactChainbase) {
                    let chainidBase = ic.interactChainbase[chainid];
                    ic.annoContactCls.showInteraction(chainid, chainidBase);
                }
            }
            ic.bInteractionShown = true;
        }
        async updatePTM() { let ic = this.icn3d; ic.icn3dui;
            if(ic.bPTMShown === undefined || !ic.bPTMShown) {
                for(let chainid in ic.PTMChainbase) {
                    let chainidBase = ic.PTMChainbase[chainid];
                    await ic.annoPTMCls.showPTM(chainid, chainidBase, 'ptm');
                }
            }
            ic.bPTMShown = true;
        }
        updateSsbond() { let ic = this.icn3d; ic.icn3dui;
            if(ic.bSSbondShown === undefined || !ic.bSSbondShown) {
                for(let chainid in ic.ssbondChainbase) {
                    let chainidBase = ic.ssbondChainbase[chainid];
                    ic.annoSsbondCls.showSsbond(chainid, chainidBase);
                }
            }
            ic.bSSbondShown = true;
        }
        updateCrosslink() { let ic = this.icn3d; ic.icn3dui;
            if(ic.bCrosslinkShown === undefined || !ic.bCrosslinkShown) {
                for(let chainid in ic.crosslinkChainbase) {
                    let chainidBase = ic.crosslinkChainbase[chainid];
                    ic.annoCrossLinkCls.showCrosslink(chainid, chainidBase);
                }
            }
            ic.bCrosslinkShown = true;
        }

        async updateTransmem() { let ic = this.icn3d, me = ic.icn3dui;
            if(ic.bTranememShown === undefined || !ic.bTranememShown) {
                for(let chainid in ic.protein_chainid) {
                    let chainidBase = ic.protein_chainid[chainid];
                    if(me.cfg.opmid !== undefined) {
                        ic.annoTransMemCls.showTransmem(chainid, chainidBase);
                    }
                    else if(ic.bAfMem && ic.afmem_start_end) {
                        let begin = ic.afmem_start_end[0];
                        let end = ic.afmem_start_end[1];
                        await ic.annoPTMCls.showPTM(chainid, chainidBase, 'afmem', begin, end);
                    }
                    else {
                        await ic.annoPTMCls.showPTM(chainid, chainidBase, 'transmem');
                    }
                }
            }
            ic.bTranememShown = true;
        }

        async updateIg(bSelection, template) { let ic = this.icn3d, me = ic.icn3dui;
            ic.opts['color'] = 'ig strand';
            
            // if(!bSelection && !template) {
            if(!bSelection) {
                // select all protein chains
                ic.hAtoms = {};
                for(let chainid in ic.protein_chainid) {
                    ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.chains[chainid]);
                }
            }

            // clear previous refnum
            let residueHash = ic.firstAtomObjCls.getResiduesFromAtoms(ic.hAtoms);
            for(let resid in residueHash) {
                if(ic.resid2refnum) delete ic.resid2refnum[resid];
                if(ic.residIgLoop) delete ic.residIgLoop[resid];
                if(ic.resid2domainid) delete ic.resid2domainid[resid];
            }

            ic.bRunRefnumAgain = true;
            let chainidHash = (!bSelection) ? ic.protein_chainid : ic.firstAtomObjCls.getChainsFromAtoms(ic.hAtoms);
            for(let chainid in chainidHash) {
                // showIgRefNum() in showIg() runs for all chains
                await ic.annoIgCls.showIg(chainid, template);
                ic.bRunRefnumAgain = false; // run it once for all chains
            }
            
            if(ic.bShowRefnum) {
                ic.hlUpdateCls.updateHlAll();
                ic.drawCls.draw();
            } 
      
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class ShowAnno {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //show annotations such as SNPs, ClinVar, domains, binding sites, etc.
        showAnnotations_part1(atoms) { let ic = this.icn3d, me = ic.icn3dui;
            me.htmlCls.dialogCls.openDlg('dl_selectannotations', 'Sequences and Annotations');
            // add note about assembly
            if((ic.bAssemblyNote === undefined || !ic.bAssemblyNote) && ic.asuCnt !== undefined ) {
                let html = "     <br><div id='" + ic.pre + "assembly_note' style='margin-left:5px;'><span class='icn3d-annoLargeTitle'>Assembly Tips:</span> Only the asymmetric unit is shown in the sequence window.<br>Click \"Assembly\" in the menu \"View\" to switch between asymmetric unit and biological assembly(<b>" + ic.asuCnt + "</b> asymmetric unit).</div>";
                $("#" + ic.pre + "dl_annotations_tabs").append(html);
                ic.bAssemblyNote = true;
            }

            if(ic.bResetAnno) {
                //reset Anno when loading another structure
                ic.giSeq = {};
                ic.currClin = {};
                ic.resi2disease_nonempty = {};
                ic.baseResi = {};
                ic.matchedPos = {};

                $("#" + me.pre + "dl_annotations").empty();
                //ic.annotationCls.setAnnoViewAndDisplay('overview');
                ic.annotationCls.setAnnoView('overview');
            }

            let nucleotide_chainid = {}, chemical_chainid = {}, chemical_set = {};
            //ic.protein_chainid = {};

            if(ic.bAnnoShown === undefined || !ic.bAnnoShown || ic.bResetAnno) { // ic.bResetAnno when loading another structure
                ic.protein_chainid = {};

                let chainArray = Object.keys(ic.chains);
                if(atoms) { // show annot just for the atoms
                    let structureArray = ic.resid2specCls.atoms2structureArray(atoms);
                    chainArray = [];
                    for(let i = 0, il = structureArray.length; i < il; ++i) {
                        chainArray = chainArray.concat(ic.structures[structureArray[i]]);
                    }
                }

                if(ic.giSeq === undefined) ic.giSeq = {};
                if(ic.currClin === undefined) ic.currClin = {};
                if(ic.resi2disease_nonempty === undefined) ic.resi2disease_nonempty = {};
                if(ic.baseResi === undefined) ic.baseResi = {};
                if(ic.matchedPos === undefined) ic.matchedPos = {};
                let dialogWidth;
                if(me.bNode) { // no $().dialog
                    dialogWidth = 500;
                }
                else {
                    dialogWidth =(me.cfg.notebook) ? me.htmlCls.WIDTH / 2 : $("#" + ic.pre + "dl_selectannotations").dialog( "option", "width" );
                }
                ic.seqAnnWidth = dialogWidth - 120 - 30*2 - 50; // title: 120px, start and end resi: 30px, extra space on the left and right: 50px
                
                for(let i = 0, il = chainArray.length; i < il; ++i) {
                    Math.round(chainArray[i].indexOf('_'));
                    //if(pos > 4) continue; // NMR structures with structure id such as 2K042,2K043, ...
                    // let atom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.chains[chainArray[i]]);

                    // the first residue of 6AL5_H is non-standard residue and treated as chemical
                    // choose the 100th atom, around the 5th residue
                    let atom = ic.firstAtomObjCls.getMiddleAtomObj(ic.chains[chainArray[i]], 100);

                    if(atom === undefined) atom = ic.firstAtomObjCls.getFirstAtomObj(ic.chains[chainArray[i]]);
                    if(atom === undefined) continue;

                    // only single letter chain has accession such as 1P9M_A
                    let chainLetter = chainArray[i].substr(chainArray[i].indexOf('_') + 1);
                    let chainidBase;
                    if(chainLetter.indexOf('_') !== -1) { // NCBI modified chainid, e.g., A_1
                        chainLetter = chainLetter.substr(0, chainLetter.indexOf('_'));
                        chainidBase = chainArray[i].substr(0, chainArray[i].indexOf('_')) + '_' + chainLetter;
                    }
                    else if(chainLetter.length > 1 && chainLetter.substr(chainLetter.length - 1) == '1') { // NCBI modified chainid, e.g., A1
                        chainLetter = chainLetter.substr(0, chainLetter.length - 1);
                        chainidBase = chainArray[i].substr(0, chainArray[i].indexOf('_')) + '_' + chainLetter;
                    }
                    else {
                        chainidBase = chainArray[i];
                    }
                    //if(me.cfg.mmdbid !== undefined) { // protein and chemicals/ions are in different chains

                    if(ic.proteins.hasOwnProperty(atom.serial) && ic.chainsSeq[chainArray[i]].length > 1) {
                        ic.protein_chainid[chainArray[i]] = chainidBase;
                    }
                    else if(ic.nucleotides.hasOwnProperty(atom.serial) && ic.chainsSeq[chainArray[i]].length > 1) {
                        nucleotide_chainid[chainArray[i]] = chainidBase;
                    }
                    else {
                        if(ic.chainsSeq[chainArray[i]].length > 1) {
                            chemical_chainid[chainArray[i]] = chainidBase;
                        }
                        else {
                            let name = ic.chainsSeq[chainArray[i]][0].name;
                            let resid = chainArray[i] + '_' + ic.chainsSeq[chainArray[i]][0].resi;
                            if(chemical_set[name] === undefined) chemical_set[name] = [];
                            chemical_set[name].push(resid);
                        }
                    }

                    //}
                    // protein and nucleotide chain may have chemicals/ions attached at the end
                    if((me.cfg.pdbid !== undefined || me.cfg.opmid !== undefined || me.cfg.mmcifid !== undefined || me.cfg.mmtfid !== undefined)
                      &&(ic.proteins.hasOwnProperty(atom.serial) || ic.nucleotides.hasOwnProperty(atom.serial)) ) {
                        for(let r = 0, rl = ic.chainsSeq[chainArray[i]].length; r < rl; ++r) {
                            let resObj = ic.chainsSeq[chainArray[i]][r];
                            if(resObj.name !== '' && resObj.name !== '-' && resObj.name == resObj.name.toUpperCase()) {
                                let resid = chainArray[i] + '_' + resObj.resi;
                                let atom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[resid]);
                                if(atom === undefined) atom = ic.firstAtomObjCls.getFirstAtomObj(ic.chains[chainArray[i]]);
                                if(ic.proteins.hasOwnProperty(atom.serial) || ic.nucleotides.hasOwnProperty(atom.serial)) {
                                    continue;
                                }
                                else {
                                    let name = resObj.name.trim();
                                    if(chemical_set[name] === undefined) chemical_set[name] = [];
                                    chemical_set[name].push(resid);
                                }
                            } // if(resObj.name !== ''
                        } // for(let r = 0
                    } // if(me.cfg.mmdbid
                } // for(let i = 0

                ic.maxAnnoLengthOri = 1;
                for(let chainid in ic.chainsSeq) {
                    // use protein or nucleotide as the max length
                    if(ic.chainsSeq[chainid].length > ic.maxAnnoLengthOri && (ic.protein_chainid.hasOwnProperty(chainid) || nucleotide_chainid.hasOwnProperty(chainid)) ) {
                        ic.maxAnnoLengthOri = ic.chainsSeq[chainid].length;
                    }
                }
                ic.maxAnnoLength = ic.maxAnnoLengthOri;
            }

            return {'nucleotide_chainid': nucleotide_chainid, 'chemical_chainid': chemical_chainid, 'chemical_set': chemical_set};
        }

        async showAnnotations(atoms) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            let result = this.showAnnotations_part1(atoms);

            let nucleotide_chainid = result.nucleotide_chainid;
            let chemical_chainid = result.chemical_chainid;
            let chemical_set = result.chemical_set;

            if(!ic.bAnnoShown || ic.bResetAnno) { // ic.bResetAnno when loading another structure
                // assign early to avoid load annotations twice
                ic.bAnnoShown = true;

                if(me.cfg.blast_rep_id === undefined) {
                   if(ic.bFullUi) {
                        if(me.cfg.mmtfid !== undefined) { // mmtf data do NOT have the missing residues
                            //let id = chainArray[0].substr(0, chainArray[0].indexOf('_'));
                            let id = Object.keys(ic.structures)[0];

                            await ic.mmcifParserCls.downloadMmcifSymmetry(id, 'mmtfid');
                        }
                        
                        await this.showAnnoSeqData(nucleotide_chainid, chemical_chainid, chemical_set);
                   }
                }
                else if(me.cfg.blast_rep_id !== undefined && !ic.bSmithwm && !ic.bLocalSmithwm) { // align sequence to structure
                    let url = me.htmlCls.baseUrl + 'pwaln/pwaln.fcgi?from=querytarget';
                    let dataObj = {'targets': me.cfg.blast_rep_id, 'queries': me.cfg.query_id};
                    if(me.cfg.query_from_to !== undefined ) {
                        // convert from 1-based to 0-based
                        let query_from_to_array = me.cfg.query_from_to.split(':');
                        for(let i = 0, il = query_from_to_array.length; i < il; ++i) {
                            query_from_to_array[i] = parseInt(query_from_to_array[i]) - 1;
                        }
                        dataObj['queries'] = me.cfg.query_id + ':' + query_from_to_array.join(':');
                    }
                    if(me.cfg.target_from_to !== undefined) {
                        // convert from 1-based to 0-based
                        let target_from_to_array = me.cfg.target_from_to.split(':');
                        for(let i = 0, il = target_from_to_array.length; i < il; ++i) {
                            target_from_to_array[i] = parseInt(target_from_to_array[i]) - 1;
                        }
                        dataObj['targets'] = me.cfg.blast_rep_id + ':' + target_from_to_array.join(':');
                    }

                    // get sequence
                    if(ic.blastAcxn) { 
                        let chainid = me.cfg.afid + '_A';
                        let seq = '';
                        for(let i = 0, il = ic.chainsSeq[chainid].length; i < il; ++i) {
                            seq += ic.chainsSeq[chainid][i].name;
                        }

                        dataObj['targets'] = seq;
                    }

                    let data = await me.getAjaxPostPromise(url, dataObj);

                    ic.seqStructAlignData = data;
                    await thisClass.showAnnoSeqData(nucleotide_chainid, chemical_chainid, chemical_set);
                } // align seq to structure
                else if(me.cfg.blast_rep_id !== undefined && (ic.bSmithwm || ic.bLocalSmithwm)) { // align sequence to structure
                    //{'targets': me.cfg.blast_rep_id, 'queries': me.cfg.query_id}
                    let idArray = [me.cfg.blast_rep_id];

                    let target, query;
                    if(me.cfg.query_id.indexOf('>') != -1) { //FASTA with header
                        query = me.cfg.query_id.substr(me.cfg.query_id.indexOf('\n') + 1);
                    }
                    else if(!(/\d/.test(me.cfg.query_id)) || me.cfg.query_id.length > 50) { //FASTA
                        query = me.cfg.query_id;
                    }
                    else { // accession
                        idArray.push(me.cfg.query_id);
                    }

                    // get sequence
                    if(ic.blastAcxn) { 
                        let chainid = me.cfg.afid + '_A';
                        let seq = '';
                        for(let i = 0, il = ic.chainsSeq[chainid].length; i < il; ++i) {
                            seq += ic.chainsSeq[chainid][i].name;
                        }

                        target = seq;
                    }
                    else {
                        let url = me.htmlCls.baseUrl + "/vastdyn/vastdyn.cgi?chainlist=" + idArray;
                        let chainid_seq = await me.getAjaxPromise(url, 'jsonp', false, "Can not retrieve the sequence of the accession(s) " + idArray.join(", "));

                        for(let acc in chainid_seq) {
                            target = chainid_seq[acc];
                        }
                    }

                    let match_score = 1, mismatch = -1, gap = -1, extension = -1;

                    let bLocal = (ic.bLocalSmithwm) ? true : false;
                    ic.seqStructAlignDataLocalSmithwm = ic.alignSWCls.alignSW(target, query, match_score, mismatch, gap, extension, bLocal);

                    await thisClass.showAnnoSeqData(nucleotide_chainid, chemical_chainid, chemical_set);
                 } // align seq to structure
            }
            //ic.bAnnoShown = true;

            if($("#" + ic.pre + "anno_ig").length && $("#" + ic.pre + "anno_ig")[0].checked) {
                ic.bRunRefnumAgain = true;
                await ic.annotationCls.setAnnoTabIg();

                ic.bRunRefnumAgain = false;
            }
        }

        async showAnnoSeqData(nucleotide_chainid, chemical_chainid, chemical_set) { let ic = this.icn3d, me = ic.icn3dui;
            if(!me.bNode) await this.getAnnotationData();

            let i = 0;
            for(let chain in nucleotide_chainid) {
                this.getSequenceData(chain, nucleotide_chainid[chain], 'nucleotide', i);
                ++i;
            }
            ic.interactChainbase = me.hashUtilsCls.unionHash(ic.interactChainbase, ic.protein_chainid);
            ic.interactChainbase = me.hashUtilsCls.unionHash(ic.interactChainbase, nucleotide_chainid);
            i = 0;
            for(let chain in chemical_chainid) {
                this.getSequenceData(chain, chemical_chainid[chain], 'chemical', i);
                ++i;
            }
            ic.interactChainbase = me.hashUtilsCls.unionHash(ic.interactChainbase, chemical_chainid);
            ic.PTMChainbase = me.hashUtilsCls.unionHash(ic.PTMChainbase, ic.protein_chainid);

            ic.ssbondChainbase = me.hashUtilsCls.unionHash(ic.ssbondChainbase, ic.protein_chainid);
            ic.ssbondChainbase = me.hashUtilsCls.unionHash(ic.ssbondChainbase, chemical_chainid);
            ic.crosslinkChainbase = me.hashUtilsCls.unionHash(ic.crosslinkChainbase, ic.protein_chainid);
            ic.crosslinkChainbase = me.hashUtilsCls.unionHash(ic.crosslinkChainbase, nucleotide_chainid);
            ic.crosslinkChainbase = me.hashUtilsCls.unionHash(ic.crosslinkChainbase, chemical_chainid);
            for(let name in chemical_set) {
                this.getCombinedSequenceData(name, chemical_set[name], i);
                ++i;
            }

            if(!me.bNode) {
                this.enableHlSeq();
                ic.annotationCls.hideAllAnno();

                // setTimeout(function(){
                //     ic.annotationCls.clickCdd();
                // }, 0);

                ic.annotationCls.clickCdd();
            }
        }

        async getAnnotationData() { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;
            let chnidBaseArray = $.map(ic.protein_chainid, function(v) { return v; });
            let index = 0;

            // get geneid
            if(!ic.chainsGene) ic.chainsGene = {};
            for(let chnid in ic.protein_chainid) {
                let structure = chnid.substr(0, chnid.indexOf('_'));
                // UniProt or NCBI protein accession
                if(structure.length > 5) {
                    let url;
                    if(ic.uniprot2acc && ic.uniprot2acc[structure]) {
                        ic.uniprot2acc[structure];
                    }
                    else {
                        ic.uniprot2acc = {};

                        // try {
                        //     if(!ic.uniprot2acc) ic.uniprot2acc = {};
                        // the following query is slow due to the missing index in DB
                        //     url = me.htmlCls.baseUrl + "vastdyn/vastdyn.cgi?uniprot2refseq=" + structure;
                        //     let result = await me.getAjaxPromise(url, 'jsonp');
                        //     refseqid = (result && result.refseq) ? result.refseq : structure;

                        //     ic.uniprot2acc[structure] = refseqid;
                        // }
                        // catch {
                        //     console.log("Problem in getting protein accession from UniProt ID...")
                        //     refseqid = structure;
                        // }
                    }

                    // get Gene info from protein name
                    // url = me.htmlCls.baseUrl + "vastdyn/vastdyn.cgi?protein2gene=" + refseqid;
                    // ic.chainsGene[chnid] = await me.getAjaxPromise(url, 'jsonp');

                    // get Gene info from uniprot
                    url = "https://rest.uniprot.org/uniprotkb/search?format=json&fields=xref_geneid,gene_names&query=" + structure;
                    let geneData = await me.getAjaxPromise(url, 'json');
                    let geneId = (geneData.results[0] && geneData.results[0].uniProtKBCrossReferences && geneData.results[0].uniProtKBCrossReferences[0]) ? geneData.results[0].uniProtKBCrossReferences[0].id : undefined;
                    let geneSymbol = (geneData.results[0] && geneData.results[0].genes && geneData.results[0].genes[0] && geneData.results[0].genes[0].geneName) ? geneData.results[0].genes[0].geneName.value : 'ID ' + geneId;
                    ic.chainsGene[chnid] = {geneId: geneId, geneSymbol: geneSymbol};
                }
            }

            for(let chnid in ic.protein_chainid) {
                let buttonStyle = me.utilsCls.isMobile() ? 'none' : 'button';
                let fullProteinName = ic.showSeqCls.getProteinName(chnid);
                let proteinName = fullProteinName;
                //if(proteinName.length > 40) proteinName = proteinName.substr(0, 40) + "...";
                let categoryStr =(index == 0) ? "<span class='icn3d-annoLargeTitle'><b>Proteins</b>: </span><br><br>" : "";
                let geneLink =(ic.chainsGene[chnid] && ic.chainsGene[chnid].geneId && ic.chainsGene[chnid].geneDesc) ? "(Gene: <a href='https://www.ncbi.nlm.nih.gov/gene/" + ic.chainsGene[chnid].geneId + "?report=gene_table' target='_blank' title='" + ic.chainsGene[chnid].geneDesc + "'>" + ic.chainsGene[chnid].geneSymbol + "</a>)" : '';
                let structure = chnid.substr(0, chnid.indexOf('_'));
                let chainLink = (structure.length > 5) ? '<a href="https://alphafold.ebi.ac.uk/entry/' + structure + '" target="_blank">' + chnid + '</a>' : chnid;
                let chainHtml = "<div id='" + ic.pre + "anno_" + chnid + "' class='icn3d-annotation'>" + categoryStr
                    + "<span style='font-weight:bold;'>Annotations of " + chainLink
                    + "</span>: <a class='icn3d-blue' href='https://www.ncbi.nlm.nih.gov/protein?term="
                    + chnid + "' target='_blank' title='" + fullProteinName + "'>" + proteinName + "</a>"
                    + geneLink + "&nbsp;&nbsp;&nbsp;"
                    + this.addButton(chnid, "icn3d-addtrack", "Add Track", "Add a custom track", 60, buttonStyle)
                    + "&nbsp;&nbsp;&nbsp;";
                //if(me.cfg.blast_rep_id !== undefined && me.cfg.blast_rep_id == chnid) {
                    chainHtml += this.addButton(chnid, "icn3d-customcolor", "Custom Color/Tube", "Use a custom file to define the colors or tubes in 3D structure", 110, buttonStyle) + "&nbsp;&nbsp;&nbsp;";
                //}
                    chainHtml += this.addButton(chnid, "icn3d-helixsets", "Helix Sets", "Define sets for each helix in this chain and add them to the menu of \"Defined Sets\"", 60, buttonStyle) + "&nbsp;"
                    + this.addButton(chnid, "icn3d-sheetsets", "Sheet Sets", "Define sets for each sheet in this chain and add them to the menu of \"Defined Sets\"", 60, buttonStyle) + "&nbsp;"
                    + this.addButton(chnid, "icn3d-coilsets", "Coil Sets", "Define sets for each coil in this chain and add them to the menu of \"Defined Sets\"", 60, buttonStyle);

                    // if(ic.bShowRefnum && ic.chainid2refpdbname.hasOwnProperty(chnid) && ic.chainid2refpdbname[chnid].length > 0) {
                        chainHtml += "&nbsp;&nbsp;&nbsp;" + this.addButton(chnid, "icn3d-iganchorsets", "Ig Anchor Set", "Define the set for all Ig anchors in this chain and add them to the menu of \"Defined Sets\"", 80, buttonStyle) + "&nbsp;" 
                        + this.addButton(chnid, "icn3d-igstrandsets", "Ig Strand Sets", "Define sets for each Ig strand in this chain and add them to the menu of \"Defined Sets\"", 80, buttonStyle) + "&nbsp;"
                        + this.addButton(chnid, "icn3d-igloopsets", "Ig Loop Sets", "Define sets for each Ig loop in this chain and add them to the menu of \"Defined Sets\"", 80, buttonStyle) + "&nbsp;"
                        + this.addButton(chnid, "icn3d-igdomainsets", "Ig Domain Sets", "Define sets for each Ig domain in this chain and add them to the menu of \"Defined Sets\"", 80, buttonStyle);
                    // }
                $("#" + ic.pre + "dl_annotations").append(chainHtml);
                //let itemArray = ['giseq', 'cdd', 'clinvar', 'snp', 'domain', 'site', 'ptm', 'interaction', 'custom', 'ssbond', 'crosslink', 'transmem'];
                let itemArray = ['giseq', 'cdd', 'clinvar', 'snp', 'site', 'ptm', 'ssbond', 'crosslink', 'transmem', 'domain', 'custom', 'interaction', 'ig'];
                // dt: detailed view, hide by default; ov: overview, show by default
                for(let i in itemArray) {
                    let item = itemArray[i];
                    $("#" + ic.pre + "anno_" + chnid).append(this.getAnDiv(chnid, item));
                }
                $("#" + ic.pre + "anno_" + chnid).append("<br><hr><br>");
                ++index;
            }
            
            if(!me.bNode) ic.annoCddSiteCls.setToolTip();

            if(ic.chainid_seq !== undefined) {     
                await this.processSeqData(ic.chainid_seq);
            }
            else {       
                try {
                    let pdbChainidArray = [], afChainidArray = [];
                    for(let i = 0, il = chnidBaseArray.length; i < il; ++i) {
                        let struct = chnidBaseArray[i].substr(0, chnidBaseArray.indexOf('_'));
                        //if(chnidBaseArray[i].length >= 6) {
                        if(struct.length >= 6) {
                            afChainidArray.push(chnidBaseArray[i]);
                        }
                        else {
                            pdbChainidArray.push(chnidBaseArray[i]);
                        }
                    }

                    if(pdbChainidArray.length > 0) {
                        let url = me.htmlCls.baseUrl + "/vastdyn/vastdyn.cgi?chainlist=" + pdbChainidArray;
                        ic.chainid_seq = await me.getAjaxPromise(url, 'jsonp');
                    }
                    else {
                        ic.chainid_seq = {};
                    }

                    let data;

                    for(let i = 0, il = afChainidArray.length; i < il; ++i) {
                        let chainid = afChainidArray[i];
                        let seq = '';
                        for(let i = 0, il = ic.chainsSeq[chainid].length; i < il; ++i) {
                            seq += ic.chainsSeq[chainid][i].name;
                        }
                        ic.chainid_seq[chainid] = seq;
                    }
                    
                    // let url = me.htmlCls.baseUrl + "/vastdyn/vastdyn.cgi?chainlist=" + chnidBaseArray;
                    // let data = await me.getAjaxPromise(url, 'jsonp');
                    // ic.chainid_seq = data;

                    await thisClass.processSeqData(ic.chainid_seq);
                }
                catch(err) {
                    thisClass.enableHlSeq();
                    if(!me.bNode) console.log( "No sequence data were found for the protein " + chnidBaseArray + "..." );
                    for(let chnid in ic.protein_chainid) {
                        let chnidBase = ic.protein_chainid[chnid];
                        ic.showSeqCls.setAlternativeSeq(chnid, chnidBase);
                        ic.showSeqCls.showSeq(chnid, chnidBase);
                    }
                    // get CDD/Binding sites
                    await ic.annoCddSiteCls.showCddSiteAll();
                    return;
                }
            }
        }

        getSequenceData(chnid, chnidBase, type, index) { let ic = this.icn3d; ic.icn3dui;
            let fullProteinName = ic.showSeqCls.getProteinName(chnid);
            let proteinName = fullProteinName;
            if(proteinName.length > 40) proteinName = proteinName.substr(0, 40) + "...";
            let categoryStr = "";
            if(index == 0) {
                if(type == 'protein') {
                    categoryStr = "<span class='icn3d-annoLargeTitle'><b>Proteins</b>: </span><br><br>";
                }
                else if(type == 'nucleotide') {
                    categoryStr = "<span class='icn3d-annoLargeTitle'><b>Nucleotides</b>: </span><br><br>";
                }
                else if(type == 'chemical') {
                    categoryStr = "<span class='icn3d-annoLargeTitle'><b>Chemicals/Ions/Water</b>: </span><br><br>";
                }
            }
            $("#" + ic.pre + "dl_annotations").append("<div id='" + ic.pre + "anno_" + chnid + "' class='icn3d-annotation'>" + categoryStr + "<b>" + chnid + "</b>: " + "<span title='" + fullProteinName + "'>" + proteinName + "</span> </div>");
            // dt: detailed view, hide by default; ov: overview, show by default
            $("#" + ic.pre + "anno_" + chnid).append(this.getAnDiv(chnid, 'giseq'));
            //$("#" + ic.pre + "anno_" + chnid).append(this.getAnDiv(chnid, 'custom'));
            $("#" + ic.pre + "anno_" + chnid).append(this.getAnDiv(chnid, 'interaction'));
            $("#" + ic.pre + "anno_" + chnid).append("<br><hr><br>");
            // show the sequence and 3D structure
            ic.giSeq[chnid] = [];

            for(let i = 0; i < ic.chainsSeq[chnid].length; ++i) {
                let res = ic.chainsSeq[chnid][i].name;
                //ic.giSeq[chnid][i] =(res.length > 1) ? res.substr(0, 1) : res;
                ic.giSeq[chnid][i] = res;
            }
            ic.matchedPos[chnid] = 0;
            ic.baseResi[chnid] = ic.chainsSeq[chnid][0].resi - ic.matchedPos[chnid] - 1;
            ic.showSeqCls.showSeq(chnid, chnidBase, type);
            //ic.annoContactCls.showInteraction(chnid, chnidBase);
        }
        getCombinedSequenceData(name, residArray, index) { let ic = this.icn3d, me = ic.icn3dui;
            let categoryStr =(index == 0) ? "<span class='icn3d-annoLargeTitle'><b>Chemicals/Ions/Water</b>: </span><br><br>" : "";
            let chemName;
            let pos = residArray[0].lastIndexOf('_');
            let firstChainid = residArray[0].substr(0, pos);
            let sid =(me.cfg.mmdbid !== undefined && ic.chainid2sid !== undefined) ? ic.chainid2sid[firstChainid] : undefined;
            if(sid !== undefined) {
                chemName = "<b>" + name + " <a class='icn3d-blue' href='https://pubchem.ncbi.nlm.nih.gov/substance/" + sid + "#section=2D-Structure' target='_blank'><img src='https://pubchem.ncbi.nlm.nih.gov/image/imgsrv.fcgi?sid=" + sid + "'></a></b>";
            }
            else {
                chemName = "<b>" + name + "</b>";
            }
            $("#" + ic.pre + "dl_annotations").append("<div id='" + ic.pre + "anno_" + name + "' class='icn3d-annotation'>" + categoryStr + chemName + "</div>");
            // dt: detailed view, hide by default; ov: overview, show by default
            $("#" + ic.pre + "anno_" + name).append("<div id='" + ic.pre + "giseq_" + name + "'><div id='" + ic.pre + "dt_giseq_" + name + "' style='display:none'></div><div id='" + ic.pre + "ov_giseq_" + name + "'></div></div>");
            $("#" + ic.pre + "anno_" + name).append("<br><hr><br>");
            // sequence, detailed view
            // let htmlTmp = '<div id="' + ic.pre + 'giseq_sequence" class="icn3d-dl_sequence">';
            let htmlTmp = '<div class="icn3d-dl_sequence">';
            let chainType = 'Chem.', chainTypeFull = 'Chemical';
            //htmlTmp += '<div class="icn3d-seqTitle2" anno="sequence"><span style="white-space:nowrap;" title="' + chainTypeFull + ' ' + name + '">' + chainType + ' ' + name + '</span></div>';
            htmlTmp += '<div class="icn3d-seqTitle icn3d-link icn3d-blue" anno="sequence" gi="' + name + '" resn="' + name + '"><span style="white-space:nowrap;" title="' + chainTypeFull + ' ' + name + '">' + chainType + ' ' + name + '</span></div>';
            htmlTmp += '<span class="icn3d-residueNum" style="width:60px!important;" title="starting protein sequence number">Count: ' + residArray.length + '</span>';
            htmlTmp += '<span class="icn3d-seqLine">';
            // sequence, overview
            let html = htmlTmp;
            let html2 = htmlTmp;
            for(let i = 0, il = residArray.length; i < il; ++i) {
              let cFull = name;
              let c = cFull;
              if(cFull.length > 3) {
                  c = cFull.substr(0,3);
              }
              if(i < residArray.length - 1) c = c + ',';
              let resid = residArray[i];
              let resi = resid.substr(resid.lastIndexOf('_') + 1);
              html += '<span id="giseq_' + ic.pre + resid + '" title="' + cFull + resi + '" class="icn3d-residue icn3d-chemical">' + c + '</span>';
            }
            let color = me.htmlCls.GREY8;
            //html2 += '<div class="icn3d-seqTitle" style="display:inline-block; color:white; font-weight:bold; background-color:' + color + '; width:' + Math.round(ic.seqAnnWidth * residArray.length / ic.maxAnnoLength) + 'px;">' + name + '</div>';
            let width = Math.round(ic.seqAnnWidth * residArray.length / ic.maxAnnoLength);
            if(width < 1) width = 1;
            html2 += '<div class="icn3d-seqTitle" style="display:inline-block; color:white; font-weight:bold; background-color:' + color + '; width:' + width + 'px;">&nbsp;</div>';
            //htmlTmp = '<span class="icn3d-residueNum" title="ending protein sequence number">' + residArray.length + '</span>';
            //htmlTmp += '</span>';
            htmlTmp = '</span>';
            htmlTmp += '<br>';
            htmlTmp += '</div>';
            html += htmlTmp;
            html2 += htmlTmp;
            $("#" + ic.pre + 'dt_giseq_' + name).html(html);
            $("#" + ic.pre + 'ov_giseq_' + name).html(html2);
        }

        async processSeqData(chainid_seq) { let ic = this.icn3d, me = ic.icn3dui;
            ic.bAnnoShown = true;

            for(let chnid in ic.protein_chainid) {
                let chnidBase = ic.protein_chainid[chnid];
                //if(chainid_seq.hasOwnProperty(chnid)) {
                //    let allSeq = chainid_seq[chnid];
                if(chainid_seq.hasOwnProperty(chnidBase)) {
                    let allSeq = chainid_seq[chnidBase];
                    ic.giSeq[chnid] = allSeq;
                    
                    // the first 10 residues from sequences with structure
                    let startResStr = '';
                    for(let i = 0; i < 10 && i < ic.chainsSeq[chnid].length; ++i) {
                        startResStr += ic.chainsSeq[chnid][i].name.substr(0, 1);
                    }
                    let pos = allSeq.toLowerCase().indexOf(startResStr.toLowerCase());
                    if(pos == -1) {
                        console.log("The gi sequence didn't match the protein sequence. The start of 3D protein sequence: " + startResStr + ". The gi sequence: " + allSeq.substr(0, 10) + ".");
                        ic.showSeqCls.setAlternativeSeq(chnid, chnidBase);
                    }
                    else {
                        ic.matchedPos[chnid] = pos;
                        ic.baseResi[chnid] = ic.chainsSeq[chnid][0].resi - ic.matchedPos[chnid] - 1;
                    }
                }
                else {
                    if(!me.bNode) console.log( "No sequence data were found for the chain " + chnid + "..." );
                    ic.showSeqCls.setAlternativeSeq(chnid, chnidBase);
                }
                         
                if(me.cfg.blast_rep_id != chnid) {               
                    ic.showSeqCls.showSeq(chnid, chnidBase);
                }
                else if(me.cfg.blast_rep_id == chnid && ic.seqStructAlignData === undefined && ic.seqStructAlignDataSmithwm === undefined) {
                  let title;
                  let query_id = (me.cfg.oriQuery_id) ? me.cfg.oriQuery_id : me.cfg.query_id;
                  if(query_id.length > 14) {
                      title = 'Query: ' + query_id.substr(0, 6) + '...';
                  }
                  else {
                      title =(isNaN(me.cfg.query_id)) ? 'Query: ' + query_id : 'Query: gi ' + query_id;
                  }
                  let compTitle = undefined;
                  let compText = undefined;
                  let text = "cannot be aligned";

                  ic.queryStart = '';
                  ic.queryEnd = '';
                  if(ic.bRender) alert('The sequence can NOT be aligned to the structure');
                  ic.showSeqCls.showSeq(chnid, chnidBase, undefined, title, compTitle, text, compText);
                }
                else if(me.cfg.blast_rep_id == chnid && (ic.seqStructAlignData !== undefined || ic.seqStructAlignDataSmithwm !== undefined) ) { // align sequence to structure
                  let title;
                  let query_id = (me.cfg.oriQuery_id) ? me.cfg.oriQuery_id : me.cfg.query_id;
                  if(query_id.length > 14) {
                      title = 'Query: ' + query_id.substr(0, 6) + '...';
                  }
                  else {
                      title =(isNaN(me.cfg.query_id)) ? 'Query: ' + query_id : 'Query: gi ' + query_id;
                  }
                
                  let evalue, targetSeq, querySeq, segArray;

                  if(ic.seqStructAlignData !== undefined) {
                    let query, target;
                    let data = ic.seqStructAlignData;
                    if(data.data !== undefined) {
                        query = data.data[0].query;
                        // if target is sequence, the key is not chnid
                        //target = data.data[0].targets[chnid];
                        let keys = Object.keys(data.data[0].targets);
                        target = data.data[0].targets[keys[0]];

                        target =(target !== undefined && target.hsps.length > 0) ? target.hsps[0] : undefined;
                    }

                    if(query !== undefined && target !== undefined) {
                        evalue = target.scores.e_value.toPrecision(2);
                        if(evalue > 1e-200) evalue = parseFloat(evalue).toExponential();
                        target.scores.bit_score;
                        // if target is sequence, the key is not chnid
                        // targetSeq = data.targets[chnid].seqdata;
                        let keys = Object.keys(data.targets);
                        targetSeq = data.targets[keys[0]].seqdata;

                        querySeq = query.seqdata;
                        segArray = target.segs;
                    }               
                  }
                  else { // mimic the output of the cgi pwaln.fcgi
                    let data = ic.seqStructAlignDataSmithwm;
                    evalue = data.score;
                    targetSeq = data.target.replace(/-/g, '');
                    querySeq = data.query.replace(/-/g, '');
                    segArray = [];
                    // target, 0-based: orifrom, orito
                    // query, 0-based: from, to

                    let targetCnt = -1, queryCnt = -1;
                    let bAlign = false, seg = {};
                    for(let i = 0, il = data.target.length; i < il; ++i) {
                        if(data.target[i] != '-')  ++targetCnt;
                        if(data.query[i] != '-')  ++queryCnt;
                        if(!bAlign && data.target[i] != '-' && data.query[i] != '-') {
                            bAlign = true;
                            seg.orifrom = targetCnt;
                            seg.from = queryCnt;
                        }
                        else if(bAlign && (data.target[i] == '-' || data.query[i] == '-') ) {
                            bAlign = false;
                            seg.orito = (data.target[i] == '-') ? targetCnt : targetCnt - 1;
                            seg.to = (data.query[i] == '-') ? queryCnt : queryCnt - 1;
                            segArray.push(seg);
                            seg = {};
                        }
                    }

                    // end condition
                    if(data.target[data.target.length - 1] != '-' && data.query[data.target.length - 1] != '-') {
                        seg.orito = targetCnt;
                        seg.to = queryCnt;

                        segArray.push(seg);
                    }
                  }

                  let text = '', compText = '';
                  ic.queryStart = '';
                  ic.queryEnd = '';
                              
                  if(segArray !== undefined) {
                      let target2queryHash = {};
                      if(ic.targetGapHash === undefined) ic.targetGapHash = {};
                      ic.fullpos2ConsTargetpos = {};
                      ic.consrvResPosArray = [];
                      let prevTargetTo = 0, prevQueryTo = 0;
                      ic.nTotalGap = 0;
                      ic.queryStart = segArray[0].from + 1;
                      ic.queryEnd = segArray[segArray.length - 1].to + 1;
                      for(let i = 0, il = segArray.length; i < il; ++i) {
                          let seg = segArray[i];
                          if(i > 0) { // determine gap
                            if(seg.orifrom - prevTargetTo < seg.from - prevQueryTo) { // gap in target
                                ic.targetGapHash[seg.orifrom] = {'from': prevQueryTo + 1, 'to': seg.from - 1};
                                ic.nTotalGap += ic.targetGapHash[seg.orifrom].to - ic.targetGapHash[seg.orifrom].from + 1;
                            }
                            else if(seg.orifrom - prevTargetTo > seg.from - prevQueryTo) { // gap in query
                                for(let j = prevTargetTo + 1; j < seg.orifrom; ++j) {
                                  target2queryHash[j] = -1; // means gap in query
                                }
                            }
                          }
                          for(let j = 0; j <= seg.orito - seg.orifrom; ++j) {
                              target2queryHash[j + seg.orifrom] = j + seg.from;
                          }
                          prevTargetTo = seg.orito;
                          prevQueryTo = seg.to;
                      }

                      // the missing residues at the end of the seq will be filled up in the API showNewTrack()
                      let nGap = 0;
                      ic.alnChainsSeq[chnid] = [];

                      //let offset =(ic.chainid2offset[chnid]) ? ic.chainid2offset[chnid] : 0;                
                      for(let i = 0, il = targetSeq.length; i < il; ++i) {
                          //text += ic.showSeqCls.insertGap(chnid, i, '-', true);
                          if(ic.targetGapHash.hasOwnProperty(i)) {
                              for(let j = ic.targetGapHash[i].from; j <= ic.targetGapHash[i].to; ++j) {
                                  text += querySeq[j];
                              }
                          }
                          compText += ic.showSeqCls.insertGap(chnid, i, '-', true);
                          if(ic.targetGapHash.hasOwnProperty(i)) nGap += ic.targetGapHash[i].to - ic.targetGapHash[i].from + 1;
                          //let pos =(ic.bUsePdbNum) ? i+1 + offset : i+1;
                          let pos =(ic.bUsePdbNum) ? ic.ParserUtilsCls.getResi(chnid, i) : i+1;
                          if(target2queryHash.hasOwnProperty(i) && target2queryHash[i] !== -1) {
                              text += querySeq[target2queryHash[i]];
                              let colorHexStr = this.getColorhexFromBlosum62(targetSeq[i], querySeq[target2queryHash[i]]);
                              if(targetSeq[i] == querySeq[target2queryHash[i]]) {
                                  compText += targetSeq[i];
                                  ic.fullpos2ConsTargetpos[i + nGap] = {'same': 1, 'pos': pos, 'res': targetSeq[i], 'color': colorHexStr};
                                  ic.consrvResPosArray.push(pos);
                                  ic.alnChainsSeq[chnid].push({'resi': pos, 'color': '#FF0000', 'color2': '#' + colorHexStr});
                              }
                              else if(this.conservativeReplacement(targetSeq[i], querySeq[target2queryHash[i]])) {
                                  compText += '+';
                                  ic.fullpos2ConsTargetpos[i + nGap] = {'same': 0, 'pos': pos, 'res': targetSeq[i], 'color': colorHexStr};
                                  ic.consrvResPosArray.push(pos);
                                  ic.alnChainsSeq[chnid].push({'resi': pos, 'color': '#0000FF', 'color2': '#' + colorHexStr});
                              }
                              else {
                                  compText += ' ';
                                  ic.fullpos2ConsTargetpos[i + nGap] = {'same': -1, 'pos': pos, 'res': targetSeq[i], 'color': colorHexStr};
                                  ic.alnChainsSeq[chnid].push({'resi': pos, 'color': me.htmlCls.GREYC, 'color2': '#' + colorHexStr});
                              }
                          }
                          else {
                              text += '-';
                              compText += ' ';
                          }
                      }

                      //title += ', E: ' + evalue;
                  }
                  else {                
                      text += "cannot be aligned";
                      if(ic.bRender) alert('The sequence can NOT be aligned to the structure');
                  }
                  let compTitle = (ic.seqStructAlignData !== undefined) ? 'BLAST, E: ' + evalue : 'Score: ' + evalue;
                  ic.showSeqCls.showSeq(chnid, chnidBase, undefined, title, compTitle, text, compText);
                  let residueidHash = {};
                  let residueid;
                  if(ic.consrvResPosArray !== undefined) {
                    for(let i = 0, il = ic.consrvResPosArray.length; i < il; ++i) {
                        residueid = chnidBase + '_' + ic.consrvResPosArray[i];
                        residueidHash[residueid] = 1;
                        //atomHash = me.hashUtilsCls.unionHash(atomHash, ic.residues[residueid]);
                    }
                  }
                  let prevHAtoms = me.hashUtilsCls.cloneHash(ic.hAtoms);
                  //ic.selectionCls.selectResidueList(residueidHash, chnidBase + '_blast', compTitle, false);
                  ic.selectionCls.selectResidueList(residueidHash, 'protein_aligned', compTitle, false);
                  ic.hAtoms = me.hashUtilsCls.cloneHash(prevHAtoms);
                } // align seq to structure
            } // for loop
            
            if(!me.bNode) {
                this.enableHlSeq();
                // get CDD/Binding sites
                await ic.annoCddSiteCls.showCddSiteAll();
            }
        }

        enableHlSeq() { let ic = this.icn3d, me = ic.icn3dui;
            if(! me.utilsCls.isMobile()) {
                ic.hlSeqCls.selectSequenceNonMobile();
            }
            else {
                ic.hlSeqCls.selectSequenceMobile();
                ic.hlSeqCls.selectChainMobile();
            }
            // highlight seq after the ajax calls
            if(Object.keys(ic.hAtoms).length < Object.keys(ic.dAtoms).length) {
                ic.hlUpdateCls.updateHlSeq();
            }
        }

        getAnDiv(chnid, anno) { let ic = this.icn3d; ic.icn3dui;
            let message = 'Loading ' + anno + '...';
            if(anno == 'custom') {
                message = '';
            }
            else if(anno == 'domain') {
                message = 'Loading 3D ' + anno + '...';
            }
            return "<div id='" + ic.pre + anno + "_" + chnid + "'><div id='" + ic.pre + "tt_" + anno + "_" + chnid + "' class='icn3d-fixed-pos' style='display:none!important'></div><div id='" + ic.pre + "dt_" + anno + "_" + chnid + "' style='display:none'>" + message + "</div><div id='" + ic.pre + "ov_" + anno + "_" + chnid + "'>" + message + "</div></div>";
        }
        addButton(chnid, classvalue, name, desc, width, buttonStyle) { let ic = this.icn3d; ic.icn3dui;
            return "<div class='" + classvalue + "' chainid='" + chnid + "' style='display:inline-block; font-size:11px; font-weight:bold; width:" + width + "px!important;'><button style='-webkit-appearance:" + buttonStyle + "; height:18px; width:" + width + "px;'><span style='white-space:nowrap; margin-left:-3px;' title='" + desc + "'>" + name + "</span></button></div>";
        }
        addSnpButton(snp, classvalue, name, desc, width, buttonStyle) { let ic = this.icn3d; ic.icn3dui;
            return "<div class='" + ic.pre + classvalue + "' snp='" + snp + "' style='margin:3px 0 3px 0; display:inline-block; font-size:11px; font-weight:bold; width:" + width + "px!important;'><button style='-webkit-appearance:" + buttonStyle + "; height:18px; width:" + width + "px;'><span style='white-space:nowrap; margin-left:-3px;' title='" + desc + "'>" + name + "</span></button></div>";
        }
        conservativeReplacement(resA, resB) { let ic = this.icn3d, me = ic.icn3dui;
            let iA =(me.parasCls.b62ResArray.indexOf(resA) !== -1) ? me.parasCls.b62ResArray.indexOf(resA) : me.parasCls.b62ResArray.length - 1; // or the last one "*"
            let iB =(me.parasCls.b62ResArray.indexOf(resB) !== -1) ? me.parasCls.b62ResArray.indexOf(resB) : me.parasCls.b62ResArray.length - 1; // or the last one "*"
            let matrixValue = me.parasCls.b62Matrix[iA][iB];
            if(matrixValue > 0) {
                return true;
            }
            else {
                return false;
            }
        }
        getColorhexFromBlosum62(resA, resB) { let ic = this.icn3d, me = ic.icn3dui;
            let color = '333333';

            if(!resA || !resB) return color;
            
            resA = resA.toUpperCase();
            resB = resB.toUpperCase();

            let iA =(me.parasCls.b62ResArray.indexOf(resA) !== -1) ? me.parasCls.b62ResArray.indexOf(resA) : me.parasCls.b62ResArray.length - 1; // or the last one "*"
            let iB =(me.parasCls.b62ResArray.indexOf(resB) !== -1) ? me.parasCls.b62ResArray.indexOf(resB) : me.parasCls.b62ResArray.length - 1; // or the last one "*"
            let matrixValue = me.parasCls.b62Matrix[iA][iB];
            if(matrixValue === undefined) return '333333';
            // range and color: blue for -4 ~ 0, red for 0 ~ 11
            // max value 221 to avoid white
            
            if(matrixValue > 0) {
                let c = 221 - parseInt(matrixValue / 11.0 * 221);
                let cStr =(c < 10) ? '0' + c.toString(16) : c.toString(16);
                color = 'DD' + cStr + cStr;
            }
            else {
                let c = 221 - parseInt(-1.0 * matrixValue / 4.0 * 221);
                let cStr =(c < 10) ? '0' + c.toString(16) : c.toString(16);
                color = cStr + cStr + 'DD';
            }
            return color;
        }

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class ShowSeq {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        getSeq(chnid) {  let ic = this.icn3d, me = ic.icn3dui;
            let giSeq;
            if(me.cfg.mmdbid === undefined && me.cfg.gi === undefined && me.cfg.blast_rep_id === undefined && me.cfg.align === undefined && me.cfg.chainalign === undefined && me.cfg.mmdbafid === undefined) {
                giSeq = [];
                for(let i = 0; i < ic.chainsSeq[chnid].length; ++i) {
                    giSeq.push(ic.chainsSeq[chnid][i]);
                }
            }
            else {
                giSeq = ic.giSeq[chnid];
            }

            if(!giSeq) return [];

            // remove null giSeq[i]
            let giSeqTmp = [];
            for(let i = 0, il = giSeq.length; i < il; ++i) {
                if(giSeq[i]) {
                    giSeqTmp.push(giSeq[i]);
                }
            }
            giSeq = giSeqTmp;

            return giSeq;
        }

        //Show the sequences and secondary structures.
        showSeq(chnid, chnidBase, type, queryTitle, compTitle, queryText, compText) {  let ic = this.icn3d, me = ic.icn3dui;
            let giSeq = this.getSeq(chnid);

            let bNonMmdb = false;
            if(me.cfg.mmdbid === undefined && me.cfg.gi === undefined && me.cfg.blast_rep_id === undefined && me.cfg.align === undefined && me.cfg.chainalign === undefined && me.cfg.mmdbafid === undefined) {
                bNonMmdb = true;
            }

            //let divLength = me.htmlCls.RESIDUE_WIDTH * (ic.giSeq[chnid].length + ic.nTotalGap) + 200;
            let divLength = me.htmlCls.RESIDUE_WIDTH * (giSeq.length + ic.nTotalGap) + 200;

            // let seqLength = ic.giSeq[chnid].length
            // if(seqLength > ic.maxAnnoLength) {
            //     ic.maxAnnoLength = seqLength;
            // }

            //let itemArray = ['giseq', 'cddsite', 'ptm', 'clinvar', 'snp', 'domain', 'interaction', 'custom', 'ssbond', 'crosslink', 'transmem'];
            let itemArray = ['giseq', 'cddsite', 'clinvar', 'snp', 'ptm', 'ssbond', 'crosslink', 'transmem', 'domain', 'custom', 'interaction', 'ig'];
            for(let i in itemArray) {
                let item = itemArray[i];
                if($("#" + ic.pre + item + "_" + chnid).length) $("#" + ic.pre + item + "_" + chnid).width(divLength);
            }
            // gi html
            let html = '', html2 = '', html3 = '', htmlTmp;
            html += '<div class="icn3d-dl_sequence">';
            html3 += '<div class="icn3d-dl_sequence">';
            // html to display protein positions(10, 20, etc)
            //if(Object.keys(ic.chains[chnid]).length > 10) {

            if(giSeq.length > 10) {
                htmlTmp = '<div class="icn3d-residueLine" style="white-space:nowrap;">';
                let atom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.chains[chnid]);
                //if(ic.baseResi[chnid] != 0 &&(me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined || me.cfg.align !== undefined)) {
                if((me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined || me.cfg.blast_rep_id !== undefined || me.cfg.align !== undefined || me.cfg.chainalign !== undefined || me.cfg.mmdbafid !== undefined) && atom.resi_ori !== undefined && atom.resi_ori != atom.resi && chnid.indexOf('Misc') == -1 ) {
                    htmlTmp += '<div class="icn3d-annoTitle" anno="0" title="NCBI Residue Numbers">NCBI Residue Numbers</div>';
                }
                else {
                    htmlTmp += '<div class="icn3d-annoTitle" anno="0"></div>';
                }
                htmlTmp += '<span class="icn3d-residueNum"></span>';
                html3 += htmlTmp + '<br>';
                html += htmlTmp + '<span class="icn3d-seqLine">';
                let helixCnt = 0, sheetCnt = 0;
                let savedSsName = '';

                if(ic.seqStartLen && ic.seqStartLen[chnid]) html += this.insertMulGap(ic.seqStartLen[chnid], ' ');

                for(let i = 0, il = giSeq.length; i < il; ++i) {
                  html += this.insertGap(chnid, i, '-');
                  let currResi;
                //   if(bNonMmdb) {
                //     currResi = giSeq[i].resi;
                //   }
                //   else {
                //     currResi =(i >= ic.matchedPos[chnid] && i - ic.matchedPos[chnid] < ic.chainsSeq[chnid].length) ? ic.chainsSeq[chnid][i - ic.matchedPos[chnid]].resi : ic.baseResi[chnid] + 1 + i;
                //   }
                  currResi = ic.ParserUtilsCls.getResi(chnid, i);
                  html += '<span>';
                  if( currResi % 10 === 0) {
                    //html += currResi + ' ';
                    html += currResi;
                  }

                  // name of secondary structures
                  let residueid = chnid + '_' + currResi;
                  // do not overlap residue number with ss label
                  let bshowSsName =(currResi % 10 != 0 && currResi % 10 != 1 && currResi % 10 != 9) ? true : false;
                  if( ic.residues.hasOwnProperty(residueid) ) {
                    let atom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[residueid]);
                    if(ic.secondaries[residueid] == 'H' && atom.ssbegin) {
                        ++helixCnt;

                        savedSsName = '<span class="icn3d-helix-color">H' + helixCnt + '</span>';

                        if(bshowSsName) {
                            html += savedSsName;
                            savedSsName = '';
                        }
                    }
                    else if(ic.secondaries[residueid] == 'E' && atom.ssbegin) {
                        ++sheetCnt;
                        if(ic.sheetcolor == 'green') {
                            savedSsName = '<span class="icn3d-sheet-color">S' + sheetCnt + '</span>';
                        }
                        else if(ic.sheetcolor == 'yellow') {
                            savedSsName = '<span class="icn3d-sheet-colory">S' + sheetCnt + '</span>';
                        }

                        if(bshowSsName) {
                            html += savedSsName;
                            savedSsName = '';
                        }
                    }
                    else if(atom.ssend) {
                        savedSsName = '';
                    }

                    if(savedSsName != '' && bshowSsName) {
                        html += savedSsName;
                        savedSsName = '';
                    }
                  }
                  html += '</span>';
                }

                if(ic.seqStartLen && ic.seqStartLen[chnid]) html += this.insertMulGap(ic.seqEndLen[chnid], ' ');

                html += '<span class="icn3d-residueNum"></span>';
                html += '</span>';
                html += '<br>';
                html += '</div>';
                html3 += '</div>';
            }

            // html to display secondary structures
            htmlTmp = '<div class="icn3d-residueLine" style="white-space:nowrap;">';
            htmlTmp += '<div class="icn3d-annoTitle" anno="0"></div>';
            htmlTmp += '<span class="icn3d-residueNum"></span>';
            html3 += htmlTmp + '<br>';
            html += htmlTmp + '<span class="icn3d-seqLine">';

            if(ic.seqStartLen && ic.seqStartLen[chnid]) html += this.insertMulGap(ic.seqStartLen[chnid], '-');

            for(let i = 0, il = giSeq.length; i < il; ++i) {
              html += this.insertGap(chnid, i, '-');
            //   let resi =(i >= ic.matchedPos[chnid] && i - ic.matchedPos[chnid] < ic.chainsSeq[chnid].length) ? ic.chainsSeq[chnid][i - ic.matchedPos[chnid]].resi : ic.baseResi[chnid] + 1 + i;
              let resi = ic.ParserUtilsCls.getResi(chnid, i);
              let residueid = chnid + '_' + resi;

              if( ic.residues.hasOwnProperty(residueid) ) {
                if(ic.secondaries[residueid] == 'H') {
                    if(i % 2 == 0) {
                        html += '<span class="icn3d-helix">';
                    }
                    else {
                        html += '<span class="icn3d-helix2">';
                    }
                    html += '&nbsp;</span>';
                }
                else if(ic.secondaries[residueid] == 'E') {
                    let atom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[residueid]);
                    if(atom.ssend) {
                        if(ic.sheetcolor == 'green') {
                            html += '<span class="icn3d-sheet2">';
                        }
                        else if(ic.sheetcolor == 'yellow') {
                            html += '<span class="icn3d-sheet2y">';
                        }
                    }
                    else {
                        if(ic.sheetcolor == 'green') {
                            html += '<span class="icn3d-sheet">';
                        }
                        else if(ic.sheetcolor == 'yellow') {
                            html += '<span class="icn3d-sheety">';
                        }
                    }
                    html += '&nbsp;</span>';
                }
                else if(ic.secondaries[residueid] == 'c') {
                    html += '<span class="icn3d-coil">&nbsp;</span>';
                }
                else if(ic.secondaries[residueid] == 'o') {
                    html += '<span class="icn3d-other">&nbsp;</span>';
                }
              }
              else {
                html += '<span>-</span>'; //'<span>-</span>';
              }
            }
            
            if(ic.seqStartLen && ic.seqStartLen[chnid]) html += this.insertMulGap(ic.seqEndLen[chnid], '-');

            html += '<span class="icn3d-residueNum"></span>';
            html += '</span>';
            html += '<br>';
            html += '</div>';
            html += '</div>'; // corresponds to above: html += '<div class="icn3d-dl_sequence">';
            html3 += '</div></div>';
            // if(me.cfg.blast_rep_id === chnid) {
            //     htmlTmp = '<div id="' + ic.pre + 'giseq_sequence" class="icn3d-dl_sequence" style="border: solid 1px #000">';
            // }
            // else {
            //     htmlTmp = '<div id="' + ic.pre + 'giseq_sequence" class="icn3d-dl_sequence">';
            // }
            if(me.cfg.blast_rep_id === chnid) {
                htmlTmp = '<div class="icn3d-dl_sequence" style="border: solid 1px #000">';
            }
            else {
                htmlTmp = '<div class="icn3d-dl_sequence">';
            }
            let chainType = 'Protein', chainTypeFull = 'Protein';
            if(type !== undefined) {
                if(type == 'nucleotide') {
                    chainType = 'Nucl.';
                    chainTypeFull = 'Nucleotide';
                }
                else if(type == 'chemical') {
                    chainType = 'Chem.';
                    chainTypeFull = 'Chemical';
                }
            }
            // sequence, detailed view
            htmlTmp += '<div class="icn3d-seqTitle icn3d-link icn3d-blue" gi="' + chnid + '" anno="sequence" chain="' + chnid + '"><span style="white-space:nowrap;" title="' + chainTypeFull + ' ' + chnid + '">' + chainType + ' ' + chnid + '</span></div>';
            htmlTmp += '<span class="icn3d-residueNum" title="starting protein sequence number">' +(ic.baseResi[chnid]+1).toString() + '</span>';
            html3 += htmlTmp + '<br>';
            let htmlTmp2 = '<span class="icn3d-seqLine">';
            html += htmlTmp + htmlTmp2;
            html2 += htmlTmp + htmlTmp2;
            let pos, nGap = 0;

            if(ic.seqStartLen && ic.seqStartLen[chnid]) html += this.insertMulGap(ic.seqStartLen[chnid], '-');

            for(let i = 0, il = giSeq.length; i < il; ++i) {
              html += this.insertGap(chnid, i, '-');
              if(ic.targetGapHash !== undefined && ic.targetGapHash.hasOwnProperty(i)) nGap += ic.targetGapHash[i].to - ic.targetGapHash[i].from + 1;
              let cFull =(bNonMmdb) ? giSeq[i].name : giSeq[i];
              let c = cFull;
              if(cFull.length > 1) {
                  c = cFull[0] + '..';
              }
              
            //   pos =(i >= ic.matchedPos[chnid] && i - ic.matchedPos[chnid] < ic.chainsSeq[chnid].length) ? ic.chainsSeq[chnid][i - ic.matchedPos[chnid]].resi : ic.baseResi[chnid] + 1 + i;
              pos = ic.ParserUtilsCls.getResi(chnid, i);
                  
              if( !ic.residues.hasOwnProperty(chnid + '_' + pos) ) {
                  c = c.toLowerCase();
                  html += '<span title="' + cFull + pos + '" class="icn3d-residue">' + c + '</span>';
              }
              else {
                  let color = '333333';
                  if(me.cfg.blast_rep_id == chnid && ic.fullpos2ConsTargetpos !== undefined && ic.fullpos2ConsTargetpos[i + nGap] !== undefined) {
                      color = ic.fullpos2ConsTargetpos[i + nGap].color;
                  }
                  else {
                      let atom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[chnid + '_' + pos]);
                      let colorStr =(atom.color === undefined || atom.color.getHexString().toUpperCase() === 'FFFFFF' || atom.color.getHexString().toUpperCase() === 'FFF') ? 'DDDDDD' : atom.color.getHexString();
                      color =(atom.color !== undefined) ? colorStr : "CCCCCC";
                  }
                  html += '<span id="giseq_' + ic.pre + chnid + '_' + pos + '" title="' + cFull + pos + '" class="icn3d-residue" style="color:#' + color + '">' + c + '</span>';
              }
            }

            if(ic.seqStartLen && ic.seqStartLen[chnid]) html += this.insertMulGap(ic.seqEndLen[chnid], '-');

            if(me.cfg.blast_rep_id == chnid) {
              // change color in 3D
              ic.opts['color'] = (ic.blastAcxn) ? 'confidence' : 'conservation';
              ic.setColorCls.setColorByOptions(ic.opts, ic.atoms);
              // remove highlight
              //ic.hlUpdateCls.removeHlSeq();
            }
            // sequence, overview
            let atom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.chains[chnid]);
            let color =(atom.color) ? atom.color.getHexString() : "CCCCCC";
            let width = Math.round(ic.seqAnnWidth * giSeq.length / (ic.maxAnnoLength + ic.nTotalGap));
            if(width < 1) width = 1;

            if(ic.seqStartLen && ic.seqStartLen[chnid]) html2 += this.insertMulGapOverview(chnid, ic.seqStartLen[chnid]);

            if(me.cfg.blast_rep_id != chnid) { // regular
                html2 += '<div id="giseq_summary_' + ic.pre + chnid + '" class="icn3d-seqTitle icn3d-link" gi chain="' + chnid + '" style="display:inline-block; color:white; font-weight:bold; background-color:#' + color + '; width:' + width + 'px;">' + chnid + '</div>';
            }
            else { // with potential gaps
                let fromArray2 = [], toArray2 = [];
                fromArray2.push(0);
                for(let i = 0, il = giSeq.length; i < il; ++i) {
                    if(ic.targetGapHash !== undefined && ic.targetGapHash.hasOwnProperty(i)) {
                        toArray2.push(i - 1);
                        fromArray2.push(i);
                    }
                }
                toArray2.push(giSeq.length - 1);

                html2 += '<div id="giseq_summary_' + ic.pre + chnid + '" class="icn3d-seqTitle icn3d-link" gi chain="' + chnid + '" style="width:' + width + 'px;">';
                
                for(let i = 0, il = fromArray2.length; i < il; ++i) {
                    html2 += this.insertGapOverview(chnid, fromArray2[i]);
                    html2 += '<div style="display:inline-block; color:white!important; font-weight:bold; background-color:#' + color + '; width:' + Math.round(ic.seqAnnWidth *(toArray2[i] - fromArray2[i] + 1) /(ic.maxAnnoLength + ic.nTotalGap)) + 'px;" class="icn3d-seqTitle icn3d-link icn3d-blue" anno="sequence" gi chain="' + chnid + '" title="' + chnid + '">' + chnid + '</div>';
                }
                html2 += '</div>';
            }
            htmlTmp = '<span class="icn3d-residueNum" title="ending protein sequence number">' + pos + '</span>';
            htmlTmp += '</span>';
            htmlTmp += '<br>';
            html += htmlTmp;
            html2 += htmlTmp;
            if(me.cfg.blast_rep_id == chnid) {
                // 1. residue conservation
                if(compText !== undefined && compText !== '') {
                // conservation, detailed view
                htmlTmp = '<div class="icn3d-seqTitle icn3d-link icn3d-blue" blast="" posarray="' + ic.consrvResPosArray.toString() + '" title="' + compTitle + '" setname="' + chnid + '_blast" anno="sequence" chain="' + chnid + '"><span style="white-space:nowrap;" title="' + compTitle + '">' + compTitle + '</span></div>';
                htmlTmp += '<span class="icn3d-residueNum"></span>';
                html3 += htmlTmp + '<br>';
                let htmlTmp2 = '<span class="icn3d-seqLine">';
                html += htmlTmp + htmlTmp2;
                html2 += htmlTmp + htmlTmp2;
                let prevEmptyWidth = 0;
                let prevLineWidth = 0;
                let widthPerRes = 1;
                ic.queryStart;
                for(let i = 0, il = compText.length; i < il; ++i) {
                  let c = compText[i];
                  if(c == '-') {
                      html += '<span>-</span>';
                  }
                  else if(c == ' ') {
                      html += '<span> </span>';
                  }
                  else {
                      let pos = ic.fullpos2ConsTargetpos[i].pos;
                      if( !ic.residues.hasOwnProperty(chnid + '_' + pos) ) {
                          c = c.toLowerCase();
                          html += '<span class="icn3d-residue">' + c + '</span>';
                      }
                      else {
                          let color = ic.fullpos2ConsTargetpos[i].color;
                          html += '<span id="giseq_' + ic.pre + chnid + '_' + pos + '" title="' + ic.fullpos2ConsTargetpos[i].res + pos + '" class="icn3d-residue" style="color:#' + color + '">' + c + '</span>';
                      }
                      html2 += this.insertGapOverview(chnid, i);
                      let emptyWidth = Math.round(ic.seqAnnWidth * i /(ic.maxAnnoLength + ic.nTotalGap) - prevEmptyWidth - prevLineWidth);
                      //if(emptyWidth < 0) emptyWidth = 0;
                      if(emptyWidth >= 0) {
                      html2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';
                      html2 += '<div style="display:inline-block; background-color:#F00; width:' + widthPerRes + 'px;" title="' + c + pos + '">&nbsp;</div>';
                      prevEmptyWidth += emptyWidth;
                      prevLineWidth += widthPerRes;
                      }
                  }
                }
                htmlTmp = '<span class="icn3d-residueNum"></span>';
                htmlTmp += '</span>';
                htmlTmp += '<br>';
                html += htmlTmp;
                html2 += htmlTmp;
                }
                // 2. Query text
                // query protein, detailed view
                htmlTmp = '<div class="icn3d-annoTitle" anno="sequence" chain="' + chnid + '"><span style="white-space:nowrap;" title="' + queryTitle + '">' + queryTitle + '</span></div>';
                htmlTmp += '<span class="icn3d-residueNum" title="starting protein sequence number">' + ic.queryStart + '</span>';
                html3 += htmlTmp + '<br>';
                //var htmlTmp2 = '<span class="icn3d-seqLine">';
                let htmlTmp2 = '<span class="icn3d-seqLine" style="font-weight: bold;">';
                html += htmlTmp + htmlTmp2;
                html2 += htmlTmp + htmlTmp2;
                let queryPos = ic.queryStart;
                for(let i = 0, il = queryText.length; i < il; ++i) {
                  let c = queryText[i];
                  if(c == ' ' || c == '-') {
                      html += '<span>-</span>';
                  }
                  else {
                      if( ic.fullpos2ConsTargetpos !== undefined && ic.fullpos2ConsTargetpos[i] !== undefined && !ic.residues.hasOwnProperty(chnid + '_' + ic.fullpos2ConsTargetpos[i].pos) ) {
                          c = c.toLowerCase();
                          html += '<span title="' + c + queryPos + '" class="icn3d-residue">' + c + '</span>';
                      }
                      else {
                          html += '<span title="' + c + queryPos + '" class="icn3d-residue">' + c + '</span>';
                      }
                      ++queryPos;
                  }
                }
                // query protein, overview
                let atom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.chains[chnid]);
                let colorStr =(atom.color === undefined || atom.color.getHexString() === 'FFFFFF') ? 'DDDDDD' : atom.color.getHexString();
                let color =(atom.color !== undefined) ? colorStr : "CCCCCC";
                let fromArray2 = [], toArray2 = [];
                let prevChar = '-';
                for(let i = 0, il = queryText.length; i < il; ++i) {
                    let c = queryText[i];
                    if(c != '-' && prevChar == '-') {
                        fromArray2.push(i);
                    }
                    else if(c == '-' && prevChar != '-' ) {
                        toArray2.push(i-1);
                    }
                    prevChar = c;
                }
                if(prevChar != '-') {
                    toArray2.push(queryText.length - 1);
                }
                for(let i = 0, il = fromArray2.length; i < il; ++i) {
                    let emptyWidth =(i == 0) ? Math.round(ic.seqAnnWidth *(fromArray2[i] - ic.baseResi[chnid] - 1) /(ic.maxAnnoLength + ic.nTotalGap)) : Math.round(ic.seqAnnWidth *(fromArray2[i] - toArray2[i-1] - 1) /(ic.maxAnnoLength + ic.nTotalGap));
                    html2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';
                    html2 += '<div style="display:inline-block; color:white!important; font-weight:bold; background-color:#' + color + '; width:' + Math.round(ic.seqAnnWidth *(toArray2[i] - fromArray2[i] + 1) /(ic.maxAnnoLength + ic.nTotalGap)) + 'px;" anno="sequence" chain="' + chnid + '" title="' + queryTitle + '">' + queryTitle + '</div>';
                }
                htmlTmp = '<span class="icn3d-residueNum" title="ending protein sequence number">' + ic.queryEnd + '</span>';
                htmlTmp += '</span>';
                htmlTmp += '<br>';
                html += htmlTmp;
                html2 += htmlTmp;
            }
            html += '</div>';
            html2 += '</div>';
            html3 += '</div>';
            
            //if(Object.keys(ic.chains[chnid]).length > 10) {
            if(giSeq.length > 10) {
                let atom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.chains[chnid]);
                //if(ic.baseResi[chnid] != 0 &&(me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined || me.cfg.align !== undefined)) {
                if((me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined || me.cfg.blast_rep_id !== undefined || me.cfg.align !== undefined || me.cfg.chainalign !== undefined || me.cfg.mmdbafid !== undefined) && atom.resi_ori !== undefined && atom.resi_ori != atom.resi && chnid.indexOf('Misc') == -1 ) {
                    htmlTmp = '<div class="icn3d-dl_sequence">';
                    htmlTmp += '<div class="icn3d-residueLine" style="white-space:nowrap;">';
                    htmlTmp += '<div class="icn3d-annoTitle" anno="0" title="PDB Residue Numbers">PDB Residue Numbers</div>';
                    htmlTmp += '<span class="icn3d-residueNum"></span>';
                    html3 += htmlTmp + '<br>';
                    html += htmlTmp + '<span class="icn3d-seqLine">';

                    if(ic.seqStartLen && ic.seqStartLen[chnid]) html += this.insertMulGap(ic.seqStartLen[chnid], '-');

                    for(let i = 0, il = giSeq.length; i < il; ++i) {
                        html += this.insertGap(chnid, i, '-');
                        //if(i >= ic.matchedPos[chnid] && i - ic.matchedPos[chnid] < ic.chainsSeq[chnid].length) {
                        //   let currResi = ic.chainsSeq[chnid][i - ic.matchedPos[chnid]].resi;
                          let currResi = ic.ParserUtilsCls.getResi(chnid, i);
                          let residueid = chnid + '_' + currResi;
                          if(!ic.residues.hasOwnProperty(residueid)) {
                              html += '<span></span>';
                          }
                          else {
                              let atom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[residueid]);
                              let resi_ori = atom.resi_ori;
                              html += '<span>';
                              if( resi_ori % 10 === 0) {
                                html += resi_ori + ' ';
                              }
                              html += '</span>';
                          }
                        // }
                        // else {
                        //   html += '<span></span>';
                        // }
                    }

                    if(ic.seqStartLen && ic.seqStartLen[chnid]) html += this.insertMulGap(ic.seqEndLen[chnid], '-');

                    html += '<span class="icn3d-residueNum"></span>';
                    html += '</span>';
                    html += '<br>';
                    html += '</div>';
                    html += '</div>';
                    html3 += '</div></div>';
                }         
                
                if(ic.bShowCustomRefnum && ic.chainsMapping.hasOwnProperty(chnid)) {              
                    let bCustom = true;
                    let result = ic.annoIgCls.showRefNum(giSeq, chnid, undefined, bCustom);
                    html += result.html;
                    // html2 += result.html2;
                    html3 += result.html3;
                }
            }
            
            // highlight reference numbers
            if(ic.bShowRefnum) {
                // comment out so that this process didn't change the selection
                //ic.hAtoms = ic.hAtomsRefnum;
                
                // commented out because it produced too many commands
                // let name = 'refnum_anchors';
                // ic.selectionCls.saveSelection(name, name);

                ic.hlUpdateCls.updateHlAll();
            }

            $("#" + ic.pre + 'dt_giseq_' + chnid).html(html);
            $("#" + ic.pre + 'ov_giseq_' + chnid).html(html2);
            $("#" + ic.pre + 'tt_giseq_' + chnid).html(html3); // fixed title for scrolling
        }

        insertGap(chnid, seqIndex, text, bNohtml) {  let ic = this.icn3d; ic.icn3dui;
          let html = '';
          //if(me.cfg.blast_rep_id == chnid && ic.targetGapHash!== undefined && ic.targetGapHash.hasOwnProperty(seqIndex)) {
          if(ic.targetGapHash!== undefined && ic.targetGapHash.hasOwnProperty(seqIndex)) {
            html += this.insertMulGap(ic.targetGapHash[seqIndex].to - ic.targetGapHash[seqIndex].from + 1, text, bNohtml);
          }
          return html;
        }

        insertMulGap(n, text, bNohtml) {  let ic = this.icn3d; ic.icn3dui;
            let html = '';
            for(let j = 0; j < n; ++j) {
                if(bNohtml) {
                    html += text;
                }
                else {
                    html += '<span>' + text + '</span>';
                }
            }
            return html;
        }

        insertGapOverview(chnid, seqIndex) {  let ic = this.icn3d; ic.icn3dui;
          let html2 = '';
        //   if(me.cfg.blast_rep_id == chnid && ic.targetGapHash !== undefined && ic.targetGapHash.hasOwnProperty(seqIndex)) {
          if(ic.targetGapHash !== undefined && ic.targetGapHash.hasOwnProperty(seqIndex)) {
            html2 += this.insertMulGapOverview(chnid, ic.targetGapHash[seqIndex].to - ic.targetGapHash[seqIndex].from + 1);
          }
          return html2;
        }

        insertMulGapOverview(chnid, n) {  let ic = this.icn3d; ic.icn3dui;
            let html2 = '';
            let width = ic.seqAnnWidth * n /(ic.maxAnnoLength + ic.nTotalGap);
            width = parseInt(width);
            
            // html2 += '<div style="display:inline-block; background-color:#333; width:' + width + 'px; height:3px;">&nbsp;</div>';
            html2 += '<div style="display:inline-block; width:' + width + 'px;">&nbsp;</div>';
            return html2;
        }

        setAlternativeSeq(chnid, chnidBase) { let ic = this.icn3d; ic.icn3dui;
            //if(ic.chainsSeq[chnid] !== undefined) {
            let resArray = ic.chainsSeq[chnid];
            ic.giSeq[chnid] = [];
            for(let i = 0, il = resArray.length; i < il; ++i) {
                let res = resArray[i].name;
                ic.giSeq[chnid][i] = res;
            }
            ic.matchedPos[chnid] = 0;
            ic.baseResi[chnid] = ic.chainsSeq[chnid][0].resi - ic.matchedPos[chnid] - 1;
        }

        getProteinName(chnid) { let ic = this.icn3d, me = ic.icn3dui;
            let fullProteinName = '';
            if((me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined || me.cfg.blast_rep_id !== undefined) && ic.mmdb_data !== undefined) {
                let moleculeInfor = ic.mmdb_data.moleculeInfor;
                let chain = chnid.substr(chnid.indexOf('_') + 1);
                for(let i in moleculeInfor) {
                    if(moleculeInfor[i].chain == chain) {
                        fullProteinName = moleculeInfor[i].name.replace(/\'/g, '&prime;');
                        //if(proteinName.length > 40) proteinName = proteinName.substr(0, 40) + "...";
                        break;
                    }
                }
            }
            else if((me.cfg.align !== undefined || me.cfg.chainalign !== undefined || me.cfg.mmdbafid !== undefined || ic.bRealign || ic.bSymd) && ic.chainid2title !== undefined) {
                if(ic.chainid2title[chnid] !== undefined) {
                    fullProteinName = ic.chainid2title[chnid];
                }
            }
            return fullProteinName;
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class HlSeq {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        selectSequenceNonMobile() { let ic = this.icn3d, me = ic.icn3dui;
          if(me.bNode) return;

          let thisClass = this;
          $("#" + ic.pre + "dl_sequence2").add("[id^=" + ic.pre + "dt_giseq]").add("[id^=" + ic.pre + "dt_custom]").add("[id^=" + ic.pre + "dt_site]").add("[id^=" + ic.pre + "dt_ptm]").add("[id^=" + ic.pre + "dt_snp]").add("[id^=" + ic.pre + "dt_clinvar]").add("[id^=" + ic.pre + "dt_cdd]").add("[id^=" + ic.pre + "dt_domain]").add("[id^=" + ic.pre + "dt_interaction]").add("[id^=" + ic.pre + "dt_ssbond]").add("[id^=" + ic.pre + "dt_crosslink]").add("[id^=" + ic.pre + "dt_transmem]").add("[id^=" + ic.pre + "dt_ig]")
          .add("[id^=" + ic.pre + "tt_giseq]").add("[id^=" + ic.pre + "tt_custom]").add("[id^=" + ic.pre + "tt_site]").add("[id^=" + ic.pre + "tt_ptm]").add("[id^=" + ic.pre + "tt_snp]").add("[id^=" + ic.pre + "tt_clinvar]").add("[id^=" + ic.pre + "tt_cdd]").add("[id^=" + ic.pre + "tt_domain]").add("[id^=" + ic.pre + "tt_interaction]").add("[id^=" + ic.pre + "tt_ssbond]").add("[id^=" + ic.pre + "tt_crosslink]").add("[id^=" + ic.pre + "tt_transmem]").add("[id^=" + ic.pre + "tt_ig]")
          .selectable({
              distance: 1, //Tolerance, in pixels, for when selecting should start. If specified, selecting will not start until the mouse has been dragged beyond the specified distance.
              stop: function() { let ic = thisClass.icn3d;
                  if($(this).attr('id') === ic.pre + "dl_sequence2") {
                      ic.bAlignSeq = true;
                      ic.bAnnotations = false;
                  }
                  //else if($(this).attr('id') === ic.pre + "dl_annotations") {
                  else {
                      ic.bAlignSeq = false;
                      ic.bAnnotations = true;
                  }
                  
                  if(ic.bSelectResidue === false && !ic.bShift && !ic.bCtrl) {
                //   if(!ic.bShift && !ic.bCtrl) {
                      ic.selectionCls.removeSelection();
                  }
                  
                  // select residues
                  $("span.ui-selected", this).each(function() {
                      let id = $(this).attr('id');

                      if(id !== undefined) {
                         thisClass.selectResidues(id, this);
                     }
                  });

                  ic.selectionCls.saveSelectionPrep(true);
                  //ic.selectionCls.saveSelection(undefined, undefined, true);
                  // do not use selected residues, use ic.hAtoms instead
                  ic.selectionCls.saveSelection(undefined, undefined, false);

                  //ic.residueLabelsCls.addResidueLabels(ic.hAtoms, false, 0.5);
                  ic.hlObjectsCls.addHlObjects();  // render() is called
                  // get all chainid in the selected residues
                  let chainHash = {};
                  for(let residueid in ic.selectedResidues) {
                      let pos = residueid.lastIndexOf('_');
                      let chainid = residueid.substr(0, pos);

                      chainHash[chainid] = 1;
                  }

                  // highlight the nodes
                  let chainArray2d = Object.keys(chainHash);
                  ic.hlUpdateCls.updateHl2D(chainArray2d);

                  // select annotation title
                  //$("#" + ic.pre + "dl_selectannotations div.ui-selected", this).each(function() {
                  $("div.ui-selected", this).each(function() {
                      if($(this).attr('chain') !== undefined) {
                          thisClass.selectTitle(this);
                      }
                  });
              }
          });

          $("[id^=" + ic.pre + "ov_giseq]").add("[id^=" + ic.pre + "ov_custom]").add("[id^=" + ic.pre + "ov_site]").add("[id^=" + ic.pre + "ov_ptm]").add("[id^=" + ic.pre + "ov_snp]").add("[id^=" + ic.pre + "ov_clinvar]").add("[id^=" + ic.pre + "ov_cdd]").add("[id^=" + ic.pre + "ov_domain]").add("[id^=" + ic.pre + "ov_interaction]").add("[id^=" + ic.pre + "ov_ssbond]").add("[id^=" + ic.pre + "ov_crosslink]").add("[id^=" + ic.pre + "ov_transmem]").add("[id^=" + ic.pre + "ov_ig]")
          .add("[id^=" + ic.pre + "tt_giseq]").add("[id^=" + ic.pre + "tt_custom]").add("[id^=" + ic.pre + "tt_site]").add("[id^=" + ic.pre + "tt_ptm]").add("[id^=" + ic.pre + "tt_snp]").add("[id^=" + ic.pre + "tt_clinvar]").add("[id^=" + ic.pre + "tt_cdd]").add("[id^=" + ic.pre + "tt_domain]").add("[id^=" + ic.pre + "tt_interaction]").add("[id^=" + ic.pre + "tt_ssbond]").add("[id^=" + ic.pre + "tt_crosslink]").add("[id^=" + ic.pre + "tt_transmem]").add("[id^=" + ic.pre + "tt_ig]")

          .add("#" + ic.pre + "dl_sequence2").add("[id^=" + ic.pre + "dt_giseq]").add("[id^=" + ic.pre + "dt_custom]").add("[id^=" + ic.pre + "dt_site]").add("[id^=" + ic.pre + "dt_ptm]").add("[id^=" + ic.pre + "dt_snp]").add("[id^=" + ic.pre + "dt_clinvar]").add("[id^=" + ic.pre + "dt_cdd]").add("[id^=" + ic.pre + "dt_domain]").add("[id^=" + ic.pre + "dt_interaction]").add("[id^=" + ic.pre + "dt_ssbond]").add("[id^=" + ic.pre + "dt_crosslink]").add("[id^=" + ic.pre + "dt_transmem]").add("[id^=" + ic.pre + "dt_ig]")
          .add("[id^=" + ic.pre + "tt_giseq]").add("[id^=" + ic.pre + "tt_custom]").add("[id^=" + ic.pre + "tt_site]").add("[id^=" + ic.pre + "tt_ptm]").add("[id^=" + ic.pre + "tt_snp]").add("[id^=" + ic.pre + "tt_clinvar]").add("[id^=" + ic.pre + "tt_cdd]").add("[id^=" + ic.pre + "tt_domain]").add("[id^=" + ic.pre + "tt_interaction]").add("[id^=" + ic.pre + "tt_ssbond]").add("[id^=" + ic.pre + "tt_crosslink]").add("[id^=" + ic.pre + "tt_transmem]").add("[id^=" + ic.pre + "tt_ig]")

          .on('click', '.icn3d-seqTitle', function(e) { let ic = thisClass.icn3d;
              e.stopImmediatePropagation();

              //if($(this).attr('id') === ic.pre + "dl_sequence2") {
              if($(this).parents('div').attr('id') === ic.pre + "dl_sequence2") {
                  ic.bAlignSeq = true;
                  ic.bAnnotations = false;
              }
              //else if($(this).attr('id') === ic.pre + "dl_annotations") {
              else {
                  ic.bAlignSeq = false;
                  ic.bAnnotations = true;
              }

              // select annotation title
              //$("div .ui-selected", this).each(function() {
                  thisClass.selectTitle(this);

                  ic.hlUpdateCls.hlSummaryDomain3ddomain(this);
               //});

                // remove possible text selection
                // the following code caused the scroll of sequence window to the top, remove it for now
                /*
                if(window.getSelection) {
                  if(window.getSelection().empty) {  // Chrome
                    window.getSelection().empty();
                  } else if(window.getSelection().removeAllRanges) {  // Firefox
                    window.getSelection().removeAllRanges();
                  }
                } else if(document.selection) {  // IE?
                  document.selection.empty();
                }
                */
          });
        }

        selectSequenceMobile() { let ic = this.icn3d, me = ic.icn3dui;
          if(me.bNode) return;

          let thisClass = this;

          $("#" + ic.pre + "dl_sequence2").add("[id^=" + ic.pre + "giseq]").add("[id^=" + ic.pre + "custom]").add("[id^=" + ic.pre + "site]").add("[id^=" + ic.pre + "ptm]").add("[id^=" + ic.pre + "clinvar]").add("[id^=" + ic.pre + "snp]").add("[id^=" + ic.pre + "cdd]").add("[id^=" + ic.pre + "domain]").add("[id^=" + ic.pre + "interaction]").add("[id^=" + ic.pre + "ssbond]").add("[id^=" + ic.pre + "crosslink]").add("[id^=" + ic.pre + "transmem]").add("[id^=" + ic.pre + "ig]").on('click', '.icn3d-residue', function(e) { let ic = thisClass.icn3d;
              e.stopImmediatePropagation();

              // select residues
              //$("span.ui-selected", this).each(function() {
                  let id = $(this).attr('id');

                  if(id !== undefined) {
                       thisClass.selectResidues(id, this);

                       ic.selectionCls.saveSelectionPrep(true);
                       //ic.selectionCls.saveSelection(undefined, undefined, true);
                       // do not use selected residues, use ic.hAtoms instead
                       ic.selectionCls.saveSelection(undefined, undefined, false);
                  }
              //});

              //ic.residueLabelsCls.addResidueLabels(ic.hAtoms, false, 0.5);
               ic.hlObjectsCls.addHlObjects();  // render() is called

              // get all chainid in the selected residues
              let chainHash = {};
              for(let residueid in ic.selectedResidues) {
                  let pos = residueid.lastIndexOf('_');
                  let chainid = residueid.substr(0, pos);

                  chainHash[chainid] = 1;
              }

              // clear nodes in 2d dgm
              ic.hlUpdateCls.removeHl2D();

              // highlight the nodes
              let chainArray2d = Object.keys(chainHash);
              ic.hlUpdateCls.updateHl2D(chainArray2d);
          });
        }

        selectChainMobile() { let ic = this.icn3d, me = ic.icn3dui;
          if(me.bNode) return;

          let thisClass = this;

          $("#" + ic.pre + "dl_sequence2").add("[id^=" + ic.pre + "giseq]").add("[id^=" + ic.pre + "custom]").add("[id^=" + ic.pre + "site]").add("[id^=" + ic.pre + "ptm]").add("[id^=" + ic.pre + "feat]").add("[id^=" + ic.pre + "clinvar]").add("[id^=" + ic.pre + "snp]").add("[id^=" + ic.pre + "cdd]").add("[id^=" + ic.pre + "domain]").add("[id^=" + ic.pre + "interaction]").add("[id^=" + ic.pre + "ssbond]").add("[id^=" + ic.pre + "crosslink]").add("[id^=" + ic.pre + "transmem]").add("[id^=" + ic.pre + "ig]").on('click', '.icn3d-seqTitle', function(e) { let ic = thisClass.icn3d;
              e.stopImmediatePropagation();

              //if($(this).attr('id') === ic.pre + "dl_sequence2") {
              if($(this).parents('div').attr('id') === ic.pre + "dl_sequence2") {
                  ic.bAlignSeq = true;
                  ic.bAnnotations = false;
              }
              //else if($(this).attr('id') === ic.pre + "dl_annotations") {
              else {
                  ic.bAlignSeq = false;
                  ic.bAnnotations = true;
              }

              // select annotation title
              //$("div.ui-selected", this).each(function() {
                  thisClass.selectTitle(this);

                  ic.hlUpdateCls.hlSummaryDomain3ddomain(this);
              //});
          });
        }

        selectTitle(that) { let ic = this.icn3d, me = ic.icn3dui;
          if(me.bNode) return;

          if($(that).hasClass('icn3d-seqTitle')) {
            let chainid = $(that).attr('chain');
            let resn = $(that).attr('resn');

            if(ic.bAlignSeq) {
                ic.bSelectAlignResidue = false;
            }
            else {
                ic.bSelectResidue = false;
            }

            if(!ic.bAnnotations) {
                ic.hlUpdateCls.removeSeqChainBkgd(chainid);
            }
            //else {
            //    ic.hlUpdateCls.removeSeqChainBkgd();
            //}

            if(!ic.bCtrl && !ic.bShift) {
                ic.hlUpdateCls.removeSeqResidueBkgd();

                ic.hlUpdateCls.removeSeqChainBkgd();

                ic.currSelectedSets = [];
            }

            $(that).toggleClass('icn3d-highlightSeq');
            let commandname, commanddescr, position;
            if(resn) {
                commandname = resn; 
            }
            else {
                if(!ic.bAnnotations) {
                    if(ic.bAlignSeq) {
                        commandname = "align_" + chainid;
                    }
                    else {
                        commandname = chainid;           
                    }
                }
                else {
                    commandname = $(that).attr('setname');
                    commanddescr = $(that).attr('title');
                }
            }

            if($(that).hasClass('icn3d-highlightSeq')) {
                if(!ic.bAnnotations) {
                    if(ic.bCtrl || ic.bShift) {
                        ic.currSelectedSets.push(commandname);
                        ic.selectionCls.selectAChain(chainid, commandname, true, true);
                    }
                    else {
                        ic.currSelectedSets = [commandname];
                        ic.selectionCls.selectAChain(chainid, commandname, ic.bAlignSeq);
                    }

                    if(ic.bAlignSeq) {
                        me.htmlCls.clickMenuCls.setLogCmd('select alignChain ' + chainid, true);
                    }
                    else {   
                        me.htmlCls.clickMenuCls.setLogCmd('select chain ' + chainid, true);
                    }

                    let setNames = ic.currSelectedSets.join(' or ');
                    //if(ic.currSelectedSets.length > 1) me.htmlCls.clickMenuCls.setLogCmd('select saved atoms ' + setNames, true);
                    if(ic.currSelectedSets.length > 1) me.htmlCls.clickMenuCls.setLogCmd('select sets ' + setNames, true);
                }
                else {
                    if($(that).hasClass('icn3d-highlightSeq')) {
                        ic.hlUpdateCls.removeHl2D();

                        if($(that).attr('gi') !== undefined) {
                            if(ic.bCtrl || ic.bShift) {
                                ic.currSelectedSets.push(chainid);
                                if(resn) {
                                    let prevHAtoms = me.hashUtilsCls.cloneHash(ic.hAtoms);
                                    let bNoUpdateAll = true;
                                    ic.selByCommCls.selectBySpec('select :3' + resn, commandname, commandname, false, bNoUpdateAll);
                                    ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, prevHAtoms);
                                    ic.hlUpdateCls.updateHlAll(resn, undefined, true, true);
                                }
                                else {
                                    ic.selectionCls.selectAChain(chainid, chainid, false, true);
                                }
                            }
                            else {
                                ic.currSelectedSets = [chainid];
                                if(resn) {
                                    let bNoUpdateAll = true;
                                    ic.selByCommCls.selectBySpec('select :3' + resn, commandname, commandname, false, bNoUpdateAll);
                                    ic.hlUpdateCls.updateHlAll(resn, undefined, true, true);
                                }
                                else {
                                    ic.selectionCls.selectAChain(chainid, chainid, false);
                                }
                            }

                            if(resn) {
                                me.htmlCls.clickMenuCls.setLogCmd('select :3' + resn, true);
                            }
                            else {
                                me.htmlCls.clickMenuCls.setLogCmd('select chain ' + chainid, true);
                            }

                            let setNames = ic.currSelectedSets.join(' or ');
                            //if(ic.currSelectedSets.length > 1) me.htmlCls.clickMenuCls.setLogCmd('select saved atoms ' + setNames, true);
                            if(ic.currSelectedSets.length > 1) me.htmlCls.clickMenuCls.setLogCmd('select sets ' + setNames, true);
                        }
                        else {
                            let residueidHash = {};
                            if($(that).attr('domain') !== undefined || $(that).attr('feat') !== undefined || $(that).attr('3ddomain') !== undefined || $(that).attr('custom') !== undefined || $(that).attr('ig') !== undefined) {
                                ic.hlUpdateCls.hlSummaryDomain3ddomain(that);

                                let fromArray = $(that).attr('from').split(',');
                                let toArray = $(that).attr('to').split(',');

                                // protein chains
                                let residueid, from, to;
                                chainid.substr(0, chainid.indexOf('_'));
                                for(let i = 0, il = fromArray.length; i < il; ++i) {
                                    from = parseInt(fromArray[i]);
                                    to = parseInt(toArray[i]);

                                    for(let j = from; j <= to; ++j) {
                                        /*
                                        if( ($(that).attr('domain') !== undefined || $(that).attr('feat') !== undefined || $(that).attr('3ddomain') !== undefined) ) {
                                            let residNCBI = chainid + '_' + (j+1).toString();
                                            // AlphaFold domains calculated on-the-fly have no conversion
                                            // if(structure.length > 5) {
                                            //     residueid = residNCBI;
                                            // }
                                            // else if(ic.ncbi2resid[residNCBI]) {
                                            //     residueid = ic.ncbi2resid[residNCBI];
                                            // }
                                            // else {
                                            //     residueid = residNCBI;
                                            // }

                                            residueid = ic.ncbi2resid[residNCBI];
                                        }
                                        */
                                        
                                        if(($(that).attr('domain') !== undefined || $(that).attr('feat') !== undefined) || $(that).attr('ig') !== undefined) {
                                            let residNCBI = chainid + '_' + (j+1).toString();
                                            residueid = ic.ncbi2resid[residNCBI];
                                        }
                                        else if($(that).attr('3ddomain') !== undefined) {
                                            // NCBI residue numbers
                                            // residueid = ic.posid2resid[chainid + '_' + (j+1).toString()];
                                            residueid = ic.ncbi2resid[chainid + '_' + j];
                                        }
                                        else {
                                            residueid = chainid + '_' + (j+1).toString();
                                        }

                                        residueidHash[residueid] = 1;

                                        //atomHash = me.hashUtilsCls.unionHash(atomHash, ic.residues[residueid]);
                                    }
                                }

                                if(ic.bCtrl || ic.bShift) {
                                    ic.selectionCls.selectResidueList(residueidHash, commandname, commanddescr, true);
                                }
                                else {
                                    ic.selectionCls.selectResidueList(residueidHash, commandname, commanddescr, false);
                                }
                                //ic.hlUpdateCls.updateHlAll();

                                residueid = chainid + '_' + parseInt((from + to)/2).toString();
                                //residueid = chainid + '_' + from.toString();
                                position = ic.applyCenterCls.centerAtoms(me.hashUtilsCls.hash2Atoms(ic.residues[residueid], ic.atoms));
                            }
                            //else if($(that).attr('site') !== undefined || $(that).attr('clinvar') !== undefined) {
                            else if($(that).attr('posarray') !== undefined) {
                                let posArray = $(that).attr('posarray').split(',');
                                //ic.hAtoms = {}

                                //removeAllLabels();

                                //var  atomHash = {}, residueidHash = {}
                                let residueid;
                                chainid.substr(0, chainid.indexOf('_'));
                                for(let i = 0, il = posArray.length; i < il; ++i) {
                                    if($(that).attr('site') !== undefined || $(that).attr('ptm') !== undefined) {
                                        // if(ic.bNCBI) {
                                            let residNCBI = chainid + '_' +(parseInt(posArray[i])+1).toString();
                                            // AlphaFold domains calculated on-the-fly have no conversion
                                            // if(structure.length > 5) {
                                            //     residueid = residNCBI;
                                            // }
                                            // else if(ic.ncbi2resid[residNCBI]) {
                                            //     residueid = ic.ncbi2resid[residNCBI];
                                            // }
                                            // else {
                                            //     residueid = residNCBI;
                                            // }

                                            residueid = ic.ncbi2resid[residNCBI];
                                        // }
                                        // else {
                                        //     residueid = chainid + '_' +(parseInt(posArray[i])+1).toString();
                                        // }
                                    }
                                    //else if($(that).attr('clinvar') !== undefined) {
                                    else {
                                        residueid = chainid + '_' + posArray[i];
                                    }

                                    residueidHash[residueid] = 1;
                                    //atomHash = me.hashUtilsCls.unionHash(atomHash, ic.residues[residueid]);
                                }

                                if(ic.bCtrl || ic.bShift) {
                                    ic.selectionCls.selectResidueList(residueidHash, commandname, commanddescr, true);
                                }
                                else {
                                    ic.selectionCls.selectResidueList(residueidHash, commandname, commanddescr, false);
                                }

                                residueid = chainid + '_' + posArray[parseInt((0 + posArray.length)/2)].toString();
                                //residueid = chainid + '_' + posArray[0].toString();
                                position = ic.applyCenterCls.centerAtoms(me.hashUtilsCls.hash2Atoms(ic.residues[residueid], ic.atoms));
                            }

                            //removeAllLabels
                            for(let name in ic.labels) {
                                if(name !== 'schematic' && name !== 'distance') {
                                   ic.labels[name] = [];
                                }
                            }

                            //var size = parseInt(ic.LABELSIZE * 10 / commandname.length);
                            let size = ic.LABELSIZE;
                            let color = (ic.opts.background != 'black') ? ic.colorWhitebkgd : ic.colorBlackbkgd; //"FFFF00";
                            if(position !== undefined) ic.analysisCls.addLabel(commanddescr, position.center.x, position.center.y, position.center.z, size, color, undefined, 'custom');

                            ic.drawCls.draw();

                            me.htmlCls.clickMenuCls.setLogCmd('select ' + ic.resid2specCls.residueids2spec(Object.keys(residueidHash)) + ' | name ' + commandname, true);

                            if(ic.bCtrl || ic.bShift) {
                                ic.currSelectedSets.push(commandname);
                            }
                            else {
                                ic.currSelectedSets = [commandname];
                            }

                            let setNames = ic.currSelectedSets.join(' or ');
                            //if(ic.currSelectedSets.length > 1) me.htmlCls.clickMenuCls.setLogCmd('select saved atoms ' + setNames, true);
                            if(ic.currSelectedSets.length > 1) me.htmlCls.clickMenuCls.setLogCmd('select sets ' + setNames, true);
                        } // if($(that).attr('gi') !== undefined) {
                    } // if($(that).hasClass('icn3d-highlightSeq')) {
                } // if(!ic.bAnnotations) {
            } // if($(that).hasClass('icn3d-highlightSeq')) {
            else {
                ic.hlObjectsCls.removeHlObjects();
                ic.hlUpdateCls.removeHl2D();

               $("#" + ic.pre + "atomsCustom").val("");
            }

          }
        }

        selectResidues(id, that) { let ic = this.icn3d, me = ic.icn3dui;
          if(me.bNode) return;

          if(ic.bSelectResidue === false && !ic.bShift && !ic.bCtrl) {
        //   if(!ic.bShift && !ic.bCtrl) {
              ic.selectionCls.removeSelection();
          }
          
          if(id !== undefined && id !== '') {
            // add "align_" in front of id so that full sequence and aligned sequence will not conflict
            //if(id.substr(0, 5) === 'align') id = id.substr(5);

            // seq_div0_1TSR_A_1, align_div0..., giseq_div0..., snp_div0..., interaction_div0..., cddsite_div0..., domain_div0...
            id = id.substr(id.indexOf('_') + 1);

            ic.bSelectResidue = true;

            $(that).toggleClass('icn3d-highlightSeq');

            let residueid = id.substr(id.indexOf('_') + 1);

            if(ic.residues.hasOwnProperty(residueid)) {
                if($(that).hasClass('icn3d-highlightSeq')) {
                  for(let j in ic.residues[residueid]) {
                    ic.hAtoms[j] = 1;
                  }

                  ic.selectedResidues[residueid] = 1;

                  if(ic.bAnnotations && $(that).attr('disease') !== undefined) {
                      let label = $(that).attr('disease');

                      let position = ic.applyCenterCls.centerAtoms(me.hashUtilsCls.hash2Atoms(ic.residues[residueid], ic.atoms));
                      //position.center.add(new THREE.Vector3(3.0, 3.0, 3.0)); // shift a little bit

                      let maxlen = 15;
                      if(label.length > maxlen) label = label.substr(0, maxlen) + '...';

                      //var size = parseInt(ic.LABELSIZE * 10 / label.length);
                      let size = ic.LABELSIZE;
                      let color = me.htmlCls.GREYD;
                      ic.analysisCls.addLabel(label, position.center.x, position.center.y, position.center.z, size, color, undefined, 'custom');
                  }
                }
                else {
                    for(let i in ic.residues[residueid]) {
                      //ic.hAtoms[i] = undefined;
                      delete ic.hAtoms[i];
                    }
                    //ic.selectedResidues[residueid] = undefined;
                    delete ic.selectedResidues[residueid];

                    ic.hlObjectsCls.removeHlObjects();
                }
            }
          }
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class HlUpdate {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //The 2D diagram only shows the currently displayed chains when users click the option "View Only Selection".
        //This method is called to dynamically update the content of the 2D interaction diagram.
        update2DdgmContent() { let ic = this.icn3d, me = ic.icn3dui;
           // update 2D diagram to show just the displayed parts
           let html2ddgm = '';
           if(me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined) {
              html2ddgm += ic.diagram2dCls.draw2Ddgm(ic.interactionData, ic.inputid, undefined, true);
              html2ddgm += ic.diagram2dCls.set2DdgmNote();

              $("#" + ic.pre + "dl_2ddgm_html").html(html2ddgm);
           }
           else if(ic.mmdbidArray &&(me.cfg.align !== undefined || me.cfg.chainalign !== undefined || ic.bRealign)) {
              html2ddgm += ic.diagram2dCls.draw2Ddgm(ic.interactionData1, ic.mmdbidArray[0].toUpperCase(), 0, true);
              if(ic.mmdbid_q !== undefined && ic.mmdbid_q === ic.mmdbid_t) {
                  html2ddgm += ic.diagram2dCls.draw2Ddgm(ic.interactionData2, ic.mmdbidArray[0].toUpperCase(), 1, true);
              }
              else {
                  html2ddgm += ic.diagram2dCls.draw2Ddgm(ic.interactionData2, ic.mmdbidArray[1].toUpperCase(), 1, true);
              }
              html2ddgm += ic.diagram2dCls.set2DdgmNote(true);

              $("#" + ic.pre + "dl_2ddgm_html").html(html2ddgm);
           }
        }

        //Change the residue color in the annotation window for the residues in the array "residueArray".
        changeSeqColor(residueArray) { let ic = this.icn3d, me = ic.icn3dui;
           for(let i = 0, il = residueArray.length; i < il; ++i) {
               let pickedResidue = residueArray[i];
               //[id$= is expensive
               //if($("[id$=" + ic.pre + pickedResidue + "]").length !== 0) {
                 let atom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[pickedResidue]);
                 if(!atom) continue;

                 let colorStr =(atom.color === undefined || atom.color.getHexString().toUpperCase() === 'FFFFFF') ? 'DDDDDD' : atom.color.getHexString();
                 let color =(atom.color !== undefined) ? colorStr : "CCCCCC";
                 // annotations will have their own color, only the chain will have the changed color
                 $("[id=giseq_" + ic.pre + pickedResidue + "]").attr('style', 'color:#' + color);
                 $("[id=align_" + ic.pre + pickedResidue + "]").attr('style', 'color:#' + color);
                 if(me.cfg.align !== undefined || me.cfg.chainalign !== undefined || ic.bRealign || ic.bSymd) $("[id=align_" + ic.pre + pickedResidue + "]").attr('style', 'color:#' + color);
               //}
           }
        }

        //Remove the highlight in 3D structure, 2D interaction, 1D sequence, and the menu of defined sets.
        removeHlAll() { let ic = this.icn3d; ic.icn3dui;
               this.removeHlObjects();
               this.removeHlSeq();
               this.removeHl2D();
               this.removeHlMenus();
        }

        //Remove the highlight in the 3D structure display.
        removeHlObjects() { let ic = this.icn3d; ic.icn3dui;
               ic.hlObjectsCls.removeHlObjects();
        }

        //Remove the highlight in the sequence display of the annotation window.
        removeHlSeq() { let ic = this.icn3d; ic.icn3dui;
        //       this.removeSeqChainBkgd();
               this.removeSeqResidueBkgd();
        }

        //Remove the highlight in the 2D interaction diagram.
        removeHl2D(bRemoveChainOnly) { let ic = this.icn3d; ic.icn3dui;
              // clear nodes in 2d dgm
              $("#" + ic.pre + "dl_2ddgm rect").attr('stroke', '#000000');
              $("#" + ic.pre + "dl_2ddgm circle").attr('stroke', '#000000');
              $("#" + ic.pre + "dl_2ddgm polygon").attr('stroke', '#000000');

              $("#" + ic.pre + "dl_2ddgm rect").attr('stroke-width', 1);
              $("#" + ic.pre + "dl_2ddgm circle").attr('stroke-width', 1);
              $("#" + ic.pre + "dl_2ddgm polygon").attr('stroke-width', 1);

              if($("#" + ic.pre + "dl_2ddgm circle").length > 0) {
                  $("#" + ic.pre + "dl_2ddgm svg line").attr('stroke', '#000000');
                  $("#" + ic.pre + "dl_2ddgm line").attr('stroke-width', 1);
              }

              if(!bRemoveChainOnly) {
                // clear nodes in 2d interaction network
                // $("#" + ic.pre + "dl_linegraph rect").attr('stroke', '#000000');
                $("#" + ic.pre + "dl_linegraph circle").attr('stroke', '#000000');
        
                // $("#" + ic.pre + "dl_linegraph rect").attr('stroke-width', 1);
                $("#" + ic.pre + "dl_linegraph circle").attr('stroke-width', 1);

                // clear nodes in 2d interaction graph
                $("#" + ic.pre + "dl_scatterplot rect").attr('stroke', '#000000');
                $("#" + ic.pre + "dl_scatterplot circle").attr('stroke', '#000000');
        
                $("#" + ic.pre + "dl_scatterplot rect").attr('stroke-width', 1);
                $("#" + ic.pre + "dl_scatterplot circle").attr('stroke-width', 1);
              }
        }

        //Remove the selection in the menu of defined sets.
        removeHlMenus() { let ic = this.icn3d; ic.icn3dui;
            $("#" + ic.pre + "atomsCustom").val("");
            $("#" + ic.pre + "atomsCustom")[0].blur();
        }

        //Update the highlight of 3D structure, 2D interaction, sequences, and the menu of defined sets
        //according to the current highlighted atoms.
        updateHlAll(commandnameArray, bSetMenu, bUnion, bForceHighlight) { let ic = this.icn3d, me = ic.icn3dui;
           // update the previously highlisghted atoms for switching between all and selection
           ic.prevHighlightAtoms = me.hashUtilsCls.cloneHash(ic.hAtoms);

           this.updateHlObjects(bForceHighlight);

           if(commandnameArray !== undefined) {
               this.updateHlSeqInChain(commandnameArray, bUnion);
           }
           else {
               this.updateHlSeq(undefined, undefined, bUnion);
           }

           this.updateHl2D();
           if(bSetMenu === undefined || bSetMenu) this.updateHlMenus(commandnameArray);

           //ic.annotationCls.showAnnoSelectedChains();
        }

        //Update the highlight of 3D structure display according to the current highlighted atoms.
        updateHlObjects(bForceHighlight) { let ic = this.icn3d; ic.icn3dui;
           ic.hlObjectsCls.removeHlObjects();

           if((ic.hAtoms && ic.atoms && Object.keys(ic.hAtoms).length < Object.keys(ic.dAtoms).length) || bForceHighlight) {
              if(ic.bShowHighlight === undefined || ic.bShowHighlight) ic.hlObjectsCls.addHlObjects();
              ic.definedSetsCls.setMode('selection');
           }
        }

        // update highlight in sequence, slow if sequence is long
        //Update the highlight of sequences in the annotation window according to the current highlighted atoms.
        updateHlSeq(bShowHighlight, residueHash, bUnion) { let ic = this.icn3d; ic.icn3dui;
               if(bUnion === undefined || !bUnion) {
                   this.removeHlSeq();
               }

               if(residueHash === undefined) residueHash = ic.firstAtomObjCls.getResiduesFromCalphaAtoms(ic.hAtoms);

               if(ic.hAtoms && ic.atoms && Object.keys(ic.hAtoms).length < Object.keys(ic.atoms).length) this.hlSequence(Object.keys(residueHash));
               this.changeSeqColor(Object.keys(residueHash));
        }

        updateHlSeqInChain(commandnameArray, bUnion) { let ic = this.icn3d; ic.icn3dui;
               if(bUnion === undefined || !bUnion) {
                   this.removeHlSeq();
               }
               //if(residueHash === undefined) residueHash = ic.firstAtomObjCls.getResiduesFromCalphaAtoms(ic.hAtoms);

               if(ic.hAtoms && ic.atoms && Object.keys(ic.hAtoms).length == Object.keys(ic.atoms).length) return;

               //this.hlSequence(Object.keys(residueHash));
               // speed up with chain highlight
               for(let i = 0, il = commandnameArray.length; i < il; ++i) {
                   let commandname = commandnameArray[i];
                   if(Object.keys(ic.chains).indexOf(commandname) !== -1) {
                       this.hlSeqInChain(commandname);
                   }
                   else {
                       let residueArray = [];

                       if(ic.defNames2Residues[commandname] !== undefined && ic.defNames2Residues[commandname].length > 0) {
                           residueArray = ic.defNames2Residues[commandname];
                       }

                       let residueHash = {};
                       if(ic.defNames2Atoms[commandname] !== undefined && ic.defNames2Atoms[commandname].length > 0) {
                           for(let j = 0, jl = ic.defNames2Atoms[commandname].length; j < jl; ++j) {
                               let serial = ic.defNames2Atoms[commandname][j];
                               let atom = ic.atoms[serial];
                               let resid = atom.structure + '_' + atom.chain + '_' + atom.resi;

                               residueHash[resid] = 1;
                           }

                           residueArray = residueArray.concat(Object.keys(residueHash));
                       }

                       this.hlSequence(residueArray);
                   }
               }

               //this.changeSeqColor(Object.keys(residueHash));
        }

        // update highlight in 2D window
        //Update the highlight of 2D interaction diagram according to the current highlighted atoms.
        updateHl2D(chainArray2d) { let ic = this.icn3d, me = ic.icn3dui;
          this.removeHl2D(true);

          if(ic.hAtoms && ic.atoms && Object.keys(ic.hAtoms).length == Object.keys(ic.atoms).length) return;

          if(chainArray2d === undefined) {
              let chainHash = ic.firstAtomObjCls.getChainsFromAtoms(ic.hAtoms);
              chainArray2d = Object.keys(chainHash);
          }

          if(chainArray2d !== undefined) {
              for(let i = 0, il = chainArray2d.length; i < il; ++i) {
                  let hlatoms = me.hashUtilsCls.intHash(ic.chains[chainArray2d[i]], ic.hAtoms);
                  if(!ic.chains[chainArray2d[i]]) continue;
                  let ratio = 1.0 * Object.keys(hlatoms).length / Object.keys(ic.chains[chainArray2d[i]]).length;

                  let firstAtom = ic.firstAtomObjCls.getFirstCalphaAtomObj(hlatoms);
                  if(ic.alnChains[chainArray2d[i]] !== undefined) {
                        let alignedAtoms = me.hashUtilsCls.intHash(ic.alnChains[chainArray2d[i]], hlatoms);
                        if(Object.keys(alignedAtoms).length > 0) firstAtom = ic.firstAtomObjCls.getFirstCalphaAtomObj(alignedAtoms);
                    }
                  let color =(firstAtom !== undefined && firstAtom.color !== undefined) ? '#' + firstAtom.color.getHexString() : '#FFFFFF';

                  let target = $("#" + ic.pre + "dl_2ddgm g[chainid=" + chainArray2d[i] + "] rect[class='icn3d-hlnode']");
                  let base = $("#" + ic.pre + "dl_2ddgm g[chainid=" + chainArray2d[i] + "] rect[class='icn3d-basenode']");
                  if(target !== undefined) {
                      ic.diagram2dCls.highlightNode('rect', target, base, ratio);
                      $(target).attr('fill', color);
                  }

                  target = $("#" + ic.pre + "dl_2ddgm g[chainid=" + chainArray2d[i] + "] circle[class='icn3d-hlnode']");
                  base = $("#" + ic.pre + "dl_2ddgm g[chainid=" + chainArray2d[i] + "] circle[class='icn3d-basenode']");
                  if(target !== undefined) {
                        ic.diagram2dCls.highlightNode('circle', target, base, ratio);
                        $(target).attr('fill', color);
                  }

                  target = $("#" + ic.pre + "dl_2ddgm g[chainid=" + chainArray2d[i] + "] ellipse[class='icn3d-hlnode']");
                  //base = $("#" + ic.pre + "dl_2ddgm g[chainid=" + chainArray2d[i] + "] ellipse[class='icn3d-basenode']");
                  if(target !== undefined) {
                        ic.diagram2dCls.highlightNode('ellipse', target, undefined, ratio);
                        //$(target).attr('fill', color);
                  }

                  target = $("#" + ic.pre + "dl_2ddgm g[chainid=" + chainArray2d[i] + "] polygon[class='icn3d-hlnode']");
                  base = $("#" + ic.pre + "dl_2ddgm g[chainid=" + chainArray2d[i] + "] polygon[class='icn3d-basenode']");

                  if(target !== undefined) {
                      ic.diagram2dCls.highlightNode('polygon', target, base, ratio);
                      $(target).attr('fill', color);
                  }
              }
          }

          if(ic.lineArray2d !== undefined) {
              for(let i = 0, il = ic.lineArray2d.length; i < il; i += 2) {
                  $("#" + ic.pre + "dl_2ddgm g[chainid1=" + ic.lineArray2d[i] + "][chainid2=" + ic.lineArray2d[i + 1] + "] line").attr('stroke', me.htmlCls.ORANGE);
              }
          }

          // update the previously highlisghted atoms for switching between all and selection
          ic.prevHighlightAtoms = me.hashUtilsCls.cloneHash(ic.hAtoms);

          ic.definedSetsCls.setMode('selection');
        }

        // update highlight in the menu of defined sets
        //Update the selection in the menu of defined sets according to the current highlighted atoms.
        updateHlMenus(commandnameArray) { let ic = this.icn3d; ic.icn3dui;
            if(commandnameArray === undefined) commandnameArray = [];

            let definedAtomsHtml = ic.definedSetsCls.setAtomMenu(commandnameArray);

            if($("#" + ic.pre + "atomsCustom").length) {
                $("#" + ic.pre + "atomsCustom").html(definedAtomsHtml);
                $("#" + ic.pre + "atomsCustom")[0].blur();
            }
        }

        hlSequence(residueArray) { let ic = this.icn3d; ic.icn3dui;
           // update annotation windows and alignment sequences
           let chainHash = {};
           for(let i = 0, il = residueArray.length; i < il; ++i) {
               let pickedResidue = residueArray[i].trim();
               //[id$= is expensive to search id ending with
               //var resElem = $("[id$=" + ic.pre + pickedResidue + "]");
               let resElem = $("[id=giseq_" + ic.pre + pickedResidue + "]");
               if(resElem.length !== 0) {
                 resElem.addClass('icn3d-highlightSeq');
               }

               resElem = $("[id=align_" + ic.pre + pickedResidue + "]");
               if(resElem.length !== 0) {
                 resElem.addClass('icn3d-highlightSeq');
               }

               let pos = pickedResidue.lastIndexOf('_');
               let chainid = pickedResidue.substr(0, pos);

               chainHash[chainid] = 1;
           }

           for(let chainid in chainHash) {
               if($("#giseq_summary_" + ic.pre + chainid).length !== 0) {
                 $("#giseq_summary_" + ic.pre + chainid).addClass('icn3d-highlightSeqBox');
               }
           }
        }

        hlSeqInChain(chainid) { let ic = this.icn3d; ic.icn3dui;
           // update annotation windows and alignment sequences
           for(let i = 0, il = ic.chainsSeq[chainid].length; i < il; ++i) {
               let resi = ic.chainsSeq[chainid][i].resi;
               let pickedResidue = chainid + '_' + resi;

               //if($("[id$=" + ic.pre + pickedResidue + "]").length !== 0) {
               //  $("[id$=" + ic.pre + pickedResidue + "]").addClass('icn3d-highlightSeq');
               //}
               // too expensive to highlight all annotations
               if($("#giseq_" + ic.pre + pickedResidue).length !== 0) {
                 $("#giseq_" + ic.pre + pickedResidue).addClass('icn3d-highlightSeq');
               }
               if($("#align_" + ic.pre + pickedResidue).length !== 0) {
                 $("#align_" + ic.pre + pickedResidue).addClass('icn3d-highlightSeq');
               }
           }

           if($("#giseq_summary_" + ic.pre + chainid).length !== 0) {
             $("#giseq_summary_" + ic.pre + chainid).addClass('icn3d-highlightSeqBox');
           }
        }

        toggleHighlight() { let ic = this.icn3d; ic.icn3dui;
            //me.htmlCls.clickMenuCls.setLogCmd("toggle highlight", true);

            //if(ic.prevHighlightObjects.length > 0 || ic.prevHighlightObjects_ghost.length > 0) { // remove
            if(ic.bShowHighlight) { // remove
                this.clearHighlight();
                ic.bShowHighlight = false;
            }
            else { // add
                this.showHighlight();
                ic.bShowHighlight = true;
            }

            //me.htmlCls.clickMenuCls.setLogCmd("toggle highlight", true);
        }

        clearHighlight() { let ic = this.icn3d; ic.icn3dui;
            ic.labels['picking']=[];
            ic.drawCls.draw();

            ic.hlObjectsCls.removeHlObjects();
            this.removeHl2D();
            if(ic.bRender) ic.drawCls.render();

            this.removeSeqChainBkgd();
            this.removeSeqResidueBkgd();

            ic.bSelectResidue = false;
        }

        showHighlight() { let ic = this.icn3d; ic.icn3dui;
            ic.hlObjectsCls.addHlObjects();
            this.updateHlAll();
            //ic.bSelectResidue = true;
        }

        highlightChains(chainArray) { let ic = this.icn3d; ic.icn3dui;
            ic.hlObjectsCls.removeHlObjects();
            this.removeHl2D();

            ic.hlObjectsCls.addHlObjects();
            this.updateHl2D(chainArray);

            let residueHash = {};
            for(let c = 0, cl = chainArray.length; c < cl; ++c) {
                let chainid = chainArray[c];
                for(let i in ic.chainsSeq[chainid]) { // get residue number
                    let resObj = ic.chainsSeq[chainid][i];
                    let residueid = chainid + "_" + resObj.resi;

                    if(resObj.name !== '' && resObj.name !== '-') {
                      residueHash[residueid] = 1;
                    }
                }
            }

            this.hlSequence(Object.keys(residueHash));
        }

        hlSummaryDomain3ddomain(that) { let ic = this.icn3d; ic.icn3dui;
          if($(that).attr('domain') !== undefined) { // domain
            let index = $(that).attr('index');
            let chainid = $(that).attr('chain');

            if($("[id^=" + chainid + "_domain_" + index + "]").length !== 0) {
                $("[id^=" + chainid + "_domain_" + index + "]").addClass('icn3d-highlightSeqBox');
            }
          }

          if($(that).attr('3ddomain') !== undefined) { // 3d domain
            let index = $(that).attr('index');
            let chainid = $(that).attr('chain');

            if($("[id^=" + chainid + "_3d_domain_" + index + "]").length !== 0) {
                $("[id^=" + chainid + "_3d_domain_" + index + "]").addClass('icn3d-highlightSeqBox');
            }
          }
        }

        //Remove the background of the highlighted chain in the sequence dialog.
        removeSeqChainBkgd(currChain) {
          if(currChain === undefined) {
            $( ".icn3d-seqTitle" ).each(function( index ) {
              $( this ).removeClass('icn3d-highlightSeq');
              $( this ).removeClass('icn3d-highlightSeqBox');
            });
          }
          else {
            $( ".icn3d-seqTitle" ).each(function( index ) {
              if($(this).attr('chain') !== currChain) {
                  $( this ).removeClass('icn3d-highlightSeq');
                  $( this ).removeClass('icn3d-highlightSeqBox');
              }
            });
          }
        }

        //Remove the background of the highlighted residues in the sequence dialog.
        removeSeqResidueBkgd() {
            $( ".icn3d-residue" ).each(function( index ) {
              $( this ).removeClass('icn3d-highlightSeq');
            });
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class HlObjects {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Show the highlight for the selected atoms: hAtoms.
        addHlObjects(color, bRender, atomsHash) { let ic = this.icn3d, me = ic.icn3dui;
           //if(atomsHash === undefined) atomsHash = ic.hAtoms;
           let atomsHashDisplay = (atomsHash) ? me.hashUtilsCls.intHash(atomsHash, ic.dAtoms) : me.hashUtilsCls.intHash(ic.hAtoms, ic.dAtoms);

           ic.applyDisplayCls.applyDisplayOptions(ic.opts, atomsHashDisplay, ic.bHighlight);

           if( (bRender) || (ic.bRender) ) {
               ic.drawCls.render();
           }
        };

        //Remove the highlight. The atom selection does not change.
        removeHlObjects() { let ic = this.icn3d; ic.icn3dui;
           // remove prevous highlight
           for(let i in ic.prevHighlightObjects) {
               if(ic.mdl) ic.mdl.remove(ic.prevHighlightObjects[i]);
           }

           ic.prevHighlightObjects = [];

           // remove prevous highlight
           for(let i in ic.prevHighlightObjects_ghost) {
            if(ic.mdl) ic.mdl.remove(ic.prevHighlightObjects_ghost[i]);
           }

           ic.prevHighlightObjects_ghost = [];
        };

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class LineGraph {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        drawLineGraph(lineGraphStr, bScatterplot) { let ic = this.icn3d, me = ic.icn3dui;
            let html, graph = JSON.parse(lineGraphStr);
            let linkArray = [],
                nodeArray1 = [],
                nodeArray2 = [];
            let name2node = {};
            for(let i = 0, il = graph.nodes.length; i < il; ++i) {
                let node = graph.nodes[i];
                name2node[node.id] = node;
            }
            // only get interaction links
            let nameHash = {};
            for(let i = 0, il = graph.links.length; i < il; ++i) {
                let link = graph.links[i];
                if(link.v == me.htmlCls.hbondValue || link.v == me.htmlCls.ionicValue || link.v == me.htmlCls.halogenValue ||
                    link.v == me.htmlCls.picationValue || link.v == me.htmlCls.pistackingValue || link.v == me.htmlCls.contactValue) {
                    linkArray.push(link);
                    nameHash[link.source] = 1;
                    nameHash[link.target] = 1;
                }
            }
            let nodeArrays = ic.getGraphCls.getNodeTopBottom(nameHash, name2node);
            nodeArray1 = nodeArrays.nodeArray1;
            nodeArray2 = nodeArrays.nodeArray2;
            ic.lineGraphStr = '{\n';

            //let structureArray = ic.resid2specCls.atoms2structureArray(ic.hAtoms);
            let structureArray = Object.keys(ic.structures);

            //if(Object.keys(ic.structures).length > 1) {
            if(structureArray.length > 1) {

                let struc2index= {};
                let nodeArray1Split = [], nodeArray2Split = [], linkArraySplit = [], nameHashSplit = [];

                // show common interactions: nodes will be the same. The links/interactins are different.
                // The mapped residue name and number are attached to "id".
                // Original node: {id : "Q24.A.2AJF", r : "1_1_2AJF_A_24", s: "a", ...}
                // Node for common interaction: {id : "Q24.A.2AJF|Q24", r : "1_1_2AJF_A_24", s: "a", ...}
                let nodeArray1SplitCommon = [], nodeArray2SplitCommon = [], linkArraySplitCommon = [], nameHashSplitCommon = [];
                let nodeArray1SplitDiff = [], nodeArray2SplitDiff = [], linkArraySplitDiff = [], nameHashSplitDiff = [];
                let linkedNodeCnt = {}, linkedNodeInterDiff = {}, linkedNodeInterDiffBool = {};

                for(let i = 0, il = structureArray.length; i < il; ++i) {   
                    nodeArray1Split[i] = [];
                    nodeArray2Split[i] = [];
                    linkArraySplit[i] = [];
                    nameHashSplit[i] = {};

                    nodeArray1SplitCommon[i] = [];
                    nodeArray2SplitCommon[i] = [];
                    linkArraySplitCommon[i] = [];
                    nameHashSplitCommon[i] = {};

                    nodeArray1SplitDiff[i] = [];
                    nodeArray2SplitDiff[i] = [];
                    linkArraySplitDiff[i] = [];
                    nameHashSplitDiff[i] = {};

                    struc2index[structureArray[i]] = i;
                }
                
                for(let i = 0, il = linkArray.length; i < il; ++i) {
                    let link = linkArray[i];
                    let nodeA = name2node[link.source];
                    let nodeB = name2node[link.target];

                    if(!nodeA || !nodeB || !nodeA.r || !nodeB.r) {
                        continue;
                    }

                    let idArrayA = this.getIdArrayFromNode(nodeA);
                    let idArrayB = this.getIdArrayFromNode(nodeB);

                    let index = struc2index[idArrayA[2]];

                    if(idArrayA[2] == structureArray[index] && idArrayB[2] == structureArray[index]) {
                        linkArraySplit[index].push(link);
                        nameHashSplit[index][link.source] = 1;
                        nameHashSplit[index][link.target] = 1;

                        let chainid1 = idArrayA[2] + '_' + idArrayA[3];
                        let chainid2 = idArrayB[2] + '_' + idArrayB[3];
                        let resid1 = chainid1 + '_' + idArrayA[4];
                        let resid2 = chainid2 + '_' + idArrayB[4];

                        let mapping1, mapping2;

                        if(ic.chainsMapping[chainid1] && ic.chainsMapping[chainid1][resid1]
                            && ic.chainsMapping[chainid2] && ic.chainsMapping[chainid2][resid2]) { 
                              mapping1 = (nodeA.s == "a") ? ic.chainsMapping[chainid1][resid1] : ic.chainsMapping[chainid2][resid2];
                              mapping2 = (nodeA.s == "a") ? ic.chainsMapping[chainid2][resid2] : ic.chainsMapping[chainid1][resid1];
      
                              let mappingid = mapping1 + '_' + mapping2 + '_' + link.c; // link.c determines the interaction type

                              if(!linkedNodeCnt.hasOwnProperty(mappingid)) {
                                linkedNodeCnt[mappingid] = 1;
                                linkedNodeInterDiff[mappingid] = link.n;
                              }
                              else {                           
                                ++linkedNodeCnt[mappingid];   
                                linkedNodeInterDiff[mappingid] += link.n;
                                
                                linkedNodeInterDiffBool[mappingid] = (linkedNodeInterDiff[mappingid] / link.n == linkedNodeCnt[mappingid]) ? 0 : 1; 
                              }
                          }
                    } 
                }
                
                // do not combine with the above section since linkedNodeCnt was pre-populated above
                // set linkArraySplitCommon and nameHashSplitCommon
                // set linkArraySplitDiff and nameHashSplitDiff
                let separatorCommon = "=>", separatorDiff = "==>", postCommon = "-", postDiff = "--";
                for(let i = 0, il = linkArray.length; i < il; ++i) {
                    let link = linkArray[i];
                    let nodeA = name2node[link.source];
                    let nodeB = name2node[link.target];

                    if(!nodeA || !nodeB || !nodeA.r || !nodeB.r) {
                        continue;
                    }

                    let idArrayA = this.getIdArrayFromNode(nodeA);
                    let idArrayB = this.getIdArrayFromNode(nodeB);

                    let index = struc2index[idArrayA[2]];

                    if(idArrayA[2] == structureArray[index] && idArrayB[2] == structureArray[index]) {
                        linkArraySplit[index].push(link);
                        nameHashSplit[index][link.source] = 1;
                        nameHashSplit[index][link.target] = 1;

                        let chainid1 = idArrayA[2] + '_' + idArrayA[3];
                        let chainid2 = idArrayB[2] + '_' + idArrayB[3];
                        let resid1 = chainid1 + '_' + idArrayA[4];
                        let resid2 = chainid2 + '_' + idArrayB[4];

                        let mapping1, mapping2;

                        if(ic.chainsMapping[chainid1] && ic.chainsMapping[chainid1][resid1]
                            && ic.chainsMapping[chainid2] && ic.chainsMapping[chainid2][resid2]) { 
                              mapping1 = (nodeA.s == "a") ? ic.chainsMapping[chainid1][resid1] : ic.chainsMapping[chainid2][resid2];
                              mapping2 = (nodeA.s == "a") ? ic.chainsMapping[chainid2][resid2] : ic.chainsMapping[chainid1][resid1];

                              let bIgRef = (mapping1.length > 4 && !isNaN(parseInt(mapping1.substr(-4, 4)))) || (mapping2.length > 4 && !isNaN(parseInt(mapping2.substr(-4, 4))));
      
                              let mappingid = mapping1 + '_' + mapping2 + '_' + link.c; // link.c determines the interaction type

                              let linkCommon = me.hashUtilsCls.cloneHash(link);
                              linkCommon.source += separatorCommon + ic.chainsMapping[chainid1][resid1];
                              linkCommon.target += separatorCommon + ic.chainsMapping[chainid2][resid2];
      
                              let linkDiff = me.hashUtilsCls.cloneHash(link);
                              linkDiff.source += separatorDiff + ic.chainsMapping[chainid1][resid1];
                              linkDiff.target += separatorDiff + ic.chainsMapping[chainid2][resid2];
                              
                              if(linkedNodeCnt[mappingid] == structureArray.length && (bIgRef || linkedNodeInterDiffBool[mappingid] == 0)) {
                                  linkArraySplitCommon[index].push(linkCommon);
                              }  
                              else {
                                  linkArraySplitDiff[index].push(linkDiff);
                              }
      
                              // use the original node names and thus use the original link
                              nameHashSplitCommon[index][link.source] = ic.chainsMapping[chainid1][resid1];
                              nameHashSplitCommon[index][link.target] = ic.chainsMapping[chainid2][resid2];
       
                              nameHashSplitDiff[index][link.source] = ic.chainsMapping[chainid1][resid1];
                              nameHashSplitDiff[index][link.target] = ic.chainsMapping[chainid2][resid2];
                          }
                          else { // unmapped residues are considered as different
                              let linkDiff = me.hashUtilsCls.cloneHash(link);
                              linkDiff.source += (ic.chainsMapping[chainid1] && ic.chainsMapping[chainid1][resid1]) ? separatorDiff + ic.chainsMapping[chainid1][resid1] : separatorDiff + postDiff;
                              linkDiff.target += (ic.chainsMapping[chainid2] && ic.chainsMapping[chainid2][resid2]) ? separatorDiff + ic.chainsMapping[chainid2][resid2] : separatorDiff + postDiff;
                          
                              linkArraySplitDiff[index].push(linkDiff);
                              
                              // use the original node names and thus use the original link
                              nameHashSplitCommon[index][link.source] = (ic.chainsMapping[chainid1] && ic.chainsMapping[chainid1][resid1]) ? ic.chainsMapping[chainid1][resid1] : postCommon;
                              nameHashSplitCommon[index][link.target] = (ic.chainsMapping[chainid2] && ic.chainsMapping[chainid2][resid2]) ? ic.chainsMapping[chainid2][resid2] : postCommon;
          
                              nameHashSplitDiff[index][link.source] = (ic.chainsMapping[chainid1] && ic.chainsMapping[chainid1][resid1]) ? ic.chainsMapping[chainid1][resid1] : postDiff;
                              nameHashSplitDiff[index][link.target] = (ic.chainsMapping[chainid2] && ic.chainsMapping[chainid2][resid2]) ? ic.chainsMapping[chainid2][resid2] : postDiff;
                          }
                    } 
                }

                let len1Split = [], len2Split = [], maxWidth = 0;
                let strucArray = [];
                let bCommonDiff = 1;
                for(let i = 0, il = structureArray.length; i < il; ++i) {  
                    let nodeArraysTmp = ic.getGraphCls.getNodeTopBottom(nameHashSplit[i], name2node);
                    nodeArray1Split[i] = nodeArraysTmp.nodeArray1;
                    nodeArray2Split[i] = nodeArraysTmp.nodeArray2;

                    if(Object.keys(ic.chainsMapping).length > 0) { 
                        // common interactions
                        bCommonDiff = 1;
                        nodeArraysTmp = ic.getGraphCls.getNodeTopBottom(nameHashSplit[i], name2node, undefined, bCommonDiff, nameHashSplitCommon[i]);
                        nodeArray1SplitCommon[i] = nodeArraysTmp.nodeArray1;
                        nodeArray2SplitCommon[i] = nodeArraysTmp.nodeArray2;
                        name2node = me.hashUtilsCls.unionHash(name2node, nodeArraysTmp.name2node);

                        // different interactions
                        bCommonDiff = 2;
                        nodeArraysTmp = ic.getGraphCls.getNodeTopBottom(nameHashSplit[i], name2node, undefined, bCommonDiff, nameHashSplitDiff[i]);
                        nodeArray1SplitDiff[i] = nodeArraysTmp.nodeArray1;
                        nodeArray2SplitDiff[i] = nodeArraysTmp.nodeArray2;
                        name2node = me.hashUtilsCls.unionHash(name2node, nodeArraysTmp.name2node);
                    }
                    
                    len1Split[i] = nodeArray1Split[i].length;
                    len2Split[i] = nodeArray2Split[i].length;
                    
                    maxWidth = Math.max(maxWidth, len2Split[i]);

                    //if(linkArraySplit[i].length > 0) strucArray.push(structureArray[i]);
                    strucArray.push(structureArray[i]);
                }

                let factor = 1;
                let r = 3 * factor;
                let gap = 7 * factor;
                let height, width, heightAll;
                let marginX = 10,
                    marginY = 10,
                    legendWidth = 30,
                    textHeight = 20;
                
                if(bScatterplot) {
                    //heightAll =(len1a + 2 + len2a + 2) *(r + gap) + 4 * marginY + 2 * legendWidth;
                    //width =(Math.max(len1b, len2b) + 2) *(r + gap) + 2 * marginX + legendWidth;
                    heightAll =(me.utilsCls.sumArray(len1Split) + 2*strucArray.length) *(r + gap) + 4 * marginY 
                      + 2 * legendWidth + textHeight*strucArray.length;

                    width = (maxWidth + 2) * (r + gap) + 2 * marginX + legendWidth;
                      
                } else {
                    height = 110 + textHeight;
                    heightAll = height * strucArray.length;

                    width = (maxWidth + 2) * (r + gap) + 2 * marginX;

                    // add some extra space
                    width += 20;
                }

                // show common and diff interaction as well
                if(Object.keys(ic.chainsMapping).length > 0) heightAll *= 3;

                let id, graphWidth;
                if(bScatterplot) {
                    ic.scatterplotWidth = 2 * width;
                    graphWidth = ic.scatterplotWidth;
                    id = me.scatterplotid;
                } else {
                    ic.linegraphWidth = 2 * width;
                    graphWidth = ic.linegraphWidth;
                    id = me.linegraphid;
                }
                html =(strucArray.length == 0) ? "No interactions found for each structure<br><br>" :
                    "2D integration graph for " + strucArray.length + " structure(s) <b>" + strucArray + "</b>. There are three sections: \"Interactions\", \"Common interactions\", and \"Different interactions\". Each section has " + strucArray.length + " graphs.<br><br>";
                html += "<svg id='" + id + "' viewBox='0,0," + width + "," + heightAll + "' width='" + graphWidth + "px'>";

                let result, heightFinal = 0;            
     
                bCommonDiff = 0; // 0: all interactions, 1: common interactions, 2: different interactions
                result = this.drawGraphPerType(bCommonDiff, structureArray, bScatterplot, nodeArray1Split, nodeArray2Split, linkArraySplit, name2node, heightFinal, height, textHeight, len1Split, r, gap, marginY);

                heightFinal = result.heightFinal;
                html += result.html;

                if(Object.keys(ic.chainsMapping).length > 0) {
                    bCommonDiff = 1;
                    result = this.drawGraphPerType(bCommonDiff, structureArray, bScatterplot, nodeArray1SplitCommon, nodeArray2SplitCommon, linkArraySplitCommon, name2node, heightFinal, height, textHeight, len1Split, r, gap, marginY);

                    heightFinal = result.heightFinal;
                    html += result.html;

                    bCommonDiff = 2;
                    result = this.drawGraphPerType(bCommonDiff, structureArray, bScatterplot, nodeArray1SplitDiff, nodeArray2SplitDiff, linkArraySplitDiff, name2node, heightFinal, height, textHeight, len1Split, r, gap, marginY);

                    heightFinal = result.heightFinal;
                    html += result.html;
                }
                
                html += "</svg>";
            } else {
                if(!bScatterplot) {
                    //let struc1 = Object.keys(ic.structures)[0];
                    let struc1 = structureArray[0];

                    let len1 = nodeArray1.length,
                        len2 = nodeArray2.length;
                    let factor = 1;
                    let r = 3 * factor;
                    let gap = 7 * factor;
                    let height = 110;
                    let margin = 10;
                    let width =(len1 > len2) ? len1 *(r + gap) + 2 * margin : len2 *(r + gap) + 2 * margin;

                    ic.linegraphWidth = 2 * width;
                    html =(linkArray.length > 0) ? "" : "No interactions found for these two sets<br><br>";
                    html += "<svg id='" + me.linegraphid + "' viewBox='0,0," + width + "," + height + "' width='" + ic.linegraphWidth + "px'>";
                    html += this.drawLineGraph_base(nodeArray1, nodeArray2, linkArray, name2node, 0);
                    ic.lineGraphStr += ic.getGraphCls.updateGraphJson(struc1, 1, nodeArray1, nodeArray2, linkArray);
                    html += "</svg>";
                } else {
                    //let struc1 = Object.keys(ic.structures)[0];
                    let struc1 = structureArray[0];

                    let len1 = nodeArray1.length,
                        len2 = nodeArray2.length;
                    let factor = 1;
                    let r = 3 * factor;
                    let gap = 7 * factor;
                    let width, heightAll;
                    let marginX = 10,
                        marginY = 10,
                        legendWidth = 30;
                    heightAll =(len1 + 2) *(r + gap) + 2 * marginY + legendWidth;
                    width =(len2 + 2) *(r + gap) + 2 * marginX + legendWidth;

                    let id, graphWidth;
                    ic.scatterplotWidth = 2 * width;
                    graphWidth = ic.scatterplotWidth;
                    id = me.scatterplotid;
                    html =(linkArray.length > 0) ? "" : "No interactions found for these two sets<br><br>";
                    html += "<svg id='" + id + "' viewBox='0,0," + width + "," + heightAll + "' width='" + graphWidth + "px'>";
                    html += this.drawScatterplot_base(nodeArray1, nodeArray2, linkArray, name2node, 0);
                    ic.lineGraphStr += ic.getGraphCls.updateGraphJson(struc1, 1, nodeArray1, nodeArray2, linkArray);
                    html += "</svg>";
                }
            }
            ic.lineGraphStr += '}\n';
            ic.scatterplotStr = ic.lineGraphStr;
            if(bScatterplot) {
                $("#" + ic.pre + "scatterplotDiv").html(html);
            } else {
                $("#" + ic.pre + "linegraphDiv").html(html);
            }
            return html;
        }

        drawGraphPerType(bCommonDiff, structureArray, bScatterplot, nodeArray1, nodeArray2, linkArray, name2node, heightFinal, height, textHeight, len1Split, r, gap, marginY) { let ic = this.icn3d; ic.icn3dui;
            let html = "";

            let bMutation = structureArray.length == 2 && structureArray[1].replace(structureArray[0], '') == '2';

            // draw common interaction
            let label, postfix;
            if(bCommonDiff == 0) {
                label = "Interactions in ";
                postfix = "";
            }
            else if(bCommonDiff == 1) {
                label = "Common interactions in ";
                postfix = "_common";
            }
            else if(bCommonDiff == 2) {
                label = "Different interactions in ";
                postfix = "_diff";
            }

            for(let i = 0, il = structureArray.length; i < il; ++i) {  
                let labelFinal = label;
                if(bMutation) {
                    if(i == 0) {
                        labelFinal += "Wild Type ";
                    }
                    else if(i == 1) {
                        labelFinal += "Mutant ";
                    }
                }

                if(bScatterplot) {
                    html += this.drawScatterplot_base(nodeArray1[i], nodeArray2[i], linkArray[i], name2node, heightFinal, undefined, labelFinal + structureArray[i], textHeight);
                    height =(len1Split[i] + 1) *(r + gap) + 2 * marginY + textHeight;
                } else {
                    html += this.drawLineGraph_base(nodeArray1[i], nodeArray2[i], linkArray[i], name2node, heightFinal, labelFinal + structureArray[i], textHeight);
                }
                heightFinal += height;

                if(bCommonDiff) { // very beginning
                    if(i > 0) ic.lineGraphStr += ', \n';
                }
                else {
                    ic.lineGraphStr += ', \n';
                }
                ic.lineGraphStr += ic.getGraphCls.updateGraphJson(structureArray[i], i + postfix, nodeArray1[i], nodeArray2[i], linkArray[i]);
            }

            return {"heightFinal": heightFinal, "html": html};
        }

        getIdArrayFromNode(node) { let ic = this.icn3d, me = ic.icn3dui;
            let idArray = []; // 1_1_1KQ2_A_1
            idArray.push('');
            idArray.push('');

            let tmpStr = node.r.substr(4); 
            idArray = idArray.concat(me.utilsCls.getIdArray(tmpStr));

            return idArray;
        }

        drawLineGraph_base(nodeArray1, nodeArray2, linkArray, name2node, height, label, textHeight) { let ic = this.icn3d, me = ic.icn3dui;
            let html = '';
            let len1 = nodeArray1.length,
                len2 = nodeArray2.length;
            let factor = 1;
            let r = 3 * factor;
            let gap = 7 * factor;
            let margin = 10;
            // draw nodes
            let margin1, margin2;
            if(len1 > len2) {
                margin1 = margin;
                margin2 = Math.abs(len1 - len2) *(r + gap) * 0.5 + margin;
            } else {
                margin2 = margin;
                margin1 = Math.abs(len1 - len2) *(r + gap) * 0.5 + margin;
            }

            // draw label
            if(label) {
                height += textHeight;
                html += "<text x='" + margin + "' y='" + height + "' style='font-size:8px; font-weight:bold'>" + label + "</text>";
            }

            let h1 = 30 + height,
                h2 = 80 + height;
            let nodeHtml = '';
            let node2posSet1 = {},
                node2posSet2 = {};
            for(let i = 0; i < len1; ++i) {
                nodeHtml += ic.getGraphCls.drawResNode(nodeArray1[i], i, r, gap, margin1, h1, 'a');
                node2posSet1[nodeArray1[i].id] = { x: margin1 + i *(r + gap), y: h1 };
            }
            for(let i = 0; i < len2; ++i) {
                nodeHtml += ic.getGraphCls.drawResNode(nodeArray2[i], i, r, gap, margin2, h2, 'b');
                node2posSet2[nodeArray2[i].id] = { x: margin2 + i *(r + gap), y: h2 };
            }
            // draw lines
            for(let i = 0, il = linkArray.length; i < il; ++i) {
                let link = linkArray[i];
                let node1 = name2node[link.source];
                let node2 = name2node[link.target];

                if(node1 === undefined || node2 === undefined) continue;

                let resid1 = node1.r.substr(4);
                let resid2 = node2.r.substr(4);
                let pos1 = node2posSet1[node1.id];
                let pos2 = node2posSet2[node2.id];
                if(pos1 === undefined || pos2 === undefined) continue;
                let linestrokewidth;
                if(link.v == me.htmlCls.contactValue) {
                    // linestrokewidth = (link.n == 1) ? 1 : 3;
                    linestrokewidth = 1;
                } else {
                    linestrokewidth = (link.n == 1) ? 2 : 4;
                }
                
                let strokecolor = this.getStrokecolor(link.v);

                html += "<g class='icn3d-interaction' resid1='" + resid1 + "' resid2='" + resid2 + "' >";
                let interactStr = (link.n == 1) ? 'Interaction' : link.n + ' interactions';
                if(link.n > 1) html += "<title>" + interactStr + " of residue " + node1.id + " with residue " + node2.id + "</title>";
                html += "<line x1='" + pos1.x + "' y1='" + pos1.y + "' x2='" + pos2.x + "' y2='" + pos2.y + "' stroke='" + strokecolor + "' stroke-width='" + linestrokewidth + "'/></g>";
            }
            // show nodes later
            html += nodeHtml;
            return html;
        }

        drawScatterplot_base(nodeArray1, nodeArray2, linkArray, name2node, height, bContactMap, label, textHeight, bAfMap) { let ic = this.icn3d; ic.icn3dui;
            let html = '';
            let len1 = nodeArray1.length,
                len2 = nodeArray2.length;
            let factor = 1;
            let r = 3 * factor;
            let gap = (bContactMap) ? r : 7 * factor;
            let legendWidth = 30;
            let marginX = 10,
                marginY = 20;
            let heightTotal =(len1 + 1) *(r + gap) + legendWidth + 2 * marginY;

            // draw label
            if(label) {
                height += textHeight;
                html += "<text x='" + marginX + "' y='" + (height + 15).toString() + "' style='font-size:8px; font-weight:bold'>" + label + "</text>";
            }

            let margin1 = height + heightTotal -(legendWidth + marginY +(r + gap)); // y-axis
            let margin2 = legendWidth + marginX +(r + gap); // x-axis

            let nodeHtml = '';
            let node2posSet1 = {},
                node2posSet2 = {};
            let x = legendWidth + marginX;
            for(let i = 0; i < len1; ++i) {
                nodeHtml += ic.getGraphCls.drawResNode(nodeArray1[i], i, r, gap, margin1, x, 'a', true, undefined, bAfMap);
                node2posSet1[nodeArray1[i].id] = { x: x, y: margin1 - i *(r + gap) };
            }
            let y = height + heightTotal -(legendWidth + marginY);
            for(let i = 0; i < len2; ++i) {
                nodeHtml += ic.getGraphCls.drawResNode(nodeArray2[i], i, r, gap, margin2, y, 'b', false, bContactMap, bAfMap);
                node2posSet2[nodeArray2[i].id] = { x: margin2 + i *(r + gap), y: y };
            }
            for(let i = 0, il = linkArray.length; i < il; ++i) {
                let link = linkArray[i];
                let node1 = name2node[link.source];
                let node2 = name2node[link.target];

                if(!node1 || !node2) continue;

                html += this.drawOnePairNode(link, node1, node2, node2posSet1, node2posSet2, bContactMap, bAfMap);

                if(bContactMap && !bAfMap) { // draw symmetric contact map, bAfmap just need to draw once          
                    html += this.drawOnePairNode(link, node2, node1, node2posSet1, node2posSet2, bContactMap, bAfMap);
                }
            }
            // show nodes later
            html += nodeHtml;
            return html;
        }

        getStrokecolor(value, type) { let ic = this.icn3d, me = ic.icn3dui;
            let strokecolor = "#000";

            if(value) {
                if(value == me.htmlCls.hbondValue) {
                    strokecolor = "#" + me.htmlCls.hbondColor;
                } else if(value == me.htmlCls.ionicValue) {
                    strokecolor = "#" + me.htmlCls.ionicColor;
                } else if(value == me.htmlCls.halogenValue) {
                    strokecolor = "#" + me.htmlCls.halogenColor;
                } else if(value == me.htmlCls.picationValue) {
                    strokecolor = "#" + me.htmlCls.picationColor;
                } else if(value == me.htmlCls.pistackingValue) {
                    strokecolor = "#" + me.htmlCls.pistackingColor;
                } else if(value == me.htmlCls.contactValue) {
                    strokecolor = "#" + me.htmlCls.contactColor;
                }
            }

            if(type) {
                if(type == 'hbond') {
                    strokecolor = "#" + me.htmlCls.hbondColor;
                } else if(type == 'ionic') {
                    strokecolor = "#" + me.htmlCls.ionicColor;
                } else if(type == 'halogen') {
                    strokecolor = "#" + me.htmlCls.halogenColor;
                } else if(type == 'pi-cation') {
                    strokecolor = "#" + me.htmlCls.picationColor;
                } else if(type == 'pi-stacking') {
                    strokecolor = "#" + me.htmlCls.pistackingColor;
                } else if(type == 'contact') {
                    strokecolor = "#" + me.htmlCls.contactColor;
                }
            }

            return strokecolor;
        }

        drawOnePairNode(link, node1, node2, node2posSet1, node2posSet2, bContactMap, bAfMap) { let ic = this.icn3d, me = ic.icn3dui;
            let html = '';

            let factor = 1;
            let r = 3 * factor;
            // draw rect
            let rectSize = (bContactMap) ? 2 * r : 1.5 * r;
            let halfSize = 0.5 * rectSize;

            let resid1 = node1.r.substr(4);
            let resid2 = node2.r.substr(4);
            let pos1 = node2posSet1[node1.id];
            let pos2 = node2posSet2[node2.id];
            if(pos1 === undefined || pos2 === undefined) return html;

            let strokecolor = this.getStrokecolor(link.v);

            if(bContactMap) strokecolor = "#" + link.c;

            let linestrokewidth;
            if(link.v == me.htmlCls.contactValue) {
                // linestrokewidth = (link.n == 1) ? 1 : 3;
                linestrokewidth = 1;
            } else {
                linestrokewidth = (link.n == 1) ? 2 : 4;
            }
            
            if(bAfMap && ic.hex2skip[link.c]) ;
            else if(bAfMap && ic.hex2id[link.c]) {
                ic.hex2id[link.c];
    //            html += "<use href='#" + id + "' x='" +(pos2.x - halfSize).toString() + "' y='" +(pos1.y - halfSize).toString() + "' />";

                //html += "<g class='icn3d-interaction' resid1='" + resid1 + "' resid2='" + resid2 + "' >";
                //html += "<title>Interaction of residue " + node1.id + " with residue " + node2.id + "</title>";
                html += "<rect class='icn3d-interaction' resid1='" + resid1 + "' resid2='" + resid2 + "' x='" +(pos2.x - halfSize).toString() + "' y='" +(pos1.y - halfSize).toString() + "' width='" + rectSize + "' height='" + rectSize + "' fill='" + strokecolor + "' stroke-width='" + linestrokewidth + "' stroke='" + strokecolor + "' />";
                //html += "</g>";
            }
            else {
                html += "<g class='icn3d-interaction' resid1='" + resid1 + "' resid2='" + resid2 + "' >";
                let interactStr = (link.n == 1) ? 'Interaction' : link.n + ' interactions';
                if(link.n > 1) html += "<title>" + interactStr + " of residue " + node1.id + " with residue " + node2.id + "</title>";
                if(bContactMap) {
                    html += "<rect x='" +(pos2.x - halfSize).toString() + "' y='" +(pos1.y - halfSize).toString() + "' width='" + rectSize + "' height='" + rectSize + "' fill='" + strokecolor + "' stroke-width='" + linestrokewidth + "' stroke='" + strokecolor + "' />";
                }
                else {
                    html += "<rect x='" +(pos2.x - halfSize).toString() + "' y='" +(pos1.y - halfSize).toString() + "' width='" + rectSize + "' height='" + rectSize + "' fill='" + strokecolor + "' fill-opacity='0.6' stroke-width='" + linestrokewidth + "' stroke='" + strokecolor + "' />";
                }
                html += "</g>";
            }

            return html;
        }

        copyStylesInline(destinationNode, sourceNode) { let ic = this.icn3d; ic.icn3dui;
            let containerElements = ["svg", "g"];
            for(let cd = 0; cd < destinationNode.childNodes.length; cd++) {
                let child = destinationNode.childNodes[cd];
                if(containerElements.indexOf(child.tagName) != -1) {
                    this.copyStylesInline(child, sourceNode.childNodes[cd]);
                    continue;
                }
                let style = sourceNode.childNodes[cd].currentStyle || window.getComputedStyle(sourceNode.childNodes[cd]);
                if(style == "undefined" || style == null) continue;
                for(let st = 0; st < style.length; st++) {
                    child.style.setProperty(style[st], style.getPropertyValue(style[st]));
                }
            }
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    // import { Refnum } from "../annotations/refnum";

    class GetGraph {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        getGraphData(atomSet2, atomSet1, nameArray2, nameArray, html, labelType, bAnyAtom) { let ic = this.icn3d, me = ic.icn3dui;
           // get the nodes and links data
           let nodeStr = '', linkStr = '';
           let nodeArray = [], linkArray = [];
           let node_link1 = this.getNodesLinksForSet(atomSet2, labelType, 'a', bAnyAtom);
           let node_link2 = this.getNodesLinksForSet(atomSet1, labelType, 'b', bAnyAtom);

           nodeArray = node_link1.node.concat(node_link2.node);
           // removed duplicated nodes
           let nodeJsonArray = [];
           let checkedNodeidHash = {};
           let cnt = 0;
           for(let i = 0, il = nodeArray.length; i < il; ++i) {
               let node = nodeArray[i];
               let nodeJson = JSON.parse(node);
               if(!checkedNodeidHash.hasOwnProperty(nodeJson.id)) {
                   nodeJsonArray.push(nodeJson);
                   checkedNodeidHash[nodeJson.id] = cnt;
                   ++cnt;
               }
               else {
                   let pos = checkedNodeidHash[nodeJson.id];
                   nodeJsonArray[pos].s = 'ab'; // appear in both sets
               }
           }
           let nodeStrArray = [];
           for(let i = 0, il = nodeJsonArray.length; i < il; ++i) {
               let nodeJson = nodeJsonArray[i];
               nodeStrArray.push(JSON.stringify(nodeJson));
           }
           nodeStr = nodeStrArray.join(', ');
           // linkStr
           linkArray = node_link1.link.concat(node_link2.link);
           linkStr = linkArray.join(', ');
           // add chemicals, no links for chemicals
           let selectedAtoms = me.hashUtilsCls.unionHash(me.hashUtilsCls.cloneHash(atomSet1), atomSet2);
           let chemicalNodeStr = '';
           let hBondLinkStr = '', ionicLinkStr = '', halogenpiLinkStr = '', contactLinkStr = '',
             disulfideLinkStr = '', crossLinkStr = '';
               // add hydrogen bonds for each set
               if(!(nameArray2.length == 1 && nameArray.length == 1 && nameArray2[0] == nameArray[0])) {
                   hBondLinkStr += this.getHbondLinksForSet(atomSet2, labelType);
                   hBondLinkStr += this.getHbondLinksForSet(atomSet1, labelType);
               }
               // add ionic interaction for each set
               if(!(nameArray2.length == 1 && nameArray.length == 1 && nameArray2[0] == nameArray[0])) {
                   ionicLinkStr += this.getIonicLinksForSet(atomSet2, labelType);
                   ionicLinkStr += this.getIonicLinksForSet(atomSet1, labelType);
               }
               // add halogen, pi-cation and pi-stacking for each set
               if(!(nameArray2.length == 1 && nameArray.length == 1 && nameArray2[0] == nameArray[0])) {
                   halogenpiLinkStr += this.getHalogenPiLinksForSet(atomSet2, labelType);
                   halogenpiLinkStr += this.getHalogenPiLinksForSet(atomSet1, labelType);
               }
               // add contacts for each set
               if(!(nameArray2.length == 1 && nameArray.length == 1 && nameArray2[0] == nameArray[0])) {
                   contactLinkStr += this.getContactLinksForSet(atomSet2, labelType);
                   contactLinkStr += this.getContactLinksForSet(atomSet1, labelType);
               }
               //else {
               //    contactLinkStr += this.getContactLinksForSet(atomSet1, labelType);
               //}
               // add disulfide bonds
               for(let structure in ic.ssbondpnts) {
                   for(let i = 0, il = ic.ssbondpnts[structure].length; i < il; i += 2) {
                       let resid1 = ic.ssbondpnts[structure][i]; //1GPK_A_402
                       let resid2 = ic.ssbondpnts[structure][i+1];
                       let atom1 = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid1]);
                       let atom2 = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid2]);
                       if(selectedAtoms.hasOwnProperty(atom1.serial) && selectedAtoms.hasOwnProperty(atom2.serial)) {
                           let resName1 = me.utilsCls.residueName2Abbr(atom1.resn) + atom1.resi;
                           if(labelType == 'chain' || labelType == 'structure') resName1 += '.' + atom1.chain;
                           if(labelType == 'structure') resName1 += '.' + atom1.structure;
                           let resName2 = me.utilsCls.residueName2Abbr(atom2.resn) + atom2.resi; // + '_' + atom.chain;
                           if(labelType == 'chain' || labelType == 'structure') resName2 += '.' + atom2.chain;
                           if(labelType == 'structure') resName2 += '.' + atom2.structure;
                           disulfideLinkStr += ', {"source": "' + resName1 + '", "target": "' + resName2
                               + '", "v": ' + me.htmlCls.ssbondValue + ', "c": "' + me.htmlCls.ssbondColor + '"}';
                       }
                   }
               }
               // add cross linkage
               for(let structure in ic.clbondpnts) {
                   for(let i = 0, il = ic.clbondpnts[structure].length; i < il; i += 2) {
                       let resid1 = ic.clbondpnts[structure][i]; //1GPK_A_402
                       let resid2 = ic.clbondpnts[structure][i+1];
                       let atom1 = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid1]);
                       let atom2 = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid2]);
                       if(selectedAtoms.hasOwnProperty(atom1.serial) && selectedAtoms.hasOwnProperty(atom2.serial)) {
                           let resName1 = me.utilsCls.residueName2Abbr(atom1.resn) + atom1.resi;
                           if(labelType == 'chain' || labelType == 'structure') resName1 += '.' + atom1.chain;
                           if(labelType == 'structure') resName1 += '.' + atom1.structure;
                           let resName2 = me.utilsCls.residueName2Abbr(atom2.resn) + atom2.resi; // + '_' + atom.chain;
                           if(labelType == 'chain' || labelType == 'structure') resName2 += '.' + atom2.chain;
                           if(labelType == 'structure') resName2 += '.' + atom2.structure;
                           crossLinkStr += ', {"source": "' + resName1 + '", "target": "' + resName2
                               + '", "v": ' + me.htmlCls.clbondValue + ', "c": "' + me.htmlCls.clbondColor + '"}';
                       }
                   }
               }
           let resStr = '{"nodes": [' + nodeStr + chemicalNodeStr + '], "links": [';
           //resStr += linkStr + html + hBondLinkStr + ionicLinkStr + halogenpiLinkStr + disulfideLinkStr + crossLinkStr + contactLinkStr;
           if(linkStr == '') {
               resStr += linkStr + html.substr(1) + disulfideLinkStr + crossLinkStr + contactLinkStr + hBondLinkStr + ionicLinkStr + halogenpiLinkStr;
           }
           else {
               resStr += linkStr + html + disulfideLinkStr + crossLinkStr + contactLinkStr + hBondLinkStr + ionicLinkStr + halogenpiLinkStr;
           }
           resStr += ']}';

           return resStr;
        }

        drawResNode(node, i, r, gap, margin, y, setName, bVertical, bContactMap, bAfMap) { let ic = this.icn3d; ic.icn3dui;
            let x, resid = node.r.substr(4);
            if(bVertical) {
                x = margin - i *(r + gap);
            }
            else {
                x = margin + i *(r + gap);
            }
            ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid]);
            //var color = "#" + atom.color.getHexString().toUpperCase();
            let color = "#" + node.c.toUpperCase();
            "#" + ic.hColor.getHexString().toUpperCase();
            let pos = node.id.indexOf('.');
            let nodeName =(pos == -1) ? node.id : node.id.substr(0, pos);
            let adjustx = 0, adjusty =(setName == 'a') ? -7 : 10;
            if(i % 2 == 1) adjusty =(setName == 'a') ? adjusty - 7 : adjusty + 7;

            if(bContactMap) {
                nodeName = nodeName.substr(1);
                if(!bVertical) adjusty += 4 * r;
            }

            // show reference numbers
            if(ic.bShownRefnum && ic.resid2refnum[resid]) {
                let refnumLabel = ic.resid2refnum[resid];
                let refnumStr = ic.refnumCls.rmStrandFromRefnumlabel(refnumLabel);

                let resn = ic.residueId2Name[resid];
                nodeName = resn + refnumStr;
            }

            let strokecolor = '#000';
            let strokewidth = '1';
            let textcolor = '#000';
            let fontsize = '6px'; // '6';
            //let html = (bAfMap) ? "<g>" : "<g class='icn3d-node' resid='" + resid + "' >";
            let html = "<g class='icn3d-node' resid='" + resid + "' >";
            let title = node.id;
            if(ic.resid2refnum[resid]) {
                title += '=>' + ic.resid2refnum[resid];
            }
            html += "<title>" + title + "</title>";
            if(bVertical) {
                html += "<circle cx='" + y + "' cy='" + x + "' r='" + r + "' fill='" + color + "' stroke-width='" + strokewidth + "' stroke='" + strokecolor + "' resid='" + resid + "' />";
                html += "<text x='" +(y - 20).toString() + "' y='" +(x + 2).toString() + "' fill='" + textcolor + "' stroke='none' style='font-size:" + fontsize + "; text-anchor:middle' >" + nodeName + "</text>";
            }
            else {
                html += "<circle cx='" + x + "' cy='" + y + "' r='" + r + "' fill='" + color + "' stroke-width='" + strokewidth + "' stroke='" + strokecolor + "' resid='" + resid + "' />";
                html += "<text x='" +(x + adjustx).toString() + "' y='" +(y + adjusty).toString() + "' fill='" + textcolor + "' stroke='none' style='font-size:" + fontsize + "; text-anchor:middle' >" + nodeName + "</text>";
            }
            html += "</g>";
            return html;
        }
        getNodeTopBottom(nameHash, name2node, bReverseNode, bCommonDiff, nameHashCommon) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;
            let nodeArray1 = [], nodeArray2 = [], name2nodeCommon = {};

            let separatorCommon = "=>", separatorDiff = "==>", postCommon = "-", postDiff = "--";
            for(let name in nameHash) {
                let node = name2node[name];
                if(!node) continue;

                if(bCommonDiff == 1 || bCommonDiff == 2) {
                    node = me.hashUtilsCls.cloneHash(node);

                    if(bCommonDiff == 1) {
                        let mapping = (nameHashCommon[name]) ? nameHashCommon[name] : postCommon;
                        node.id += separatorCommon + mapping;
                    }
                    else {
                        let mapping = (nameHashCommon[name]) ? nameHashCommon[name] : postDiff;
                        node.id += separatorDiff + mapping;
                    }

                    name2nodeCommon[node.id] = node;
                }

                if(node.s == 'a') {
                    nodeArray1.push(node);
                }
                else if(node.s == 'b') {
                    nodeArray2.push(node);
                }
                else if(node.s == 'ab') {
                    nodeArray1.push(node);
                    nodeArray2.push(node);
                }
            }

            // sort array
            nodeArray1.sort(function(a,b) {
              return thisClass.compNode(a, b);
            });
            nodeArray2.sort(function(a,b) {
              return thisClass.compNode(a, b, bReverseNode);
            });

            return {"nodeArray1": nodeArray1, "nodeArray2": nodeArray2, "name2node": name2nodeCommon};
        }
        updateGraphJson(struc, index, nodeArray1, nodeArray2, linkArray) { let ic = this.icn3d, me = ic.icn3dui;
            let lineGraphStr = '';
            lineGraphStr += '"structure' + index + '": {"id": "' + struc + '", "nodes1":[';
            lineGraphStr += me.utilsCls.getJSONFromArray(nodeArray1);
            lineGraphStr += '], \n"nodes2":[';
            lineGraphStr += me.utilsCls.getJSONFromArray(nodeArray2);
            lineGraphStr += '], \n"links":[';
            lineGraphStr += me.utilsCls.getJSONFromArray(linkArray);
            lineGraphStr += ']}';
            return lineGraphStr;
        }

        updateGraphColor() { let ic = this.icn3d; ic.icn3dui;
          // change graph color

          // do not update the graph for now
          /*
          if(ic.graphStr !== undefined) {
              let graphJson = JSON.parse(ic.graphStr);
              let resid2color = {}
              for(let resid in ic.residues) {
                  let atom = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid]);
                  resid2color[resid] = atom.color.getHexString().toUpperCase();
              }

              let target2resid = {}
              for(let i = 0, il = graphJson.nodes.length; i < il; ++i) {
                  let node = graphJson.nodes[i];
                  //node.r: 1_1_1KQ2_A_1
                  //var idArray = node.r.split('_');
                  let idArray = [];
                  idArray.push('');
                  idArray.push('');

                  let tmpStr = node.r.substr(4);
                  idArray = idArray.concat(me.utilsCls.getIdArray(tmpStr));

                  let resid = idArray[2] + '_' + idArray[3] + '_' + idArray[4];
                  node.c = resid2color[resid];
                  target2resid[node.id] = resid;
              }
              for(let i = 0, il = graphJson.links.length; i < il; ++i) {
                  let link = graphJson.links[i];
                  if(link.v == me.htmlCls.ssValue || link.v == me.htmlCls.coilValue) {
                      let resid = target2resid[link.target];
                      link.c = resid2color[resid];
                  }
              }
              ic.graphStr = JSON.stringify(graphJson);
          }

          if(ic.bGraph) ic.drawGraphCls.drawGraph(ic.graphStr, ic.pre + 'dl_graph');
          if(ic.bLinegraph) ic.lineGraphCls.drawLineGraph(ic.graphStr);
          if(ic.bScatterplot) ic.lineGraphCls.drawLineGraph(ic.graphStr, true);
          */
        }

        handleForce() { let ic = this.icn3d, me = ic.icn3dui;
           if(me.htmlCls.force == 0 && ic.simulation !== undefined) {
               ic.simulation.stop();
               ic.simulation.force("charge", null);
               ic.simulation.force("x", null);
               ic.simulation.force("y", null);
               ic.simulation.force("r", null);
               ic.simulation.force("link", null);
           }
           else {
               ic.drawGraphCls.drawGraph(ic.graphStr, ic.pre + 'dl_graph');
           }
        }

        getNodesLinksForSet(atomSet, labelType, setName, bAnyAtom) { let ic = this.icn3d, me = ic.icn3dui;
           //var nodeStr = '', linkStr = '';
           let nodeArray = [], linkArray = [];
           let cnt = 0;
           let thickness = me.htmlCls.coilValue;
           let prevChain = '', prevResName = '', prevResi = 0;
           // add chemicals as well
           let residHash = {};
           for(let i in atomSet) {
               let atom = ic.atoms[i];

               if(atom.chain != 'DUM' && (bAnyAtom || atom.het || (atom.name == "CA" && atom.elem == "C") || atom.name == "O3'" || atom.name == "O3*" || atom.name == "P")) {
               // starting nucleotide have "P"
               //if(atom.chain != 'DUM' &&(atom.name == "CA" || atom.name == "P")) {
                   let resid = atom.structure + '_' + atom.chain + '_' + atom.resi;
                   if(residHash.hasOwnProperty(resid)) {
                       continue;
                   }
                   else {
                       residHash[resid] = 1;
                   }
                   let resName = me.utilsCls.residueName2Abbr(atom.resn) + atom.resi;
                   if(labelType == 'chain' || labelType == 'structure') resName += '.' + atom.chain;
                   if(labelType == 'structure') resName += '.' + atom.structure;
                   // add 1_1_ to match other conventionssuch as seq_div0_1KQ2_A_50
                   let residLabel = '1_1_' + resid;
                   //if(cnt > 0) nodeStr += ', ';
                   let colorStr = (atom.color) ? atom.color.getHexString().toUpperCase() : '000';
                   
                   nodeArray.push('{"id": "' + resName + '", "r": "' + residLabel + '", "s": "' + setName + '", "x": ' + atom.coord.x.toFixed(0)
                       + ', "y": ' + atom.coord.y.toFixed(0) + ', "c": "' + colorStr + '"}');
                   if(cnt > 0 && prevChain == atom.chain &&(ic.resid2ncbi[atom.resi] == ic.resid2ncbi[prevResi] + 1 || ic.resid2ncbi[atom.resi] == ic.resid2ncbi[prevResi]) ) {
                       //if(linkCnt > 0) linkStr += ', ';
                       linkArray.push('{"source": "' + prevResName + '", "target": "' + resName
                           + '", "v": ' + thickness + ', "c": "' + colorStr + '"}');
                       if(atom.ssbegin) thickness = me.htmlCls.ssValue;
                       if(atom.ssend) thickness = me.htmlCls.coilValue;
                   }
                   prevChain = atom.chain;
                   prevResName = resName;
                   prevResi = atom.resi;
                   ++cnt;
               }
           }

           return {"node": nodeArray, "link":linkArray}
        }
        getHbondLinksForSet(atoms, labelType) { let ic = this.icn3d, me = ic.icn3dui;
            let resid2ResidhashHbond = {};
            let threshold = parseFloat($("#" + ic.pre + "hbondthreshold" ).val());
            // not only protein or nucleotides, could be ligands
            let firstSetAtoms = atoms;
            let complement = firstSetAtoms;
            if(Object.keys(complement).length > 0 && Object.keys(firstSetAtoms).length > 0) {
                let bSaltbridge = false;
                // let selectedAtoms = ic.hBondCls.calculateChemicalHbonds(me.hashUtilsCls.intHash2Atoms(ic.dAtoms, complement, ic.atoms), me.hashUtilsCls.intHash2Atoms(ic.dAtoms, firstSetAtoms, ic.atoms), parseFloat(threshold), bSaltbridge, 'graph', true );
                ic.hBondCls.calculateChemicalHbonds(me.hashUtilsCls.hash2Atoms(complement, ic.atoms), me.hashUtilsCls.hash2Atoms(firstSetAtoms, ic.atoms), parseFloat(threshold), bSaltbridge, 'graph', true );
                resid2ResidhashHbond = me.hashUtilsCls.cloneHash(ic.resid2Residhash);
            }

            //let hbondStr = this.getGraphLinks(resid2ResidhashHbond, resid2ResidhashHbond, me.htmlCls.hbondInsideColor, labelType, me.htmlCls.hbondValuehbondInsideValue);
            let hbondStr = this.getGraphLinks(resid2ResidhashHbond, resid2ResidhashHbond, me.htmlCls.hbondInsideColor, labelType, me.htmlCls.hbondInsideValue);

            return hbondStr;
        }
        getIonicLinksForSet(atoms, labelType) { let ic = this.icn3d, me = ic.icn3dui;
            let resid2Residhash = {};
            let threshold = parseFloat($("#" + ic.pre + "saltbridgethreshold" ).val());
            // not only protein or nucleotides, could be ligands
            let firstSetAtoms = atoms;
            let complement = firstSetAtoms;
            if(Object.keys(complement).length > 0 && Object.keys(firstSetAtoms).length > 0) {
                let bSaltbridge = false;
                // let selectedAtoms = ic.saltbridgeCls.calculateIonicInteractions(me.hashUtilsCls.intHash2Atoms(ic.dAtoms, complement, ic.atoms), me.hashUtilsCls.intHash2Atoms(ic.dAtoms, firstSetAtoms, ic.atoms), parseFloat(threshold), bSaltbridge, 'graph', true );
                ic.saltbridgeCls.calculateIonicInteractions(me.hashUtilsCls.hash2Atoms(complement, ic.atoms), me.hashUtilsCls.hash2Atoms(firstSetAtoms, ic.atoms), parseFloat(threshold), bSaltbridge, 'graph', true );
                resid2Residhash = me.hashUtilsCls.cloneHash(ic.resid2Residhash);
            }
            let ionicStr = this.getGraphLinks(resid2Residhash, resid2Residhash, me.htmlCls.ionicInsideColor, labelType, me.htmlCls.ionicInsideValue);
            return ionicStr;
        }
        getHalogenPiLinksForSet(atoms, labelType) { let ic = this.icn3d, me = ic.icn3dui;
            let resid2Residhash = {};
            let firstSetAtoms = atoms;
            let complement = firstSetAtoms;
            let halogenpiStr = '', threshold;
            threshold = parseFloat($("#" + ic.pre + "halogenthreshold" ).val());
            if(Object.keys(complement).length > 0 && Object.keys(firstSetAtoms).length > 0) {
                // let selectedAtoms = ic.piHalogenCls.calculateHalogenPiInteractions(me.hashUtilsCls.intHash2Atoms(ic.dAtoms, firstSetAtoms, ic.atoms), me.hashUtilsCls.intHash2Atoms(ic.dAtoms, complement, ic.atoms), parseFloat(threshold), 'graph', 'halogen', true );
                ic.piHalogenCls.calculateHalogenPiInteractions(me.hashUtilsCls.hash2Atoms(firstSetAtoms, ic.atoms), me.hashUtilsCls.hash2Atoms(complement, ic.atoms), parseFloat(threshold), 'graph', 'halogen', true );
                resid2Residhash = me.hashUtilsCls.cloneHash(ic.resid2Residhash);
            }
            halogenpiStr += this.getGraphLinks(resid2Residhash, resid2Residhash, me.htmlCls.halogenInsideColor, labelType, me.htmlCls.halogenInsideValue);
            threshold = parseFloat($("#" + ic.pre + "picationthreshold" ).val());
            if(Object.keys(complement).length > 0 && Object.keys(firstSetAtoms).length > 0) {
                // let selectedAtoms = ic.piHalogenCls.calculateHalogenPiInteractions(me.hashUtilsCls.intHash2Atoms(ic.dAtoms, firstSetAtoms, ic.atoms), me.hashUtilsCls.intHash2Atoms(ic.dAtoms, complement, ic.atoms), parseFloat(threshold), 'graph', 'pi-cation', true );
                ic.piHalogenCls.calculateHalogenPiInteractions(me.hashUtilsCls.hash2Atoms(firstSetAtoms, ic.atoms), me.hashUtilsCls.hash2Atoms(complement, ic.atoms), parseFloat(threshold), 'graph', 'pi-cation', true );
                resid2Residhash = me.hashUtilsCls.cloneHash(ic.resid2Residhash);
            }
            halogenpiStr += this.getGraphLinks(resid2Residhash, resid2Residhash, me.htmlCls.picationInsideColor, labelType, me.htmlCls.picationInsideValue);
            threshold = parseFloat($("#" + ic.pre + "pistackingthreshold" ).val());
            if(Object.keys(complement).length > 0 && Object.keys(firstSetAtoms).length > 0) {
                // let selectedAtoms = ic.piHalogenCls.calculateHalogenPiInteractions(me.hashUtilsCls.intHash2Atoms(ic.dAtoms, firstSetAtoms, ic.atoms), me.hashUtilsCls.intHash2Atoms(ic.dAtoms, complement, ic.atoms), parseFloat(threshold), 'graph', 'pi-stacking', true );
                ic.piHalogenCls.calculateHalogenPiInteractions(me.hashUtilsCls.hash2Atoms(firstSetAtoms, ic.atoms), me.hashUtilsCls.hash2Atoms(complement, ic.atoms), parseFloat(threshold), 'graph', 'pi-stacking', true );
                resid2Residhash = me.hashUtilsCls.cloneHash(ic.resid2Residhash);
            }
            halogenpiStr += this.getGraphLinks(resid2Residhash, resid2Residhash, me.htmlCls.pistackingInsideColor, labelType, me.htmlCls.pistackingInsideValue);
            return halogenpiStr;
        }
        getContactLinksForSet(atoms, labelType, bCartoon2d) { let ic = this.icn3d; ic.icn3dui;
            let ssAtomsArray = [];
            let prevSS = '', prevChain = '';
            let ssAtoms = {};
            for(let i in atoms) {
                let atom = ic.atoms[i];
                if(atom.ss != prevSS || atom.chain != prevChain) {
                    if(Object.keys(ssAtoms).length > 0) ssAtomsArray.push(ssAtoms);
                    ssAtoms = {};
                }
                ssAtoms[atom.serial] = 1;
                prevSS = atom.ss;
                prevChain = atom.chain;
            }
            // last ss
            if(Object.keys(ssAtoms).length > 0) ssAtomsArray.push(ssAtoms);
            let len = ssAtomsArray.length;
            let interStr = '';
            for(let i = 0; i < len; ++i) {
                for(let j = i + 1; j < len; ++j) {
                    interStr += this.getContactLinks(ssAtomsArray[i], ssAtomsArray[j], labelType, true, bCartoon2d);
                }
            }

            return interStr;
        }
        getContactLinks(atomlistTarget, otherAtoms, labelType, bInternal, bCartoon2d) { let ic = this.icn3d, me = ic.icn3dui;
            let radius = parseFloat($("#" + ic.pre + "contactthreshold" ).val());
            let bGetPairs = true, bInteraction = false;
            ic.contactCls.getAtomsWithinAtom(otherAtoms, atomlistTarget, parseFloat(radius), bGetPairs, bInteraction, bInternal);
            let residHash = me.hashUtilsCls.cloneHash(ic.resid2Residhash);
            let interStr = this.getGraphLinks(residHash, residHash, me.htmlCls.contactInsideColor, labelType, me.htmlCls.contactInsideValue, bCartoon2d);
            return interStr;
        }
        compNode(a, b, bReverseChain) { let ic = this.icn3d, me = ic.icn3dui;
          let resid1 = a.r.substr(4); // 1_1_1KQ2_A_1
          let resid2 = b.r.substr(4); // 1_1_1KQ2_A_1
          let aIdArray = me.utilsCls.getIdArray(resid1); //resid1.split('_');
          let bIdArray = me.utilsCls.getIdArray(resid2); //resid2.split('_');
          let aChainid = aIdArray[0] + '_' + aIdArray[1];
          let bChainid = bIdArray[0] + '_' + bIdArray[1];
          let aResi = parseInt(aIdArray[2]);
          let bResi = parseInt(bIdArray[2]);
          if(aChainid > bChainid){
              if(bReverseChain) return -1;
              else return 1;
          }
          else if(aChainid < bChainid){
              if(bReverseChain) return 1;
              else return -1;
          }
          else if(aChainid == bChainid){
            return (aResi > bResi) ? 1 :(aResi < bResi) ? -1 : 0;
          }
        }

        getGraphLinks(hash1, hash2, color, labelType, value, bCartoon2d) {var ic = this.icn3d, me = ic.icn3dui;
            let hbondStr = '';
            value =(value === undefined) ? 1 : value;
            //let prevLinkStr = '';
            //let sourceTargetHash = {};

            let linkstr2cnt = {};
            for(let resid1 in hash1) {
                //ASN $1KQ2.A:6@ND2
                //or ASN $1KQ2.A:6
                // or ASN $1KQ2.A:6@ND2 2006
                let resid1Ori = resid1.trim();

                let idArray1 = resid1Ori.split(' ');
                if(idArray1.length == 3) {
                    resid1 = idArray1[0] + ' ' + idArray1[1];
                }
                
                let pos1a = resid1.indexOf(' ');
                let pos1b = resid1.indexOf(':');
                let posTmp1 = resid1.indexOf('@');
                let pos1c =(posTmp1 !== -1) ? posTmp1 : resid1.length;
                let pos1d = resid1.indexOf('.');
                let pos1e = resid1.indexOf('$');
                let resName1 = me.utilsCls.residueName2Abbr(resid1.substr(0, pos1a)) + resid1.substr(pos1b + 1, pos1c - pos1b - 1);
                if(labelType == 'chain' || labelType == 'structure') resName1 += '.' + resid1.substr(pos1d + 1, pos1b - pos1d - 1);
                if(labelType == 'structure') resName1 += '.' + resid1.substr(pos1e + 1, pos1d - pos1e - 1);
                for(let resid2 in hash2[resid1Ori]) {
                    let resid2Ori = resid2.trim();

                    let idArray2 = resid2Ori.split(' ');
                    if(idArray2.length == 3) {
                        resid2 = idArray2[0] + ' ' + idArray2[1];
                    }

                    let pos2a = resid2.indexOf(' ');
                    let pos2b = resid2.indexOf(':');
                    let posTmp2 = resid2.indexOf('@');
                    let pos2c =(posTmp2 !== -1) ? posTmp2 : resid2.length;
                    let pos2d = resid2.indexOf('.');
                    let pos2e = resid2.indexOf('$');
                    let resName2 = me.utilsCls.residueName2Abbr(resid2.substr(0, pos2a)) + resid2.substr(pos2b + 1, pos2c - pos2b - 1); //
                        + '_' + resid2.substr(pos2d + 1, pos2b - pos2d - 1);
                    if(labelType == 'chain' || labelType == 'structure') resName2 += '.' + resid2.substr(pos2d + 1, pos2b - pos2d - 1);
                    if(labelType == 'structure') resName2 += '.' + resid2.substr(pos2e + 1, pos2d - pos2e - 1);

                    if(bCartoon2d) {
                        resName1 = ic.resi2resirange[resName1];
                        resName2 = ic.resi2resirange[resName2];
                    }

                    if(resName1 !== undefined && resName2 !== undefined ) {
                        let linkStr = '"source": "' + resName1 + '", "target": "' + resName2 + '", "v": ' + value + ', "c": "' + color + '"';

                        //prevLinkStr = linkStr;

                        if(!linkstr2cnt.hasOwnProperty(linkStr)) {
                            linkstr2cnt[linkStr] = 1;
                        }
                        else {
                            ++linkstr2cnt[linkStr];
                        }
                    }
                }
            }

            for(let linkStr in linkstr2cnt) {
                // do not differentiate the number of contacts
                let n = (value == me.htmlCls.contactInsideValue || value == me.htmlCls.contactValue) ? 1 : linkstr2cnt[linkStr];
                hbondStr += ', {' + linkStr + ', "n": ' + n + '}';
            }

            return hbondStr;
        }
        convertLabel2Resid(residLabel) {var ic = this.icn3d; ic.icn3dui;
            //ASN $1KQ2.A:6@ND2
            //or ASN $1KQ2.A:6
            // or ASN $1KQ2.A:6@ND2 1234
            let idArray = residLabel.split(' ');
            residLabel = (idArray.length == 2) ? residLabel : residLabel.substr(0, residLabel.lastIndexOf(' '));
            
            residLabel.indexOf(' ');
            let pos2Tmp = residLabel.indexOf('@');
            let pos2 =(pos2Tmp !== -1) ? pos2Tmp : residLabel.length;
            let pos3 = residLabel.indexOf('$');
            let pos4 = residLabel.indexOf('.');
            let pos5 = residLabel.indexOf(':');
            let resid = residLabel.substr(pos3 + 1, pos4 - pos3 - 1) + '_' + residLabel.substr(pos4 + 1, pos5 - pos4 - 1)
                + '_' + residLabel.substr(pos5 + 1, pos2 - pos5 - 1);
            return resid;
        }

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class ShowInter {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        async showInteractions(type) { let ic = this.icn3d, me = ic.icn3dui;
           let nameArray = $("#" + ic.pre + "atomsCustomHbond").val();
           let nameArray2 = $("#" + ic.pre + "atomsCustomHbond2").val();

           let atoms, atoms2;
           atoms = ic.definedSetsCls.getAtomsFromNameArray(nameArray);
           atoms2 = ic.definedSetsCls.getAtomsFromNameArray(nameArray2);

           // add the interacting atoms to display
           ic.dAtoms = me.hashUtilsCls.unionHash(ic.dAtoms, atoms);
           ic.dAtoms = me.hashUtilsCls.unionHash(ic.dAtoms, atoms2);

           if(type == 'ligplot') {
                let residueHash1 = ic.firstAtomObjCls.getResiduesFromAtoms(atoms);
                let residueHash2 = ic.firstAtomObjCls.getResiduesFromAtoms(atoms2);

                if(Object.keys(residueHash1).length > 1 && Object.keys(residueHash2).length > 1) {
                    alert("Please select one ligand or residue as one of the interaction sets...");
                    return;
                }

                // switch the sets to make the first set as the ligand
                if(Object.keys(residueHash1).length < Object.keys(residueHash2).length) {
                    nameArray2 = $("#" + ic.pre + "atomsCustomHbond").val();
                    nameArray = $("#" + ic.pre + "atomsCustomHbond2").val();
             
                    atoms = ic.definedSetsCls.getAtomsFromNameArray(nameArray);
                    atoms2 = ic.definedSetsCls.getAtomsFromNameArray(nameArray2);
                }
           }

           if(nameArray2.length == 0) {
               alert("Please select the first set");
           }
           else {
               ic.definedSetsCls.setMode('selection');
               let bHbond = $("#" + ic.pre + "analysis_hbond")[0].checked;
               let bSaltbridge = $("#" + ic.pre + "analysis_saltbridge")[0].checked;
               let bInteraction = $("#" + ic.pre + "analysis_contact")[0].checked;
               let bHalogen = $("#" + ic.pre + "analysis_halogen")[0].checked;
               let bPication = $("#" + ic.pre + "analysis_pication")[0].checked;
               let bPistacking = $("#" + ic.pre + "analysis_pistacking")[0].checked;
               let thresholdHbond = $("#" + ic.pre + "hbondthreshold").val();
               let thresholdSaltbridge = $("#" + ic.pre + "saltbridgethreshold").val();
               let thresholdContact = $("#" + ic.pre + "contactthreshold").val();
               let thresholdHalogen = $("#" + ic.pre + "halogenthreshold").val();
               let thresholdPication = $("#" + ic.pre + "picationthreshold").val();
               let thresholdPistacking = $("#" + ic.pre + "pistackingthreshold").val();
               let thresholdStr = 'threshold ' + thresholdHbond + ' ' + thresholdSaltbridge + ' ' + thresholdContact
                + ' ' + thresholdHalogen + ' ' + thresholdPication + ' ' + thresholdPistacking;
               let result = await ic.viewInterPairsCls.viewInteractionPairs(nameArray2, nameArray, ic.bHbondCalc, type,
                    bHbond, bSaltbridge, bInteraction, bHalogen, bPication, bPistacking);
               let interactionTypes = result.interactionTypes;

               let bHbondCalcStr =(ic.bHbondCalc) ? "true" : "false";
               let tmpStr = nameArray2 + " " + nameArray + " | " + interactionTypes + " | " + bHbondCalcStr + " | " + thresholdStr;
               if(type == '3d') {
                   me.htmlCls.clickMenuCls.setLogCmd("display interaction 3d | " + tmpStr, true);
               }
               else if(type == 'view') {
                   me.htmlCls.clickMenuCls.setLogCmd("view interaction pairs | " + tmpStr, true);
               }
               else if(type == 'save1') {
                   me.htmlCls.clickMenuCls.setLogCmd("save1 interaction pairs | " + tmpStr, true);
               }
               else if(type == 'save2') {
                   me.htmlCls.clickMenuCls.setLogCmd("save2 interaction pairs | " + tmpStr, true);
               }
               else if(type == 'linegraph') {
                   me.htmlCls.clickMenuCls.setLogCmd("line graph interaction pairs | " + tmpStr, true);
               }
               else if(type == 'scatterplot') {
                   me.htmlCls.clickMenuCls.setLogCmd("scatterplot interaction pairs | " + tmpStr, true);
               }
               else if(type == 'ligplot') {
                me.htmlCls.clickMenuCls.setLogCmd("ligplot interaction pairs | " + tmpStr, true);
               }
               else if(type == 'graph') { // force-directed graph
                    let dist_ss = parseInt($("#" + ic.pre + "dist_ss").val());
                    let dist_coil = parseInt($("#" + ic.pre + "dist_coil").val());
                    let dist_hbond = parseInt($("#" + ic.pre + "dist_hbond").val());
                    let dist_inter = parseInt($("#" + ic.pre + "dist_inter").val());
                    let dist_ssbond = parseInt($("#" + ic.pre + "dist_ssbond").val());
                    let dist_ionic = parseInt($("#" + ic.pre + "dist_ionic").val());
                    let dist_halogen = parseInt($("#" + ic.pre + "dist_halogen").val());
                    let dist_pication = parseInt($("#" + ic.pre + "dist_pication").val());
                    let dist_pistacking = parseInt($("#" + ic.pre + "dist_pistacking").val());
                    me.htmlCls.clickMenuCls.setLogCmd("graph interaction pairs | " + nameArray2 + " " + nameArray + " | " + interactionTypes
                        + " | " + bHbondCalcStr + " | " + thresholdStr + " | " + dist_ss + " " + dist_coil
                        + " " + dist_hbond + " " + dist_inter + " " + dist_ssbond + " " + dist_ionic
                        + " " + dist_halogen + " " + dist_pication + " " + dist_pistacking, true);
               }
               // avoid repeated calculation
               ic.bHbondCalc = true;
           }
        }

        // between the highlighted and atoms in nameArray
        //Show the hydrogen bonds between chemicals and proteins/nucleotides with dashed-lines.
        //"threshold" defines the distance of hydrogen bonds.
        showHbonds(threshold, nameArray2, nameArray, bHbondCalc, bSaltbridge, type) { let ic = this.icn3d, me = ic.icn3dui;
            if(bHbondCalc) return;
            let hbonds_saltbridge, select;
            if(bSaltbridge) {
                hbonds_saltbridge = 'saltbridge';
                select = 'salt bridge ' + threshold + ' | sets ' + nameArray2 + " " + nameArray + " | " + bHbondCalc;
            }
            else {
                hbonds_saltbridge = 'hbonds';
                select = 'hbonds ' + threshold + ' | sets ' + nameArray2 + " " + nameArray + " | " + bHbondCalc;
            }
            ic.opts[hbonds_saltbridge] = "yes";
            ic.opts["water"] = "dot";
            let firstSetAtoms, complement;
            firstSetAtoms = ic.definedSetsCls.getAtomsFromNameArray(nameArray2);
            complement = ic.definedSetsCls.getAtomsFromNameArray(nameArray);
            // let firstAtom = ic.firstAtomObjCls.getFirstAtomObj(firstSetAtoms);

            if(Object.keys(complement).length > 0 && Object.keys(firstSetAtoms).length > 0) {
                // let selectedAtoms = ic.hBondCls.calculateChemicalHbonds(me.hashUtilsCls.intHash2Atoms(ic.dAtoms, complement, ic.atoms), me.hashUtilsCls.intHash2Atoms(ic.dAtoms, firstSetAtoms, ic.atoms), parseFloat(threshold), bSaltbridge );
                let selectedAtoms = ic.hBondCls.calculateChemicalHbonds(me.hashUtilsCls.hash2Atoms(complement, ic.atoms), me.hashUtilsCls.hash2Atoms(firstSetAtoms, ic.atoms), parseFloat(threshold), bSaltbridge );

                let commanddesc;
                if(bSaltbridge) {
                    ic.resid2ResidhashSaltbridge = me.hashUtilsCls.cloneHash(ic.resid2Residhash);
                    commanddesc = 'all atoms that have salt bridges with the selected atoms';
                }
                else {
                    ic.resid2ResidhashHbond = me.hashUtilsCls.cloneHash(ic.resid2Residhash);
                    commanddesc = 'all atoms that are hydrogen-bonded with the selected atoms';
                }
                let residues = {};
                for(let i in selectedAtoms) {
                    let residueid = ic.atoms[i].structure + '_' + ic.atoms[i].chain + '_' + ic.atoms[i].resi;
                    residues[residueid] = 1;
                }
                ic.hAtoms = {};
                for(let resid in residues) {
                    for(let i in ic.residues[resid]) {
                        ic.hAtoms[i] = 1;
                        ic.atoms[i].style2 = 'stick';
                        //ic.atoms[i].style2 = 'lines';
                    }
                }

                //let commandname = hbonds_saltbridge + '_' + firstAtom.serial;
                let commandname = hbonds_saltbridge + '_auto';
                ic.selectionCls.addCustomSelection(Object.keys(residues), commandname, commanddesc, select, true);
                ic.selectionCls.saveSelectionIfSelected();
                ic.drawCls.draw();
            }
        }

        showHydrogens() { let ic = this.icn3d, me = ic.icn3dui;
            // get hydrogen atoms for currently selected atoms
            if(me.cfg.cid !== undefined) {
                for(let i in ic.hAtoms) {
                        let atom = ic.atoms[i];
                
                        //if(atom.name !== 'H') {
                        if(atom.elem.substr(0, 1) !== 'H') {
                            ic.atoms[atom.serial].bonds = ic.atoms[atom.serial].bonds2.concat();
                            ic.atoms[atom.serial].bondOrder = ic.atoms[atom.serial].bondOrder2.concat();
                            for(let j = 0, jl = ic.atoms[atom.serial].bonds.length; j < jl; ++j) {
                                let serial = ic.atoms[atom.serial].bonds[j];
                                //if(ic.atoms[serial].name === 'H') {
                                if(ic.atoms[serial].elem.substr(0, 1) === 'H') {
                                    ic.dAtoms[serial] = 1;
                                    ic.hAtoms[serial] = 1;
                                }
                            }
                        }
                }
            }
            else {
                // for(let serial in ic.atoms) {
                //     ic.dAtoms[serial] = 1;
                //     ic.hAtoms[serial] = 1;
                // }  

                // add bonds in heavy atoms
                //for(let serial in ic.hAtoms) {
                for(let serial in ic.atoms) {
                    let atom = ic.atoms[serial];
                    //if(atom.name === 'H') {
                    if(atom.elem.substr(0, 1) === 'H') {                   
                        if(ic.atoms[serial].bonds.length > 0) {
                            let otherSerial = ic.atoms[serial].bonds[0];
                            ic.atoms[otherSerial].bonds.push(atom.serial);
                            if(ic.atoms[otherSerial].bondOrder) ic.atoms[otherSerial].bondOrder.push(1);
                        }        
                        
                        ic.dAtoms[serial] = 1;
                    }
                }
            }

            //!!!ic.bShowHighlight = false;
        }

        hideHydrogens() { let ic = this.icn3d; ic.icn3dui;
           // remove hydrogen atoms for currently selected atoms
           for(let i in ic.hAtoms) {
               let atom = ic.atoms[i];
               //if(atom.name === 'H') {
               if(atom.elem.substr(0, 1) === 'H') {
                   if(ic.atoms[atom.serial].bonds.length > 0) {
                       let otherSerial = ic.atoms[atom.serial].bonds[0];
                       //ic.atoms[atom.serial].bonds = [];
                       let pos = (ic.atoms[otherSerial].bonds) ? ic.atoms[otherSerial].bonds.indexOf(atom.serial) : -1;
                       if(pos !== -1) {
                           ic.atoms[otherSerial].bonds.splice(pos, 1);
                           if(ic.atoms[otherSerial].bondOrder) ic.atoms[otherSerial].bondOrder.splice(pos, 1);
                       }
                   }
                   delete ic.dAtoms[atom.serial];
                   delete ic.hAtoms[atom.serial];            
               }
           }
        }

        hideExtraBonds() { let ic = this.icn3d; ic.icn3dui;
            for(let i in ic.atoms) {
                ic.atoms[i].style2 = 'nothing';
            }

            for(let i in ic.sidec) {
                if(ic.hAtoms.hasOwnProperty(i)) {
                    ic.atoms[i].style2 = ic.opts["sidec"];
                }
            }

            for(let i in ic.water) {
                if(ic.hAtoms.hasOwnProperty(i)) {
                    ic.atoms[i].style = ic.opts["water"];
                }
            }
        }

        hideHbondsContacts() { let ic = this.icn3d, me = ic.icn3dui;
               let select = "set hbonds off";
               me.htmlCls.clickMenuCls.setLogCmd(select, true);
               ic.hBondCls.hideHbonds();
               //ic.drawCls.draw();
               select = "set salt bridge off";
               me.htmlCls.clickMenuCls.setLogCmd(select, true);
               ic.saltbridgeCls.hideSaltbridge();
               select = "set contact off";
               me.htmlCls.clickMenuCls.setLogCmd(select, true);
               ic.contactCls.hideContact();
               select = "set halogen pi off";
               me.htmlCls.clickMenuCls.setLogCmd(select, true);
               ic.piHalogenCls.hideHalogenPi();

               this.hideExtraBonds();
        }

        showIonicInteractions(threshold, nameArray2, nameArray, bHbondCalc, bSaltbridge, type) { let ic = this.icn3d, me = ic.icn3dui;
            if(bHbondCalc) return;
            let hbonds_saltbridge, select;
            hbonds_saltbridge = 'saltbridge';
            select = 'salt bridge ' + threshold + ' | sets ' + nameArray2 + " " + nameArray + " | " + bHbondCalc;
            ic.opts[hbonds_saltbridge] = "yes";
            let firstSetAtoms, complement;
            firstSetAtoms = ic.definedSetsCls.getAtomsFromNameArray(nameArray2);
            complement = ic.definedSetsCls.getAtomsFromNameArray(nameArray);
            ic.firstAtomObjCls.getFirstAtomObj(firstSetAtoms);
            if(Object.keys(complement).length > 0 && Object.keys(firstSetAtoms).length > 0) {
                // let selectedAtoms = ic.saltbridgeCls.calculateIonicInteractions(me.hashUtilsCls.intHash2Atoms(ic.dAtoms, complement, ic.atoms), me.hashUtilsCls.intHash2Atoms(ic.dAtoms, firstSetAtoms, ic.atoms), parseFloat(threshold), bSaltbridge );
                let selectedAtoms = ic.saltbridgeCls.calculateIonicInteractions(me.hashUtilsCls.hash2Atoms(complement, ic.atoms), me.hashUtilsCls.hash2Atoms(firstSetAtoms, ic.atoms), parseFloat(threshold), bSaltbridge );
                let commanddesc;
                ic.resid2ResidhashSaltbridge = me.hashUtilsCls.cloneHash(ic.resid2Residhash);
                commanddesc = 'all atoms that have ionic interactions with the selected atoms';
                let residues = {};
                for(let i in selectedAtoms) {
                    let residueid = ic.atoms[i].structure + '_' + ic.atoms[i].chain + '_' + ic.atoms[i].resi;
                    residues[residueid] = 1;
                }
                ic.hAtoms = {};
                for(let resid in residues) {
                    for(let i in ic.residues[resid]) {
                        ic.hAtoms[i] = 1;
                        ic.atoms[i].style2 = 'stick';
                        if(ic.ions.hasOwnProperty(i)) ic.atoms[i].style2 = 'sphere';
                        //ic.atoms[i].style2 = 'lines';
                    }
                }
                //let commandname = hbonds_saltbridge + '_' + firstAtom.serial;
                let commandname = hbonds_saltbridge + '_auto';
                ic.selectionCls.addCustomSelection(Object.keys(residues), commandname, commanddesc, select, true);
                ic.selectionCls.saveSelectionIfSelected();
                ic.drawCls.draw();
            }
        }

        showHalogenPi(threshold, nameArray2, nameArray, bHbondCalc, type, interactionType) { let ic = this.icn3d, me = ic.icn3dui;
            if(bHbondCalc) return;
            let select = interactionType + ' ' + threshold + ' | sets ' + nameArray2 + " " + nameArray + " | " + bHbondCalc;
            ic.opts[interactionType] = "yes";
            let firstSetAtoms, complement;
            firstSetAtoms = ic.definedSetsCls.getAtomsFromNameArray(nameArray2);
            complement = ic.definedSetsCls.getAtomsFromNameArray(nameArray);
            ic.firstAtomObjCls.getFirstAtomObj(firstSetAtoms);
            if(Object.keys(complement).length > 0 && Object.keys(firstSetAtoms).length > 0) {
                // let selectedAtoms = ic.piHalogenCls.calculateHalogenPiInteractions(me.hashUtilsCls.intHash2Atoms(ic.dAtoms, firstSetAtoms, ic.atoms), me.hashUtilsCls.intHash2Atoms(ic.dAtoms, complement, ic.atoms), parseFloat(threshold), type, interactionType );
                let selectedAtoms = ic.piHalogenCls.calculateHalogenPiInteractions(me.hashUtilsCls.hash2Atoms(firstSetAtoms, ic.atoms), me.hashUtilsCls.hash2Atoms(complement, ic.atoms), parseFloat(threshold), type, interactionType );
                let commanddesc;
                if(interactionType == 'halogen') {
                    ic.resid2ResidhashHalogen = me.hashUtilsCls.cloneHash(ic.resid2Residhash);
                    commanddesc = 'all atoms that have halogen bonds with the selected atoms';
                }
                else if(interactionType == 'pi-cation') {
                    ic.resid2ResidhashPication = me.hashUtilsCls.cloneHash(ic.resid2Residhash);
                    commanddesc = 'all atoms that have pi-cation interactions with the selected atoms';
                }
                else if(interactionType == 'pi-stacking') {
                    ic.resid2ResidhashPistacking = me.hashUtilsCls.cloneHash(ic.resid2Residhash);
                    commanddesc = 'all atoms that have pi-stacking with the selected atoms';
                }
                let residues = {};
                for(let i in selectedAtoms) {
                    let residueid = ic.atoms[i].structure + '_' + ic.atoms[i].chain + '_' + ic.atoms[i].resi;
                    residues[residueid] = 1;
                }
                ic.hAtoms = {};
                for(let resid in residues) {
                    for(let i in ic.residues[resid]) {
                        ic.hAtoms[i] = 1;
                        ic.atoms[i].style2 = 'stick';
                        if(ic.ions.hasOwnProperty(i)) ic.atoms[i].style2 = 'sphere';
                        //ic.atoms[i].style2 = 'lines';
                    }
                }
                //let commandname = interactionType + '_' + firstAtom.serial;
                let commandname = interactionType + '_auto';
                ic.selectionCls.addCustomSelection(Object.keys(residues), commandname, commanddesc, select, true);
                ic.selectionCls.saveSelectionIfSelected();
                ic.drawCls.draw();
            }
        }

        // show all cross-linkages bonds
        showClbonds() { let ic = this.icn3d, me = ic.icn3dui;
             ic.opts["clbonds"] = "yes";
             let select = 'cross linkage';
             // find all bonds to chemicals
             let residues = ic.applyClbondsCls.applyClbondsOptions();
             for(let resid in residues) {
                 ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.residues[resid]);
             }
             if(Object.keys(residues).length > 0) {
                let commandname = 'clbonds';
                let commanddesc = 'all atoms that have cross-linkages';
                ic.selectionCls.addCustomSelection(Object.keys(residues), commandname, commanddesc, select, true);
                //ic.changeCustomResidues(nameArray);
                ic.selectionCls.saveSelectionIfSelected();
                // show side chains for the selected atoms
                //ic.setOptionCls.setStyle('sidec', 'stick');
                ic.drawCls.draw();
             }
        }

        // show all disulfide bonds
        showSsbonds() { let ic = this.icn3d, me = ic.icn3dui;
             ic.opts["ssbonds"] = "yes";
             let select = 'disulfide bonds';
        //         ic.hlUpdateCls.removeHlMenus();
             let residues = {};
             let structureArray = Object.keys(ic.structures);
             for(let s = 0, sl = structureArray.length; s < sl; ++s) {
                 let structure = structureArray[s];
                 if(ic.ssbondpnts[structure] === undefined) continue;
                 for(let i = 0, lim = Math.floor(ic.ssbondpnts[structure].length / 2); i < lim; i++) {
                    let res1 = ic.ssbondpnts[structure][2 * i], res2 = ic.ssbondpnts[structure][2 * i + 1];
                    residues[res1] = 1;
                    residues[res2] = 1;
                    ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.residues[res1]);
                    ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.residues[res2]);
                }
            }
            if(Object.keys(residues).length > 0) {
                let commandname = 'ssbonds';
                let commanddesc = 'all atoms that have disulfide bonds';
                ic.selectionCls.addCustomSelection(Object.keys(residues), commandname, commanddesc, select, true);
                //ic.changeCustomResidues(nameArray);
                ic.selectionCls.saveSelectionIfSelected();
                // show side chains for the selected atoms
                //ic.setOptionCls.setStyle('sidec', 'stick');
                ic.drawCls.draw();
            }
        }

        //Select a sphere around the highlight atoms with a predefined distance.
        pickCustomSphere(radius, nameArray2, nameArray, bSphereCalc, bInteraction, type) {  let ic = this.icn3d, me = ic.icn3dui;  // ic.pAtom is set already
            if(bSphereCalc) return;
            let select = "select zone cutoff " + radius + " | sets " + nameArray2 + " " + nameArray + " | " + bSphereCalc;
            if(bInteraction) {
                select = "interactions " + radius + " | sets " + nameArray2 + " " + nameArray + " | " + bSphereCalc;
                ic.opts['contact'] = "yes";
            }
            let atomlistTarget, otherAtoms;
            // could be ligands
            atomlistTarget = ic.definedSetsCls.getAtomsFromNameArray(nameArray2);
            otherAtoms = ic.definedSetsCls.getAtomsFromNameArray(nameArray);
            let bGetPairs = true;
            let result = this.pickCustomSphere_base(radius, atomlistTarget, otherAtoms, bSphereCalc, bInteraction, type, select, bGetPairs);
            let residueArray = Object.keys(result.residues);
            ic.hAtoms = {};
            for(let index = 0, indexl = residueArray.length; index < indexl; ++index) {
              let residueid = residueArray[index];
              for(let i in ic.residues[residueid]) {
                ic.hAtoms[i] = 1;
              }
            }
            // do not change the set of displaying atoms
            //ic.dAtoms = me.hashUtilsCls.cloneHash(ic.atoms);
            let commandname, commanddesc, commandname2;
            let firstAtom = ic.firstAtomObjCls.getFirstAtomObj(atomlistTarget);

            if(firstAtom !== undefined) {
                commandname = "sphere." + firstAtom.chain + ":" + me.utilsCls.residueName2Abbr(firstAtom.resn.substr(0, 3)).trim() + firstAtom.resi + "-" + radius + "A";
                //sometimes firstAtom.resi changed, thus we add a general name
                commandname2 = "sphere-" + radius + "A";
                if(bInteraction) {
                    commandname = "interactions." + firstAtom.chain + ":" + me.utilsCls.residueName2Abbr(firstAtom.resn.substr(0, 3)).trim() + firstAtom.resi + "-" + $("#" + ic.pre + "contactthreshold").val() + "A";
                    commandname2 = "interactions-" + $("#" + ic.pre + "contactthreshold").val() + "A";
                }
                commanddesc = commandname;
                ic.selectionCls.addCustomSelection(residueArray, commandname, commanddesc, select, true);
                ic.selectionCls.addCustomSelection(residueArray, commandname2, commanddesc, select, true);
            }
            ic.selectionCls.saveSelectionIfSelected();
            ic.drawCls.draw();
        }
        pickCustomSphere_base(radius, atomlistTarget, otherAtoms, bSphereCalc, bInteraction, type, select, bGetPairs, bIncludeTarget) {  let ic = this.icn3d, me = ic.icn3dui;  // ic.pAtom is set already
            let atoms;
            if(bInteraction) {
                atoms = ic.contactCls.getAtomsWithinAtom(me.hashUtilsCls.hash2Atoms(otherAtoms, ic.atoms), me.hashUtilsCls.hash2Atoms(atomlistTarget, ic.atoms), parseFloat(radius), bGetPairs, bInteraction, undefined, bIncludeTarget);
                ic.resid2ResidhashInteractions = me.hashUtilsCls.cloneHash(ic.resid2Residhash);
            }
            else {
                atoms = ic.contactCls.getAtomsWithinAtom(otherAtoms, atomlistTarget, parseFloat(radius), bGetPairs, bInteraction);
                ic.resid2ResidhashSphere = me.hashUtilsCls.cloneHash(ic.resid2Residhash);
            }
            let residues = {};
            for(let i in atoms) {
                let atom = atoms[i];
                if(ic.bOpm && atom.resn === 'DUM') continue;
                let residueid = atom.structure + '_' + atom.chain + '_' + atom.resi;
                residues[residueid] = 1;
            }
            return {"residues": residues, "resid2Residhash": ic.resid2Residhash}
        }

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class ViewInterPairs {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        async viewInteractionPairs(nameArray2, nameArray, bHbondCalc, type,
          bHbond, bSaltbridge, bInteraction, bHalogen, bPication, bPistacking, contactDist) { let ic = this.icn3d, me = ic.icn3dui;
           let bondCnt;

           // reset
           if(!bHbondCalc) {
                ic.hbondpnts = [];
                ic.saltbridgepnts = [];
                ic.contactpnts = [];
                ic.halogenpnts = [];
                ic.picationpnts = [];
                ic.pistackingpnts = [];
           }

           // type: view, save, forcegraph
           ic.bRender = false;
           let hAtoms = {};
           let prevHatoms = me.hashUtilsCls.cloneHash(ic.hAtoms);

           let bContactMapLocal = (type == 'calpha' || type == 'cbeta' || type == 'heavyatoms');

           let atomSet1 = {}, atomSet2 = {};
           if(bContactMapLocal) { // contact map
               for(let i in ic.hAtoms) {
                   let atom = ic.atoms[i];

                   // skip solvent
                   if(atom.resn == 'HOH' || atom.resn == 'WAT' || atom.resn == 'SOL') continue;

                   if( (type == 'calpha' && ( atom.het || atom.name == "CA" || atom.name == "O3'" || atom.name == "O3*"))
                       || (type == 'cbeta' && ( atom.het || atom.name == "CB" || atom.name == "O3'" || atom.name == "O3*"))
                       || (type == 'heavyatoms' && atom.elem != "H")
                   ) {
                       atomSet1[i] = atom;
                       atomSet2[i] = atom;
                   }
               }
           }
           else {
               atomSet1 = ic.definedSetsCls.getAtomsFromNameArray(nameArray2);
               atomSet2 = ic.definedSetsCls.getAtomsFromNameArray(nameArray);
           }

           let labelType; // residue, chain, structure
           let cntChain = 0, cntStructure = 0;
           for(let structure in ic.structures) {
               for(let i = 0, il = ic.structures[structure].length; i < il; ++i) {
                   let chainid = ic.structures[structure][i];
                   for(let serial in ic.chains[chainid]) {
                       if(atomSet1.hasOwnProperty(serial) || atomSet2.hasOwnProperty(serial)) {
                           ++cntChain;
                           break;
                       }
                   }
               }
               ++cntStructure;
           }
           if(cntStructure > 1) labelType = 'structure';
           else if(cntChain > 1) labelType = 'chain';
           else labelType = 'residue';
           // fixed order of interaction type
           let interactionTypes = [];
           if(bHbond) {
               interactionTypes.push('hbonds');
           }
           if(bSaltbridge) {
               interactionTypes.push('salt bridge');
           }
           if(bInteraction) {
               interactionTypes.push('interactions');
           }
           if(bHalogen) {
               interactionTypes.push('halogen');
           }
           if(bPication) {
               interactionTypes.push('pi-cation');
           }
           if(bPistacking) {
               interactionTypes.push('pi-stacking');
           }
           if(!bHbondCalc) {
               ic.resids2inter = {};
               ic.resids2interAll = {};
           }

           if(bSaltbridge) {
               let threshold = parseFloat($("#" + ic.pre + "saltbridgethreshold" ).val());
               if(!threshold || isNaN(threshold)) threshold = ic.tsIonic;
               if(!bHbondCalc) {
                   ic.hAtoms = me.hashUtilsCls.cloneHash(prevHatoms);
                   //ic.showInterCls.showHbonds(threshold, nameArray2, nameArray, bHbondCalc, true, type);
                   ic.showInterCls.showIonicInteractions(threshold, nameArray2, nameArray, bHbondCalc, true, type);
               }
               hAtoms = me.hashUtilsCls.unionHash(hAtoms, ic.hAtoms);
           }
           if(bHbond) {
               let threshold = parseFloat($("#" + ic.pre + "hbondthreshold" ).val());
               if(!threshold || isNaN(threshold)) threshold = ic.tsHbond;
               if(!bHbondCalc) {
                   ic.hAtoms = me.hashUtilsCls.cloneHash(prevHatoms);

                   ic.showInterCls.showHbonds(threshold, nameArray2, nameArray, bHbondCalc, undefined, type);
               }
               hAtoms = me.hashUtilsCls.unionHash(hAtoms, ic.hAtoms);
           }
           // switch display order, show hydrogen first
           let tableHtml = '';
           if(bHbond) {
               tableHtml += this.exportHbondPairs(type, labelType);
           }
           if(bSaltbridge) {
               tableHtml += this.exportSaltbridgePairs(type, labelType);
           }
           if(bHalogen) {
               let threshold = parseFloat($("#" + ic.pre + "halogenthreshold" ).val());
               if(!threshold || isNaN(threshold)) threshold = ic.tsHalogen;
               if(!bHbondCalc) {
                   ic.hAtoms = me.hashUtilsCls.cloneHash(prevHatoms);
                   ic.showInterCls.showHalogenPi(threshold, nameArray2, nameArray, bHbondCalc, type, 'halogen');
               }
               hAtoms = me.hashUtilsCls.unionHash(hAtoms, ic.hAtoms);
               tableHtml += this.exportHalogenPiPairs(type, labelType, 'halogen');
           }
           if(bPication) {
               let threshold = parseFloat($("#" + ic.pre + "picationthreshold" ).val());
               if(!threshold || isNaN(threshold)) threshold = ic.tsPication;
               if(!bHbondCalc) {
                   ic.hAtoms = me.hashUtilsCls.cloneHash(prevHatoms);
                   ic.showInterCls.showHalogenPi(threshold, nameArray2, nameArray, bHbondCalc, type, 'pi-cation');
               }
               hAtoms = me.hashUtilsCls.unionHash(hAtoms, ic.hAtoms);
               tableHtml += this.exportHalogenPiPairs(type, labelType, 'pi-cation');
           }
           if(bPistacking) {
               let threshold = parseFloat($("#" + ic.pre + "pistackingthreshold" ).val());
               if(!threshold || isNaN(threshold)) threshold = ic.tsPistacking;
               if(!bHbondCalc) {
                   ic.hAtoms = me.hashUtilsCls.cloneHash(prevHatoms);
                   ic.showInterCls.showHalogenPi(threshold, nameArray2, nameArray, bHbondCalc, type, 'pi-stacking');
               }
               hAtoms = me.hashUtilsCls.unionHash(hAtoms, ic.hAtoms);
               //tableHtml += this.exportHalogenPiPairs(type, labelType, 'pi-stacking');
               let tmp = this.exportHalogenPiPairs(type, labelType, 'pi-stacking');
               tableHtml += tmp;
           }
           if(bInteraction) {
               let threshold = (bContactMapLocal) ? contactDist : parseFloat($("#" + ic.pre + "contactthreshold" ).val());
               if(!threshold || isNaN(threshold)) threshold = ic.tsContact;
               if(!(nameArray2.length == 1 && nameArray.length == 1 && nameArray2[0] == nameArray[0])) {
                    if(!bHbondCalc) {
                        ic.hAtoms = me.hashUtilsCls.cloneHash(prevHatoms);
                        ic.showInterCls.pickCustomSphere(threshold, nameArray2, nameArray, bHbondCalc, true, type);
                    }
                    hAtoms = me.hashUtilsCls.unionHash(hAtoms, ic.hAtoms);
                    tableHtml += this.exportSpherePairs(true, type, labelType);
               }
               else { // contact in a set, atomSet1 same as atomSet2
                    if(!bHbondCalc) {
                        let residues = {};
                        let resid2ResidhashInteractions = {};

                        if(bContactMapLocal) {
                            let bIncludeTarget = true;
                            let result = ic.showInterCls.pickCustomSphere_base(threshold, atomSet1, atomSet2, bHbondCalc, true, undefined, undefined, true, bIncludeTarget);
                            residues = me.hashUtilsCls.unionHash(residues, result.residues);
                            for(let resid in result.resid2Residhash) {
                                resid2ResidhashInteractions[resid] = me.hashUtilsCls.unionHash(resid2ResidhashInteractions[resid], result.resid2Residhash[resid]);
                            }
                        }
                        else {
                            let ssAtomsArray = [];
                            let prevSS = '', prevChain = '';
                            let ssAtoms = {};
                            for(let i in atomSet1) {
                                let atom = ic.atoms[i];
                                if(atom.ss != prevSS || atom.chain != prevChain) {
                                    if(Object.keys(ssAtoms).length > 0) ssAtomsArray.push(ssAtoms);
                                    ssAtoms = {};
                                }
                                ssAtoms[atom.serial] = 1;
                                prevSS = atom.ss;
                                prevChain = atom.chain;
                            }
                            // last ss
                            if(Object.keys(ssAtoms).length > 0) ssAtomsArray.push(ssAtoms);
                            let len = ssAtomsArray.length;
                            let select = "interactions " + threshold + " | sets " + nameArray2 + " " + nameArray + " | true";
                            ic.opts['contact'] = "yes";

                            for(let i = 0; i < len; ++i) {
                                for(let j = i + 1; j < len; ++j) {
                                    ic.hAtoms = me.hashUtilsCls.cloneHash(prevHatoms);
                                    let result = ic.showInterCls.pickCustomSphere_base(threshold, ssAtomsArray[i], ssAtomsArray[j], bHbondCalc, true, type, select, true);
                                    residues = me.hashUtilsCls.unionHash(residues, result.residues);
                                    for(let resid in result.resid2Residhash) {
                                        resid2ResidhashInteractions[resid] = me.hashUtilsCls.unionHash(resid2ResidhashInteractions[resid], result.resid2Residhash[resid]);
                                    }
                                }
                            }
                        }

                        ic.resid2ResidhashInteractions = resid2ResidhashInteractions;
                        let residueArray = Object.keys(residues);
                        ic.hAtoms = {};
                        for(let index = 0, indexl = residueArray.length; index < indexl; ++index) {
                          let residueid = residueArray[index];
                          for(let i in ic.residues[residueid]) {
                            ic.hAtoms[i] = 1;
                          }
                        }
                        // do not change the set of displaying atoms
                        //ic.dAtoms = me.hashUtilsCls.cloneHash(ic.atoms);
                        let commandname, commanddesc;
                        let firstAtom = ic.firstAtomObjCls.getFirstAtomObj(residues);
                        if(firstAtom !== undefined) {
                            commandname = "sphere." + firstAtom.chain + ":" + me.utilsCls.residueName2Abbr(firstAtom.resn.substr(0, 3)).trim() + firstAtom.resi + "-" + radius + "A";
                            if(bInteraction) commandname = "interactions." + firstAtom.chain + ":" + me.utilsCls.residueName2Abbr(firstAtom.resn.substr(0, 3)).trim() + firstAtom.resi + "-" + $("#" + ic.pre + "contactthreshold").val() + "A";
                            commanddesc = commandname;
                            ic.selectionCls.addCustomSelection(residueArray, commandname, commanddesc, select, true);
                        }
                        ic.selectionCls.saveSelectionIfSelected();
                        ic.drawCls.draw();
                    }
                    hAtoms = me.hashUtilsCls.unionHash(hAtoms, ic.hAtoms);
                    tableHtml += this.exportSpherePairs(true, type, labelType);
               } // same set
           }
           ic.hAtoms = me.hashUtilsCls.cloneHash(hAtoms);
           ic.bRender = true;
           //ic.hlUpdateCls.updateHlAll();
           ic.drawCls.draw();
           let residHash, select, commandname, commanddesc;
           residHash = ic.firstAtomObjCls.getResiduesFromAtoms(hAtoms);
           select = "select " + ic.resid2specCls.residueids2spec(Object.keys(residHash));
           commandname = 'interface_all';
           commanddesc = commandname;
           ic.selectionCls.addCustomSelection(Object.keys(residHash), commandname, commanddesc, select, true);
           let interface1 = me.hashUtilsCls.intHash(hAtoms, atomSet1);
           residHash = ic.firstAtomObjCls.getResiduesFromAtoms(interface1);
           select = "select " + ic.resid2specCls.residueids2spec(Object.keys(residHash));
           commandname = 'interface_1';
           commanddesc = commandname;
           ic.selectionCls.addCustomSelection(Object.keys(residHash), commandname, commanddesc, select, true);
           let interface2 = me.hashUtilsCls.intHash(hAtoms, atomSet2);
           residHash = ic.firstAtomObjCls.getResiduesFromAtoms(interface2);
           select = "select " + ic.resid2specCls.residueids2spec(Object.keys(residHash));
           commandname = 'interface_2';
           commanddesc = commandname;
           ic.selectionCls.addCustomSelection(Object.keys(residHash), commandname, commanddesc, select, true);
           //var html = '<div style="text-align:center"><b>Hydrogen Bonds, Salt Bridges, Contacts, Halogen Bonds, &pi;-cation, &pi;-stacking between Two Sets:</b><br>';
           let html = '<div style="text-align:center"><b>' + interactionTypes.join(', ') + ' between Two Sets:</b><br>';
           let residueArray1 = ic.resid2specCls.atoms2residues(Object.keys(atomSet1));
           let residueArray2 = ic.resid2specCls.atoms2residues(Object.keys(atomSet2));
           let cmd1 = 'select ' + ic.resid2specCls.residueids2spec(residueArray1);
           let cmd2 = 'select ' + ic.resid2specCls.residueids2spec(residueArray2);
           html += 'Set 1: ' + nameArray2 + ' <button class="' + ic.pre + 'selset" cmd="' + cmd1 + '">Highlight in 3D</button><br>';
           html += 'Set 2: ' + nameArray + ' <button class="' + ic.pre + 'selset" cmd="' + cmd2 + '">Highlight in 3D</button><br><br></div>';
           html += '<div style="text-align:center"><b>The interfaces are:</b><br>';
           let residueArray3 = ic.resid2specCls.atoms2residues(Object.keys(interface1));
           let residueArray4 = ic.resid2specCls.atoms2residues(Object.keys(interface2));
           let cmd3 = 'select ' + ic.resid2specCls.residueids2spec(residueArray3);
           let cmd4 = 'select ' + ic.resid2specCls.residueids2spec(residueArray4);
           html += 'interface_1 <button class="' + ic.pre + 'selset" cmd="' + cmd3 + '">Highlight in 3D</button><br>';
           html += 'interface_2 <button class="' + ic.pre + 'selset" cmd="' + cmd4 + '">Highlight in 3D</button><br><br></div>';
           html += '<div><b>Note</b>: Each checkbox below selects the corresponding residue. '
             + 'You can click "Save Selection" in the "Select" menu to save the selection '
             + 'and click on "Highlight" button to clear the checkboxes.</div><br>';
           let header = html;
           if(type == 'graph' || type == 'linegraph' || type == 'scatterplot' || bContactMapLocal) html = '';
           html += tableHtml;

           if(type == 'save1' || type == 'save2') {
               html = header;
               let tmpText = '';
               if(type == 'save1') {
                   tmpText = 'Set 1';
               }
               else if(type == 'save2') {
                   tmpText = 'Set 2';
               }
               html += '<div style="text-align:center"><br><b>Interactions Sorted on ' + tmpText + '</b>: <button class="' + ic.pre + 'showintercntonly" style="margin-left:20px">Show Count Only</button><button class="' + ic.pre + 'showinterdetails" style="margin-left:20px">Show Details</button></div>';
               let result = this.getAllInteractionTable(type);
               html += result.html;
               bondCnt = result.bondCnt;

               $("#" + ic.pre + "dl_interactionsorted_html").html(html);
               me.htmlCls.dialogCls.openDlg('dl_interactionsorted', 'Show sorted interactions');
           }
           else if(type == 'view') {
               $("#" + ic.pre + "dl_allinteraction_html").html(html);
               me.htmlCls.dialogCls.openDlg('dl_allinteraction', 'Show interactions');
           }
           else if(type == 'linegraph') {
               me.htmlCls.dialogCls.openDlg('dl_linegraph', 'Show interactions between two lines of residue nodes');
               ic.graphStr = ic.getGraphCls.getGraphData(atomSet1, atomSet2, nameArray2, nameArray, html, labelType);
               ic.bLinegraph = true;
               // draw SVG
               let svgHtml = ic.lineGraphCls.drawLineGraph(ic.graphStr);
               $("#" + ic.pre + "linegraphDiv").html(svgHtml);
           }
           else if(type == 'scatterplot') {
               me.htmlCls.dialogCls.openDlg('dl_scatterplot', 'Show interactions as scatterplot');
               ic.graphStr = ic.getGraphCls.getGraphData(atomSet1, atomSet2, nameArray2, nameArray, html, labelType);
               ic.bScatterplot = true;
               // draw SVG
               let svgHtml = ic.lineGraphCls.drawLineGraph(ic.graphStr, true);
               $("#" + ic.pre + "scatterplotDiv").html(svgHtml);
           }
           else if(type == 'ligplot') {
                await ic.ligplotCls.drawLigplot(atomSet1);
           }
           else if(bContactMapLocal) {
               me.htmlCls.dialogCls.openDlg('dl_contactmap', 'Show contact map');
               let bAnyAtom = true;
               let graphStr = ic.getGraphCls.getGraphData(atomSet1, atomSet2, nameArray2, nameArray, html, labelType, bAnyAtom);
               ic.bContactMap = true;
               // draw SVG
               let svgHtml = ic.contactMapCls.drawContactMap(graphStr);
               $("#" + ic.pre + "contactmapDiv").html(svgHtml);
           }
           else if(type == 'graph') {
               // atomSet1 and atomSet2 are in the right order here
               ic.graphStr = ic.getGraphCls.getGraphData(atomSet1, atomSet2, nameArray2, nameArray, html, labelType);
               ic.bGraph = true;
               // show only displayed set in 2D graph
               if(Object.keys(atomSet2).length + Object.keys(atomSet1).length > Object.keys(ic.dAtoms).length) {
                   ic.graphStr = ic.selectionCls.getGraphDataForDisplayed();
               }

               if(ic.bD3 === undefined) {
                    //let url = "https://d3js.org/d3.v4.min.js";
                    let url = "./script/d3v4-force-all.min.js";
                    await me.getAjaxPromise(url, 'script');

                    ic.bD3 = true;
               }

                $("#" + me.svgid).empty();
                me.htmlCls.dialogCls.openDlg('dl_graph', 'Force-directed graph');
                ic.drawGraphCls.drawGraph(ic.graphStr, ic.pre + 'dl_graph');
           }

           return {interactionTypes: interactionTypes.toString(), bondCnt: bondCnt};
        }

        clearInteractions() { let ic = this.icn3d; ic.icn3dui;
            ic.lines['hbond'] = [];
            ic.hbondpnts = [];
            ic.lines['saltbridge'] = [];
            ic.saltbridgepnts = [];
            ic.lines['contact'] = [];
            ic.contactpnts = [];

            ic.lines['halogen'] = [];
            ic.lines['pi-cation'] = [];
            ic.lines['pi-stacking'] = [];
            ic.halogenpnts = [];
            ic.picationpnts = [];
            ic.pistackingpnts = [];
        }

        resetInteractionPairs() { let ic = this.icn3d; ic.icn3dui;
           ic.bHbondCalc = false;
           //me.htmlCls.clickMenuCls.setLogCmd('set calculate hbond false', true);
           ic.showInterCls.hideHbondsContacts();
           ic.hlUpdateCls.clearHighlight();
           // reset the interaction pairs
           ic.resids2inter = {};
           ic.resids2interAll = {};
        }

        async retrieveInteractionData() { let ic = this.icn3d, me = ic.icn3dui;
             if(!ic.b2DShown) {
                 if(me.cfg.align !== undefined) {
                     let structureArray = Object.keys(ic.structures);

                     if(me.cfg.atype == 2) {
                        let bDiagramOnly = true;
                        await ic.alignParserCls.downloadAlignment(structureArray[0] + ',' + structureArray[1], bDiagramOnly);
                     }
                     
                     await ic.ParserUtilsCls.set2DDiagramsForAlign(structureArray[0].toUpperCase(), structureArray[1].toUpperCase());
                 }
                 else if(me.cfg.chainalign !== undefined) {
                     Object.keys(ic.structures);
                     //if(structureArray.length == 2) {
                     //   ic.ParserUtilsCls.set2DDiagramsForAlign(structureArray[1].toUpperCase(), structureArray[0].toUpperCase());
                     //}
                     //else if(structureArray.length == 1) {
                     //   ic.ParserUtilsCls.set2DDiagramsForAlign(structureArray[0].toUpperCase(), structureArray[0].toUpperCase());
                     //}

                     await ic.ParserUtilsCls.set2DDiagramsForChainalign(ic.chainidArray);
                 }
                 else {
                     ic.ParserUtilsCls.download2Ddgm(ic.inputid.toUpperCase());
                 }
             }
        }

        getAllInteractionTable(type, index2xy, xlen, ylen, xcenter, ycenter) { let ic = this.icn3d, me = ic.icn3dui;
            let svgHtmlNode = '', svgHtmlLine = '';

            let bondCnt = [];

            let residsArray = Object.keys(ic.resids2inter);
            if(type == 'save1') {
               residsArray.sort(function(a,b) {
                  return me.utilsCls.compResid(a, b, type);
               });
            }
            else if(type == 'save2') {
               residsArray.sort(function(a,b) {
                  return me.utilsCls.compResid(a, b, type);
               });
            }
            //ic.resids2inter
            let tmpText = '';
            let prevResidname1 = '', prevIds = '';
            let strHbond = '', strIonic = '', strContact = '', strHalegen = '', strPication = '', strPistacking = '';
            let cntHbond = 0, cntIonic = 0, cntContact = 0, cntHalegen = 0, cntPication = 0, cntPistacking = 0;
            let residname1, residname2, residname2List = '';
            for(let i = 0, il = residsArray.length; i < il; ++i) {
                let resids = residsArray[i];
                let residname1_residname2 = resids.split(',');
                residname1 =(type == 'save1') ? residname1_residname2[0] : residname1_residname2[1];
                residname2 =(type == 'save1') ? residname1_residname2[1] : residname1_residname2[0];

                // stru_chain_resi_resn
                let ids = residname1.split('_');
                if(i > 0 && residname1 != prevResidname1) {
                    bondCnt.push({res1: prevResidname1, res2: residname2List, cntHbond: cntHbond, cntIonic: cntIonic, cntContact: cntContact, cntHalegen: cntHalegen, cntPication: cntPication, cntPistacking: cntPistacking});

                    tmpText += this.getInteractionPerResidue(prevIds, strHbond, strIonic, strContact, strHalegen, strPication, strPistacking,
                      cntHbond, cntIonic, cntContact, cntHalegen, cntPication, cntPistacking);
                    strHbond = ''; strIonic = ''; strContact = ''; strHalegen = ''; strPication = ''; strPistacking = '';
                    cntHbond = 0; cntIonic = 0; cntContact = 0; cntHalegen = 0; cntPication = 0; cntPistacking = 0;
                    residname2List = '';
                }
                let labels2dist, result;
                labels2dist = ic.resids2inter[resids]['hbond'];
                result = this.getInteractionPairDetails(labels2dist, type, 'hbond', index2xy, xlen, ylen, xcenter, ycenter);
                strHbond += result.html;
                cntHbond += result.cnt;
                svgHtmlNode += result.svgHtmlNode;
                svgHtmlLine += result.svgHtmlLine;
                // if(result.cnt > 0) residname2List += residname2 + ":hbond_" + result.cnt + " ";
                // add hydrogen bond between main or side chains. result.mainside has value such as main,side,side,side  
                // for two hydrogens between main and side, and side and side chains
                if(result.cnt > 0) residname2List += residname2 + ":hbond_" + result.cnt + ":type_" + result.mainside + " ";

                labels2dist = ic.resids2inter[resids]['ionic'];
                result = this.getInteractionPairDetails(labels2dist, type, 'ionic', index2xy, xlen, ylen, xcenter, ycenter);
                strIonic += result.html;
                cntIonic += result.cnt;
                svgHtmlNode += result.svgHtmlNode;
                svgHtmlLine += result.svgHtmlLine;
                if(result.cnt > 0) residname2List += residname2 + ":ionic_" + result.cnt + ":type_" + result.mainside + " ";

                labels2dist = ic.resids2inter[resids]['halogen'];
                result = this.getInteractionPairDetails(labels2dist, type, 'halogen', index2xy, xlen, ylen, xcenter, ycenter);
                strHalegen += result.html;
                cntHalegen += result.cnt;
                svgHtmlNode += result.svgHtmlNode;
                svgHtmlLine += result.svgHtmlLine;
                if(result.cnt > 0) residname2List += residname2 + ":halogen_" + result.cnt + ":type_" + result.mainside + " ";

                labels2dist = ic.resids2inter[resids]['pi-cation'];
                result = this.getInteractionPairDetails(labels2dist, type, 'pi-cation', index2xy, xlen, ylen, xcenter, ycenter);
                strPication += result.html;
                cntPication += result.cnt;
                svgHtmlNode += result.svgHtmlNode;
                svgHtmlLine += result.svgHtmlLine;
                if(result.cnt > 0) residname2List += residname2 + ":pi-cation_" + result.cnt + ":type_" + result.mainside + " ";

                labels2dist = ic.resids2inter[resids]['pi-stacking'];
                result = this.getInteractionPairDetails(labels2dist, type, 'pi-stacking', index2xy, xlen, ylen, xcenter, ycenter);
                strPistacking += result.html;
                cntPistacking += result.cnt;
                svgHtmlNode += result.svgHtmlNode;
                svgHtmlLine += result.svgHtmlLine;
                if(result.cnt > 0) residname2List += residname2 + ":pi-stacking_" + result.cnt + ":type_" + result.mainside + " ";

                // put contact as the last one since contact will use the same node as other interactions in ligand-protein interactoin
                labels2dist = ic.resids2inter[resids]['contact'];
                result = this.getContactPairDetails(labels2dist, type, 'contact', index2xy, xlen, ylen, xcenter, ycenter);
                strContact += result.html;
                cntContact += result.cnt;
                svgHtmlNode += result.svgHtmlNode;
                svgHtmlLine += result.svgHtmlLine;
                if(result.cnt > 0) residname2List += residname2 + ":contact_" + result.cnt + " ";

                prevResidname1 = residname1;
                prevIds = ids;
            }
            bondCnt.push({res1: prevResidname1, res2: residname2List, cntHbond: cntHbond, cntIonic: cntIonic, cntContact: cntContact, cntHalegen: cntHalegen, cntPication: cntPication, cntPistacking: cntPistacking});

            tmpText += this.getInteractionPerResidue(prevIds, strHbond, strIonic, strContact, strHalegen, strPication, strPistacking,
              cntHbond, cntIonic, cntContact, cntHalegen, cntPication, cntPistacking);
            let html = '';
            if(residsArray.length > 0) {
                html += '<br><table class="icn3d-sticky" align=center border=1 cellpadding=10 cellspacing=0><thead>';
                html += '<tr><th rowspan=2>Residue</th><th rowspan=2># Hydrogen<br>Bond</th><th rowspan=2># Salt Bridge<br>/Ionic Interaction</th><th rowspan=2># Contact</th>';
                html += '<th rowspan=2># Halogen<br>Bond</th><th rowspan=2># &pi;-Cation</th><th rowspan=2># &pi;-Stacking</th>';
                html += '<th>Hydrogen Bond (backbone atoms: @CA, @N, @C, @O)</th><th>Salt Bridge/Ionic Interaction</th><th>Contact</th>';
                html += '<th>Halogen Bond</th><th>&pi;-Cation</th><th>&pi;-Stacking</th></tr>';
                html += '<tr>';
                let tmpStr = '<td><table width="100%" class="icn3d-border"><tr><td>Atom1</td><td>Atom2</td><td>Distance(&#8491;)</td><td>Highlight in 3D</td></tr></table></td>';
                html += tmpStr;
                html += tmpStr;
                html += '<td><table width="100%" class="icn3d-border"><tr><td>Atom1</td><td>Atom2</td><td># Contacts</td><td>Min Distance(&#8491;)</td><td>C-alpha Distance(&#8491;)</td><td>Highlight in 3D</td></tr></table></td>';
                html += tmpStr;
                html += tmpStr;
                html += tmpStr;
                html += '</tr>';
                html += '</thead><tbody>';
                html += tmpText;
                html += '</tbody></table><br/>';
            }
            return  {html: html, bondCnt: bondCnt, svgHtmlNode: svgHtmlNode, svgHtmlLine: svgHtmlLine};
        }
        getInteractionPerResidue(prevIds, strHbond, strIonic, strContact, strHalegen, strPication, strPistacking,
          cntHbond, cntIonic, cntContact, cntHalegen, cntPication, cntPistacking) { let ic = this.icn3d; ic.icn3dui;
            let tmpText = '';
            tmpText += '<tr align="center"><th>' + prevIds[3] + prevIds[2] + '</th><td>' + cntHbond + '</td><td>' + cntIonic + '</td><td>' + cntContact + '</td><td>' + cntHalegen + '</td><td>' + cntPication + '</td><td>' + cntPistacking + '</td>';

            let itemArray = [strHbond, strIonic, strContact, strHalegen, strPication, strPistacking];
            for(let i in itemArray) {
                let item = itemArray[i];
                tmpText += '<td valign="top"><table width="100%" class="icn3d-border">' + item + '</table></td>';
            }
            tmpText += '</tr>';
            return tmpText;
        }
        getInteractionPairDetails(labels2dist, type, interactionType, index2xy, xlen, ylen, xcenter, ycenter) { let ic = this.icn3d; ic.icn3dui;
            let svgHtmlNode = '', svgHtmlLine = '', tmpText = '', cnt = 0, mainside= '';
            let colorText1 = ' <span style="background-color:#';
            let colorText2 = '">&nbsp;&nbsp;&nbsp;</span>';
            if(labels2dist !== undefined) {
                if(!ic.resid2cnt) ic.resid2cnt = {};
                if(!ic.resid2ToXy) ic.resid2ToXy = {};
                if(!ic.nodeid2lineid) ic.nodeid2lineid = {};
                for(let labels in labels2dist) {
                    let resid1_resid2 = labels.split('|');
                    let resid1Ori =(type == 'save1') ? resid1_resid2[0] : resid1_resid2[1];
                    let resid2Ori =(type == 'save1') ? resid1_resid2[1] : resid1_resid2[0];
                    //resid1: MET $3GVU.A:364@N 1234
                    let pos1 = resid1Ori.lastIndexOf(' ');
                    let pos2 = resid2Ori.lastIndexOf(' ');
                    let resid1 = resid1Ori.substr(0, pos1);
                    let resid2 = resid2Ori.substr(0, pos2);

                    let atomName1 = resid1.substr(resid1.indexOf('@') + 1);
                    resid2.substr(resid2.indexOf('@') + 1);
                    let atomType1 = (atomName1 === "N" || atomName1 === "C" || atomName1 === "O" || atomName1 === "CA") ? 'main' : 'side';
                    if(mainside) mainside += ';';
                    mainside += atomType1 + ',' + atomType1;

                    let resid1Real = ic.getGraphCls.convertLabel2Resid(resid1);
                    let atom1 = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid1Real]);
                    let color1 = (atom1.color) ? atom1.color.getHexString() : '';
                    let resid2Real = ic.getGraphCls.convertLabel2Resid(resid2);
                    let atom2 = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid2Real]);
                    let color2 = (atom2.color) ? atom2.color.getHexString() : '';
                    let dist = Math.sqrt(labels2dist[labels]).toFixed(1);
                    tmpText += '<tr><td><span style="white-space:nowrap"><input type="checkbox" class="' + ic.pre + 'seloneres" id="' + ic.pre + interactionType + '2_' +  cnt + 'a" resid="' + resid1 + '"/> ' + resid1 + colorText1 + color1 + colorText2 + '</span></td><td><span style="white-space:nowrap"><input type="checkbox" class="' + ic.pre + 'seloneres" id="' + ic.pre + interactionType + '2_' +  cnt + 'b" resid="' + resid2 + '"/> ' + resid2 + colorText1 + color2 + colorText2 + '</span></td><td align="center">' + dist + '</td>';
                    tmpText += '<td align="center"><button class="' + ic.pre + 'selres" resid="' + resid1 + '|' + resid2 + '">Highlight</button></td>';
                    tmpText += '</tr>';
                    ++cnt;

                    if(index2xy) {
                        let serialArray1 = resid1Ori.substr(pos1 + 1).split(',');

                        let result = ic.ligplotCls.getSvgPerPair(serialArray1, resid1, resid2, interactionType, index2xy, xlen, ylen, xcenter, ycenter, dist);
                        svgHtmlNode += result.node;
                        svgHtmlLine += result.line;
                    }
                }
            }
            return {html: tmpText, cnt: cnt, svgHtmlNode: svgHtmlNode, svgHtmlLine: svgHtmlLine, mainside: mainside}
        }

        getContactPairDetails(labels2dist, type, interactionType, index2xy, xlen, ylen, xcenter, ycenter) { let ic = this.icn3d; ic.icn3dui;
            let svgHtmlNode = '', svgHtmlLine = '', tmpText = '', cnt = 0;
            let colorText1 = ' <span style="background-color:#';
            let colorText2 = '">&nbsp;&nbsp;&nbsp;</span>';
            if(labels2dist !== undefined) {
                let resids2distCnt = {};
                if(!ic.resid2cnt) ic.resid2cnt = {};
                if(!ic.resid2ToXy) ic.resid2ToXy = {};
                if(!ic.nodeid2lineid) ic.nodeid2lineid = {};
                for(let labels in labels2dist) {
                    let resid1_resid2 = labels.split('|');
                    let resid1Ori =(type == 'save1') ? resid1_resid2[0] : resid1_resid2[1];
                    let resid2Ori =(type == 'save1') ? resid1_resid2[1] : resid1_resid2[0];
                    //resid1: MET $3GVU.A:364 1234
                    let pos1 = resid1Ori.lastIndexOf(' ');
                    let pos2 = resid2Ori.lastIndexOf(' ');
                    
                    let serialArray1 = resid1Ori.substr(pos1 + 1).split(',');
                    let resid1 = resid1Ori.substr(0, pos1);
                    if(index2xy) {
                        // add atom name to resid1
                        resid1 += '@' + ic.atoms[serialArray1[0]].name;
                    }
                    
                    let resid2 = resid2Ori.substr(0, pos2);
                    let resids = resid1 + '|' + resid2;

                    let resid1Real = ic.getGraphCls.convertLabel2Resid(resid1);
                    ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid1Real]);
                    // let color1 = (atom1.color) ? atom1.color.getHexString() : '';
                    let resid2Real = ic.getGraphCls.convertLabel2Resid(resid2);
                    ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid2Real]);
                    // let color2 = (atom2.color) ? atom2.color.getHexString() : '';
                    let dist1_dist2_atom1_atom2 = labels2dist[labels].split('_');
                    let dist1 = parseFloat(dist1_dist2_atom1_atom2[0]);
                    // let dist2 = parseFloat(dist1_dist2_atom1_atom2[1]);
                    // let atom1Name = dist1_dist2_atom1_atom2[2];
                    // let atom2Name = dist1_dist2_atom1_atom2[3];
                    let contactCnt = parseInt(dist1_dist2_atom1_atom2[4]);
                    if(!resids2distCnt.hasOwnProperty(resids)) {
                        resids2distCnt[resids] = {'dist1': dist1, 'dist1_dist2_atom1_atom2': dist1_dist2_atom1_atom2, 'cnt': contactCnt, 'serialArray1': serialArray1};
                    }
                    else {
                        resids2distCnt[resids].cnt += contactCnt;
                        if(dist1 < resids2distCnt[resids].dist1) {
                            resids2distCnt[resids].dist1 = dist1;
                            resids2distCnt[resids].dist1_dist2_atom1_atom2 = dist1_dist2_atom1_atom2;
                            resids2distCnt[resids].serialArray1 = serialArray1;
                        }
                    }
                }

                let resid2ToResid1 = {};
                for(let resids in resids2distCnt) {
                    let resid1_resid2 = resids.split('|');
                    let resid1 = resid1_resid2[0];
                    let resid2 = resid1_resid2[1];

                    if(!resid2ToResid1.hasOwnProperty(resid2)) {
                        resid2ToResid1[resid2] = [resid1];
                    }
                    else {
                        resid2ToResid1[resid2].push(resid1);
                    }

                    let resid1Real = ic.getGraphCls.convertLabel2Resid(resid1);
                    let atom1 = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid1Real]);
                    let color1 = (atom1.color) ? atom1.color.getHexString() : '';
                    let resid2Real = ic.getGraphCls.convertLabel2Resid(resid2);
                    let atom2 = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid2Real]);
                    let color2 = (atom2.color) ? atom2.color.getHexString() : '';
                    let dist1_dist2_atom1_atom2 = resids2distCnt[resids].dist1_dist2_atom1_atom2;
                    let dist1 = dist1_dist2_atom1_atom2[0];
                    let dist2 = dist1_dist2_atom1_atom2[1];
                    let atom1Name = dist1_dist2_atom1_atom2[2];
                    let atom2Name = dist1_dist2_atom1_atom2[3];
                    let contactCnt = 1; //resids2distCnt[resids].cnt;
                    
                    tmpText += '<tr><td><span style="white-space:nowrap"><input type="checkbox" class="' + ic.pre + 'seloneres" id="' + ic.pre + 'inter2_' +  cnt + 'a" resid="' + resid1 + '"/> ' + resid1 + '@' + atom1Name + colorText1 + color1 + colorText2 + '</span></td><td><span style="white-space:nowrap"><input type="checkbox" class="' + ic.pre + 'seloneres" id="' + ic.pre + 'inter2_' +  cnt + 'b" resid="' + resid2 + '"/> ' + resid2 + '@' + atom2Name + colorText1 + color2 + colorText2 + '</span></td><td align="center">' + contactCnt + '</td><td align="center">' + dist1 + '</td><td align="center">' + dist2 + '</td>';
                    tmpText += '<td align="center"><button class="' + ic.pre + 'selres" resid="' + resid1 + '|' + resid2 + '">Highlight</button></td>';
                    tmpText += '</tr>';
                    cnt += parseInt(contactCnt);
                }

                if(index2xy) {
                    for(let resid2 in resid2ToResid1) {
                        let resid1Array = resid2ToResid1[resid2];
                        let prevX2, prevY2;
                        for(let i = 0, il = resid1Array.length; i < il; ++i) {
                            let resid1 = resid1Array[i];
                            let resids = resid1 + '|' + resid2;
                
                            let serialArray1 = resids2distCnt[resids].serialArray1;
                            let dist1_dist2_atom1_atom2 = resids2distCnt[resids].dist1_dist2_atom1_atom2;
                            let dist1 = dist1_dist2_atom1_atom2[0]; // min dist
                            dist1_dist2_atom1_atom2[1]; // c-alpha dist
                            // let dist = (dist1 < dist2) ? dist1 : dist2;
                            let bNotDrawNode = (i == 0) ? false : true;
                            let result = ic.ligplotCls.getSvgPerPair(serialArray1, resid1, resid2, interactionType, index2xy, xlen, ylen, xcenter, ycenter, dist1, bNotDrawNode, prevX2, prevY2);
                            svgHtmlNode += result.node;
                            svgHtmlLine += result.line;
                            prevX2 = result.x2;
                            prevY2 = result.y2;
                        }
                    }
                }
            }

            return {html: tmpText, cnt: cnt, svgHtmlNode: svgHtmlNode, svgHtmlLine: svgHtmlLine};
        }

        //Export the list of residues in some chain interacting with residues in another chain.
        exportInteractions() {var ic = this.icn3d, me = ic.icn3dui;
           let text = '<html><body><div style="text-align:center"><br><b>Interacting residues</b>:<br/><table align=center border=1 cellpadding=10 cellspacing=0><tr><th>Base Chain: Residues</th><th>Interacting Chain</th></tr>';
           for(let fisrtChainid in ic.chainname2residues) {
               for(let name in ic.chainname2residues[fisrtChainid]) {
                   let secondChainid = fisrtChainid.substr(0, fisrtChainid.indexOf('_')) + '_' + name.substr(0, name.indexOf(' '));
                   text += '<tr><td>' + fisrtChainid + ': ';
                   text += ic.resid2specCls.residueids2spec(ic.chainname2residues[fisrtChainid][name]);
                   text += '</td><td>' + secondChainid + '</td></tr>';
               }
           }
           text += '</table><br/></div></body></html>';
           let file_pref = Object.keys(me.utilsCls.getHlStructures()).join(',');
           ic.saveFileCls.saveFile(file_pref + '_interactions.html', 'html', text);
        }
        exportSsbondPairs() {var ic = this.icn3d, me = ic.icn3dui;
            let tmpText = '';
            let cnt = 0;
            for(let structure in ic.structures) {
                let ssbondArray = ic.ssbondpnts[structure];
                if(ssbondArray === undefined) {
                    break;
                }
                for(let i = 0, il = ssbondArray.length; i < il; i = i + 2) {
                    let resid1 = ssbondArray[i];
                    let resid2 = ssbondArray[i+1];
                    tmpText += '<tr><td>' + resid1 + ' Cys</td><td>' + resid2 + ' Cys</td></tr>';
                    ++cnt;
                }
            }
            let text = '<html><body><div style="text-align:center"><br><b>' + cnt + ' disulfide pairs</b>:<br><br><table align=center border=1 cellpadding=10 cellspacing=0><tr><th>Residue ID 1</th><th>Residue ID 2</th></tr>';
            text += tmpText;
            text += '</table><br/></div></body></html>';
            let file_pref = Object.keys(me.utilsCls.getHlStructures()).join(',');
            ic.saveFileCls.saveFile(file_pref + '_disulfide_pairs.html', 'html', text);
        }
        exportClbondPairs() {var ic = this.icn3d, me = ic.icn3dui;
            let tmpText = '';
            let cnt = 0;
            let residHash = {};
            for(let structure in ic.structures) {
                let clbondArray = ic.clbondpnts[structure];
                if(clbondArray === undefined) {
                    break;
                }
                for(let i = 0, il = clbondArray.length; i < il; i = i + 2) {
                    let resid1 = clbondArray[i];
                    let resid2 = clbondArray[i+1];
                    if(!residHash.hasOwnProperty(resid1 + '_' + resid2)) {
                        let atom1 = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid1]);
                        let atom2 = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid2]);
                        tmpText += '<tr><td>' + resid1 + ' ' + atom1.resn + '</td><td>' + resid2 + ' ' + atom2.resn + '</td></tr>';
                        ++cnt;
                    }
                    residHash[resid1 + '_' + resid2] = 1;
                    residHash[resid2 + '_' + resid1] = 1;
                }
            }
            let text = '<html><body><div style="text-align:center"><br><b>' + cnt + ' cross-linkage pairs</b>:<br><br><table align=center border=1 cellpadding=10 cellspacing=0><tr><th>Residue ID 1</th><th>Residue ID 2</th></tr>';
            text += tmpText;
            text += '</table><br/></div></body></html>';
            let file_pref = Object.keys(me.utilsCls.getHlStructures()).join(',');
            ic.saveFileCls.saveFile(file_pref + '_crosslinkage_pairs.html', 'html', text);
        }
        exportHbondPairs(type, labelType) {var ic = this.icn3d, me = ic.icn3dui;
            let tmpText = '';
            let cnt = 0;
            let colorText1 = ' <span style="background-color:#';
            let colorText2 = '">&nbsp;&nbsp;&nbsp;</span>';
            for(let resid1 in ic.resid2ResidhashHbond) {
                let resid1Real = ic.getGraphCls.convertLabel2Resid(resid1);
                let atom1 = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid1Real]);
                let color1 = (atom1.color) ? atom1.color.getHexString() : '';
                for(let resid2 in ic.resid2ResidhashHbond[resid1]) {
                    let resid2Real = ic.getGraphCls.convertLabel2Resid(resid2);
                    let atom2 = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid2Real]);
                    let color2 = (atom2.color) ? atom2.color.getHexString() : '';
                    let dist = Math.sqrt(ic.resid2ResidhashHbond[resid1][resid2]).toFixed(1);
                    tmpText += '<tr><td><input type="checkbox" class="' + ic.pre + 'seloneres" id="' + ic.pre + 'hbond_' +  cnt + 'a" resid="' + resid1 + '"/> ' + resid1 + colorText1 + color1 + colorText2 + '</td><td><input type="checkbox" class="' + ic.pre + 'seloneres" id="' + ic.pre + 'hbond_' +  cnt + 'b" resid="' + resid2 + '"/> ' + resid2 + colorText1 + color2 + colorText2 + '</td><td align="center">' + dist + '</td>';
                    if(type == 'view') tmpText += '<td align="center"><button class="' + ic.pre + 'selres" resid="' + resid1 + '|' + resid2 + '">Highlight</button></td>';
                    tmpText += '</tr>';
                    ++cnt;
                }
            }
            let text = '<div style="text-align:center"><br><b>' + cnt
              + ' hydrogen bond pairs</b> (backbone atoms: @CA, @N, @C, @O):</div><br>';
            if(cnt > 0) {
                text += '<br><table align=center border=1 cellpadding=10 cellspacing=0>'
                + '<tr><th>Atom 1</th><th>Atom 2</th><th>Distance(&#8491;)</th>';
                if(type == 'view') text += '<th align="center">Highlight in 3D</th>';
                text += '</tr>';
                text += tmpText;
                text += '</table><br/>';
            }
            if(type == 'graph' || type == 'linegraph' || type == 'scatterplot') {
                let hbondStr = ic.getGraphCls.getGraphLinks(ic.resid2ResidhashHbond, ic.resid2ResidhashHbond, me.htmlCls.hbondColor, labelType, me.htmlCls.hbondValue);
                return hbondStr;
            }
            else {
                return text;
            }
        }
        exportSaltbridgePairs(type, labelType) {var ic = this.icn3d, me = ic.icn3dui;
            let tmpText = '';
            let cnt = 0;
            let colorText1 = ' <span style="background-color:#';
            let colorText2 = '">&nbsp;&nbsp;&nbsp;</span>';
            for(let resid1 in ic.resid2ResidhashSaltbridge) {
                let resid1Real = ic.getGraphCls.convertLabel2Resid(resid1);
                let atom1 = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid1Real]);
                let color1 = (atom1.color) ? atom1.color.getHexString() : '';
                for(let resid2 in ic.resid2ResidhashSaltbridge[resid1]) {
                    let resid2Real = ic.getGraphCls.convertLabel2Resid(resid2);
                    let atom2 = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid2Real]);
                    let color2 = (atom2.color) ? atom2.color.getHexString() : '';
                    let dist = Math.sqrt(ic.resid2ResidhashSaltbridge[resid1][resid2]).toFixed(1);
                    tmpText += '<tr><td><input type="checkbox" class="' + ic.pre + 'seloneres" id="' + ic.pre + 'saltb_' +  cnt + 'a" resid="' + resid1 + '"/> ' + resid1 + colorText1 + color1 + colorText2 + '</td><td><input type="checkbox" class="' + ic.pre + 'seloneres" id="' + ic.pre + 'saltb_' +  cnt + 'b" resid="' + resid2 + '"/> ' + resid2 + colorText1 + color2 + colorText2 + '</td><td align="center">' + dist + '</td>';
                    if(type == 'view') tmpText += '<td align="center"><button class="' + ic.pre + 'selres" resid="' + resid1 + '|' + resid2 + '">Highlight</button></td>';
                    tmpText += '</tr>';
                    ++cnt;
                }
            }
            let text = '<div style="text-align:center"><br><b>' + cnt
              + ' salt bridge/ionic interaction pairs</b>:</div><br>';
            if(cnt > 0) {
                text += '<br><table align=center border=1 cellpadding=10 cellspacing=0>'
                  + '<tr><th>Atom 1</th><th>Atom 2</th><th>Distance(&#8491;)</th>';
                if(type == 'view') text += '<th align="center">Highlight in 3D</th>';
                text += '</tr>';
                text += tmpText;
                text += '</table><br/>';
            }
            if(type == 'graph' || type == 'linegraph' || type == 'scatterplot') {
                let hbondStr = ic.getGraphCls.getGraphLinks(ic.resid2ResidhashSaltbridge, ic.resid2ResidhashSaltbridge, me.htmlCls.ionicColor, labelType, me.htmlCls.ionicValue);
                return hbondStr;
            }
            else {
                return text;
            }
        }
        exportHalogenPiPairs(type, labelType, interactionType) {var ic = this.icn3d, me = ic.icn3dui;
            let tmpText = '';
            let cnt = 0;
            let colorText1 = ' <span style="background-color:#';
            let colorText2 = '">&nbsp;&nbsp;&nbsp;</span>';
            let resid2Residhash, color, value;
            if(interactionType == 'halogen') {
                resid2Residhash = ic.resid2ResidhashHalogen;
                color = me.htmlCls.halogenColor;
                value = me.htmlCls.halogenValue;
            }
            else if(interactionType == 'pi-cation') {
                resid2Residhash = ic.resid2ResidhashPication;
                color = me.htmlCls.picationColor;
                value = me.htmlCls.picationValue;
            }
            else if(interactionType == 'pi-stacking') {
                resid2Residhash = ic.resid2ResidhashPistacking;
                color = me.htmlCls.pistackingColor;
                value = me.htmlCls.pistackingValue;
            }
            for(let resid1 in resid2Residhash) {
                let resid1Real = ic.getGraphCls.convertLabel2Resid(resid1);
                let atom1 = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid1Real]);
                let color1 = (atom1.color) ? atom1.color.getHexString() : '';
                for(let resid2 in resid2Residhash[resid1]) {
                    let resid2Real = ic.getGraphCls.convertLabel2Resid(resid2);
                    let atom2 = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid2Real]);
                    let color2 = (atom2.color) ? atom2.color.getHexString() : '';
                    let dist = Math.sqrt(resid2Residhash[resid1][resid2]).toFixed(1);
                    tmpText += '<tr><td><input type="checkbox" class="' + ic.pre + 'seloneres" id="' + ic.pre + interactionType + '_' +  cnt + 'a" resid="' + resid1 + '"/> ' + resid1 + colorText1 + color1 + colorText2 + '</td><td><input type="checkbox" class="' + ic.pre + 'seloneres" id="' + ic.pre + interactionType + '_' +  cnt + 'b" resid="' + resid2 + '"/> ' + resid2 + colorText1 + color2 + colorText2 + '</td><td align="center">' + dist + '</td>';
                    if(type == 'view') tmpText += '<td align="center"><button class="' + ic.pre + 'selres" resid="' + resid1 + '|' + resid2 + '">Highlight</button></td>';
                    tmpText += '</tr>';
                    ++cnt;
                }
            }
            let text = '<div style="text-align:center"><br><b>' + cnt
              + ' ' + interactionType + ' pairs</b>:</div><br>';
            if(cnt > 0) {
                text += '<br><table align=center border=1 cellpadding=10 cellspacing=0>'
                  + '<tr><th>Atom 1</th><th>Atom 2</th><th>Distance(&#8491;)</th>';
                if(type == 'view') text += '<th align="center">Highlight in 3D</th>';
                text += '</tr>';
                text += tmpText;
                text += '</table><br/>';
            }
            if(type == 'graph' || type == 'linegraph' || type == 'scatterplot') {
                let hbondStr = ic.getGraphCls.getGraphLinks(resid2Residhash, resid2Residhash, color, labelType, value);
                return hbondStr;
            }
            else {
                return text;
            }
        }
        exportSpherePairs(bInteraction, type, labelType) {var ic = this.icn3d, me = ic.icn3dui;
            let tmpText = '';
            let cnt = 0;
            let residHash =(bInteraction) ? ic.resid2ResidhashInteractions : ic.resid2ResidhashSphere;
            let colorText1 = ' <span style="background-color:#';
            let colorText2 = '">&nbsp;&nbsp;&nbsp;</span>';
            for(let resid1 in residHash) { // e.g., resid1: TYR $1KQ2.A:42
                let resid1Real = ic.getGraphCls.convertLabel2Resid(resid1);
                let atom1 = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid1Real]);
                let color1 = (atom1.color) ? atom1.color.getHexString() : '';
                for(let resid2 in residHash[resid1]) {
                    let resid2Real = ic.getGraphCls.convertLabel2Resid(resid2);
                    let atom2 = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid2Real]);
                    let color2 = (atom2.color) ? atom2.color.getHexString() : '';
                    let dist1_dist2_atom1_atom2 = residHash[resid1][resid2].split('_');
                    let dist1 = dist1_dist2_atom1_atom2[0];
                    let dist2 = dist1_dist2_atom1_atom2[1];
                    atom1 = dist1_dist2_atom1_atom2[2];
                    atom2 = dist1_dist2_atom1_atom2[3];
                    let contactCnt = dist1_dist2_atom1_atom2[4];
                    if(bInteraction) {
                        tmpText += '<tr><td><input type="checkbox" class="' + ic.pre + 'seloneres" id="' + ic.pre + 'inter_' +  cnt + 'a" resid="' + resid1 + '"/> ' + resid1 + '@' + atom1 + colorText1 + color1 + colorText2 + '</td><td><input type="checkbox" class="' + ic.pre + 'seloneres" id="' + ic.pre + 'inter_' +  cnt + 'b" resid="' + resid2 + '"/> ' + resid2 + '@' + atom2 + colorText1 + color2 + colorText2 + '</td><td align="center">' + contactCnt + '</td><td align="center">' + dist1 + '</td><td align="center">' + dist2 + '</td>';
                        if(type == 'view') tmpText += '<td align="center"><button class="' + ic.pre + 'selres" resid="' + resid1 + '|' + resid2 + '">Highlight</button></td>';
                        tmpText += '</tr>';
                    }
                    else {
                        tmpText += '<tr><td>' + resid1 + '</td><td>' + resid2 + '</td><td align="center">' + contactCnt + '</td><td align="center">' + dist1 + '</td><td align="center">' + dist2 + '</td></tr>';
                    }
                    ++cnt;
                }
            }
            let nameStr =(bInteraction) ? "the contacts" : "sphere";
            let text = '<div style="text-align:center"><br><b>' + cnt
              + ' residue pairs in ' + nameStr + '</b>:</div><br>';
            if(cnt > 0) {
                if(bInteraction) {
                    text += '<br><table align=center border=1 cellpadding=10 cellspacing=0>'
                      + '<tr><th>Residue 1</th><th>Residue 2</th><th align="center">Num Contacts</th><th align="center">Min Distance(&#8491;)</th><th align="center">C-alpha Distance(&#8491;)</th>';
                    if(type == 'view') text += '<th align="center">Highlight in 3D</th>';
                    text += '</tr>';
                }
                else {
                    text += '<br><table align=center border=1 cellpadding=10 cellspacing=0>'
                      + '<tr><th>Residue 1</th><th>Residue 2</th><th align="center">Num Contacts</th><th align="center">Min Distance(&#8491;)</th><th align="center">C-alpha Distance(&#8491;)</th></tr>';
                }
                text += tmpText;
                text += '</table><br/>';
            }
            if(type == 'graph' || type == 'linegraph' || type == 'scatterplot'
              || type == 'calpha' || type == 'cbeta' || type == 'heavyatoms') {
                let interStr = ic.getGraphCls.getGraphLinks(residHash, residHash, me.htmlCls.contactColor, labelType, me.htmlCls.contactValue);
                return interStr;
            }
            else {
                return text;
            }
        }

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class DrawGraph {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        drawGraph(jsonStr, divid) { var ic = this.icn3d, me = ic.icn3dui;
            //function createV4SelectableForceDirectedGraph(svg, graph) {
            // if both d3v3 and d3v4 are loaded, we'll assume
            // that d3v4 is called d3v4, otherwise we'll assume
            // that d3v4 is the default (d3)
            if (typeof d3v4 == 'undefined')
                var d3v4 = d3;

            //if(ic.bRender !== true) return;

            var graph = JSON.parse(jsonStr);

            //var width = +svg.attr("width"),
            //    height = +svg.attr("height");

            var width = $("#" + divid).width();
            var height = $("#" + divid).height();

            var widthView = (!isNaN(width)) ? width * 1.0 : 300;
            var heightView = (!isNaN(height)) ? height * 1.0 : 300;

            var parentWidth = width;
            var parentHeight = height;

            //    var svg = d3v4.select('svg')
            //    .attr('width', parentWidth)
            //    .attr('height', parentHeight)

            var svg = d3.select("#" + me.svgid)
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", "0,0," + widthView + "," + heightView);

            // remove any previous graphs
            svg.selectAll('.g-main').remove();
            // added
            //$("#" + me.svgid).empty();

            var gMain = svg.append('g')
                .classed('g-main', true);

            var rect = gMain.append('rect')
                .attr('width', parentWidth)
                .attr('height', parentHeight)
                .style('fill', '#FFF');

            var gDraw = gMain.append('g');

            var zoom = d3v4.zoom()
                .on('zoom', zoomed);

            gMain.call(zoom);


            function zoomed() {
                gDraw.attr('transform', d3v4.event.transform);
            }

            //var color = d3v4.scaleOrdinal(d3v4.schemeCategory20);

            if (!(graph.links)) {
                console.log("Graph is missing links");
                return;
            }

            // clean graph.links
            var linkArray = [];

            var nodeHash = {};
            for (var i = 0, il = graph.nodes.length; i < il; ++i) {
                var node = graph.nodes[i];
                nodeHash[node.id] = 1;
            }

            var bError = false;
            for (var i = 0, il = graph.links.length; i < il; ++i) {
                var link = graph.links[i];

                if (nodeHash.hasOwnProperty(link.source) && nodeHash.hasOwnProperty(link.target)) {
                    linkArray.push(link);
                } else {
                    if (!nodeHash.hasOwnProperty(link.source)) {
                        console.log("The node " + link.source + " is not found... ");
                    }
                    if (!nodeHash.hasOwnProperty(link.target)) {
                        console.log("The node " + link.target + " is not found... ");
                    }

                    bError = true;
                }
            }

            if (bError) console.log(JSON.stringify(graph));

            graph.links = linkArray;

            var nodes = {};
            var i;
            for (i = 0; i < graph.nodes.length; i++) {
                // enlarge the distance when no force
                if (!me.htmlCls.force) {
                    graph.nodes[i].x *= 10;
                    graph.nodes[i].y *= 10;
                }
                nodes[graph.nodes[i].id] = graph.nodes[i];
                graph.nodes[i].weight = 1.01;
            }

            // remove the internal edges when no force
            if (me.htmlCls.hideedges && !me.htmlCls.force) {
                var links2 = [];
                for (i = 0; i < graph.links.length; i++) {
                    if (graph.links[i].c != 'FFF') {
                        links2.push(graph.links[i]);
                    }
                }

                graph.links = links2;
            }

            // the brush needs to go before the nodes so that it doesn't
            // get called when the mouse is over a node
            var gBrushHolder = gDraw.append('g');
            var gBrush = null;

            var link = gDraw.append("g")
                .attr("class", "link")
                .selectAll("line")
                .data(graph.links)
                .enter().append("line")
                //.attr("stroke", function(d) { return "#" + d.c; })
                .attr("stroke", function(d) {
                    if (d.v == me.htmlCls.contactInsideValue) return "#" + me.htmlCls.contactInsideColor;
                    else if (d.v == me.htmlCls.hbondInsideValue) return "#" + me.htmlCls.hbondInsideColor;
                    else if (d.v == me.htmlCls.ionicInsideValue) return "#" + me.htmlCls.ionicInsideColor;
                    else if (d.v == me.htmlCls.halogenInsideValue) return "#" + me.htmlCls.halogenInsideColor;
                    else if (d.v == me.htmlCls.picationInsideValue) return "#" + me.htmlCls.picationInsideColor;
                    else if (d.v == me.htmlCls.pistackingInsideValue) return "#" + me.htmlCls.pistackingInsideColor;
                    else return "#" + d.c;
                })
                .attr("stroke-width", function(d) {
                    if (d.v == me.htmlCls.contactValue || d.v == me.htmlCls.contactInsideValue ||
                        d.v == me.htmlCls.hbondInsideValue || d.v == me.htmlCls.ionicInsideValue ||
                        d.v == me.htmlCls.halogenInsideValue || d.v == me.htmlCls.picationInsideValue ||
                        d.v == me.htmlCls.pistackingInsideValue) return "1px";
                    else if (d.v == me.htmlCls.hbondValue || d.v == me.htmlCls.ionicValue ||
                        d.v == me.htmlCls.halogenValue || d.v == me.htmlCls.picationValue ||
                        d.v == me.htmlCls.pistackingValue) return "2px";
                    else if (d.v == me.htmlCls.ssbondValue || d.v == me.htmlCls.clbondValue) return "3px";
                    else return d.v + "px";
                });

            var allNodes = gDraw.append("g")
                .attr("class", "node");

            var node = allNodes.selectAll("circle")
                .data(graph.nodes)
                //.attr("cx", function(d){return d.x})
                //.attr("cy", function(d){return d.y})
                .enter().append("circle")
                .attr("r", 3) //5)
                .attr("fill", function(d) { return "#" + d.c; })
                .attr("stroke", function(d) { return "#" + d.c; })
                .attr("res", function(d) { return d.r; })
                .attr("class", "icn3d-node")
                .call(d3v4.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            var label = allNodes.selectAll("text")
                .data(graph.nodes)
                .enter().append("text")
                .text(function(d) {
                    var idStr = d.id;
                    var pos = idStr.indexOf('.');
                    if (pos !== -1) idStr = idStr.substr(0, pos);
                    return idStr;
                })
                //.style("stroke", function(d) { return "#" + d.c; })
                .attr("fill", function(d) { return "#" + d.c; })
                .attr("stroke", "none")
                .attr("class", "icn3d-node-text8");
            //.style("font-size", "8px")
            //.style("font-weight", "bold")
            //.attr("x", function(d){return d.x + 6})
            //.attr("y", function(d){return d.y + 3})

            // add titles for mouseover blurbs
            node.append("title")
                .text(function(d) { return d.id; });

            var dist_ss = parseInt($("#" + ic.pre + "dist_ss").val());
            var dist_coil = parseInt($("#" + ic.pre + "dist_coil").val());
            var dist_hbond = parseInt($("#" + ic.pre + "dist_hbond").val());
            var dist_inter = parseInt($("#" + ic.pre + "dist_inter").val());
            var dist_ssbond = parseInt($("#" + ic.pre + "dist_ssbond").val());
            var dist_ionic = parseInt($("#" + ic.pre + "dist_ionic").val());

            var dist_halogen = parseInt($("#" + ic.pre + "dist_halogen").val());
            var dist_pication = parseInt($("#" + ic.pre + "dist_pication").val());
            var dist_pistacking = parseInt($("#" + ic.pre + "dist_pistacking").val());

            me.htmlCls.simulation = d3v4.forceSimulation()
                .force("link", d3v4.forceLink()
                    .id(function(d) { return d.id; })
                    .distance(function(d) {
                        //var dist = 20 / d.value;
                        //return dist;

                        return 30;
                    })
                    .strength(function(d) {
                        if (!me.htmlCls.force) {
                            return 0;
                        } else {
                            //return 1 / Math.min(count(d.source), count(d.target));

                            // larger distance means more relaxed
                            if (d.v == me.htmlCls.ssValue) { // secondary
                                return !isNaN(dist_ss) ? dist_ss / 100.0 : 1;
                            } else if (d.v == me.htmlCls.coilValue || d.v == me.htmlCls.clbondValue) { // coil
                                return !isNaN(dist_coil) ? dist_coil / 100.0 : 0.5;
                            } else if (d.v == me.htmlCls.hbondValue || d.v == me.htmlCls.hbondInsideValue) { // hydrogen bonds
                                return !isNaN(dist_hbond) ? dist_hbond / 100.0 : 0.5;
                            } else if (d.v == me.htmlCls.contactValue || d.v == me.htmlCls.contactInsideValue) { // interactions
                                return !isNaN(dist_inter) ? dist_inter / 100.0 : 0.25;
                            } else if (d.v == me.htmlCls.ssbondValue) { // hydrogen bonds
                                return !isNaN(dist_ssbond) ? dist_ssbond / 100.0 : 0.5;
                            } else if (d.v == me.htmlCls.ionicValue || d.v == me.htmlCls.ionicInsideValue) { // ionic interaction
                                return !isNaN(dist_ionic) ? dist_ionic / 100.0 : 0.5;
                            } else if (d.v == me.htmlCls.halogenValue || d.v == me.htmlCls.halogenInsideValue) {
                                return !isNaN(dist_halogen) ? dist_halogen / 100.0 : 0.5;
                            } else if (d.v == me.htmlCls.picationValue || d.v == me.htmlCls.picationInsideValue) {
                                return !isNaN(dist_pication) ? dist_pication / 100.0 : 0.5;
                            } else if (d.v == me.htmlCls.pistackingValue || d.v == me.htmlCls.pistackingInsideValue) {
                                return !isNaN(dist_pistacking) ? dist_pistacking / 100.0 : 0.5;
                            } else {
                                return 0;
                            }
                        } // else
                    })
                )
                .force("center", d3v4.forceCenter(parentWidth / 2, parentHeight / 2));

            if (me.htmlCls.force) {
                me.htmlCls.simulation.force("charge", d3v4.forceManyBody());
            }

            //me.htmlCls.simulation.force("x", d3v4.forceX(parentWidth/2))
            //    .force("y", d3v4.forceY(parentHeight/2));

            if (me.htmlCls.force == 1) { // x-axis
                me.htmlCls.simulation.force("x", d3v4.forceX(function(d) {
                        if (d.s == 'a') {
                            return parentWidth / 4;
                        } else {
                            return parentWidth * 0.75;
                        }
                    }).strength(function(d) { return 0.4; }))
                    .force("y", d3v4.forceY(parentHeight / 2).strength(function(d) { return 0.02; }));

            } else if (me.htmlCls.force == 2) { // y-axis
                me.htmlCls.simulation.force("y", d3v4.forceY(function(d) {
                        if (d.s == 'a') {
                            return parentHeight * 0.75;
                        } else {
                            return parentHeight / 4;
                        }
                    }).strength(function(d) { return 0.4; }))
                    .force("x", d3v4.forceX(parentWidth / 2).strength(function(d) { return 0.02; }));
            } else if (me.htmlCls.force == 3) { // circle
                me.htmlCls.simulation.force("r", d3v4.forceRadial(function(d) {
                    if (d.s == 'a') {
                        return 200;
                    } else {
                        return 100;
                    }

                }, parentWidth / 2, parentHeight / 2).strength(function(d) { return 0.8; }));
            } else if (me.htmlCls.force == 4) ;

            me.htmlCls.simulation
                .nodes(graph.nodes)
                .on("tick", ticked);

            me.htmlCls.simulation.force("link")
                .links(graph.links);

            //    me.htmlCls.simulation.stop();
            //    me.htmlCls.simulation.restart();

            function ticked() {
                // update node and line positions at every step of
                // the force me.htmlCls.simulation
                link.attr("x1", function(d) { var ret = d.source.x; return !isNaN(ret) ? ret : 0; })
                    .attr("y1", function(d) { var ret = parentHeight - d.source.y; return !isNaN(ret) ? ret : 0; })
                    .attr("x2", function(d) { var ret = d.target.x; return !isNaN(ret) ? ret : 0; })
                    .attr("y2", function(d) { var ret = parentHeight - d.target.y; return !isNaN(ret) ? ret : 0; });

                node.attr("cx", function(d) { var ret = d.x; return !isNaN(ret) ? ret : 0; })
                    .attr("cy", function(d) { var ret = parentHeight - d.y; return !isNaN(ret) ? ret : 0; });

                label.attr("x", function(d) { var ret = d.x + 6; return !isNaN(ret) ? ret : 0; })
                    .attr("y", function(d) { var ret = parentHeight - (d.y + 3); return !isNaN(ret) ? ret : 0; });

            }

            var brushMode = false;
            var brushing = false;

            var brush = d3v4.brush()
                .on("start", brushstarted)
                .on("brush", brushed)
                .on("end", brushended);

            function brushstarted() {
                // keep track of whether we're actively brushing so that we
                // don't remove the brush on keyup in the middle of a selection
                brushing = true;

                node.each(function(d) {
                    d.previouslySelected = ctrlKey && d.selected;
                });
            }

            rect.on('click', function() {
                node.each(function(d) {
                    d.selected = false;
                    d.previouslySelected = false;
                });
                node.classed("selected", false);
            });

            function brushed() {
                if (!d3v4.event.sourceEvent) return;
                if (!d3v4.event.selection) return;

                var extent = d3v4.event.selection;

                node.classed("selected", function(d) {
                    return d.selected = d.previouslySelected ^
                        (extent[0][0] <= d.x && d.x < extent[1][0] &&
                            extent[0][1] <= parentHeight - d.y && parentHeight - d.y < extent[1][1]);
                });
            }

            function brushended() {
                if (!d3v4.event.sourceEvent) return;
                if (!d3v4.event.selection) return;
                if (!gBrush) return;

                gBrush.call(brush.move, null);

                if (!brushMode) {
                    // the shift key has been release before we ended our brushing
                    gBrush.remove();
                    gBrush = null;
                }

                brushing = false;
            }

            d3v4.select('body').on('keydown', keydown);
            d3v4.select('body').on('keyup', keyup);

            var ctrlKey;

            function keydown() {
                ctrlKey = d3v4.event.ctrlKey;

                if (ctrlKey) {
                    // if we already have a brush, don't do anything
                    if (gBrush)
                        return;

                    brushMode = true;

                    if (!gBrush) {
                        gBrush = gBrushHolder.append('g');
                        gBrush.call(brush);
                    }
                }
            }

            function keyup() {
                ctrlKey = false;
                brushMode = false;

                if (!gBrush)
                    return;

                if (!brushing) {
                    // only remove the brush if we're not actively brushing
                    // otherwise it'll be removed when the brushing ends
                    gBrush.remove();
                    gBrush = null;
                }
            }

            function dragstarted(d) {
                if (!d3v4.event.active) me.htmlCls.simulation.alphaTarget(0.9).restart();

                if (!d.selected && !ctrlKey) {
                    // if this node isn't selected, then we have to unselect every other node
                    node.classed("selected", function(p) {
                        return p.selected = p.previouslySelected = false;
                    });
                }

                d3v4.select(this).classed("selected", function(p) { d.previouslySelected = d.selected; return d.selected = true; });

                node.filter(function(d) { return d.selected; })
                    .each(function(d) { //d.fixed |= 2;
                        d.fx = d.x;
                        d.fy = d.y;
                    });

            }

            function dragged(d) {
                //d.fx = d3v4.event.x;
                //d.fy = d3v4.event.y;
                node.filter(function(d) { return d.selected; })
                    .each(function(d) {
                        d.fx += d3v4.event.dx;
                        d.fy -= d3v4.event.dy; // += d3v4.event.dy;
                    });
            }

            function dragended(d) {
                if (!d3v4.event.active) me.htmlCls.simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
                node.filter(function(d) { return d.selected; })
                    .each(function(d) { //d.fixed &= ~6;
                        d.fx = null;
                        d.fy = null;
                    });
            }

            return graph;
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class ContactMap {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        async contactMap(contactDist, type) { let ic = this.icn3d; ic.icn3dui;
           let nameArray = ['selected'];
           let nameArray2 = ['selected'];
           if(nameArray2.length == 0) {
               alert("Please select the first set");
           }
           else {
               ic.definedSetsCls.setMode('selection');
               let bHbond = false;
               let bSaltbridge = false;
               let bInteraction = true;
               let bHalogen = false;
               let bPication = false;
               let bPistacking = false;
               await ic.viewInterPairsCls.viewInteractionPairs(nameArray2, nameArray, false, type,
                    bHbond, bSaltbridge, bInteraction, bHalogen, bPication, bPistacking, contactDist);
           }
        }

        async afErrorMap(afid, bFull) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            me.htmlCls.dialogCls.openDlg('dl_alignerrormap', 'Show Predicted Aligned Error (PAE) map');
        
            let url = "https://alphafold.ebi.ac.uk/files/AF-" + afid + "-F1-predicted_aligned_error_" + ic.AFUniprotVersion + ".json";

            let data = await me.getAjaxPromise(url, 'json', false, 'There are some problems in loading the PAE file...');

            thisClass.processAfErrorMap(data, bFull);
        }

        processAfErrorMap(dataJson, bFull) { let ic = this.icn3d, me = ic.icn3dui;
            // json format: [{"residue1": [1, ..., 1, ..., n, ..., n], "residue2": [1, 2, ..., n, ..., 1, 2, ..., n], 
            // "distance": [n*n matrix],"max_predicted_aligned_error":31.75}]
            //let distMatrix = dataJson[0].distance; // version 2, one dimension
            let data = (dataJson[0]) ? dataJson[0] : dataJson; // dataJson[0] is from AlphaFold UniProt database
            let distMatrix = data.predicted_aligned_error || data.pae; // version 3, two dimensions 
            let max = data.max_predicted_aligned_error || data.max_pae; // max_predicted_aligned_error is from AlphaFold UniProt database

            if(!distMatrix || !max) {
                alert("The PAE file didn't have the right format...");
                return;
            }

            // generate lineGraphStr
            // e.g.,  {"nodes": [{"id":"A1.A","r":"1_1_1TOP_A_1","s":"ab","x":1,"y":21,"c":"FF00FF"}, ...],
            // "links": [{"source": "A1.A", "target": "S2.A", "v": 3, "c": "FF00FF"}, ...]}
            let nodeStr = '"nodes": [', linkStr = '"links": [';
            let bNode = false, bLink = false;
            let postA = '', postB = '.';

            // initialize some parameters if no structure wasloaded yet
            let bStruData;
            if(!ic.chains || Object.keys(ic.chains).length == 0) {
                bStruData = false;
                ic.init_base();
            }
            else {
                bStruData = true;
            }

            //let chainidArray = Object.keys(ic.chains);
            //let chainid = (chainidArray.length == 1) ? chainidArray[0] : 'stru_A';

            //let dim = parseInt(Math.sqrt(distMatrix.length));
            let dim = distMatrix.length;

            // map index with residue number when the structure has multiple chains
            let index = 0;
            let index2resObj = {};
            for(let chainid in ic.chains) {
                for(let j = 0, jl = ic.chainsSeq[chainid].length; j < jl; ++j) {
                    index2resObj[index] = ic.chainsSeq[chainid][j];
                    index2resObj[index].chainid = chainid;
                    ++index;
                }
            }

            //for(let chainid in ic.chains) {
            //for(let i = 0, il = ic.chainsSeq[chainid].length; i < il; ++i) {
            index = 0;
            for(let i = 0; i < dim; ++i) {
                let resi = (bStruData) ? index2resObj[i].resi : i + 1;
                let resn = (bStruData) ? index2resObj[i].name : '*';
                let chainid = (bStruData) ? index2resObj[i].chainid : 'stru_A';

                let resid = chainid + '_' + resi;
                let atom = (ic.residues[resid]) ? ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid]) 
                    : {color: me.parasCls.thr(0x888888)};
                let chain = chainid.substr(chainid.indexOf('_') + 1);
                let color = atom.color.getHexString();

                if(bNode) nodeStr += ', ';
                let idStr = resn + resi + '.' + chain;
                nodeStr += '{"id":"' + idStr + postA + '","r":"1_1_' + resid + '","s":"a","c":"' + color + '"}\n';
                nodeStr += ', {"id":"' + idStr + postB + '","r":"1_1_' + resid + '","s":"b","c":"' + color + '"}';
                bNode = true;

                let start = (bFull) ? 0 : i; // full map, or half map

                //for(let j = 0, jl = ic.chainsSeq[chainid].length; j < jl; ++j) {
                //for(let j = 0; j < dim; ++j) {
                for(let j = start; j < dim; ++j) { 
                    index = i * dim + j;
                    let resi2 = (bStruData) ? index2resObj[j].resi : j + 1;
                    let resn2 = (bStruData) ? index2resObj[j].name : '*';
                    let chainid2 = (bStruData) ? index2resObj[j].chainid : 'stru_A';
                    let chain2 = chainid2.substr(chainid2.indexOf('_') + 1);

                    let idStr2 = resn2 + resi2 + '.' + chain2;
                    
                    // max dark green color 004d00, 0x4d = 77, 77/255 = 0.302
                    // 0: 004d00, max: FFFFFF
                    //let ratio = (distMatrix[index]) ? distMatrix[index] / max : 0;
                    let ratio = (distMatrix[i][j]) ? distMatrix[i][j] / max : 0;
                    let r = parseInt(ratio*255).toString(16);
                    let g = parseInt(((1.0 - 0.302)*ratio + 0.302) * 255).toString(16);
                    let rHex = (r.length == 1) ? '0' + r : r;
                    let gHex = (g.length == 1) ? '0' + g : g;
                    let bHex = rHex;
                    let color2 = rHex + gHex + bHex;

                    if(bLink) linkStr += ', ';
                    linkStr += '{"source": "' + idStr + postA + '", "target": "' + idStr2 + postB + '", "v": 11, "c": "' + color2 + '", "pae": ' + parseInt(distMatrix[i][j]) + '}\n';
                    bLink = true;
                }
            }
            //}

            dataJson = {};

            let lineGraphStr = '{' + nodeStr + '], ' + linkStr + ']}';
            let bAfMap = true;
            this.drawContactMap(lineGraphStr, bAfMap, max);    
            
            /// if(ic.deferredAfmap !== undefined) ic.deferredAfmap.resolve();
        }

        drawContactMap(lineGraphStr, bAfMap, max) { let ic = this.icn3d, me = ic.icn3dui;
            let html, graph = JSON.parse(lineGraphStr);
            let linkArray = graph.links;

            let nodeArray1 = [], nodeArray2 = [];
            let name2node = {};
            for(let i = 0, il = graph.nodes.length; i < il; ++i) {
                let node = graph.nodes[i];
                if(!node) continue;

                name2node[node.id] = node;

                if(node.s == 'a') {
                    nodeArray1.push(node);
                }
                else if(node.s == 'b') {
                    nodeArray2.push(node);
                }
                else if(node.s == 'ab') {
                    nodeArray1.push(node);
                    nodeArray2.push(node);
                }
            }

            // sort array
            nodeArray1.sort(function(a,b) {
              return ic.getGraphCls.compNode(a, b);
            });
            nodeArray2.sort(function(a,b) {
              return ic.getGraphCls.compNode(a, b);
            });

            let graphStr = '{\n';

            let struc1 = (Object.keys(ic.structures).length > 0) ? ic.structures[0] : ic.defaultPdbId;
            let len1 = nodeArray1.length,
                len2 = nodeArray2.length;
            let factor = 1;
            let r = 3 * factor;
            let gap = 7 * factor;
            let width, heightAll;
            let marginX = 10,
                marginY = 10,
                legendWidth = 30;
            heightAll =(len1 + 2) *(r + gap) + 2 * marginY + legendWidth;
            width =(len2 + 2) *(r + gap) + 2 * marginX + legendWidth;

            let id, graphWidth;
            if(bAfMap) {
                ic.alignerrormapWidth = 2 * width;
                graphWidth = ic.alignerrormapWidth;
                id = me.alignerrormapid;
            }
            else {
                ic.contactmapWidth = 2 * width;
                graphWidth = ic.contactmapWidth;
                id = me.contactmapid;
            }

            html =(linkArray.length > 0) ? "" : "No interactions found for these two sets<br><br>";
            html += "<svg xmlns='http://www.w3.org/2000/svg' id='" + id + "' viewBox='0,0," + width + "," + heightAll + "' width='" + graphWidth + "px'>";
            let bContactMap = true;

            if(bAfMap) { // cleaned the code by using "use" in SVG, but didn't improve rendering

                ic.hex2id = {};
                let threshold = 29.0 / max;
                ic.hex2skip = {}; // do not display any error larger than 29 angstrom
                let nRef = 1000;
                for(let i = 0; i < nRef; ++i) {
                    let ratio = 1.0 * i / nRef;
                    let r = parseInt(ratio*255).toString(16);
                    let g = parseInt(((1.0 - 0.302)*ratio + 0.302) * 255).toString(16);
                    let rHex = (r.length == 1) ? '0' + r : r;
                    let gHex = (g.length == 1) ? '0' + g : g;
                    let bHex = rHex;
                    let color = rHex + gHex + bHex;

                    let idRect = me.pre + "afmap_" + i;

                    ic.hex2id[color] = idRect;
                    if(ratio > threshold) {
                        ic.hex2skip[color] = idRect;
                    }
                    
                    //html += "<g id='" + id + "'>";
    //                html += "<rect id='" + idRect + "' x='0' y='0' width='" + rectSize + "' height='" + rectSize + "' fill='" 
    //                    + strokecolor + "' stroke-width='" + linestrokewidth + "' stroke='" + strokecolor + "' />";
                    //html += "</g>"
                }
    //            html += "</defs>";
            }

            html += ic.lineGraphCls.drawScatterplot_base(nodeArray1, nodeArray2, linkArray, name2node, 0, bContactMap, undefined, undefined, bAfMap);
            graphStr += ic.getGraphCls.updateGraphJson(struc1, 1, nodeArray1, nodeArray2, linkArray);
            html += "</svg>";

            graphStr += '}\n';
            if(bAfMap) {
                ic.alignerrormapStr = graphStr;
                $("#" + ic.pre + "alignerrormapDiv").html(html);
      
                let scale = $("#" + me.alignerrormapid + "_scale").val();
                $("#" + me.alignerrormapid).attr("width",(ic.alignerrormapWidth * parseFloat(scale)).toString() + "px");
            }
            else {
                ic.contactmapStr = graphStr;
                $("#" + ic.pre + "contactmapDiv").html(html);
            }

            return html;
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class AlignParser {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Load the VAST+ structure alignment for the pair of structures "align", e.g., "align" could be "1HHO,4N7N".
        async downloadAlignment(align, bDiagramOnly) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            ic.opts['proteins'] = 'c alpha trace';

            let alignArray = align.split(',');
            //var ids_str =(alignArray.length === 2? 'uids=' : 'ids=') + align;
            let ids_str = 'ids=' + align;

        //    let url2 = me.htmlCls.baseUrl + 'vastplus/vastplus.cgi?v=2&cmd=c&b=1&s=1&w3d&' + ids_str;
        //    let url2 = me.htmlCls.baseUrl + 'vastplus/vastplus.cgi?v=2&cmd=c&b=1&s=1&w3d&' + ids_str;
        //    let url1 = me.htmlCls.baseUrl + 'vastplus/vastplus.cgi?v=2&cmd=c1&b=1&s=1&d=1&' + ids_str;

            // combined url1 and url2
            let url2 = me.htmlCls.baseUrl + 'vastplus/vastplus.cgi?v=3&cmd=c&b=1&s=1&w3d&' + ids_str;

            if(me.cfg.inpara !== undefined) {
              //url1 += me.cfg.inpara;
              url2 += me.cfg.inpara;
            }

            //ic.bCid = undefined;

            // define for 'align' only
            ic.pdbid_chain2title = {};

            if(ic.chainids2resids === undefined) ic.chainids2resids = {}; // ic.chainids2resids[chainid1][chainid2] = [resid, resid]

            let seqalign = {};

            let errMess = "These two MMDB IDs " + alignArray + " do not have 3D alignment data in the VAST+ database. You can try the VAST alignment by visiting the VAST+ page https://www.ncbi.nlm.nih.gov/Structure/vastplus/vastplus.cgi?uid=[PDB ID] (e.g., uid=1KQ2), and clicking \"Original VAST\"";

            let data = await me.getAjaxPromise(url2, 'jsonp', true, errMess);

            seqalign = data.seqalign;
            if(seqalign === undefined) {
                alert(errMess);
                return false;
            }

            // set ic.pdbid_molid2chain and ic.chainsColor
            ic.pdbid_molid2chain = {};
            ic.chainsColor = {};
            //ic.mmdbidArray = [];
            //for(let i in data) {

            for(let i = 0, il = 2; i < il; ++i) {
                //if(i === 'seqalign') continue;
                let mmdbTmp = data['alignedStructures'][0][i];

                //var pdbid =(data[i].pdbid !== undefined) ? data[i].pdbid : i;
                let pdbid =(mmdbTmp.pdbId !== undefined) ? mmdbTmp.pdbId : mmdbTmp.mmdbId;
                //ic.mmdbidArray.push(pdbid); // here two molecules are in alphabatic order, themaster molecule could not be the first one

                let chainNameHash = {}; // chain name may be the same in assembly
                //for(let molid in mmdbTmp.molecules) {
                for(let j = 0, jl = mmdbTmp.molecules.length; j < jl; ++j) {
                    let molecule = mmdbTmp.molecules[j];
                    let molid = molecule.moleculeId;
                    let chainName = molecule.chain.trim().replace(/_/g, ''); // change "A_1" to "A1"
                    if(chainNameHash[chainName] === undefined) {
                        chainNameHash[chainName] = 1;
                    }
                    else {
                        ++chainNameHash[chainName];
                    }

                    let finalChain =(chainNameHash[chainName] === 1) ? chainName : chainName + chainNameHash[chainName].toString();

                    ic.pdbid_molid2chain[pdbid + '_' + molid] = finalChain;

                    if(molecule.kind === 'p' || molecule.kind === 'n') {
                        ic.chainsColor[pdbid + '_' + finalChain] = me.parasCls.thr(me.htmlCls.GREY8);
                    }
                }
            }

            //var index = 0;
            //for(let mmdbid in data) {
            ic.mmdbidArray = [];
            for(let i = 0, il = 2; i < il; ++i) {
                //if(index < 2) {
                    let mmdbTmp = data['alignedStructures'][0][i];

                    let pdbid = mmdbTmp.pdbId;
                    ic.mmdbidArray.push(pdbid);

                    let molecule = mmdbTmp.molecules;
                    for(let molname in molecule) {
                        let chain = molecule[molname].chain;
                        ic.pdbid_chain2title[pdbid + '_' + chain] = molecule[molname].name;
                    }
                //}

                //++index;
            }

            // get the color for each aligned chain pair
            ic.alignmolid2color = [];
            //ic.alignmolid2color[0] = {}
            //ic.alignmolid2color[1] = {}
            me.parasCls.stdChainColors.length;

            for(let i = 0, il = seqalign.length; i < il; ++i) {
                let molid1 = seqalign[i][0].moleculeId;
                let molid2 = seqalign[i][1].moleculeId;

                //ic.alignmolid2color[0][molid1] =(i+1).toString();
                //ic.alignmolid2color[1][molid2] =(i+1).toString();

                let tmpHash = {};
                tmpHash[molid1] =(i+1).toString();
                ic.alignmolid2color.push(tmpHash);

                tmpHash = {};
                tmpHash[molid2] =(i+1).toString();
                ic.alignmolid2color.push(tmpHash);
            }

            if(!bDiagramOnly) {
                //var url3 = me.htmlCls.baseUrl + "mmdb/mmdb_strview.cgi?v=2&program=icn3d&b=1&s=1&ft=1&bu=" + me.cfg.bu + "&atomonly=1&uid=" + ic.mmdbidArray[0];
                //var url4 = me.htmlCls.baseUrl + "mmdb/mmdb_strview.cgi?v=2&program=icn3d&b=1&s=1&ft=1&bu=" + me.cfg.bu + "&atomonly=1&uid=" + ic.mmdbidArray[1];
                // need the parameter moleculeInfor
                let url3 = me.htmlCls.baseUrl + "mmdb/mmdb_strview.cgi?v=2&program=icn3d&b=1&s=1&ft=1&bu=" + me.cfg.bu + "&uid=" + ic.mmdbidArray[0];
                let url4 = me.htmlCls.baseUrl + "mmdb/mmdb_strview.cgi?v=2&program=icn3d&b=1&s=1&ft=1&bu=" + me.cfg.bu + "&uid=" + ic.mmdbidArray[1];

                let d3 = me.getAjaxPromise(url3, 'jsonp', true);
                let d4 = me.getAjaxPromise(url4, 'jsonp', true);

                let allPromise = Promise.allSettled([d3, d4]);

                let dataArray = await allPromise;

                let data2 = data;
                // let data3 = (me.bNode) ? dataArray[0] : dataArray[0].value; //v3[0];
                // let data4 = (me.bNode) ? dataArray[1] : dataArray[1].value; //v4[0];
                let data3 = dataArray[0].value; //v3[0];
                let data4 = dataArray[1].value; //v4[0];

                if(data3.atoms !== undefined && data4.atoms !== undefined) {
                    // ic.deferredOpm = $.Deferred(function() {
                        //ic.mmdbidArray = [];
                        //for(let i = 0, il = data.alignedStructures[0].length; i < il; ++i) {
                        //    ic.mmdbidArray.push(data.alignedStructures[0][i].pdbId);
                        //}

                        ic.ParserUtilsCls.setYourNote((ic.mmdbidArray[0] + ',' + ic.mmdbidArray[1]).toUpperCase() + '(VAST+) in iCn3D');

                        // get transformation factors
                        let factor = 1; //10000;
                        //var scale = data2.transform.scale / factor;
                        let tMaster = data2.transform.translate.master;
                        let tMVector = new THREE.Vector3(tMaster[0] / factor, tMaster[1] / factor, tMaster[2] / factor);
                        let tSlave = data2.transform.translate.slave;
                        let tSVector = new THREE.Vector3(tSlave[0] / factor, tSlave[1] / factor, tSlave[2] / factor);
                        let rotation = data2.transform.rotate;
                        let rMatrix = [];
                        for(let i = 0, il = rotation.length; i < il; ++i) { // 9 elements
                            rMatrix.push(rotation[i] / factor);
                        }

                        // get sequence
                        ic.chainid2seq = {};
                        for(let chain in data3.sequences) {
                            let chainid = ic.mmdbidArray[0] + '_' + chain;
                            ic.chainid2seq[chainid] = data3.sequences[chain]; // ["0","D","ASP"],
                        }
                        for(let chain in data4.sequences) {
                            let chainid = ic.mmdbidArray[1] + '_' + chain;
                            ic.chainid2seq[chainid] = data4.sequences[chain]; // ["0","D","ASP"],
                        }

                        // atoms
                        let atomsM = data3.atoms;
                        let atomsS = data4.atoms;

                        // fix serialInterval
                        let nAtom1 = data3.atomCount;
                        let nAtom2 = data4.atomCount;

                        for(let i = 0, il = data2.alignedStructures[0].length; i < il; ++i) {
                        let structure = data2.alignedStructures[0][i];

                        structure.serialInterval = [];
                        if(i == 0) {
                            structure.serialInterval.push(1);
                            structure.serialInterval.push(nAtom1);
                        }
                        else if(i == 1) {
                            structure.serialInterval.push(nAtom1 + 1);
                            structure.serialInterval.push(nAtom1 + nAtom2);
                        }
                        }

                        let allAtoms = {};
                        for(let i in atomsM) {
                            let atm = atomsM[i];

                            atm.coord = new THREE.Vector3(atm.coord[0], atm.coord[1], atm.coord[2]);
                            atm.coord.add(tMVector);

                            let x = atm.coord.x * rMatrix[0] + atm.coord.y * rMatrix[1] + atm.coord.z * rMatrix[2];
                            let y = atm.coord.x * rMatrix[3] + atm.coord.y * rMatrix[4] + atm.coord.z * rMatrix[5];
                            let z = atm.coord.x * rMatrix[6] + atm.coord.y * rMatrix[7] + atm.coord.z * rMatrix[8];

                            atm.coord.x = x;
                            atm.coord.y = y;
                            atm.coord.z = z;

                            allAtoms[i] = atm;
                        }

                        for(let i in atomsS) {
                            let atm = atomsS[i];

                            atm.coord = new THREE.Vector3(atm.coord[0], atm.coord[1], atm.coord[2]);
                            atm.coord.add(tSVector);

                            // update the bonds
                            for(let j = 0, jl = atm.bonds.length; j < jl; ++j) {
                                atm.bonds[j] += nAtom1;
                            }

                            allAtoms[(parseInt(i) + nAtom1).toString()] = atm;
                        }

                        // combine data
                        let allData = {};
                        allData.alignedStructures = data2.alignedStructures;
                        allData.alignment = data2.alignment;
                        allData.atoms = allAtoms;

                        await thisClass.loadOpmDataForAlign(allData, seqalign, ic.mmdbidArray);
                    // });
                    // return ic.deferredOpm.promise();
                }
                else {
                    alert('invalid atoms data.');
                    return false;
                }
            }
        }

        async downloadAlignmentPart2(data, seqalign, chainresiCalphaHash2) { let ic = this.icn3d, me = ic.icn3dui;
            //ic.init();

            ic.loadAtomDataCls.loadAtomDataIn(data, undefined, 'align', seqalign);

            if(me.cfg.align === undefined && Object.keys(ic.structures).length == 1) {
                $("#" + ic.pre + "alternateWrapper").hide();
            }

            // show all
            let allAtoms = {};
            for(let i in ic.atoms) {
                allAtoms[i] = 1;
            }
            ic.dAtoms = allAtoms;
            ic.hAtoms = allAtoms;

            ic.setStyleCls.setAtomStyleByOptions(ic.opts);
            // change the default color to "Identity"
            ic.setColorCls.setColorByOptions(ic.opts, ic.atoms);

            // memebrane is determined by one structure. But transform both structures
            if(chainresiCalphaHash2 !== undefined) ic.ParserUtilsCls.transformToOpmOriForAlign(ic.selectedPdbid, chainresiCalphaHash2, true);

            await ic.ParserUtilsCls.renderStructure();

            if(me.cfg.rotate !== undefined) ic.resizeCanvasCls.rotStruc(me.cfg.rotate, true);

            ic.html2ddgm = '';

            // by default, open the seq alignment window
            //if(me.cfg.show2d !== undefined && me.cfg.show2d) me.htmlCls.dialogCls.openDlg('dl_2ddgm', 'Interactions');
            if(me.cfg.showalignseq) {
                me.htmlCls.dialogCls.openDlg('dl_alignment', 'Select residues in aligned sequences');
            }

            if(me.cfg.show2d && ic.bFullUi) {
                await ic.ParserUtilsCls.set2DDiagramsForAlign(ic.mmdbidArray[0].toUpperCase(), ic.mmdbidArray[1].toUpperCase());
            }

            //if(me.deferred !== undefined) me.deferred.resolve(); /// if(ic.deferred2 !== undefined) ic.deferred2.resolve();
        }

        async loadOpmDataForAlign(data, seqalign, mmdbidArray) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            try {
                let url = "https://opm-assets.storage.googleapis.com/pdb/" + mmdbidArray[0].toLowerCase()+ ".pdb";
                let prms1 = me.getAjaxPromise(url, 'text');
                let url2 = "https://opm-assets.storage.googleapis.com/pdb/" + mmdbidArray[1].toLowerCase()+ ".pdb";
                let prms2 = me.getAjaxPromise(url2, 'text');

                let allPromise = Promise.allSettled([prms1, prms2]);

                let dataArray = await allPromise;

                let bFound = false;
                for(let i = 0, il = dataArray.length; i < il; ++i) {
                    // if(dataArray[i].status == 'rejected') continue;

                    let opmdata = dataArray[i].value;
                    if(!opmdata) continue;

                    ic.selectedPdbid = mmdbidArray[i];

                    ic.bOpm = true;
                    let bVector = true;
                    let chainresiCalphaHash = ic.loadPDBCls.loadPDB(opmdata, mmdbidArray[i], ic.bOpm, bVector); // defined in the core library

                    $("#" + ic.pre + "selectplane_z1").val(ic.halfBilayerSize);
                    $("#" + ic.pre + "selectplane_z2").val(-ic.halfBilayerSize);

                    $("#" + ic.pre + "extra_mem_z").val(ic.halfBilayerSize);
                    $("#" + ic.pre + "intra_mem_z").val(-ic.halfBilayerSize);

                    ic.init(); // remove all previously loaded data

                    await thisClass.downloadAlignmentPart2(data, seqalign, chainresiCalphaHash);

                    bFound = true;

                    /// if(ic.deferredOpm !== undefined) ic.deferredOpm.resolve();

                    // use the first one with membrane
                    break;
                }

                if(!bFound) {
                    ic.init(); // remove all previously loaded data
                    await thisClass.downloadAlignmentPart2(data, seqalign);
                }
            }
            catch(err) {
                ic.init(); // remove all previously loaded data
                await thisClass.downloadAlignmentPart2(data, seqalign);

                /// if(ic.deferredOpm !== undefined) ic.deferredOpm.resolve();
                return;
            }
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class ChainalignParser {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        async downloadChainalignmentPart2(data1, data2Array, chainresiCalphaHash2, chainidArray) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            let hAtoms = {}, hAtomsTmp = {};
            let mmdbid_t, mmdbid_q;
            mmdbid_t = chainidArray[0].substr(0, chainidArray[0].indexOf('_'));
            let bLastQuery = false;
            if(mmdbid_t.length > 5) { 
                let bAppend = false, bNoDssp = true;
                hAtoms = await ic.pdbParserCls.loadPdbData(data1, mmdbid_t, false, bAppend, 'target', bLastQuery, bNoDssp);
            }
            else {
                let bNoSeqalign = true;
                hAtoms = await ic.mmdbParserCls.parseMmdbData(data1, 'target', chainidArray[0], 0, bLastQuery, bNoSeqalign);
            }

            for(let i = 0, il = data2Array.length; i < il; ++i) {
                if(i == data2Array.length - 1) bLastQuery = true;
                // each alignment has a chainIndex i
                mmdbid_q = chainidArray[i + 1].substr(0, chainidArray[i + 1].indexOf('_'));
                //mmdbid_q = (mmdbid_q_tmp.length == 5) ? mmdbid_q_tmp.substr(0, 4) : mmdbid_q_tmp; // added postfixfor same PDB IDs

                //if(mmdbid_q.length > 4) {
                if(mmdbid_q.length > 5) {  // PDB ID plus postfix could be 5 
                    let bAppend = true, bNoDssp = true;
                    hAtomsTmp = await ic.pdbParserCls.loadPdbData(data2Array[i], mmdbid_q, false, bAppend, 'query', bLastQuery, bNoDssp);
                }
                else {
                    let bNoSeqalign = true;
                    hAtomsTmp = await ic.mmdbParserCls.parseMmdbData(data2Array[i], 'query', chainidArray[i + 1], i, bLastQuery, bNoSeqalign);
                }
                hAtoms = me.hashUtilsCls.unionHash(hAtoms, hAtomsTmp);
            }

            if(me.cfg.resnum) {
                await ic.realignParserCls.realignChainOnSeqAlign(chainresiCalphaHash2, chainidArray);
            }
            else if(me.cfg.resdef) {
                await ic.realignParserCls.realignChainOnSeqAlign(chainresiCalphaHash2, chainidArray, undefined, true);
            }
            else {
                // calculate secondary structures with applyCommandDssp
                //$.when(ic.pdbParserCls.applyCommandDssp(true)).then(function() {
                    await ic.pdbParserCls.applyCommandDssp(true);
    //!!!
    /*
                    // original version =============
                    // align PDB chains
                    for(let index in ic.pdbChainIndexHash) {
                        //ic.pdbChainIndexHash[index] = mmdbid_q_tmp + "_" + ic.chain_q + "_" + ic.mmdbid_t + "_" + ic.chain_t;
                        let idArray = ic.pdbChainIndexHash[index].split('_');
                        mmdbid_q = idArray[0];
                        let chain_q = idArray[1];
                        mmdbid_t = idArray[2];
                        let chain_t = idArray[3];

                        thisClass.transformStructure(mmdbid_q, index-1, 'query');                
                    }

                    // dynamically align pairs in ic.afChainIndexHash
                    let ajaxArray = [], indexArray = [], struArray = [];
                    let urlalign = me.htmlCls.baseUrl + "vastdyn/vastdyn.cgi";
                    let urltmalign = me.htmlCls.baseUrl + "tmalign/tmalign.cgi";

                    let resRangeArray = (me.cfg.resrange) ? decodeURIComponent(me.cfg.resrange).split(' | ') : [];

                    for(let index in ic.afChainIndexHash) {
                        let idArray = ic.afChainIndexHash[index].split('_');
                        mmdbid_q = idArray[0];
                        let chain_q = idArray[1];
                        let chainid_q = mmdbid_q + '_' + chain_q;

                        mmdbid_t = idArray[2];
                        let chain_t = idArray[3];
                        let chainid_t = mmdbid_t + '_' + chain_t;

                        // let atomSet_t = (resRangeArray[0]) ? ic.realignParserCls.getSeqCoorResid(resRangeArray[0].split(','), chainid_t, true).hAtoms : ic.chains[chainid_t];
                        // let atomSet_q = (resRangeArray[index]) ? ic.realignParserCls.getSeqCoorResid(resRangeArray[index].split(','), chainid_q, true).hAtoms : ic.chains[chainid_q];
                        let atomSet_t = (resRangeArray[0]) ? ic.realignParserCls.getSeqCoorResid([resRangeArray[0]], chainid_t, true).hAtoms : ic.chains[chainid_t];
                        let atomSet_q = (resRangeArray[index]) ? ic.realignParserCls.getSeqCoorResid([resRangeArray[index]], chainid_q, true).hAtoms : ic.chains[chainid_q];
                    // end of original version =============
    */                

                    // new version to be done for VASTsrv ==============
                    // dynamically align pairs in all chainids
                    let ajaxArray = [], indexArray = [], struArray = [];
                    let urlalign = me.htmlCls.baseUrl + "vastdyn/vastdyn.cgi";
                    let urltmalign = me.htmlCls.baseUrl + "tmalign/tmalign.cgi";

                    let resRangeArray = (me.cfg.resrange) ? decodeURIComponent(me.cfg.resrange).split(' | ') : [];

                    // dynamically align pairs in all chainids
                    // the resrange from VASTSrv or VAST search uses NCBI residue numbers!!!
                    let atomSet_t = (me.cfg.resrange) ? ic.realignParserCls.getSeqCoorResid([resRangeArray[0]], chainidArray[0], true).hAtoms : ic.chains[chainidArray[0]];
                    for(let index = 1, indexl = chainidArray.length; index < indexl; ++index) {
                        let atomSet_q = (me.cfg.resrange) ? ic.realignParserCls.getSeqCoorResid([resRangeArray[index]], chainidArray[index], true).hAtoms : ic.chains[chainidArray[index]];
                    // end of new version to be done for VASTsrv ==============

                        let alignAjax;
                        if(me.cfg.aligntool != 'tmalign') {
                            let jsonStr_q = ic.domain3dCls.getDomainJsonForAlign(atomSet_q);
                            let jsonStr_t = ic.domain3dCls.getDomainJsonForAlign(atomSet_t);
                                
                            let dataObj = {'domains1': jsonStr_q, 'domains2': jsonStr_t};
                            alignAjax = me.getAjaxPostPromise(urlalign, dataObj);
                        }
                        else {
                            let pdb_query = ic.saveFileCls.getAtomPDB(atomSet_q);
                            let pdb_target= ic.saveFileCls.getAtomPDB(atomSet_t);

                            let dataObj = {'pdb_query': pdb_query, 'pdb_target': pdb_target};
                            alignAjax = me.getAjaxPostPromise(urltmalign, dataObj);                
                        }

                        ajaxArray.push(alignAjax);
                        indexArray.push(index - 1);
                        mmdbid_q = chainidArray[index].substr(0, chainidArray[index].indexOf('_'));
                        struArray.push(mmdbid_q);
                    }

                    let allPromise = Promise.allSettled(ajaxArray);
                    // try {
                        let dataArray = await allPromise;
                        
                        await thisClass.downloadChainalignmentPart2b(chainresiCalphaHash2, chainidArray, hAtoms, dataArray, indexArray, mmdbid_t, struArray);
                    // }
                    // catch(err) {
                    //     if(ic.bRender) alert("These structures can NOT be aligned to each other...");
                    // }                  
                //});
            }
        }

        async downloadChainalignmentPart2b(chainresiCalphaHash2, chainidArray, hAtoms, dataArray, 
            indexArray, mmdbid_t, struArray) { let ic = this.icn3d, me = ic.icn3dui;
            //let bTargetTransformed = (ic.qt_start_end[0]) ? true : false;

            // modify the previous trans and rotation matrix
            for(let i = 0, il = dataArray.length; i < il; ++i) {
                // let align = (me.bNode) ? dataArray[i] : dataArray[i].value;//[0];
                let align = dataArray[i].value;//[0];

                let mmdbid_q = struArray[i];
                let index = indexArray[i];

                // let bEqualMmdbid = (mmdbid_q == mmdbid_t);
                let bEqualMmdbid = (mmdbid_q.substr(0,4) == mmdbid_t.substr(0,4));
                let bEqualChain = false;

                let queryData = {}; // check whether undefined

                me.htmlCls.clickMenuCls.setLogCmd("Align " + mmdbid_t + " with " + mmdbid_q, false);

                this.processAlign(align, index, queryData, bEqualMmdbid, bEqualChain);
            }
           
            // do not transform the target
            //if(!bTargetTransformed) {
            //    this.transformStructure(mmdbid_t, indexArray[0], 'target');
            //}

            // transform the rest
            for(let i = 0, il = dataArray.length; i < il; ++i) {
                let mmdbid_q = struArray[i];
                let index = indexArray[i];

                this.transformStructure(mmdbid_q, index, 'query');
            }

            let hAtomsAll = {};

            if(ic.bFullUi && ic.q_rotation !== undefined && !me.cfg.resnum && !me.cfg.resdef) {
                // set multiple sequence alignment from ic.qt_start_end
                hAtomsAll = this.setMsa(chainidArray);
            }

            // highlight all aligned atoms
            //ic.hAtoms = me.hashUtilsCls.cloneHash(hAtomsTmp);
            ic.hAtoms = me.hashUtilsCls.cloneHash(hAtomsAll);

            ic.transformCls.zoominSelection();

            // do the rest
            await this.downloadChainalignmentPart3(chainresiCalphaHash2, chainidArray, ic.hAtoms);
        }

        setMsa(chainidArray, bVastplus, bRealign) { let ic = this.icn3d, me = ic.icn3dui;        
            // get aligned length for each pair
            let index_alignLen = [];
            for(let index = 1, indexl = chainidArray.length; index < indexl; ++index) {
                let alignLen = 0;
                if(ic.qt_start_end && ic.qt_start_end[index - 1]) {
                    for(let i = 0, il = ic.qt_start_end[index - 1].length; i < il; ++i) { 
                        alignLen += parseInt(ic.qt_start_end[index - 1][i].q_end) - parseInt(ic.qt_start_end[index - 1][i].q_start) + 1;
                    }
                }
                index_alignLen.push({index: index, alignLen: alignLen});
            }
            index_alignLen.sort(function(a,b){
                return b.alignLen - a.alignLen;
            });

            let hAtomsAll = ic.setSeqAlignCls.setSeqAlignChainForAll(chainidArray, index_alignLen, bRealign);

            if(bVastplus) {
                ic.opts['color'] = 'identity';
                ic.setColorCls.setColorByOptions(ic.opts, hAtomsAll);
            }

            let bReverse = false;
            let seqObj = me.htmlCls.alignSeqCls.getAlignSequencesAnnotations(Object.keys(ic.alnChains), undefined, undefined, false, undefined, bReverse);
            let oriHtml = $("#" + ic.pre + "dl_sequence2").html();

            $("#" + ic.pre + "dl_sequence2").html(oriHtml + seqObj.sequencesHtml);
            $("#" + ic.pre + "dl_sequence2").width(me.htmlCls.RESIDUE_WIDTH * seqObj.maxSeqCnt + 200);

            me.htmlCls.dialogCls.openDlg('dl_alignment', 'Select residues in aligned sequences');

            return hAtomsAll;
        }

        async downloadChainalignmentPart2bRealign(dataArray, chainidPairArray, bReverse) { let ic = this.icn3d, me = ic.icn3dui;
            // set trans and rotation matrix
            ic.t_trans_add = [];
            ic.q_trans_sub = [];

            if(me.cfg.aligntool == 'tmalign') ic.q_trans_add = [];

            ic.q_rotation = [];
            ic.qt_start_end = [];

            let mmdbid2cnt = {}, mmdbidpairHash = {};

            let bFoundAlignment = false;
            for(let i = 0, il = dataArray.length; i < il; ++i) {
                // let align = (me.bNode) ? dataArray[i] : dataArray[i].value;//[0];
                let align = dataArray[i].value;//[0];

                let bEqualMmdbid = false;
                let bEqualChain = false;

                let queryData = {}; // check whether undefined

                let chainpair = chainidPairArray[i].split(',');
                let mmdbid1 = chainpair[0].substr(0, chainpair[0].indexOf('_'));
                let mmdbid2 = chainpair[1].substr(0, chainpair[1].indexOf('_'));
                if(mmdbidpairHash.hasOwnProperty(mmdbid1 + '_' + mmdbid2)) { // aligned already
                    continue;
                }

                me.htmlCls.clickMenuCls.setLogCmd("Align " + mmdbid1 + " with " + mmdbid2, false);

                let bNoAlert = true;

                let bAligned = this.processAlign(align, i, queryData, bEqualMmdbid, bEqualChain, bNoAlert);

                if(bAligned) {
                    bFoundAlignment = true;

                    mmdbid2cnt[mmdbid1] = (mmdbid2cnt[mmdbid1] === undefined) ? 1 : ++mmdbid2cnt[mmdbid1];
                    mmdbid2cnt[mmdbid2] = (mmdbid2cnt[mmdbid2] === undefined) ? 1 : ++mmdbid2cnt[mmdbid2];

                    mmdbidpairHash[mmdbid1 + '_' + mmdbid2] = chainpair + ',' + i;
                }
            }

            if(!bFoundAlignment) {
                // sometimes VAST align works for the reversed pair
                if(!bReverse) {
                    let bVastsearch = true;
                    ic.realignParserCls.realignOnStructAlign(true, bVastsearch);
                    return;
                }
                else {
                    if(me.cfg.aligntool == 'tmalign') {
                        if(ic.bRender) alert("These structures can NOT be aligned...");
                        return;
                    }
                    else {
                        console.log("These structures can NOT be aligned with VAST. Realign the chains with TM-align."); 

                        // ic.hAtoms = {};
                        // for(let i = 0, il = chainidPairArray.length; i < il; ++i) {
                        //     ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.chains[chainidPairArray[i]]);
                        // }
                
                        me.cfg.aligntool = 'tmalign';
                        await ic.realignParserCls.realignOnStructAlign();
                        return;
                    }
                }
            }

            // find the max aligned mmdbid as mmdbid_t
            let cnt = 0, mmdbid_t;
            for(let mmdbidpair in mmdbidpairHash) {
                let mmdbidArray = mmdbidpair.split('_');
                if(mmdbid2cnt[mmdbidArray[0]] > cnt) {
                    cnt = mmdbid2cnt[mmdbidArray[0]];
                    mmdbid_t = mmdbidArray[0];
                }
                if(mmdbid2cnt[mmdbidArray[1]] > cnt) {
                    cnt = mmdbid2cnt[mmdbidArray[1]];
                    mmdbid_t = mmdbidArray[1];
                }
            }

            let aligType;
            // transform all pairs 
            let allChainidHash = {}, hAtoms = {}, alignMMdbids = {}, mmdbidpairFinalHash = {};
            for(let mmdbidpair in mmdbidpairHash) {
                let mmdbidArray = mmdbidpair.split('_');
                let chainidArray = mmdbidpairHash[mmdbidpair].split(',');
                let index = chainidArray[2];

                let target, query;
                if(mmdbid_t == mmdbidArray[0]) {
                    target = mmdbidArray[0];
                    query = mmdbidArray[1];
                } 
                else if(mmdbid_t == mmdbidArray[1]) {
                    target = mmdbidArray[1];
                    query = mmdbidArray[0];               
                }
                else {
                    target = mmdbidArray[0];
                    query = mmdbidArray[1];               
                }

                // If all chains align to the same target, just check the query.
                // If there are different targets, also just check the query. The target should not appear again in the query.
                alignMMdbids[target] = 1;
                  
                if(alignMMdbids.hasOwnProperty(query)) continue;
                alignMMdbids[query] = 1;

                mmdbidpairFinalHash[mmdbidpair] = mmdbidpairHash[mmdbidpair];

                // chainid1 is target
                aligType = 'target';
                let bForce = true;
                this.transformStructure(target, index, aligType, bForce);

                aligType = 'query';
                this.transformStructure(query, index, aligType, bForce);

                allChainidHash[chainidArray[0]] = 1;
                allChainidHash[chainidArray[1]] = 1;

                //hAtoms = me.hashUtilsCls.unionHash(hAtoms, ic.chains[chainidArray[0]]);
                //hAtoms = me.hashUtilsCls.unionHash(hAtoms, ic.chains[chainidArray[1]]);
            }

            // set up the view of sequence alignment for each pair
            for(let mmdbidpair in mmdbidpairFinalHash) {                 
                if(ic.q_rotation !== undefined) {
                    let chainidArrayTmp = mmdbidpairFinalHash[mmdbidpair].split(','); // chainid_chainid_index
                    // switch these two chains
                    let chainidArray = [chainidArrayTmp[1], chainidArrayTmp[0], chainidArrayTmp[2]];

                    let hAtomsTmp = ic.setSeqAlignCls.setSeqAlignChain(undefined, undefined, chainidArray);
                    hAtoms = me.hashUtilsCls.unionHash(hAtoms, hAtomsTmp);

                    let bReverse = false;
                    let seqObj = me.htmlCls.alignSeqCls.getAlignSequencesAnnotations(Object.keys(ic.alnChains), undefined, undefined, false, undefined, bReverse);
                    let oriHtml = $("#" + ic.pre + "dl_sequence2").html();

                    $("#" + ic.pre + "dl_sequence2").html(oriHtml + seqObj.sequencesHtml);
                    $("#" + ic.pre + "dl_sequence2").width(me.htmlCls.RESIDUE_WIDTH * seqObj.maxSeqCnt + 200);
                }
            }

            //this.downloadChainalignmentPart3(undefined, Object.keys(allChainidHash), hAtoms);

            ic.dAtoms = me.hashUtilsCls.cloneHash(hAtoms);
            ic.hAtoms = me.hashUtilsCls.cloneHash(hAtoms);

            let name = 'protein_aligned';
            ic.selectionCls.saveSelection(name, name);

            ic.opts['color'] = 'identity';
            //ic.setColorCls.setColorByOptions(ic.opts, ic.atoms);
            ic.setColorCls.setColorByOptions(ic.opts, ic.hAtoms);

            me.htmlCls.dialogCls.openDlg('dl_alignment', 'Select residues in aligned sequences');

            ic.drawCls.draw();
            ic.transformCls.zoominSelection();
            
            ic.hlUpdateCls.updateHlAll();

            /// if(ic.deferredRealignByStruct !== undefined) ic.deferredRealignByStruct.resolve();
        }

        transformStructure(mmdbid, index, alignType, bForce) { let ic = this.icn3d, me = ic.icn3dui;
            let chainidArray = ic.structures[mmdbid];
            
            for(let i = 0, il = chainidArray.length; i < il; ++i) {
                for(let serial in ic.chains[chainidArray[i]]) {
                    let atm = ic.atoms[serial];
                    //if(ic.q_rotation !== undefined && ic.t_trans_add.length > 0 && !me.cfg.resnum && !me.cfg.resdef) {
                    if(ic.q_rotation !== undefined && (bForce || (!me.cfg.resnum && !me.cfg.resdef)) ) {
                        atm = this.transformAtom(atm, index, alignType);
                    }
                }
            }
        }

        transformAtom(atm, index, alignType) { let ic = this.icn3d, me = ic.icn3dui;
            if(alignType === 'target') ;
            else if(alignType === 'query') {
                if(me.cfg.aligntool != 'tmalign') {
                    atm.coord.x -= ic.q_trans_sub[index].x;
                    atm.coord.y -= ic.q_trans_sub[index].y;
                    atm.coord.z -= ic.q_trans_sub[index].z;
                }

                let x = atm.coord.x * ic.q_rotation[index].x1 + atm.coord.y * ic.q_rotation[index].y1 + atm.coord.z * ic.q_rotation[index].z1;
                let y = atm.coord.x * ic.q_rotation[index].x2 + atm.coord.y * ic.q_rotation[index].y2 + atm.coord.z * ic.q_rotation[index].z2;
                let z = atm.coord.x * ic.q_rotation[index].x3 + atm.coord.y * ic.q_rotation[index].y3 + atm.coord.z * ic.q_rotation[index].z3;

                if(me.cfg.aligntool != 'tmalign') {
                    x -= ic.t_trans_add[index].x;
                    y -= ic.t_trans_add[index].y;
                    z -= ic.t_trans_add[index].z;
                }
                else {
                    x += ic.q_trans_add[index].x;
                    y += ic.q_trans_add[index].y;
                    z += ic.q_trans_add[index].z;
                }

                atm.coord.x = x;
                atm.coord.y = y;
                atm.coord.z = z;
            }

            return atm;
        }

        async downloadChainalignmentPart3(chainresiCalphaHash2, chainidArray, hAtoms) { let ic = this.icn3d, me = ic.icn3dui;
            // select all
            let allAtoms = {};
            for(let i in ic.atoms) {
                allAtoms[i] = 1;
            }
            ic.dAtoms = allAtoms;
            ic.hAtoms = allAtoms;

            ic.setStyleCls.setAtomStyleByOptions(ic.opts);
            // change the default color to "Identity"

            ic.opts['color'] = 'identity';
            ic.setColorCls.setColorByOptions(ic.opts, ic.atoms);

            // memebrane is determined by one structure. But transform both structures
            if(chainresiCalphaHash2 !== undefined) ic.ParserUtilsCls.transformToOpmOriForAlign(ic.selectedPdbid, chainresiCalphaHash2, true);

            //ic.dAtoms = hAtoms;
            //ic.hAtoms = hAtoms;
            ic.hAtoms = me.hashUtilsCls.cloneHash(hAtoms);
            ic.dAtoms = me.hashUtilsCls.cloneHash(hAtoms);
            
            await ic.ParserUtilsCls.renderStructure();

            //if(ic.chainidArray.length > 2) {
            if(chainidArray.length > 2) {
                let residuesHash = ic.firstAtomObjCls.getResiduesFromAtoms(hAtoms);

                let commandname = 'protein_aligned';
                let commanddescr = 'protein aligned';
                let select = "select " + ic.resid2specCls.residueids2spec(Object.keys(residuesHash));

                ic.selectionCls.addCustomSelection(Object.keys(residuesHash), commandname, commanddescr, select, true);
            }

            ic.hlUpdateCls.updateHlAll();

            me.htmlCls.dialogCls.openDlg('dl_alignment', 'Select residues in aligned sequences');

            if(me.cfg.rotate !== undefined) ic.resizeCanvasCls.rotStruc(me.cfg.rotate, true);

            ic.html2ddgm = '';

            // by default, open the seq alignment window
             //if(me.cfg.showalignseq) {
    //            me.htmlCls.dialogCls.openDlg('dl_alignment', 'Select residues in aligned sequences');
            //}

            if(me.cfg.show2d && ic.bFullUi) {
                me.htmlCls.dialogCls.openDlg('dl_2ddgm', 'Interactions');
                if(ic.bFullUi) {
                    if(!ic.bChainAlign) {
                        ic.ParserUtilsCls.download2Ddgm(ic.inputid.toUpperCase());
                    }
                    else {
                        //ic.ParserUtilsCls.set2DDiagramsForAlign(ic.inputid2.toUpperCase(), ic.inputid.toUpperCase());
                        await ic.ParserUtilsCls.set2DDiagramsForChainalign(chainidArray);
                    }
                }
            }

            //if(me.deferred !== undefined) me.deferred.resolve(); /// if(ic.deferred2 !== undefined) ic.deferred2.resolve();
        }

        addPostfixForChainids(chainidArray) { let ic = this.icn3d; ic.icn3dui;
            let struct2cnt = {};
            for(let i = 0, il = chainidArray.length; i < il; ++i) {
                let chainid = chainidArray[i];
                let pos = chainid.indexOf('_');
                let struct = chainid.substr(0, pos); 
                //if(struct != ic.defaultPdbId) struct = struct.toUpperCase();

                if(!struct2cnt.hasOwnProperty(struct)) {
                    struct2cnt[struct] = 1;
                }
                else {
                    ++struct2cnt[struct];
                }

                struct = (struct2cnt[struct] == 1) ? struct : struct + struct2cnt[struct];

                chainidArray[i] = struct + chainid.substr(pos);
            }

            return chainidArray;
        }

        addPostfixForStructureids(structArray) { let ic = this.icn3d; ic.icn3dui;
            let struct2cnt = {};
            for(let i = 0, il = structArray.length; i < il; ++i) {
                let struct = structArray[i].toUpperCase(); 

                if(!struct2cnt.hasOwnProperty(struct)) {
                    struct2cnt[struct] = 1;
                }
                else {
                    ++struct2cnt[struct];
                }

                struct = (struct2cnt[struct] == 1) ? struct : struct + struct2cnt[struct];

                structArray[i] = struct;
            }

            return structArray;
        }

        async downloadChainalignment(chainalign) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            ic.opts['proteins'] = 'c alpha trace';

            let alignArray = chainalign.split(',');
            let domainArray = (me.cfg.domainids) ? me.cfg.domainids.split(',') : [];
            if(domainArray.length < alignArray.length) domainArray = [];

            ic.chainidArray = this.addPostfixForChainids(alignArray);

            let pos1 = alignArray[0].indexOf('_');
            ic.mmdbid_t = alignArray[0].substr(0, pos1).toUpperCase();
            ic.chain_t = alignArray[0].substr(pos1+1);

            let ajaxArray = [];
            let targetAjax;

            let url_t;
            if(ic.mmdbid_t.length > 5) {
                url_t = "https://alphafold.ebi.ac.uk/files/AF-" + ic.mmdbid_t + "-F1-model_" + ic.AFUniprotVersion + ".pdb";

                targetAjax = me.getAjaxPromise(url_t, 'text');
            }
            else {
                url_t = me.htmlCls.baseUrl + "mmdb/mmdb_strview.cgi?v=2&program=icn3d&b=1&s=1&ft=1&bu=" + me.cfg.bu + "&uid=" + ic.mmdbid_t;
                if(me.cfg.inpara !== undefined) url_t += me.cfg.inpara;

                targetAjax = me.getAjaxPromise(url_t, 'jsonp');
            }

            ajaxArray.push(targetAjax);

            ic.ParserUtilsCls.setYourNote(chainalign.toUpperCase() + ' in iCn3D');
            //ic.bCid = undefined;
            // define for 'align' only
            ic.pdbid_chain2title = {};
            if(ic.chainids2resids === undefined) ic.chainids2resids = {}; // ic.chainids2resids[chainid1][chainid2] = [resid, resid]

            ic.afChainIndexHash = {};
            ic.pdbChainIndexHash = {};

            for(let index = 1, indexLen = alignArray.length; index < indexLen; ++index) {
                let pos2 = alignArray[index].indexOf('_');
                let mmdbid_q_tmp = alignArray[index].substr(0, pos2).toUpperCase();
                ic.mmdbid_q = (mmdbid_q_tmp.length == 5) ? mmdbid_q_tmp.substr(0, 4) : mmdbid_q_tmp; // added postfix for same PDB IDs

                ic.chain_q = alignArray[index].substr(pos2+1);

                let url_q, queryAjax;
                if(ic.mmdbid_q.length > 5) {
                    url_q = "https://alphafold.ebi.ac.uk/files/AF-" + ic.mmdbid_q + "-F1-model_" + ic.AFUniprotVersion + ".pdb";

                    queryAjax = me.getAjaxPromise(url_q, 'text');
                }
                else {
                    url_q = me.htmlCls.baseUrl + "mmdb/mmdb_strview.cgi?v=2&program=icn3d&b=1&s=1&ft=1&bu=" + me.cfg.bu + "&uid=" + ic.mmdbid_q;
                    if(me.cfg.inpara !== undefined) url_q += me.cfg.inpara;

                    queryAjax = me.getAjaxPromise(url_q, 'jsonp');
                }

                ajaxArray.push(queryAjax);
            }
            
            for(let index = 1, indexLen = alignArray.length; index < indexLen; ++index) {
                let pos2 = alignArray[index].indexOf('_');
                let mmdbid_q_tmp = alignArray[index].substr(0, pos2).toUpperCase();
                ic.mmdbid_q = (mmdbid_q_tmp.length == 5) ? mmdbid_q_tmp.substr(0, 4) : mmdbid_q_tmp; // added postfix for same PDB IDs

                ic.chain_q = alignArray[index].substr(pos2+1);

                if(!me.cfg.resnum && !me.cfg.resdef) {
                    let chainalignFinal = ic.mmdbid_q + "_" + ic.chain_q + "," + ic.mmdbid_t + "_" + ic.chain_t;
                    let domainalign = (domainArray.length > 0) ? domainArray[index] + "," + domainArray[0] : undefined;

                    // TM-align (me.cfg.aligntool == 'tmalign') needs to input PDB
                    if(me.cfg.aligntool != 'tmalign' && ic.mmdbid_t.length == 4 && ic.mmdbid_q.length == 4) {
                        let urlalign;
                        
                        if(domainArray.length > 0) {
                            urlalign = me.htmlCls.baseUrl + "vastdyn/vastdyn.cgi?domainpairs=" + domainalign;
                        }
                        else {
                            urlalign = me.htmlCls.baseUrl + "vastdyn/vastdyn.cgi?chainpairs=" + chainalignFinal;
                        }
                        
                        let alignAjax = me.getAjaxPromise(urlalign, 'jsonp');

                        ajaxArray.push(alignAjax);

                        ic.pdbChainIndexHash[index] = mmdbid_q_tmp + "_" + ic.chain_q + "_" + ic.mmdbid_t + "_" + ic.chain_t;
                    }
                    else {
                        // get the dynamic alignment after loading the structures
                        ic.afChainIndexHash[index] = ic.mmdbid_q + "_" + ic.chain_q + "_" + ic.mmdbid_t + "_" + ic.chain_t;
                    }
                }
            }

            let allPromise = Promise.allSettled(ajaxArray);
            // try {
                let dataArray = await allPromise;
                await thisClass.parseChainAlignData(dataArray, alignArray, ic.mmdbid_t, ic.chain_t);
            // }
            // catch(err) {
            //     let serverName = (me.cfg.aligntool == 'tmalign') ? 'TM-align' : 'VAST';
             
            //     if(ic.bRender) alert("These chains can not be aligned by " + serverName + ". You can specify the residue range and try it again...");
            // }          
        }

        async parseChainAlignData(dataArray, chainidArray, mmdbid_t, chain_t) { let ic = this.icn3d, me = ic.icn3dui;

            //var dataArray =(chainidArray.length == 1) ? [data] : data;

            // Each argument is an array with the following structure: [ data, statusText, jqXHR ]
            //var data2 = v2[0];
            // index = 0: the mmdb data of target
            // let targetData = (me.bNode) ? dataArray[0] : dataArray[0].value; //[0];
            let targetData = dataArray[0].value; //[0];
            let header = 'HEADER                                                        ' + mmdbid_t + '\n';
            if(isNaN(mmdbid_t) && mmdbid_t.length > 5) targetData = header + targetData;

            ic.t_trans_add = [];
            ic.q_trans_sub = [];

            if(me.cfg.aligntool == 'tmalign') ic.q_trans_add = [];

            ic.q_rotation = [];
            ic.qt_start_end = [];

            ic.mmdbidArray = [];
            ic.mmdbidArray.push(mmdbid_t);

            let queryDataArray = [];

            for(let index = 1, indexl = chainidArray.length; index < indexl; ++index) {
                // let queryData = (me.bNode) ? dataArray[index] : dataArray[index].value;//[0];
                let queryData = dataArray[index].value;//[0];

                let pos = chainidArray[index].indexOf('_');
                let mmdbid_q = chainidArray[index].substr(0, pos).toUpperCase();

                let header = 'HEADER                                                        ' + mmdbid_q + '\n';
                if(isNaN(mmdbid_q) && mmdbid_q.length > 5) queryData = header + queryData;

                if(queryData !== undefined && JSON.stringify(queryData).indexOf('Oops there was a problem') === -1
                    ) {
                    // ic.mmdbidArray.push(mmdbid_q);
                    ic.mmdbidArray.push(mmdbid_q.substr(0,4));
                    queryDataArray.push(queryData);
                }
                else {
                    alert("The coordinate data can NOT be retrieved for the structure " + mmdbid_q + "...");
                    return;
                }
            }

            let missedChainCnt = 0;
            //for(let index = chainidArray.length, indexl = dataArray.length; index < indexl; index += step) {
            for(let index = 1, indexl = chainidArray.length; index < indexl; ++index) {
                let queryData = queryDataArray[index - 1]; 

                let pos = chainidArray[index].indexOf('_');
                let mmdbid_q = chainidArray[index].substr(0, pos).toUpperCase();
                let chain_q = chainidArray[index].substr(pos+1);

                if(!me.cfg.resnum && !me.cfg.resdef) {
                    let index2 = chainidArray.length + index - 1;
                    if(ic.afChainIndexHash.hasOwnProperty(index)) {
                        ++missedChainCnt;

                        if(me.cfg.aligntool == 'tmalign') {
                            ic.q_trans_add[index-1] = {"x":0, "y":0, "z":0};
                        }
                        else {
                            // need to pass C-alpha coords and get transformation matrix from backend
                            ic.t_trans_add[index-1] = {"x":0, "y":0, "z":0};
                            ic.q_trans_sub[index-1] = {"x":0, "y":0, "z":0};
                        }

                        ic.q_rotation[index-1] = {"x1":1, "y1":0, "z1":0, "x2":0, "y2":1, "z2":0, "x3":0, "y3":0, "z3":1};
                        ic.qt_start_end[index-1] = undefined;
                    }
                    else {
                        // let align = (me.bNode) ? dataArray[index2 - missedChainCnt] : dataArray[index2 - missedChainCnt].value;//[0];
                        let align = dataArray[index2 - missedChainCnt].value;//[0];

                        // let bEqualMmdbid = (mmdbid_q == mmdbid_t);
                        let bEqualMmdbid = (mmdbid_q.substr(0,4) == mmdbid_t.substr(0,4));
                        let bEqualChain = (chain_q == chain_t);

                        me.htmlCls.clickMenuCls.setLogCmd("Align " + mmdbid_t + " with " + mmdbid_q, false);

                        this.processAlign(align, index-1, queryData, bEqualMmdbid, bEqualChain);
                    }
                }
            }

            ic.mmdb_data_q = queryDataArray;

            await this.loadOpmDataForChainalign(targetData, queryDataArray, chainidArray, ic.mmdbidArray);
        }

        processAlign(align, index, queryData, bEqualMmdbid, bEqualChain, bNoAlert) { let ic = this.icn3d, me = ic.icn3dui;
            let bAligned = false;

            if((!align || align.length == 0) && !bNoAlert) {
                let serverName = (me.cfg.aligntool == 'tmalign') ? 'TM-align' : 'VAST';
            
                if(ic.bRender) alert("These chains can not be aligned by " + serverName + ".");
                return bAligned;
            }

            if(queryData !== undefined && JSON.stringify(queryData).indexOf('Oops there was a problem') === -1
                && align !== undefined && JSON.stringify(align).indexOf('Oops there was a problem') === -1
            ) {
                if((align === "error" || align === undefined || align.length == 0) && bEqualMmdbid && bEqualChain) {
                    ic.t_trans_add[index] = {"x":0, "y":0, "z":0};
                    ic.q_trans_sub[index] = {"x":0, "y":0, "z":0};
                    ic.q_rotation[index] = {"x1":1, "y1":0, "z1":0, "x2":0, "y2":1, "z2":0, "x3":0, "y3":0, "z3":1};
                    ic.qt_start_end[index] = undefined;
                }
                else if(align === "error" || align === undefined || align.length == 0) {
                    if(!me.cfg.command && !bNoAlert) alert('These two chains can not align to each other. ' + 'Please select sequences from these two chains in the "Sequences & Annotations" window, ' + 'and click "Realign Selection" in the "File" menu to align your selection.');

                    ic.t_trans_add[index] = {"x":0, "y":0, "z":0};
                    ic.q_trans_sub[index] = {"x":0, "y":0, "z":0};
                    ic.q_rotation[index] = {"x1":1, "y1":0, "z1":0, "x2":0, "y2":1, "z2":0, "x3":0, "y3":0, "z3":1};
                    ic.qt_start_end[index] = undefined;

                    me.cfg.showanno = 1;
                    me.cfg.showalignseq = 0;
                }
                else {
                    /*
                    ic.t_trans_add.push(align[0].t_trans_add);
                    ic.q_trans_sub.push(align[0].q_trans_sub);
                    ic.q_rotation.push(align[0].q_rotation);
                    ic.qt_start_end.push(align[0].segs);
                    */

                    if(me.cfg.aligntool == 'tmalign') {
                        ic.q_trans_add[index] = align[0].q_trans_add;
                    }
                    else {
                        ic.t_trans_add[index] = align[0].t_trans_add;
                        ic.q_trans_sub[index] = align[0].q_trans_sub;
                    }

                    ic.q_rotation[index] = align[0].q_rotation;
                    ic.qt_start_end[index] = align[0].segs;

                    let rmsd = align[0].super_rmsd;
                    let rmsdStr = (rmsd) ? rmsd.toPrecision(4) : rmsd;
                    let scoreStr = (align[0].score) ? align[0].score.toPrecision(4) : align[0].score;

                    let logStr = "alignment RMSD: " + rmsdStr;
                    if(me.cfg.aligntool == 'tmalign') logStr += "; TM-score: " + scoreStr;
                    me.htmlCls.clickMenuCls.setLogCmd(logStr, false);
                    let html = "<br><b>Alignment RMSD</b>: " + rmsdStr + " &#8491;<br>";
                    if(me.cfg.aligntool == 'tmalign') {
                        html += "<b>TM-score</b>: " + scoreStr + "<br><br>";
                        ic.tmscore = scoreStr;
                    }

                    $("#" + ic.pre + "dl_rmsd_html").html(html);
                    if(!me.cfg.bSidebyside) me.htmlCls.dialogCls.openDlg('dl_rmsd', 'RMSD of alignment');

                    bAligned = true;
                }
            }

            return bAligned;
        }

        async loadOpmDataForChainalign(data1, data2, chainidArray, mmdbidArray) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            if(me.cfg.resnum || me.cfg.resdef || me.cfg.resrange) {
                if(!ic.bCommandLoad) ic.init(); // remove all previously loaded data
                await this.downloadChainalignmentPart2(data1, data2, undefined, chainidArray);

                /// if(ic.deferredOpm !== undefined) ic.deferredOpm.resolve();
            }
            else {
                let url = me.htmlCls.baseUrl + "vastdyn/vastdyn.cgi?mmdbids2opm=" + mmdbidArray.join("','");

                // try {
                    let data = await me.getAjaxPromise(url, 'jsonp');

                    if(!data || !data.mmdbid) {
                      if(!ic.bCommandLoad) ic.init(); // remove all previously loaded data
                      await thisClass.downloadChainalignmentPart2(data1, data2, undefined, chainidArray);

                      /// if(ic.deferredOpm !== undefined) ic.deferredOpm.resolve();
                    }
                    else {
                        let mmdbid = data.mmdbid;
                        ic.selectedPdbid = mmdbid;

                        let url2 = "https://opm-assets.storage.googleapis.com/pdb/" + mmdbid.toLowerCase()+ ".pdb";

                        // try {
                            let opmdata = await me.getAjaxPromise(url2, 'text');

                            ic.bOpm = true;
                            let bVector = true;
                            let chainresiCalphaHash = ic.loadPDBCls.loadPDB(opmdata, mmdbid, ic.bOpm, bVector); // defined in the core library

                            $("#" + ic.pre + "selectplane_z1").val(ic.halfBilayerSize);
                            $("#" + ic.pre + "selectplane_z2").val(-ic.halfBilayerSize);

                            $("#" + ic.pre + "extra_mem_z").val(ic.halfBilayerSize);
                            $("#" + ic.pre + "intra_mem_z").val(-ic.halfBilayerSize);

                            if(!ic.bCommandLoad) ic.init(); // remove all previously loaded data
                            await thisClass.downloadChainalignmentPart2(data1, data2, chainresiCalphaHash, chainidArray);

                            /// if(ic.deferredOpm !== undefined) ic.deferredOpm.resolve();
                        // }
                        // catch(err) {
                        //     if(!ic.bCommandLoad) ic.init(); // remove all previously loaded data
                        //     await thisClass.downloadChainalignmentPart2(data1, data2, undefined, chainidArray);

                        //     /// if(ic.deferredOpm !== undefined) ic.deferredOpm.resolve();
                        //     return;
                        // }
                    }
                // }
                // catch(err) {
                //       if(!ic.bCommandLoad) ic.init(); // remove all previously loaded data
                //       await thisClass.downloadChainalignmentPart2(data1, data2, undefined, chainidArray);

                //       /// if(ic.deferredOpm !== undefined) ic.deferredOpm.resolve();
                //       return;
                // }
            }
        }

        async downloadMmdbAf(idlist, bQuery, vastplusAtype, bNoDuplicate) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            ic.structArray = (ic.structures) ? Object.keys(ic.structures) : [];

            if(ic.structArray.length == 0) {
                ic.init();
            }
            else {
                //ic.resetConfig();
            
                ic.bResetAnno = true;
                ic.bResetSets = true;
            }

            // ic.deferredMmdbaf = $.Deferred(function() {
            let structArrayTmp = idlist.split(',');

            let structArray = [];

            // only when bNoDuplicate is undefined/false, it's allowed to load multiple copies of the same structure
            if(!bNoDuplicate) {
                structArray =  this.addPostfixForStructureids(structArrayTmp);
            }
            else {
                for(let i = 0, il = structArrayTmp.length; i < il; ++i) {
                    let id = structArrayTmp[i].toUpperCase();
                    if(!ic.structures.hasOwnProperty(id)) structArray.push(structArrayTmp[i]);
                }
            }
            
            if(structArray.length == 0) return;
            
            ic.structArray = ic.structArray.concat(structArray);

            let ajaxArray = [];

            for(let i = 0, il = structArray.length; i < il; ++i) {
                let url_t, targetAjax;
                let structure = structArray[i];

                if(isNaN(structure) && structure.length > 5) {
                    url_t = "https://alphafold.ebi.ac.uk/files/AF-" + structure + "-F1-model_" + ic.AFUniprotVersion + ".pdb";

                    targetAjax = me.getAjaxPromise(url_t, 'text');
                }
                else {
                    let structureTmp = structure;
                    if(structure.length == 5) {
                        structureTmp = structure.substr(0,4);
                    }

                    url_t = me.htmlCls.baseUrl + "mmdb/mmdb_strview.cgi?v=2&program=icn3d&b=1&s=1&ft=1&bu=" + me.cfg.bu + "&uid=" + structureTmp;
                    if(me.cfg.inpara !== undefined) url_t += me.cfg.inpara;

                    targetAjax = me.getAjaxPromise(url_t, 'jsonp');
                }

                ajaxArray.push(targetAjax);
            }

            ic.ParserUtilsCls.setYourNote(ic.structArray + ' in iCn3D');
            //ic.bCid = undefined;

            ic.ParserUtilsCls.showLoading();

            let allPromise = Promise.allSettled(ajaxArray);
            // try {
                let dataArray = await allPromise;

                await thisClass.parseMMdbAfData(dataArray, structArray, bQuery, vastplusAtype);
                if(vastplusAtype === undefined) ic.ParserUtilsCls.hideLoading();
            // }
            // catch(err) {
            //     alert("There are some problems in retrieving the coordinates...");
            // }          
        //   });
        
        //   return ic.deferredMmdbaf.promise();
        }

        async parseMMdbAfData(dataArray, structArray, bQuery, vastplusAtype) { let ic = this.icn3d, me = ic.icn3dui;

            let queryDataArray = [];
            for(let index = 0, indexl = structArray.length; index < indexl; ++index) {
                // let queryData = (me.bNode) ? dataArray[index] : dataArray[index].value;//[0];
                let queryData = dataArray[index].value;//[0];
                let header = 'HEADER                                                        ' + structArray[index] + '\n';
                if(isNaN(structArray[index]) && structArray[index].length > 5) queryData = header + queryData;

                if(queryData !== undefined && JSON.stringify(queryData).indexOf('Oops there was a problem') === -1
                    ) {
                    queryDataArray.push(queryData);
                }
                else {
                    alert("The coordinate data can NOT be retrieved for the structure " + structArray[index] + "...");
                    return;
                }
            }

            //if(!ic.bCommandLoad && !bQuery) ic.init(); // remove all previously loaded data
            
            let hAtoms = {};
            let bLastQuery = false;

            for(let i = 0, il = structArray.length; i < il; ++i) {
                if(i == structArray.length - 1) bLastQuery = true;

                let targetOrQuery, bAppend;
                //if(i == 0 && !bQuery) {
                // check if structures were loaded before
                if(i == 0 && !bQuery && ic.structArray.length == structArray.length) {
                    targetOrQuery = 'target';
                    bAppend = false; 
                }
                else {
                    targetOrQuery = 'query';
                    bAppend = true; 
                }

                //if(structArray[i].length > 4) {
                if(isNaN(structArray[i]) && structArray[i].length > 5) {  // PDB ID plus postfix could be 5 
                    //let bNoDssp = true;
                    let bNoDssp = false; // get secondary structure info
                    await ic.pdbParserCls.loadPdbData(queryDataArray[i], structArray[i], false, bAppend, targetOrQuery, bLastQuery, bNoDssp);
                }
                else {
                    let bNoSeqalign = true;
                    let pdbid = structArray[i];

                    //hAtomsTmp contains all atoms
                    await ic.mmdbParserCls.parseMmdbData(queryDataArray[i], targetOrQuery, undefined, undefined, bLastQuery, bNoSeqalign, pdbid);
                }
                        
                // hAtoms = me.hashUtilsCls.unionHash(hAtoms, hAtomsTmp);
            }

            let structArrayAll = Object.keys(ic.structures);

            ic.opts['color'] = (structArrayAll.length > 1) ? 'structure' : ((structArrayAll[0].length > 5) ? 'confidence' : 'chain');

            // add color for all structures
            ic.setColorCls.setColorByOptions(ic.opts, hAtoms);

            await ic.ParserUtilsCls.renderStructure();

            if(ic.bAnnoShown) {
                await ic.showAnnoCls.showAnnotations();
                ic.annotationCls.resetAnnoTabAll();
            }

            if(me.cfg.rotate !== undefined) ic.resizeCanvasCls.rotStruc(me.cfg.rotate, true);

            if(bQuery && me.cfg.matchedchains) {          
               // $.when(ic.pdbParserCls.applyCommandDssp(true)).then(function() {
                    // let bRealign = true, bPredefined = true;
                    // await ic.realignParserCls.realignChainOnSeqAlign(undefined, ic.chainidArray, bRealign, bPredefined);

                    ic.hAtoms = ic.definedSetsCls.getAtomsFromNameArray(ic.chainidArray);
                    let bVastsearch = true;
                    await ic.realignParserCls.realignOnStructAlign(undefined, bVastsearch);

                    // reset annotations
                    $("#" + ic.pre + "dl_annotations").html("");
                    ic.bAnnoShown = false;
                    if($('#' + me.pre + 'dl_selectannotations').hasClass('ui-dialog-content') && $('#' + ic.pre + 'dl_selectannotations').dialog( 'isOpen' )) {
                        $('#' + ic.pre + 'dl_selectannotations').dialog( 'close' );
                    }
               //});
            }
            else if(vastplusAtype !== undefined) {
                // vastplusAtype: 0: VAST, global, 1: VAST, invarant core, 2: TM-align, global
                // VAST+ on the fly
                let structArray = Object.keys(ic.structures);
                if(vastplusAtype == 2) me.cfg.aligntool = 'tmalign';
                await ic.vastplusCls.vastplusAlign(structArray, vastplusAtype);
            }
        }
    }

    /**
     * @file Dsn6 Parser
     * @author Alexander Rose <alexander.rose@weirdbyte.de>
     * @private
     * Modified by Jiyao Wang / https://github.com/ncbi/icn3d
     */

    class Dsn6Parser {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        async dsn6Parser(pdbid, type, sigma) { let ic = this.icn3d; ic.icn3dui;
            // https://edmaps.rcsb.org/maps/1kq2_2fofc.dsn6
            // https://edmaps.rcsb.org/maps/1kq2_fofc.dsn6

            let url = "https://edmaps.rcsb.org/maps/" + pdbid.toLowerCase() + "_" + type + ".dsn6";
            await this.dsn6ParserBase(url, type, sigma, 'url', true);
        }

        async dsn6ParserBase(url, type, sigma, location, bInputSigma) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            //https://stackoverflow.com/questions/33902299/using-jquery-ajax-to-download-a-binary-file
            if(type == '2fofc' && ic.bAjax2fofc) {
                ic.mapData.sigma2 = sigma;
                ic.setOptionCls.setOption('map', type);
            }
            else if(type == 'fofc' && ic.bAjaxfofc) {
                ic.mapData.sigma = sigma;
                ic.setOptionCls.setOption('map', type);
            }
            else {
                let arrayBuffer = await me.getXMLHttpRqstPromise(url, 'GET', 'arraybuffer', 'rcsbEdmaps');
                sigma = thisClass.loadDsn6Data(arrayBuffer, type, sigma, location, bInputSigma);

                if(type == '2fofc') {
                    ic.bAjax2fofc = true;
                }
                else if(type == 'fofc') {
                    ic.bAjaxfofc = true;
                }

                ic.setOptionCls.setOption('map', type);
            }

            return sigma;
        }

        loadDsn6Data(dsn6data, type, sigma, location, bInputSigma) { let ic = this.icn3d, me = ic.icn3dui;
            // DSN6 http://www.uoxray.uoregon.edu/tnt/manual/node104.html
            // BRIX http://svn.cgl.ucsf.edu/svn/chimera/trunk/libs/VolumeData/dsn6/brix-1.html

            let voxelSize = 1;

            let header = {};
            let divisor, summand;

            let bin =(dsn6data.buffer && dsn6data.buffer instanceof ArrayBuffer) ? dsn6data.buffer : dsn6data;
            let intView = new Int16Array(bin);
            let byteView = new Uint8Array(bin);
            let brixStr = String.fromCharCode.apply(null, byteView.subarray(0, 512));

            if(brixStr.indexOf(':-)') == 0) {
              header.xStart = parseInt(brixStr.substr(10, 5)); // NXSTART
              header.yStart = parseInt(brixStr.substr(15, 5));
              header.zStart = parseInt(brixStr.substr(20, 5));

              header.xExtent = parseInt(brixStr.substr(32, 5)); // NX
              header.yExtent = parseInt(brixStr.substr(38, 5));
              header.zExtent = parseInt(brixStr.substr(42, 5));

              header.xRate = parseInt(brixStr.substr(52, 5)); // MX
              header.yRate = parseInt(brixStr.substr(58, 5));
              header.zRate = parseInt(brixStr.substr(62, 5));

              header.xlen = parseFloat(brixStr.substr(73, 10)) * voxelSize;
              header.ylen = parseFloat(brixStr.substr(83, 10)) * voxelSize;
              header.zlen = parseFloat(brixStr.substr(93, 10)) * voxelSize;

              header.alpha = parseFloat(brixStr.substr(103, 10));
              header.beta = parseFloat(brixStr.substr(113, 10));
              header.gamma = parseFloat(brixStr.substr(123, 10));

              divisor = parseFloat(brixStr.substr(138, 12)) / 100;
              summand = parseInt(brixStr.substr(155, 8));

              header.sigma = parseFloat(brixStr.substr(170, 12)) * 100;
            } else {
              // swap byte order when big endian
              if(intView[ 18 ] !== 100) { // true
                for(let i = 0, n = intView.length; i < n; ++i) {
                  let val = intView[ i ];

                  intView[ i ] =((val & 0xff) << 8) |((val >> 8) & 0xff);
                }
              }

              header.xStart = intView[ 0 ]; // NXSTART
              header.yStart = intView[ 1 ];
              header.zStart = intView[ 2 ];

              header.xExtent = intView[ 3 ]; // NX
              header.yExtent = intView[ 4 ];
              header.zExtent = intView[ 5 ];

              header.xRate = intView[ 6 ]; // MX
              header.yRate = intView[ 7 ];
              header.zRate = intView[ 8 ];

              let factor = 1 / intView[ 17 ];
              let scalingFactor = factor * voxelSize;

              header.xlen = intView[ 9 ] * scalingFactor;
              header.ylen = intView[ 10 ] * scalingFactor;
              header.zlen = intView[ 11 ] * scalingFactor;

              header.alpha = intView[ 12 ] * factor;
              header.beta = intView[ 13 ] * factor;
              header.gamma = intView[ 14 ] * factor;

              //divisor = intView[ 15 ] / 100;
              divisor = intView[ 15 ] / intView[ 18 ];
              summand = intView[ 16 ];
            }

            if(!me.bNode) console.log("header: " + JSON.stringify(header));

            let data = new Float32Array(
              header.xExtent * header.yExtent * header.zExtent
            );

            let offset = 512;
            let xBlocks = Math.ceil(header.xExtent / 8);
            let yBlocks = Math.ceil(header.yExtent / 8);
            let zBlocks = Math.ceil(header.zExtent / 8);

            // loop over blocks
            let maxValue = -999;
            for(let zz = 0; zz < zBlocks; ++zz) {
              for(let yy = 0; yy < yBlocks; ++yy) {
                for(let xx = 0; xx < xBlocks; ++xx) {
                  // loop inside block
                  for(let k = 0; k < 8; ++k) {
                    let z = 8 * zz + k;
                    for(let j = 0; j < 8; ++j) {
                      let y = 8 * yy + j;
                      for(let i = 0; i < 8; ++i) {
                        let x = 8 * xx + i;

                        // check if remaining slice-part contains data
                        if(x < header.xExtent && y < header.yExtent && z < header.zExtent) {
                          let idx =((((x * header.yExtent) + y) * header.zExtent) + z);
                          data[ idx ] =(byteView[ offset ] - summand) / divisor;
                          if(data[ idx ] > maxValue) maxValue = data[ idx ];
                          ++offset;
                        } else {
                          offset += 8 - i;
                          break;
                        }
                      }
                    }
                  }
                }
              }
            }

            if(!bInputSigma) {
              sigma = this.setSigma(maxValue, location, type, sigma);
            }

            if(type == '2fofc') {
                ic.mapData.header2 = header;
                ic.mapData.data2 = data;
                ic.mapData.matrix2 = this.getMatrix(header);
                ic.mapData.type2 = type;
                ic.mapData.sigma2 = sigma;
            }
            else {
                ic.mapData.header = header;
                ic.mapData.data = data;
                ic.mapData.matrix = this.getMatrix(header);
                ic.mapData.type = type;
                ic.mapData.sigma = sigma;
            }

            return sigma;
        }

        setSigma(maxValue, location, type, sigma) { let ic = this.icn3d, me = ic.icn3dui;
          let inputId;
          if(location == 'file') {
            inputId = 'dsn6sigma' + type;
          }
          else if(location == 'url') {
            inputId = 'dsn6sigmaurl' + type;
          }

          let factor = (type == '2fofc') ? 0.2 : 0.2;

          if(inputId) {
            if(!($("#" + me.pre + inputId).val())) {
              sigma = (factor * maxValue).toFixed(2);
              $("#" + me.pre + inputId).val(sigma);
            }
            else {
              sigma = $("#" + me.pre + inputId).val();
            }
          }

          return sigma;
        }

        getMatrix(header) { let ic = this.icn3d; ic.icn3dui;
            let h = header;

            let basisX = [
              h.xlen,
              0,
              0
            ];

            let basisY = [
              h.ylen * Math.cos(Math.PI / 180.0 * h.gamma),
              h.ylen * Math.sin(Math.PI / 180.0 * h.gamma),
              0
            ];

            let basisZ = [
              h.zlen * Math.cos(Math.PI / 180.0 * h.beta),
              h.zlen *(
                Math.cos(Math.PI / 180.0 * h.alpha) -
                Math.cos(Math.PI / 180.0 * h.gamma) *
                Math.cos(Math.PI / 180.0 * h.beta)
              ) / Math.sin(Math.PI / 180.0 * h.gamma),
              0
            ];
            basisZ[ 2 ] = Math.sqrt(
              h.zlen * h.zlen * Math.sin(Math.PI / 180.0 * h.beta) *
              Math.sin(Math.PI / 180.0 * h.beta) - basisZ[ 1 ] * basisZ[ 1 ]
            );

            let basis = [ [], basisX, basisY, basisZ ];
            let nxyz = [ 0, h.xRate, h.yRate, h.zRate ];
            let mapcrs = [ 0, 1, 2, 3 ];

            let matrix = new THREE.Matrix4();

            matrix.set(
              basis[ mapcrs[1] ][0] / nxyz[ mapcrs[1] ],
              basis[ mapcrs[2] ][0] / nxyz[ mapcrs[2] ],
              basis[ mapcrs[3] ][0] / nxyz[ mapcrs[3] ],
              0,
              basis[ mapcrs[1] ][1] / nxyz[ mapcrs[1] ],
              basis[ mapcrs[2] ][1] / nxyz[ mapcrs[2] ],
              basis[ mapcrs[3] ][1] / nxyz[ mapcrs[3] ],
              0,
              basis[ mapcrs[1] ][2] / nxyz[ mapcrs[1] ],
              basis[ mapcrs[2] ][2] / nxyz[ mapcrs[2] ],
              basis[ mapcrs[3] ][2] / nxyz[ mapcrs[3] ],
              0,
              0, 0, 0, 1
            );

            matrix.multiply(new THREE.Matrix4().makeTranslation(
              h.xStart, h.yStart, h.zStart
            ));

            return matrix;
        }

        loadDsn6File(type) {var ic = this.icn3d, me = ic.icn3dui;
           let thisClass = this;

           let file = $("#" + ic.pre + "dsn6file" + type)[0].files[0];
           let sigma = $("#" + ic.pre + "dsn6sigma" + type).val();
           if(!file) {
             alert("Please select a file before clicking 'Load'");
           }
           else {
             me.utilsCls.checkFileAPI();
             let reader = new FileReader();
             reader.onload = function(e) { let ic = thisClass.icn3d;
               let arrayBuffer = e.target.result; // or = reader.result;

               sigma = thisClass.loadDsn6Data(arrayBuffer, type, sigma, 'file');

               if(type == '2fofc') {
                   ic.bAjax2fofc = true;
               }
               else if(type == 'fofc') {
                   ic.bAjaxfofc = true;
               }
               ic.setOptionCls.setOption('map', type);
               me.htmlCls.clickMenuCls.setLogCmd('load map file ' + $("#" + ic.pre + "dsn6file" + type).val() + ' with sigma ' + sigma, false);
             };
             reader.readAsArrayBuffer(file);
           }
        }

        loadDsn6FileUrl(type) {var ic = this.icn3d, me = ic.icn3dui;
           let url = $("#" + ic.pre + "dsn6fileurl" + type).val();
           let sigma = $("#" + ic.pre + "dsn6sigmaurl" + type).val();
           if(!url) {
              alert("Please input the file URL before clicking 'Load'");
           }
           else {
              sigma = this.dsn6ParserBase(url, type, sigma, 'url');
              me.htmlCls.clickMenuCls.setLogCmd('set map ' + type + ' sigma ' + sigma + ' file dsn6 | ' + encodeURIComponent(url), true);
           }
        }

    }

    /**
     * @file Ccp4 Parser
     * @author Marcin Wojdyr <wojdyr@gmail.com>
     * @private
     * Modified by Jiyao Wang / https://github.com/ncbi/icn3d
     */

    class Ccp4Parser {
          constructor(icn3d) {
              this.icn3d = icn3d;
          }

          async ccp4ParserBase(url, type, sigma, location) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            //https://stackoverflow.com/questions/33902299/using-jquery-ajax-to-download-a-binary-file
            // if(type == '2fofc' && ic.bAjax2fofcccp4) {
            //     ic.mapData.sigma2 = sigma;
            //     ic.setOptionCls.setOption('map', type);
            // }
            // else if(type == 'fofc' && ic.bAjaxfofcccp4) {
            //     ic.mapData.sigma = sigma;
            //     ic.setOptionCls.setOption('map', type);
            // }
            // else {
                let arrayBuffer = await me.getXMLHttpRqstPromise(url, 'GET', 'arraybuffer', '');
                let bInputSigma = true;
                sigma = thisClass.load_map_from_buffer(arrayBuffer, type, sigma, location, bInputSigma);

                // if(type == '2fofc') {
                //     ic.bAjax2fofcccp4 = true;
                // }
                // else if(type == 'fofc') {
                //     ic.bAjaxfofcccp4 = true;
                // }

                ic.setOptionCls.setOption('map', type);

                return sigma;
            // }
        }

        // modified from_ccp4() at https://github.com/uglymol/uglymol.github.io/blob/master/src/elmap.js
        load_map_from_buffer(buf, type, sigma, location, bInputSigma) { let ic = this.icn3d; ic.icn3dui;
            if (buf.byteLength < 1024) throw Error('File shorter than 1024 bytes.');

            //console.log('buf type: ' + Object.prototype.toString.call(buf));
            // for now we assume both file and host are little endian
            const iview = new Int32Array(buf, 0, 256);
            // word 53 - character string 'MAP ' to identify file type
            if (iview[52] !== 0x2050414d) throw Error('not a CCP4 map');

            // map has 3 dimensions referred to as columns (fastest changing), rows
            // and sections (c-r-s)
            const n_crs = [iview[0], iview[1], iview[2]]; // 108, 108, 108
            const mode = iview[3]; //2
            let nb;
            if (mode === 2) nb = 4;
            else if (mode === 0) nb = 1;
            else throw Error('Only Mode 2 and Mode 0 of CCP4 map is supported.');

            const start = [iview[4], iview[5], iview[6]]; // 0,0,0
            const n_grid = [iview[7], iview[8], iview[9]]; // 108,108,108 
            const nsymbt = iview[23]; // size of extended header in bytes
                                      // nsymbt = 1920
     
            if (1024 + nsymbt + nb*n_crs[0]*n_crs[1]*n_crs[2] !== buf.byteLength) {
              throw Error('ccp4 file too short or too long');
            }

            const fview = new Float32Array(buf, 0, buf.byteLength / 4);
            const grid = new GridArray(n_grid);
            const unit_cell = new UnitCell(fview[10], fview[11], fview[12], fview[13], fview[14], fview[15]); // 79.1, 79.1, 79.1, 90, 90, 90
                                          
            // MAPC, MAPR, MAPS - axis corresp to cols, rows, sections (1,2,3 for X,Y,Z)
            const map_crs = [iview[16], iview[17], iview[18]]; // 2,1,3
            const ax = map_crs.indexOf(1);
            const ay = map_crs.indexOf(2);
            const az = map_crs.indexOf(3);
        
            const min = fview[19]; // -0.49
            const max = fview[20]; // 0.94
            //const sg_number = iview[22];
            //const lskflg = iview[24];

            if (nsymbt % 4 !== 0) {
              throw Error('CCP4 map with NSYMBT not divisible by 4 is not supported.');
            }
            let data_view;
            if (mode === 2) data_view = fview;
            else /* mode === 0 */ data_view = new Int8Array(buf);
            let idx = (1024 + nsymbt) / nb | 0; //736

            // We assume that if DMEAN and RMS from the header are not clearly wrong
            // they are what the user wants. Because the map can cover a small part
            // of the asu and its rmsd may be different than the total rmsd.
            // let stats = { mean: 0.0, rms: 1.0 };
            // stats.mean = fview[21]; //0
            // stats.rms = fview[54]; //0.15
            // if (stats.mean < min || stats.mean > max || stats.rms <= 0) {
            //   stats = this.calculate_stddev(data_view, idx);
            // }

            let b1 = 1;
            let b0 = 0;
            // if the file was converted by mapmode2to0 - scale the data
            if (mode === 0 && iview[39] === -128 && iview[40] === 127) { //39:0, 40:0
              // scaling f(x)=b1*x+b0 such that f(-128)=min and f(127)=max
              b1 = (max - min) / 255.0;
              b0 = 0.5 * (min + max + b1);
            }
        
            const end = [start[0] + n_crs[0], start[1] + n_crs[1], start[2] + n_crs[2]];
            let it = [0, 0, 0];
            let maxValue = -999;
            for (it[2] = start[2]; it[2] < end[2]; it[2]++) { // sections
              for (it[1] = start[1]; it[1] < end[1]; it[1]++) { // rows
                for (it[0] = start[0]; it[0] < end[0]; it[0]++) { // cols
                  let value = b1 * data_view[idx] + b0;
                  grid.set_grid_value(it[ax], it[ay], it[az], value);

                  if(value > maxValue) maxValue = value;
                  idx++;
                }
              }
            }
            
    /*
            if (expand_symmetry && nsymbt > 0) {
              const u8view = new Uint8Array(buf);
              for (let i = 0; i+80 <= nsymbt; i += 80) {
                let j;
                let symop = '';
                for (j = 0; j < 80; ++j) {
                  symop += String.fromCharCode(u8view[1024 + i + j]);
                }
                if (/^\s*x\s*,\s*y\s*,\s*z\s*$/i.test(symop)) continue;  // skip x,y,z
                //console.log('sym ops', symop.trim());
                let mat = this.parse_symop(symop);
                // Note: we apply here symops to grid points instead of coordinates.
                // In the cases we came across it is equivalent, but in general not.
                for (j = 0; j < 3; ++j) {
                  mat[j][3] = Math.round(mat[j][3] * n_grid[j]) | 0;
                }
                idx = (1024 + nsymbt) / nb | 0;
                let xyz = [0, 0, 0];
                for (it[2] = start[2]; it[2] < end[2]; it[2]++) { // sections
                  for (it[1] = start[1]; it[1] < end[1]; it[1]++) { // rows
                    for (it[0] = start[0]; it[0] < end[0]; it[0]++) { // cols
                      for (j = 0; j < 3; ++j) {
                        xyz[j] = it[ax] * mat[j][0] + it[ay] * mat[j][1] +
                                 it[az] * mat[j][2] + mat[j][3];
                      }
                      let value = b1 * data_view[idx] + b0;
                      grid.set_grid_value(xyz[0], xyz[1], xyz[2], value);

                      if(value > maxValue) maxValue = value;
                      idx++;
                    }
                  }
                }
              }
            }
    */

            if(!bInputSigma) {
              sigma = ic.dsn6ParserCls.setSigma(maxValue, location, type, sigma);
            }

            if(type == '2fofc') {
              ic.mapData.ccp4 = 1;
              ic.mapData.grid2 = grid;
              ic.mapData.unit_cell2 = unit_cell;
              ic.mapData.type2 = type;
              ic.mapData.sigma2 = sigma;
            }
            else {
              ic.mapData.ccp4 = 1;
              ic.mapData.grid = grid;
              ic.mapData.unit_cell = unit_cell;
              ic.mapData.type = type;
              ic.mapData.sigma = sigma;
            }

            return sigma;
        }

        load_maps_from_mtz_buffer(mtz, type, sigma, location, bInputSigma, bRcsb) { let ic = this.icn3d; ic.icn3dui;
          let is_diff = (type == 'fofc'); // diff: fofc, non-diff: 2fofc
          let dataArray = mtz.calculate_map(is_diff);

          let mc = mtz.cell;
          const unit_cell = new UnitCell(mc.a, mc.b, mc.c, mc.alpha, mc.beta, mc.gamma);

          let maxValue = -999;
          for(let i = 0, il = dataArray.length; i < il; ++i) {
              if(dataArray[i] > maxValue) maxValue = dataArray[i];
          }

          if(!bInputSigma) {
            sigma = ic.dsn6ParserCls.setSigma(maxValue, location, type, sigma);
          }

          if(!bRcsb) {
            const grid = new GridArray([mtz.nx, mtz.ny, mtz.nz]);
            grid.values.set(dataArray);

            if(type == '2fofc') {
              ic.mapData.ccp4 = 1;
              ic.mapData.grid2 = grid;
              ic.mapData.unit_cell2 = unit_cell;
              ic.mapData.type2 = type;
              ic.mapData.sigma2 = sigma;
            }
            else {
              ic.mapData.ccp4 = 1;
              ic.mapData.grid = grid;
              ic.mapData.unit_cell = unit_cell;
              ic.mapData.type = type;
              ic.mapData.sigma = sigma;
            }
          }
          else {
            ic.mapData.ccp4 = 0;

            let header = {xExtent: mtz.nx, yExtent: mtz.ny, zExtent: mtz.nz, mean: undefined, sigma: sigma, ccp4: 1};
            
            header.xStart = 0; //start[ 0 ];
            header.yStart = 0; //start[ 1 ];
            header.zStart = 0; //start[ 2 ];

            header.xRate = mtz.nx;
            header.yRate = mtz.ny;
            header.zRate = mtz.nz;

            header.xlen = mc.a;
            header.ylen = mc.b;
            header.zlen = mc.c;

            header.alpha = mc.alpha;
            header.beta = mc.beta;
            header.gamma = mc.gamma;

            if(type == '2fofc') {
                ic.mapData.header2 = header;
                ic.mapData.data2 = dataArray;

                ic.mapData.matrix2 = ic.dsn6ParserCls.getMatrix(header);
                ic.mapData.type2 = type;
                ic.mapData.sigma2 = sigma;
            }
            else {
                ic.mapData.header = header;
                ic.mapData.data = dataArray;

                ic.mapData.matrix = ic.dsn6ParserCls.getMatrix(header);
                ic.mapData.type = type;
                ic.mapData.sigma = sigma;
            }
          }

          mtz.delete();

          return sigma;
        }

        // calculate_stddev(a, offset) {
        //   let sum = 0;
        //   let sq_sum = 0;
        //   const alen = a.length;
        //   for (let i = offset; i < alen; i++) {
        //     sum += a[i];
        //     sq_sum += a[i] * a[i];
        //   }
        //   const mean = sum / (alen - offset);
        //   const variance = sq_sum / (alen - offset) - mean * mean;
        //   return {mean: mean, rms: Math.sqrt(variance)};
        // }
        
        parse_symop(symop) {
          const ops = symop.toLowerCase().replace(/\s+/g, '').split(',');
          if (ops.length !== 3) throw Error('Unexpected symop: ' + symop);
          let mat = [];
          for (let i = 0; i < 3; i++) {
            const terms = ops[i].split(/(?=[+-])/);
            let row = [0, 0, 0, 0];
            for (let j = 0; j < terms.length; j++) {
              const term = terms[j];
              const sign = (term[0] === '-' ? -1 : 1);
              let m = terms[j].match(/^[+-]?([xyz])$/);
              if (m) {
                const pos = {x: 0, y: 1, z: 2}[m[1]];
                row[pos] = sign;
              } else {
                m = terms[j].match(/^[+-]?(\d)\/(\d)$/);
                if (!m) throw Error('What is ' + terms[j] + ' in ' + symop);
                row[3] = sign * Number(m[1]) / Number(m[2]);
              }
            }
            mat.push(row);
          }
          return mat;
        }    

        loadCcp4File(type) {let ic = this.icn3d, me = ic.icn3dui;
           let thisClass = this;

           let file = $("#" + ic.pre + "dsn6file" + type)[0].files[0];
           let sigma = $("#" + ic.pre + "dsn6sigma" + type).val();
           if(!file) {
             alert("Please select a file before clicking 'Load'");
           }
           else {
             me.utilsCls.checkFileAPI();
             let reader = new FileReader();
             reader.onload = function(e) { let ic = thisClass.icn3d;
                let arrayBuffer = e.target.result; // or = reader.result;
                sigma = thisClass.load_map_from_buffer(arrayBuffer, type, sigma, 'file');

                // if(type == '2fofc') {
                //   ic.bAjax2fofcCcp4 = true;
                // }
                // else if(type == 'fofc') {
                //     ic.bAjaxfofcCcp4 = true;
                // }
                ic.setOptionCls.setOption('map', type);
                me.htmlCls.clickMenuCls.setLogCmd('load map file ' + $("#" + ic.pre + "dsn6file" + type).val() + ' with sigma ' + sigma, false);
             };
             reader.readAsArrayBuffer(file);
           }
        }

        async loadCcp4FileUrl(type) { let ic = this.icn3d, me = ic.icn3dui;
           let url = $("#" + ic.pre + "dsn6fileurl" + type).val();
           let sigma = $("#" + ic.pre + "dsn6sigmaurl" + type).val();
           if(!url) {
                alert("Please input the file URL before clicking 'Load'");
           }
           else {
               sigma = await this.ccp4ParserBase(url, type, sigma, 'file');

               me.htmlCls.clickMenuCls.setLogCmd('set map ' + type + ' sigma ' + sigma + ' file ccp4 | ' + encodeURIComponent(url), true);
           }
        }

        // Extract a block of density for calculating an isosurface using the
        // separate marching cubes implementation.
        extract_block(grid, unit_cell, radius, center, typeDetail) { let ic = this.icn3d; ic.icn3dui;
          //     let grid = this.grid;
          //     let unit_cell = this.unit_cell;
          if (grid == null || unit_cell == null) { return; }
          let fc = unit_cell.fractionalize(center);

          let r = [radius / unit_cell.parameters[0],
                  radius / unit_cell.parameters[1],
                  radius / unit_cell.parameters[2]];
          let grid_min = grid.frac2grid([fc[0] - r[0], fc[1] - r[1], fc[2] - r[2]]);
          let grid_max = grid.frac2grid([fc[0] + r[0], fc[1] + r[1], fc[2] + r[2]]);

          let size = [grid_max[0] - grid_min[0] + 1,
                      grid_max[1] - grid_min[1] + 1,
                      grid_max[2] - grid_min[2] + 1];
          let points = [];
          let values = [];
          let threshold = 1;
          let bAtoms = ic.hAtoms && Object.keys(ic.hAtoms).length > 0;
          for (let i = grid_min[0]; i <= grid_max[0]; i++) {
              for (let j = grid_min[1]; j <= grid_max[1]; j++) {
                  for (let k = grid_min[2]; k <= grid_max[2]; k++) {
                    let frac = grid.grid2frac(i, j, k);
                    let orth = unit_cell.orthogonalize(frac);
                    points.push(orth);

                    // get overlap between map and atoms
                    let position = new THREE.Vector3(orth[0], orth[1], orth[2]);
                    let atomsNear = ic.rayCls.getAtomsFromPosition(position, threshold, ic.hAtoms);

                    let map_value = (atomsNear || !bAtoms) ? grid.get_grid_value(i, j, k) : 0;

                    if(typeDetail == 'fofc_pos' && map_value < 0) map_value = 0;
                    if(typeDetail == 'fofc_neg') map_value = (map_value > 0) ? 0 : -map_value;

                    values.push(map_value);
                  }
              }
          }

          return {size: size, values: values, points: points};
      //     this.block.set(points, values, size);
        };

        marchingCubes(dims, values, points, isolevel, method) {  let ic = this.icn3d; ic.icn3dui;
          const edgeTable = new Int32Array([
            0x0  , 0x0  , 0x202, 0x302, 0x406, 0x406, 0x604, 0x704,
            0x804, 0x805, 0xa06, 0xa06, 0xc0a, 0xd03, 0xe08, 0xf00,
            0x90 , 0x98 , 0x292, 0x292, 0x496, 0x49e, 0x694, 0x694,
            0x894, 0x894, 0xa96, 0xa96, 0xc9a, 0xc92, 0xe91, 0xe90,
            0x230, 0x230, 0x33 , 0x13a, 0x636, 0x636, 0x434, 0x43c,
            0xa34, 0xa35, 0x837, 0x936, 0xe3a, 0xf32, 0xc31, 0xd30,
            0x2a0, 0x2a8, 0xa3 , 0xaa , 0x6a6, 0x6af, 0x5a4, 0x4ac,
            0xaa4, 0xaa4, 0x9a6, 0x8a6, 0xfaa, 0xea3, 0xca1, 0xca0,
            0x460, 0x460, 0x662, 0x762, 0x66 , 0x66 , 0x265, 0x364,
            0xc64, 0xc65, 0xe66, 0xe66, 0x86a, 0x863, 0xa69, 0xa60,
            0x4f0, 0x4f8, 0x6f2, 0x6f2, 0xf6 , 0xfe , 0x2f5, 0x2fc,
            0xcf4, 0xcf4, 0xef6, 0xef6, 0x8fa, 0x8f3, 0xaf9, 0xaf0,
            0x650, 0x650, 0x453, 0x552, 0x256, 0x256, 0x54 , 0x154,
            0xe54, 0xf54, 0xc57, 0xd56, 0xa5a, 0xb52, 0x859, 0x950,
            0x7c0, 0x6c1, 0x5c2, 0x4c2, 0x3c6, 0x2ce, 0xc5 , 0xc4 ,
            0xfc4, 0xec5, 0xdc6, 0xcc6, 0xbca, 0xac2, 0x8c1, 0x8c0,
            0x8c0, 0x8c0, 0xac2, 0xbc2, 0xcc6, 0xcc6, 0xec4, 0xfcc,
            0xc4 , 0xc5 , 0x2c6, 0x3c6, 0x4c2, 0x5c2, 0x6c1, 0x7c0,
            0x950, 0x859, 0xb52, 0xa5a, 0xd56, 0xc57, 0xe54, 0xe5c,
            0x154, 0x54 , 0x25e, 0x256, 0x552, 0x453, 0x658, 0x650,
            0xaf0, 0xaf0, 0x8f3, 0x8fa, 0xef6, 0xef6, 0xcf4, 0xcfc,
            0x2f4, 0x3f5, 0xff , 0x1f6, 0x6f2, 0x6f3, 0x4f9, 0x5f0,
            0xa60, 0xa69, 0x863, 0x86a, 0xe66, 0xe67, 0xd65, 0xc6c,
            0x364, 0x265, 0x166, 0x66 , 0x76a, 0x663, 0x460, 0x460,
            0xca0, 0xca0, 0xea2, 0xfa2, 0x8a6, 0x8a6, 0xaa4, 0xba4,
            0x4ac, 0x5a4, 0x6ae, 0x7a6, 0xaa , 0xa3 , 0x2a8, 0x2a0,
            0xd30, 0xc31, 0xf32, 0xe3a, 0x936, 0x837, 0xb35, 0xa34,
            0x43c, 0x434, 0x73e, 0x636, 0x13a, 0x33 , 0x339, 0x230,
            0xe90, 0xe90, 0xc92, 0xc9a, 0xa96, 0xa96, 0x894, 0x89c,
            0x694, 0x695, 0x49f, 0x496, 0x292, 0x392, 0x98 , 0x90 ,
            0xf00, 0xe08, 0xd03, 0xc0a, 0xa06, 0xa0e, 0x805, 0x804,
            0x704, 0x604, 0x506, 0x406, 0x302, 0x202, 0x0  , 0x0]);

          const segTable = [
            [],
            [],
            [1, 9],
            [1, 8, 1, 9],
            [2, 10, 10, 1],
            [2, 10, 10, 1],
            [9, 2, 2, 10, 10, 9],
            [2, 8, 2, 10, 10, 8, 10, 9],
            [11, 2],
            [0, 11, 11, 2],
            [1, 9, 11, 2],
            [1, 11, 11, 2, 1, 9, 9, 11],
            [3, 10, 10, 1, 11, 10],
            [0, 10, 10, 1, 8, 10, 11, 10],
            [3, 9, 11, 9, 11, 10, 10, 9],
            [8, 10, 10, 9, 11, 10],
            [4, 7],
            [4, 3, 4, 7],
            [1, 9, 4, 7],
            [4, 1, 1, 9, 4, 7, 7, 1],
            [2, 10, 10, 1, 4, 7],
            [3, 4, 4, 7, 2, 10, 10, 1],
            [9, 2, 2, 10, 10, 9, 4, 7],
            [2, 10, 10, 9, 9, 2, 9, 7, 7, 2, 4, 7],
            [4, 7, 11, 2],
            [11, 4, 4, 7, 11, 2, 2, 4],
            [1, 9, 4, 7, 11, 2],
            [4, 7, 11, 4, 11, 9, 11, 2, 2, 9, 1, 9],
            [3, 10, 10, 1, 11, 10, 4, 7],
            [1, 11, 11, 10, 10, 1, 1, 4, 4, 11, 4, 7],
            [4, 7, 0, 11, 11, 9, 11, 10, 10, 9],
            [4, 7, 11, 4, 11, 9, 11, 10, 10, 9],
            [9, 5, 5, 4],
            [9, 5, 5, 4],
            [0, 5, 5, 4, 1, 5],
            [8, 5, 5, 4, 3, 5, 1, 5],
            [2, 10, 10, 1, 9, 5, 5, 4],
            [2, 10, 10, 1, 9, 5, 5, 4],
            [5, 2, 2, 10, 10, 5, 5, 4, 4, 2],
            [2, 10, 10, 5, 5, 2, 5, 3, 5, 4, 4, 3],
            [9, 5, 5, 4, 11, 2],
            [0, 11, 11, 2, 9, 5, 5, 4],
            [0, 5, 5, 4, 1, 5, 11, 2],
            [1, 5, 5, 2, 5, 8, 8, 2, 11, 2, 5, 4],
            [10, 3, 11, 10, 10, 1, 9, 5, 5, 4],
            [9, 5, 5, 4, 8, 1, 8, 10, 10, 1, 11, 10],
            [5, 4, 0, 5, 0, 11, 11, 5, 11, 10, 10, 5],
            [5, 4, 8, 5, 8, 10, 10, 5, 11, 10],
            [9, 7, 5, 7, 9, 5],
            [9, 3, 9, 5, 5, 3, 5, 7],
            [0, 7, 1, 7, 1, 5, 5, 7],
            [1, 5, 5, 3, 5, 7],
            [9, 7, 9, 5, 5, 7, 10, 1, 2, 10],
            [10, 1, 2, 10, 9, 5, 5, 0, 5, 3, 5, 7],
            [2, 8, 2, 5, 5, 8, 5, 7, 10, 5, 2, 10],
            [2, 10, 10, 5, 5, 2, 5, 3, 5, 7],
            [7, 9, 9, 5, 5, 7, 11, 2],
            [9, 5, 5, 7, 7, 9, 7, 2, 2, 9, 11, 2],
            [11, 2, 1, 8, 1, 7, 1, 5, 5, 7],
            [11, 2, 1, 11, 1, 7, 1, 5, 5, 7],
            [9, 5, 5, 8, 5, 7, 10, 1, 3, 10, 11, 10],
            [5, 7, 7, 0, 0, 5, 9, 5, 11, 0, 0, 10, 10, 1, 11, 10],
            [11, 10, 10, 0, 0, 11, 10, 5, 5, 0, 0, 7, 5, 7],
            [11, 10, 10, 5, 5, 11, 5, 7],
            [10, 6, 6, 5, 5, 10],
            [5, 10, 10, 6, 6, 5],
            [1, 9, 5, 10, 10, 6, 6, 5],
            [1, 8, 1, 9, 5, 10, 10, 6, 6, 5],
            [1, 6, 6, 5, 5, 1, 2, 6],
            [1, 6, 6, 5, 5, 1, 2, 6],
            [9, 6, 6, 5, 5, 9, 0, 6, 2, 6],
            [5, 9, 8, 5, 8, 2, 2, 5, 2, 6, 6, 5],
            [11, 2, 10, 6, 6, 5, 5, 10],
            [11, 0, 11, 2, 10, 6, 6, 5, 5, 10],
            [1, 9, 11, 2, 5, 10, 10, 6, 6, 5],
            [5, 10, 10, 6, 6, 5, 1, 9, 9, 2, 9, 11, 11, 2],
            [6, 3, 11, 6, 6, 5, 5, 3, 5, 1],
            [11, 0, 11, 5, 5, 0, 5, 1, 11, 6, 6, 5],
            [11, 6, 6, 3, 6, 0, 6, 5, 5, 0, 5, 9],
            [6, 5, 5, 9, 9, 6, 9, 11, 11, 6],
            [5, 10, 10, 6, 6, 5, 4, 7],
            [4, 3, 4, 7, 6, 5, 5, 10, 10, 6],
            [1, 9, 5, 10, 10, 6, 6, 5, 4, 7],
            [10, 6, 6, 5, 5, 10, 1, 9, 9, 7, 7, 1, 4, 7],
            [6, 1, 2, 6, 6, 5, 5, 1, 4, 7],
            [2, 5, 5, 1, 2, 6, 6, 5, 4, 3, 4, 7],
            [4, 7, 0, 5, 5, 9, 0, 6, 6, 5, 2, 6],
            [3, 9, 9, 7, 4, 7, 2, 9, 5, 9, 9, 6, 6, 5, 2, 6],
            [11, 2, 4, 7, 10, 6, 6, 5, 5, 10],
            [5, 10, 10, 6, 6, 5, 4, 7, 7, 2, 2, 4, 11, 2],
            [1, 9, 4, 7, 11, 2, 5, 10, 10, 6, 6, 5],
            [9, 2, 1, 9, 9, 11, 11, 2, 4, 11, 4, 7, 5, 10, 10, 6, 6, 5],
            [4, 7, 11, 5, 5, 3, 5, 1, 11, 6, 6, 5],
            [5, 1, 1, 11, 11, 5, 11, 6, 6, 5, 0, 11, 11, 4, 4, 7],
            [0, 5, 5, 9, 0, 6, 6, 5, 3, 6, 11, 6, 4, 7],
            [6, 5, 5, 9, 9, 6, 9, 11, 11, 6, 4, 7, 7, 9],
            [10, 4, 9, 10, 6, 4, 10, 6],
            [4, 10, 10, 6, 6, 4, 9, 10],
            [10, 0, 1, 10, 10, 6, 6, 0, 6, 4],
            [1, 8, 1, 6, 6, 8, 6, 4, 1, 10, 10, 6],
            [1, 4, 9, 1, 2, 4, 2, 6, 6, 4],
            [2, 9, 9, 1, 2, 4, 2, 6, 6, 4],
            [2, 4, 2, 6, 6, 4],
            [2, 8, 2, 4, 2, 6, 6, 4],
            [10, 4, 9, 10, 10, 6, 6, 4, 11, 2],
            [8, 2, 11, 2, 9, 10, 10, 4, 10, 6, 6, 4],
            [11, 2, 1, 6, 6, 0, 6, 4, 1, 10, 10, 6],
            [6, 4, 4, 1, 1, 6, 1, 10, 10, 6, 8, 1, 1, 11, 11, 2],
            [9, 6, 6, 4, 9, 3, 3, 6, 9, 1, 11, 6],
            [11, 1, 1, 8, 11, 6, 6, 1, 9, 1, 1, 4, 6, 4],
            [11, 6, 6, 3, 6, 0, 6, 4],
            [6, 4, 8, 6, 11, 6],
            [7, 10, 10, 6, 6, 7, 8, 10, 9, 10],
            [0, 7, 0, 10, 10, 7, 9, 10, 6, 7, 10, 6],
            [10, 6, 6, 7, 7, 10, 1, 10, 7, 1, 8, 1],
            [10, 6, 6, 7, 7, 10, 7, 1, 1, 10],
            [2, 6, 6, 1, 6, 8, 8, 1, 9, 1, 6, 7],
            [2, 6, 6, 9, 9, 2, 9, 1, 6, 7, 7, 9, 9, 3],
            [0, 7, 0, 6, 6, 7, 2, 6],
            [2, 7, 6, 7, 2, 6],
            [11, 2, 10, 6, 6, 8, 8, 10, 9, 10, 6, 7],
            [0, 7, 7, 2, 11, 2, 9, 7, 6, 7, 7, 10, 10, 6, 9, 10],
            [1, 8, 1, 7, 1, 10, 10, 7, 6, 7, 10, 6, 11, 2],
            [11, 2, 1, 11, 1, 7, 10, 6, 6, 1, 1, 10, 6, 7],
            [9, 6, 6, 8, 6, 7, 9, 1, 1, 6, 11, 6, 6, 3],
            [9, 1, 11, 6, 6, 7],
            [0, 7, 0, 6, 6, 7, 11, 0, 11, 6],
            [11, 6, 6, 7],
            [7, 6, 6, 11],
            [7, 6, 6, 11],
            [1, 9, 7, 6, 6, 11],
            [8, 1, 1, 9, 7, 6, 6, 11],
            [10, 1, 2, 10, 6, 11, 7, 6],
            [2, 10, 10, 1, 6, 11, 7, 6],
            [2, 9, 2, 10, 10, 9, 6, 11, 7, 6],
            [6, 11, 7, 6, 2, 10, 10, 3, 10, 8, 10, 9],
            [7, 2, 6, 2, 7, 6],
            [7, 0, 7, 6, 6, 0, 6, 2],
            [2, 7, 7, 6, 6, 2, 1, 9],
            [1, 6, 6, 2, 1, 8, 8, 6, 1, 9, 7, 6],
            [10, 7, 7, 6, 6, 10, 10, 1, 1, 7],
            [10, 7, 7, 6, 6, 10, 1, 7, 10, 1, 1, 8],
            [7, 0, 7, 10, 10, 0, 10, 9, 6, 10, 7, 6],
            [7, 6, 6, 10, 10, 7, 10, 8, 10, 9],
            [6, 8, 4, 6, 6, 11],
            [3, 6, 6, 11, 0, 6, 4, 6],
            [8, 6, 6, 11, 4, 6, 1, 9],
            [4, 6, 6, 9, 6, 3, 3, 9, 1, 9, 6, 11],
            [6, 8, 4, 6, 6, 11, 2, 10, 10, 1],
            [2, 10, 10, 1, 0, 11, 0, 6, 6, 11, 4, 6],
            [4, 11, 4, 6, 6, 11, 2, 9, 2, 10, 10, 9],
            [10, 9, 9, 3, 3, 10, 2, 10, 4, 3, 3, 6, 6, 11, 4, 6],
            [8, 2, 4, 2, 4, 6, 6, 2],
            [4, 2, 4, 6, 6, 2],
            [1, 9, 3, 4, 4, 2, 4, 6, 6, 2],
            [1, 9, 4, 1, 4, 2, 4, 6, 6, 2],
            [8, 1, 8, 6, 6, 1, 4, 6, 6, 10, 10, 1],
            [10, 1, 0, 10, 0, 6, 6, 10, 4, 6],
            [4, 6, 6, 3, 3, 4, 6, 10, 10, 3, 3, 9, 10, 9],
            [10, 9, 4, 10, 6, 10, 4, 6],
            [9, 5, 5, 4, 7, 6, 6, 11],
            [9, 5, 5, 4, 7, 6, 6, 11],
            [5, 0, 1, 5, 5, 4, 7, 6, 6, 11],
            [7, 6, 6, 11, 3, 4, 3, 5, 5, 4, 1, 5],
            [9, 5, 5, 4, 10, 1, 2, 10, 7, 6, 6, 11],
            [6, 11, 7, 6, 2, 10, 10, 1, 9, 5, 5, 4],
            [7, 6, 6, 11, 5, 4, 4, 10, 10, 5, 4, 2, 2, 10],
            [3, 4, 3, 5, 5, 4, 2, 5, 10, 5, 2, 10, 7, 6, 6, 11],
            [7, 2, 7, 6, 6, 2, 5, 4, 9, 5],
            [9, 5, 5, 4, 8, 6, 6, 0, 6, 2, 7, 6],
            [3, 6, 6, 2, 7, 6, 1, 5, 5, 0, 5, 4],
            [6, 2, 2, 8, 8, 6, 7, 6, 1, 8, 8, 5, 5, 4, 1, 5],
            [9, 5, 5, 4, 10, 1, 1, 6, 6, 10, 1, 7, 7, 6],
            [1, 6, 6, 10, 10, 1, 1, 7, 7, 6, 0, 7, 9, 5, 5, 4],
            [0, 10, 10, 4, 10, 5, 5, 4, 3, 10, 6, 10, 10, 7, 7, 6],
            [7, 6, 6, 10, 10, 7, 10, 8, 5, 4, 4, 10, 10, 5],
            [6, 9, 9, 5, 5, 6, 6, 11, 11, 9],
            [3, 6, 6, 11, 0, 6, 0, 5, 5, 6, 9, 5],
            [0, 11, 0, 5, 5, 11, 1, 5, 5, 6, 6, 11],
            [6, 11, 3, 6, 3, 5, 5, 6, 1, 5],
            [2, 10, 10, 1, 9, 5, 5, 11, 11, 9, 5, 6, 6, 11],
            [0, 11, 0, 6, 6, 11, 9, 6, 5, 6, 9, 5, 2, 10, 10, 1],
            [8, 5, 5, 11, 5, 6, 6, 11, 0, 5, 10, 5, 5, 2, 2, 10],
            [6, 11, 3, 6, 3, 5, 5, 6, 2, 10, 10, 3, 10, 5],
            [5, 8, 9, 5, 5, 2, 2, 8, 5, 6, 6, 2],
            [9, 5, 5, 6, 6, 9, 6, 0, 6, 2],
            [1, 5, 5, 8, 8, 1, 5, 6, 6, 8, 8, 2, 6, 2],
            [1, 5, 5, 6, 6, 1, 6, 2],
            [3, 6, 6, 1, 6, 10, 10, 1, 8, 6, 5, 6, 6, 9, 9, 5],
            [10, 1, 0, 10, 0, 6, 6, 10, 9, 5, 5, 0, 5, 6],
            [5, 6, 6, 10, 10, 5],
            [10, 5, 5, 6, 6, 10],
            [11, 5, 5, 10, 10, 11, 7, 5],
            [11, 5, 5, 10, 10, 11, 7, 5],
            [5, 11, 7, 5, 5, 10, 10, 11, 1, 9],
            [10, 7, 7, 5, 5, 10, 10, 11, 8, 1, 1, 9],
            [11, 1, 2, 11, 7, 1, 7, 5, 5, 1],
            [2, 7, 7, 1, 7, 5, 5, 1, 2, 11],
            [9, 7, 7, 5, 5, 9, 9, 2, 2, 7, 2, 11],
            [7, 5, 5, 2, 2, 7, 2, 11, 5, 9, 9, 2, 2, 8],
            [2, 5, 5, 10, 10, 2, 3, 5, 7, 5],
            [8, 2, 8, 5, 5, 2, 7, 5, 10, 2, 5, 10],
            [1, 9, 5, 10, 10, 3, 3, 5, 7, 5, 10, 2],
            [8, 2, 2, 9, 1, 9, 7, 2, 10, 2, 2, 5, 5, 10, 7, 5],
            [3, 5, 5, 1, 7, 5],
            [7, 0, 7, 1, 7, 5, 5, 1],
            [3, 9, 3, 5, 5, 9, 7, 5],
            [7, 9, 5, 9, 7, 5],
            [5, 8, 4, 5, 5, 10, 10, 8, 10, 11],
            [5, 0, 4, 5, 5, 11, 11, 0, 5, 10, 10, 11],
            [1, 9, 4, 10, 10, 8, 10, 11, 4, 5, 5, 10],
            [10, 11, 11, 4, 4, 10, 4, 5, 5, 10, 3, 4, 4, 1, 1, 9],
            [2, 5, 5, 1, 2, 8, 8, 5, 2, 11, 4, 5],
            [4, 11, 11, 0, 4, 5, 5, 11, 2, 11, 11, 1, 5, 1],
            [2, 5, 5, 0, 5, 9, 2, 11, 11, 5, 4, 5, 5, 8],
            [4, 5, 5, 9, 2, 11],
            [2, 5, 5, 10, 10, 2, 3, 5, 3, 4, 4, 5],
            [5, 10, 10, 2, 2, 5, 2, 4, 4, 5],
            [3, 10, 10, 2, 3, 5, 5, 10, 8, 5, 4, 5, 1, 9],
            [5, 10, 10, 2, 2, 5, 2, 4, 4, 5, 1, 9, 9, 2],
            [4, 5, 5, 8, 5, 3, 5, 1],
            [4, 5, 5, 0, 5, 1],
            [4, 5, 5, 8, 5, 3, 0, 5, 5, 9],
            [4, 5, 5, 9],
            [4, 11, 7, 4, 9, 11, 9, 10, 10, 11],
            [9, 7, 7, 4, 9, 11, 9, 10, 10, 11],
            [1, 10, 10, 11, 11, 1, 11, 4, 4, 1, 7, 4],
            [1, 4, 4, 3, 1, 10, 10, 4, 7, 4, 4, 11, 10, 11],
            [4, 11, 7, 4, 9, 11, 9, 2, 2, 11, 9, 1],
            [9, 7, 7, 4, 9, 11, 9, 1, 1, 11, 2, 11],
            [7, 4, 4, 11, 4, 2, 2, 11],
            [7, 4, 4, 11, 4, 2, 2, 11, 3, 4],
            [2, 9, 9, 10, 10, 2, 2, 7, 7, 9, 7, 4],
            [9, 10, 10, 7, 7, 9, 7, 4, 10, 2, 2, 7, 7, 0],
            [7, 10, 10, 3, 10, 2, 7, 4, 4, 10, 1, 10, 10, 0],
            [1, 10, 10, 2, 7, 4],
            [9, 1, 1, 4, 1, 7, 7, 4],
            [9, 1, 1, 4, 1, 7, 7, 4, 8, 1],
            [3, 4, 7, 4],
            [7, 4],
            [9, 10, 10, 8, 10, 11],
            [9, 3, 9, 11, 9, 10, 10, 11],
            [1, 10, 10, 0, 10, 8, 10, 11],
            [1, 10, 10, 3, 10, 11],
            [2, 11, 11, 1, 11, 9, 9, 1],
            [9, 3, 9, 11, 2, 9, 9, 1, 2, 11],
            [2, 11, 11, 0],
            [2, 11],
            [8, 2, 8, 10, 10, 2, 9, 10],
            [9, 10, 10, 2, 2, 9],
            [8, 2, 8, 10, 10, 2, 1, 8, 1, 10],
            [1, 10, 10, 2],
            [8, 1, 9, 1],
            [9, 1],
            [],
            []];

          const snap = (method === 'snapped MC');
          // const seg_table = (method === 'squarish' ? segTable2 : segTable);
          const seg_table = segTable;

          let vlist = new Array(12);
          const vert_offsets = this.calculateVertOffsets(dims);

          const edgeIndex = [[0,1], [1,2], [2,3], [3,0], [4,5], [5,6],
                    [6,7], [7,4], [0,4], [1,5], [2,6], [3,7]];  

          let vertex_values = new Float32Array(8);
          let p0 = [0, 0, 0]; // unused initial value - to make Flow happy
          let vertex_points = [p0, p0, p0, p0, p0, p0, p0, p0];
          const size_x = dims[0];
          const size_y = dims[1];
          const size_z = dims[2];
          if (values == null || points == null) return;
          let vertices = [];
          let segments = [];
          let vertex_count = 0;
          for (let x = 0; x < size_x - 1; x++) {
            for (let y = 0; y < size_y - 1; y++) {
              for (let z = 0; z < size_z - 1; z++) {
                const offset0 = z + size_z * (y + size_y * x);
                let cubeindex = 0;
                let i;
                let j;
                for (i = 0; i < 8; ++i) {
                  j = offset0 + vert_offsets[i];
                  cubeindex |= (values[j] < isolevel) ? 1 << i : 0;
                }
                if (cubeindex === 0 || cubeindex === 255) continue;
                for (i = 0; i < 8; ++i) {
                  j = offset0 + vert_offsets[i];
                  vertex_values[i] = values[j];
                  vertex_points[i] = points[j];
                }
        
                // 12 bit number, indicates which edges are crossed by the isosurface
                const edge_mask = edgeTable[cubeindex];
        
                // check which edges are crossed, and estimate the point location
                // using a weighted average of scalar values at edge endpoints.
                for (i = 0; i < 12; ++i) {
                  if ((edge_mask & (1 << i)) !== 0) {
                    const e = edgeIndex[i];
                    let mu = (isolevel - vertex_values[e[0]]) /
                            (vertex_values[e[1]] - vertex_values[e[0]]);
                    if (snap === true) {
                      if (mu > 0.85) mu = 1;
                      else if (mu < 0.15) mu = 0;
                    }
                    const p1 = vertex_points[e[0]];
                    const p2 = vertex_points[e[1]];
                    // The number of added vertices could be roughly halved
                    // if we avoided duplicates between neighbouring cells.
                    // Using a map for lookups is too slow, perhaps a big
                    // array would do?
                    vertices.push(p1[0] + (p2[0] - p1[0]) * mu,
                                  p1[1] + (p2[1] - p1[1]) * mu,
                                  p1[2] + (p2[2] - p1[2]) * mu);
                    vlist[i] = vertex_count++;
                  }
                }
                const t = seg_table[cubeindex];
                for (i = 0; i < t.length; i++) {
                  segments.push(vlist[t[i]]);
                }
              }
            }
          }

          return { vertices: vertices, segments: segments };
        }

        // return offsets relative to vertex [0,0,0]
        calculateVertOffsets(dims) { let ic = this.icn3d; ic.icn3dui;
          let vert_offsets = [];
          const cubeVerts = [[0,0,0], [1,0,0], [1,1,0], [0,1,0],
                    [0,0,1], [1,0,1], [1,1,1], [0,1,1]];
                  
          for (let i = 0; i < 8; ++i) {
            const v = cubeVerts[i];
            vert_offsets.push(v[0] + dims[2] * (v[1] + dims[1] * v[2]));
          }
          return vert_offsets;
        }

        makeChickenWire(data, typeDetail) { let ic = this.icn3d, me = ic.icn3dui;
          let geom = new THREE.BufferGeometry();
          let position = new Float32Array(data.vertices);
          geom.setAttribute('position', new THREE.BufferAttribute(position, 3));

          // Although almost all browsers support OES_element_index_uint nowadays,
          // use Uint32 indexes only when needed.
          let arr = (data.vertices.length < 3*65536 ? new Uint16Array(data.segments) : new Uint32Array(data.segments));
          
          geom.setIndex(new THREE.BufferAttribute(arr, 1));

          let colorFor2fofc = me.parasCls.thr('#00FFFF');
          let colorForfofcPos = me.parasCls.thr('#00FF00');
          let colorForfofcNeg = me.parasCls.thr('#ff0000');

          let color = (typeDetail == '2fofc') ? colorFor2fofc : ((typeDetail == 'fofc_pos') ? colorForfofcPos : colorForfofcNeg);
          let material = new THREE.LineBasicMaterial({ linewidth: 1, color: color });
          //return new THREE.LineSegments(geom, material);

          let mesh = new THREE.LineSegments(geom, material);
          ic.mdl.add(mesh);

          ic.prevMaps.push(mesh);
        }
    }


    class UnitCell {
      /*::
      parameters: number[]
      orth: number[]
      frac: number[]
      */
      // eslint-disable-next-line max-params
      constructor(a /*:number*/, b /*:number*/, c /*:number*/,
                  alpha /*:number*/, beta /*:number*/, gamma /*:number*/) {
        if (a <= 0 || b <= 0 || c <= 0 || alpha <= 0 || beta <= 0 || gamma <= 0) {
          throw Error('Zero or negative unit cell parameter(s).');
        }
        this.parameters = [a, b, c, alpha, beta, gamma];
        const deg2rad = Math.PI / 180.0;
        const cos_alpha = Math.cos(deg2rad * alpha);
        const cos_beta = Math.cos(deg2rad * beta);
        const cos_gamma = Math.cos(deg2rad * gamma);
        const sin_alpha = Math.sin(deg2rad * alpha);
        const sin_beta = Math.sin(deg2rad * beta);
        const sin_gamma = Math.sin(deg2rad * gamma);
        if (sin_alpha === 0 || sin_beta === 0 || sin_gamma === 0) {
          throw Error('Impossible angle - N*180deg.');
        }
        const cos_alpha_star_sin_beta = (cos_beta * cos_gamma - cos_alpha) /
                                        sin_gamma;
        const cos_alpha_star = cos_alpha_star_sin_beta / sin_beta;
        const s1rca2 = Math.sqrt(1.0 - cos_alpha_star * cos_alpha_star);
        // The orthogonalization matrix we use is described in ITfC B p.262:
        // "An alternative mode of orthogonalization, used by the Protein
        // Data Bank and most programs, is to align the a1 axis of the unit
        // cell with the Cartesian X_1 axis, and to align the a*_3 axis with the
        // Cartesian X_3 axis."
        //
        // Zeros in the matrices below are kept to make matrix multiplication
        // faster: they make extract_block() 2x (!) faster on V8 4.5.103,
        // no difference on FF 50.
        /* eslint-disable no-multi-spaces, comma-spacing */
        this.orth = [a,   b * cos_gamma,  c * cos_beta,
                     0.0, b * sin_gamma, -c * cos_alpha_star_sin_beta,
                     0.0, 0.0          ,  c * sin_beta * s1rca2];
        // based on xtal.js which is based on cctbx.uctbx
        this.frac = [
          1.0 / a,
          -cos_gamma / (sin_gamma * a),
          -(cos_gamma * cos_alpha_star_sin_beta + cos_beta * sin_gamma) /
              (sin_beta * s1rca2 * sin_gamma * a),
          0.0,
          1.0 / (sin_gamma * b),
          cos_alpha_star / (s1rca2 * sin_gamma * b),
          0.0,
          0.0,
          1.0 / (sin_beta * s1rca2 * c),
        ];
      }

      // This function is only used with matrices frac and orth, which have 3 zeros.
      // We skip these elements, but it doesn't affect performance (on FF50 and V8).
      multiply(xyz, mat) {
        /* eslint-disable indent */
        return [mat[0] * xyz[0]  + mat[1] * xyz[1]  + mat[2] * xyz[2],
              /*mat[3] * xyz[0]*/+ mat[4] * xyz[1]  + mat[5] * xyz[2],
              /*mat[6] * xyz[0]  + mat[7] * xyz[1]*/+ mat[8] * xyz[2]];
      }

      fractionalize(xyz /*:[number,number,number]*/) {
        return this.multiply(xyz, this.frac);
      }

      orthogonalize(xyz /*:[number,number,number]*/) {
        return this.multiply(xyz, this.orth);
      }
    }


    class GridArray {
      /*::
      dim: number[]
      values: Float32Array
      */
      constructor(dim /*:number[]*/) {
        this.dim = dim; // dimensions of the grid for the entire unit cell
        this.values = new Float32Array(dim[0] * dim[1] * dim[2]);
      }

      modulo(a, b) {
        const reminder = a % b;
        return reminder >= 0 ? reminder : reminder + b;
      }

      grid2index(i/*:number*/, j/*:number*/, k/*:number*/) {
        i = this.modulo(i, this.dim[0]);
        j = this.modulo(j, this.dim[1]);
        k = this.modulo(k, this.dim[2]);
        return this.dim[2] * (this.dim[1] * i + j) + k;
      }

      grid2index_unchecked(i/*:number*/, j/*:number*/, k/*:number*/) {
        return this.dim[2] * (this.dim[1] * i + j) + k;
      }

      grid2frac(i/*:number*/, j/*:number*/, k/*:number*/) {
        return [i / this.dim[0], j / this.dim[1], k / this.dim[2]];
      }

      // return grid coordinates (rounded down) for the given fractional coordinates
      frac2grid(xyz/*:number[]*/) {
        // at one point "| 0" here made extract_block() 40% faster on V8 3.14,
        // but I don't see any effect now
        return [Math.floor(xyz[0] * this.dim[0]) | 0,
                Math.floor(xyz[1] * this.dim[1]) | 0,
                Math.floor(xyz[2] * this.dim[2]) | 0];
      }

      set_grid_value(i/*:number*/, j/*:number*/, k/*:number*/, value/*:number*/) {
        const idx = this.grid2index(i, j, k);
        this.values[idx] = value;
      }

      get_grid_value(i/*:number*/, j/*:number*/, k/*:number*/) {
        const idx = this.grid2index(i, j, k);
        return this.values[idx];
      }
    }

    /**
     * @file Mtz Parser
     * @author Marcin Wojdyr <wojdyr@gmail.com>
     * @private
     * Modified by Jiyao Wang / https://github.com/ncbi/icn3d
     */

    class MtzParser {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        async mtzParserBase(url, type, sigma, location, bInputSigma, bRcsb) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            //https://stackoverflow.com/questions/33902299/using-jquery-ajax-to-download-a-binary-file
            // if(type == '2fofc' && ic.bAjax2fofcccp4) {
            //     ic.mapData.sigma2 = sigma;
            //     ic.setOptionCls.setOption('map', type);
            // }
            // else if(type == 'fofc' && ic.bAjaxfofcccp4) {
            //     ic.mapData.sigma = sigma;
            //     ic.setOptionCls.setOption('map', type);
            // }
            // else {
                let arrayBuffer = await me.getXMLHttpRqstPromise(url, 'GET', 'arraybuffer', '');
                sigma = await thisClass.loadMtzFileBase(arrayBuffer, type, sigma, location, bInputSigma, url, bRcsb);

                // if(type == '2fofc') {
                //     ic.bAjax2fofcccp4 = true;
                // }
                // else if(type == 'fofc') {
                //     ic.bAjaxfofcccp4 = true;
                // }

                ic.setOptionCls.setOption('map', type);

                return sigma;
            // }
        }

        loadMtzFile(type, bRcsb) {var ic = this.icn3d, me = ic.icn3dui;
           let thisClass = this;

           let file = $("#" + ic.pre + "dsn6file" + type)[0].files[0];
           let sigma = $("#" + ic.pre + "dsn6sigma" + type).val();
           if(!file) {
             alert("Please select a file before clicking 'Load'");
           }
           else {
             me.utilsCls.checkFileAPI();
             let reader = new FileReader();
             reader.onload = async function(e) { let ic = thisClass.icn3d;
                sigma = await thisClass.loadMtzFileBase(e.target.result, type, sigma, 'file', undefined, undefined, bRcsb);
                me.htmlCls.clickMenuCls.setLogCmd('load map file ' + $("#" + ic.pre + "dsn6file" + type).val() + ' with sigma ' + sigma, false);
             };
             reader.readAsArrayBuffer(file);
           }
        }

        async loadMtzFileBase(data, type, sigma, location, bInputSigma, url, bRcsb) {var ic = this.icn3d, me = ic.icn3dui;
            if(ic.bMtz === undefined) {
                let url = "./script/mtz.js";
                await me.getAjaxPromise(url, 'script');

                ic.bMtz = true;
            }

            GemmiMtz().then(function(Gemmi) {
                let mtz = Gemmi.readMtz(data);

                sigma = ic.ccp4ParserCls.load_maps_from_mtz_buffer(mtz, type, sigma, location, bInputSigma, bRcsb);

                // if(type == '2fofc') {
                //     ic.bAjax2fofcCcp4 = true;
                // }
                // else if(type == 'fofc') {
                //     ic.bAjaxfofcCcp4 = true;
                // }
                ic.setOptionCls.setOption('map', type);
                let mtzType = (bRcsb) ? 'rcsbmtz' : 'mtz';
                if(url) me.htmlCls.clickMenuCls.setLogCmd('set map ' + type + ' sigma ' + sigma + ' file ' + mtzType + ' | ' + encodeURIComponent(url), true);

                return sigma;
            });
         }

        async loadMtzFileUrl(type, bRcsb) {var ic = this.icn3d; ic.icn3dui;
           let url = $("#" + ic.pre + "dsn6fileurl" + type).val();
           let sigma = $("#" + ic.pre + "dsn6sigmaurl" + type).val();
           if(!url) {
                alert("Please input the file URL before clicking 'Load'");
           }
           else {
               sigma = await this.mtzParserBase(url, type, sigma, 'url', undefined, bRcsb);

               //me.htmlCls.clickMenuCls.setLogCmd('set map ' + type + ' sigma ' + sigma + ' file mtz | ' + encodeURIComponent(url), true);
           }
        }

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class MmcifParser {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Ajax call was used to get the atom data from the "mmcifid". This function was deferred
        //so that it can be chained together with other deferred functions for sequential execution.
        async downloadMmcif(mmcifid) { let ic = this.icn3d, me = ic.icn3dui;
            //ic.bCid = undefined;

            ic.ParserUtilsCls.setYourNote(mmcifid.toUpperCase() + '(MMCIF) in iCn3D');

            // let url = "https://files.rcsb.org/view/" + mmcifid + ".cif";
            let url = "https://files.rcsb.org/download/" + mmcifid + ".cif";
            let data = await me.getAjaxPromise(url, 'text', true);

            // url = me.htmlCls.baseUrl + "mmcifparser/mmcifparser.cgi";
            // let dataObj = {'mmciffile': data};
            // let data2 = await me.getAjaxPostPromise(url, dataObj, true);

            // await this.loadMmcifData(data2, mmcifid);

            let bText = true;
            // let bcifData = ic.bcifParserCls.getBcifJson(data, mmcifid, bText);
            // let bcifJson = JSON.parse(bcifData);

            // await this.loadMmcifData(bcifJson, mmcifid);
            await ic.opmParserCls.loadOpmData(data, mmcifid, undefined, 'mmcif', undefined, bText);
        }

        async downloadMmcifSymmetry(mmcifid, type) { let ic = this.icn3d, me = ic.icn3dui;
          try {
            // let url = "https://files.rcsb.org/download/" + mmcifid + ".cif";
            // let data1 = await me.getAjaxPromise(url, 'text', false, "The structure " + mmcifid + " was not found...");
            // let bText = true;

            let url = 'https://models.rcsb.org/' + mmcifid + '.bcif';
            let data1 = await me.getXMLHttpRqstPromise(url, 'GET', 'arraybuffer', 'bcif');
            let bText = false;

            // url = me.htmlCls.baseUrl + "mmcifparser/mmcifparser.cgi";
            // let dataObj = {'mmcifheader': data1};

            // let data = await me.getAjaxPostPromise(url, dataObj, false, "The mmCIF data of " + mmcifid + " can not be parsed...");

            let bNoCoord = true;
            let bcifData = ic.bcifParserCls.getBcifJson(data1, mmcifid, bText, bNoCoord);

            let data = JSON.parse(bcifData);

            if(data.emd !== undefined) ic.emd = data.emd;
            if(data.organism !== undefined) ic.organism = data.organism;

            if(ic.bAssemblyUseAsu) {
                for(let i = 0, il = data.assembly.length; i < il; ++i) {
                    let mat4 = new THREE.Matrix4();
                    mat4.fromArray(data.assembly[i]);
        
                    ic.biomtMatrices[i] = mat4;
                }
        
                ic.asuCnt = ic.biomtMatrices.length;
        
                // show bioassembly 
                if(me.cfg.bu == 1 && Object.keys(ic.atoms).length * ic.asuCnt > ic.maxatomcnt) {
                    ic.bAssembly = true;
                }
            }

            if(type === 'mmtfid' && data.missingseq !== undefined) {
                // adjust missing residues
                let maxMissingResi = 0, prevMissingChain = '';
                //let chainMissingResidueArray = {}
                for(let i = 0, il = data.missingseq.length; i < il; ++i) {
                    let resn = data.missingseq[i].resn;
                    let chain = data.missingseq[i].chain;
                    let resi = data.missingseq[i].resi;

                    let chainNum = mmcifid + '_' + chain;

                    if(ic.chainMissingResidueArray[chainNum] === undefined) ic.chainMissingResidueArray[chainNum] = [];
                    let resObject = {};
                    resObject.resi = resi;
                    resObject.name = me.utilsCls.residueName2Abbr(resn).toLowerCase();

                    if(chain != prevMissingChain) {
                        maxMissingResi = 0;
                    }

                    // not all listed residues are considered missing, e.g., PDB ID 4OR2, only the first four residues are considered missing
                    if(!isNaN(resi) &&(prevMissingChain == '' ||(chain != prevMissingChain) ||(chain == prevMissingChain && resi > maxMissingResi)) ) {
                        ic.chainMissingResidueArray[chainNum].push(resObject);

                        maxMissingResi = resi;
                        prevMissingChain = chain;
                    }
                }

                ic.loadPDBCls.adjustSeq(ic.chainMissingResidueArray);
            }

            ///// if(ic.deferredSymmetry !== undefined) ic.deferredSymmetry.resolve();
          }
          catch (err) {
            if(!me.bNode) console.log("mmcifparser.cgi issues: " + err);
            return;
          }
        }

        //Atom "data" from mmCIF file was parsed to set up parameters for the 3D viewer by calling the function
        //loadAtomDataIn. The deferred parameter was resolved after the parsing so that other javascript code can be executed.
        async loadMmcifData(data, mmcifid) { let ic = this.icn3d; ic.icn3dui;
            if(!mmcifid) mmcifid = data.mmcif;
            if(!mmcifid) mmcifid = ic.defaultPdbId;

            if(data.atoms !== undefined) {
                ic.init();

                if(data.emd !== undefined) ic.emd = data.emd;
                if(data.organism !== undefined) ic.organism = data.organism;

                await ic.opmParserCls.loadOpmData(data, mmcifid, undefined, 'mmcif');

                ic.opmParserCls.modifyUIMapAssembly();
            }
            else {
                return false;
            }
        }

        async loadMultipleMmcifData(data, mmcifid, bAppend) { let ic = this.icn3d; ic.icn3dui;
            let bText = true;
            ic.loadCIFCls.loadCIF(data, mmcifid, bText, bAppend);
            
            if(Object.keys(ic.structures).length > 1) {
                ic.opts['color'] = 'structure';
            }

            ic.opmParserCls.modifyUIMapAssembly();

            ic.pdbParserCls.addSecondary(bAppend);

            // ic.setStyleCls.setAtomStyleByOptions(ic.opts);
            // ic.setColorCls.setColorByOptions(ic.opts, ic.atoms);

            // await ic.ParserUtilsCls.renderStructure();
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class MmdbParser {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Ajax call was used to get the atom data from the NCBI "mmdbid". This function was deferred so that
        //it can be chained together with other deferred functions for sequential execution. If the structure
        //is too large, a 3D dgm will show up. You can select your interested chains to see the details.

        //Atom "data" from MMDB file was parsed to set up parameters for the 3D viewer by calling the function
        //loadAtomDataIn. The deferred parameter was resolved after the parsing so that other javascript code can be executed.
        async downloadMmdb(mmdbid, bGi) { let ic = this.icn3d, me = ic.icn3dui;
            let data;
            
            try {
                data = await this.loadMmdbPrms(mmdbid, bGi);

                if(!data || data.error) {
                    this.getNoData(mmdbid, bGi);
                    return;
                }    
            }
            catch(err) {
                this.getNoData(mmdbid, bGi);
                return;
            }
            
            if(Object.keys(data.atoms).length == 0) { // for large structures such as 3J3Q
                // use mmtfid
                let pdbid = data.pdbId;
                await ic.bcifParserCls.downloadBcif(pdbid);

                return;
            }

            let bCalphaOnly = me.utilsCls.isCalphaPhosOnly(data.atoms); //, 'CA');

            if(bCalphaOnly || data.atomCount <= ic.maxatomcnt) {
                await this.parseMmdbData(data);
            }
            else {
                let data2;
            
                try {
                    data2 = await this.loadMmdbPrms(mmdbid, bGi, true);
                }
                catch(err) {
                    this.getNoData(mmdbid, bGi);
                    return;
                }

                await this.parseMmdbData(data2);
            }
        }

            //Ajax call was used to get the atom data from the NCBI "gi". This function was deferred so that
        //it can be chained together with other deferred functions for sequential execution. Note that
        //only one structure corresponding to the gi will be shown. If there is no structures available
        //for the gi, a warning message will be shown.
        async downloadGi(gi) { let ic = this.icn3d; ic.icn3dui;
            ic.bCid = undefined;
            let bGi = true;
            await this.downloadMmdb(gi, bGi);
        }

        //Ajax call was used to get the atom data from "sequence_id_comma_structure_id", comma-separated
        //NCBI protein accessions of a protein sequence and a chain of a 3D structure (e.g., 23491729,1TUP_A).
        //This function was deferred so that it can be chained together with other deferred functions for
        //sequential execution. Note that only one structure corresponding to the blast_rep_id will be shown.
        //If there is no structures available for the blast_rep_id, a warning message will be shown.
        async downloadBlast_rep_id(sequence_structure_ids) { let ic = this.icn3d, me = ic.icn3dui;
            //ic.bCid = undefined;

            let idArray = sequence_structure_ids.split(',');
            me.cfg.query_id = idArray[0];
            me.cfg.blast_rep_id = idArray[1];

            let mmdbid = me.cfg.blast_rep_id.split('_')[0]; // 1TSR_A, XP_003256700.1, Q9H3D4.1

            if(mmdbid.length == 4) { // pdb
                await this.downloadMmdb(mmdbid);
            }
            else {
                ic.blastAcxn = me.cfg.blast_rep_id.split('.')[0];
                //await ic.pdbParserCls.downloadPdb(ic.blastAcxn, true);
                await this.downloadRefseq(ic.blastAcxn, true);
            }
        }

        async downloadRefseq(refseqid, bBlast_rep_id) { let ic = this.icn3d, me = ic.icn3dui;
            let url = me.htmlCls.baseUrl + "vastdyn/vastdyn.cgi?refseq2uniprot=" + refseqid;

            me.cfg.refseqid = refseqid;
     
            //ic.bCid = undefined;

            let data = await me.getAjaxPromise(url, 'jsonp', false, 'The protein accession ' + refseqid + ' can not be mapped to AlphaFold UniProt ID...');

            if(data && data.uniprot) {
                me.cfg.afid = data.uniprot;
                if(!ic.uniprot2acc) ic.uniprot2acc = {};
                ic.uniprot2acc[data.uniprot] = refseqid;
            }
            else {
                alert('The accession ' + refseqid + ' can not be mapped to AlphaFold UniProt ID. It will be treated as a UniProt ID instead.');
                
                return;

                //me.cfg.afid = refseqid;
            }

            if(bBlast_rep_id) me.cfg.blast_rep_id = me.cfg.afid + '_A';

            let bAf = true;

            await ic.pdbParserCls.downloadPdb(me.cfg.afid, bAf);
            //await ic.loadScriptCls.loadScript(me.cfg.command, undefined, true);
        }

        async downloadProteinname(protein) { let ic = this.icn3d, me = ic.icn3dui;
            me.icn3d.bCid = undefined;

            // get RefSeq ID from protein name
            let url = me.htmlCls.baseUrl + "vastdyn/vastdyn.cgi?protein2acc=" + protein;

            let accJson = await me.getAjaxPromise(url, 'jsonp');

            let accArray = accJson.acc;

            if(accArray.length == 0) {
                if(!me.bNode) alert('The protein/gene name ' + protein + ' can not be mapped to RefSeq proteins...');
                return;
            }

            let ajaxArray = [];
            for(let index = 0, indexl = accArray.length; index < indexl; ++index) {
                let refseqid = accArray[index];
                url = me.htmlCls.baseUrl + "vastdyn/vastdyn.cgi?refseq2uniprot=" + refseqid;

                let ajax = me.getAjaxPromise(url, 'jsonp');

                ajaxArray.push(ajax);
            }

            let allPromise = Promise.allSettled(ajaxArray);
            let dataArray = await allPromise;

            ajaxArray = [];
            let afidArray = [];
            for(let i = 0, il = dataArray.length; i < il; ++i) {
                let data = dataArray[i].value;

                if(data && data.uniprot) {
                    let afid = data.uniprot;
                    url = "https://alphafold.ebi.ac.uk/files/AF-" + afid + "-F1-model_" + ic.AFUniprotVersion + ".pdb";
                    ic.ParserUtilsCls.setYourNote(me.cfg.protein + '(NCBI Protein/Gene) in iCn3D');

                    let ajax = me.getAjaxPromise(url, 'text', true);
                    ajaxArray.push(ajax);
                    afidArray.push(afid);
                }
            }
            
            allPromise = Promise.allSettled(ajaxArray);
            dataArray = await allPromise;
           
            for(let i = 0, il = dataArray.length; i < il; ++i) {
                let data = dataArray[i].value;
                me.cfg.afid = afidArray[i];

                if(data) {
                    // add UniProt ID into the header
                    let header = 'HEADER                                                        ' + me.cfg.afid + '\n';
                    data = header + data;          
                    await ic.opmParserCls.parseAtomData(data, me.cfg.afid, undefined, 'pdb', undefined);

                    break;
                }
            }

            if(!me.cfg.afid) {
                if(!me.bNode) alert('The protein/gene name ' + protein + ' can not be mapped to AlphaFold structures...');
                return;
            }
        }

        getNoData(mmdbid, bGi) { let ic = this.icn3d, me = ic.icn3dui;
            if(bGi) {
                alert("This gi " + mmdbid + " has no corresponding 3D structure...");
            }
            else {
                alert("This mmdbid " + mmdbid + " with the parameters " + me.cfg.inpara + " may not have 3D structure data. Please visit the summary page for details: " + me.htmlCls.baseUrl + "pdb/" + mmdbid);
            }
        }

        async parseMmdbData(data, type, chainid, chainIndex, bLastQuery, bNoTransformNoSeqalign, pdbidIn) { let ic = this.icn3d, me = ic.icn3dui;
            let hAtoms;
            let pdbid = (data.pdbId !== undefined) ? data.pdbId : data.mmdbId;
            if(pdbidIn) pdbid = pdbidIn;

            this.parseMmdbDataPart1(data, type);

            if(type === undefined) { // default mmdbid input
                if(data.opm !== undefined && data.opm.rot !== undefined) {
                    ic.bOpm = true;
                    ic.opmParserCls.setOpmData(data);
                }

                hAtoms = ic.loadAtomDataCls.loadAtomDataIn(data, pdbid, 'mmdbid', undefined, type);
            }
            else { // multiple mmdbids, typically for alignment
                if(chainid) pdbid = chainid.substr(0, chainid.indexOf('_'));

                hAtoms = ic.loadAtomDataCls.loadAtomDataIn(data, pdbid, 'mmdbid', undefined, type, chainid, chainIndex, bLastQuery, bNoTransformNoSeqalign);
            }

            // show ligand-protein interaction
            if(me.cfg.ligand) { // sid123059722
                for(let chainid in ic.chainid2sid) {
                    if(ic.chainid2sid[chainid] == me.cfg.ligand.substr(3)) {
                        // save a set named me.cfg.ligand
                        let residueHash = ic.firstAtomObjCls.getResiduesFromAtoms(ic.chains[chainid]);
                        let idArray = Object.keys(residueHash)[0].split('_');
                        let select = '.' + idArray[1] + ':' + idArray[2];

                        await ic.selByCommCls.selectByCommand(select, me.cfg.ligand, me.cfg.ligand);
                        break;
                    }
                }
            }
            ic.hAtoms = hAtoms;

            // set 3d domains
            let structure = data.pdbId;

            if(type === undefined) ic.ParserUtilsCls.setYourNote(structure.toUpperCase() + '(MMDB) in iCn3D');

            // let bNCBI = (me.cfg.mmdbid || me.cfg.gi || me.cfg.align || me.cfg.chainalign || me.cfg.mmdbafid || me.cfg.blast_rep_id);

            for(let molid in data.domains) {
                let chain = data.domains[molid].chain;
                let chainid = structure + '_' + chain;
                let domainArray = data.domains[molid].domains;

                for(let index = 0, indexl = domainArray.length; index < indexl; ++index) {
                    let domainName = structure + '_' + chain + '_3d_domain_' +(index+1).toString();
                    ic.tddomains[domainName] = {};

                    let subdomainArray = domainArray[index].intervals;

                    // remove duplicate, e.g., at https://www.ncbi.nlm.nih.gov/Structure/mmdb/mmdb_strview.cgi?v=2&program=icn3d&domain&molinfor&uid=1itw
                    let domainFromHash = {}, domainToHash = {};

                    //var fromArray = [], toArray = [];
                    //var resCnt = 0
                    for(let i = 0, il = subdomainArray.length; i < il; ++i) {
                        let domainFrom = Math.round(subdomainArray[i][0]) - 1; // 1-based
                        let domainTo = Math.round(subdomainArray[i][1]) - 1;

                        if(domainFromHash.hasOwnProperty(domainFrom) || domainToHash.hasOwnProperty(domainTo)) {
                            continue; // do nothing for duplicated "from" or "to", e.g, PDBID 1ITW, 5FWI
                        }
                        else {
                            domainFromHash[domainFrom] = 1;
                            domainToHash[domainTo] = 1;
                        }

                        //fromArray.push(domainFrom + ic.baseResi[chnid]);
                        //toArray.push(domainTo + ic.baseResi[chnid]);
                        //resCnt += domainTo - domainFrom + 1;

                        for(let j = domainFrom; j <= domainTo; ++j) {
                            let resid;
                            let residNCBI = chainid + '_' +(j+1).toString();

                            // if(bNCBI && ic.ncbi2resid[residNCBI]) {
                                resid = ic.ncbi2resid[residNCBI];
                            // }
                            // else {
                            //     resid = chainid + '_' +(j+1 + ic.chainid2offset[chainid]).toString();
                            // }

                            if(resid) ic.tddomains[domainName][resid] = 1;
                        }
                    }
                } // for each domainArray
            } // for each molid

            // "asuAtomCount" is defined when: 1) atom count is over the threshold 2) bu=1 3) asu atom count is smaller than biological unit atom count
            ic.bAssemblyUseAsu =(data.asuAtomCount !== undefined) ? true : false;
            if(type !== undefined) {
                ic.bAssemblyUseAsu = false;
            }
            else {
                await ic.mmcifParserCls.downloadMmcifSymmetry(pdbid);
            }

            if(ic.bAssemblyUseAsu) { 
                $("#" + ic.pre + "assemblyWrapper").show();
                //ic.bAssembly = true;
            }

            if(ic.emd !== undefined) {
              $("#" + ic.pre + "mapWrapper1").hide();
              $("#" + ic.pre + "mapWrapper2").hide();
              $("#" + ic.pre + "mapWrapper3").hide();
            }
            else {
              $("#" + ic.pre + "emmapWrapper1").hide();
              $("#" + ic.pre + "emmapWrapper2").hide();
              $("#" + ic.pre + "emmapWrapper3").hide();
            }

            ic.setStyleCls.setAtomStyleByOptions(ic.opts);
            // use the original color from cgi output
            if(me.cfg.blast_rep_id !== undefined) {
              ic.setColorCls.setColorByOptions(ic.opts, ic.atoms);
            }
            else {
              ic.setColorCls.setColorByOptions(ic.opts, ic.atoms, true);
            }

            if(type === undefined) {
                await ic.ParserUtilsCls.renderStructure();
                if(me.cfg.rotate !== undefined) ic.resizeCanvasCls.rotStruc(me.cfg.rotate, true);

                ic.html2ddgm = '';
                if(me.cfg.show2d) {
                    me.htmlCls.dialogCls.openDlg('dl_2ddgm', 'Interactions');
                    if(ic.bFullUi) {
                        //if(type === undefined) {
                            ic.ParserUtilsCls.download2Ddgm(ic.inputid.toUpperCase());
                        //}
                        //else {
                        //    ic.ParserUtilsCls.set2DDiagramsForAlign(ic.inputid2.toUpperCase(), ic.inputid.toUpperCase());
                            //ic.ParserUtilsCls.set2DDiagramsForChainalign(chainidArray);
                        //}
                    }
                }
            }

            if((me.cfg.align === undefined || me.cfg.chainalign === undefined || me.cfg.mmdbafid === undefined) && Object.keys(ic.structures).length == 1) {
                if($("#" + ic.pre + "alternateWrapper") !== null) $("#" + ic.pre + "alternateWrapper").hide();
            }

            //if(me.deferred !== undefined) me.deferred.resolve(); /// if(ic.deferred2 !== undefined) ic.deferred2.resolve();

            return hAtoms;
        }

        parseMmdbDataPart1(data, type) { let ic = this.icn3d, me = ic.icn3dui;
            // if type is defined, always process target before query
            if(data.atoms === undefined && data.molid2rescount === undefined) {
                alert('invalid MMDB data.');
                return false;
            }

            if(type === undefined || type === 'target') {
                // if a command contains "load...", the commands should not be cleared with init()
                let bKeepCmd = (ic.bCommandLoad) ? true : false;
                if(!ic.bStatefile) ic.init(bKeepCmd);

                ic.chainsColor = {};
                ic.chainsGene = {};
            }

            // used in download2Ddgm()
            if(type === 'query') ;
            else {
                ic.interactionData = {"moleculeInfor": data.moleculeInfor, "intrac": data.intrac, "intracResidues": data.intracResidues};
            }

            if(type === 'query') ;
            else {
                ic.mmdb_data = data;
            }

            let id =(data.pdbId !== undefined) ? data.pdbId : data.mmdbId;
            if(type === 'query') {
                ic.inputid2 = id;
            }
            else {
                ic.inputid = id;
            }

            let molid2rescount = data.moleculeInfor;
            let molid2color = {}, chain2molid = {}, molid2chain = {};
            let chainNameHash = {};       
            for(let i in molid2rescount) {
              if(Object.keys(molid2rescount[i]).length === 0) continue;

              let color =(molid2rescount[i].color === undefined) ? '#CCCCCC' : '#' +( '000000' + molid2rescount[i].color.toString( 16 ) ).slice( - 6 );
              let chainName =(molid2rescount[i].chain === undefined) ? '' : molid2rescount[i].chain.trim();
              // remove "_" in chain name
            //   if(parseInt(me.cfg.date) >= 20231001 || (!me.cfg.date && parseInt(me.utilsCls.getDateDigitStr()) >= 20231001)) {
                chainName = chainName.replace(/_/g, '');
            //   }

              if(chainNameHash[chainName] === undefined) {
                  chainNameHash[chainName] = 1;
              }
              else {
                  ++chainNameHash[chainName];
              }

              let chainNameFinal =(chainNameHash[chainName] === 1) ? chainName : chainName + chainNameHash[chainName].toString();
              let chain = id + '_' + chainNameFinal;

              molid2color[i] = color;
              chain2molid[chain] = i;
              molid2chain[i] = chain;

            //   ic.chainsColor[chain] = (type !== undefined && !me.cfg.mmdbafid) ? me.parasCls.thr(me.htmlCls.GREY8) : me.parasCls.thr(color);
              if(type === undefined || me.cfg.mmdbafid) ic.chainsColor[chain] = me.parasCls.thr(color);

              let geneId =(molid2rescount[i].geneId === undefined) ? '' : molid2rescount[i].geneId;
              let geneSymbol =(molid2rescount[i].geneSymbol === undefined) ? '' : molid2rescount[i].geneSymbol;
              let geneDesc =(molid2rescount[i].geneDesc === undefined) ? '' : molid2rescount[i].geneDesc;
              ic.chainsGene[chain] = {'geneId': geneId, 'geneSymbol': geneSymbol, 'geneDesc': geneDesc};
            }

            //ic.molid2color = molid2color;
            //ic.chain2molid = chain2molid;
            ic.molid2chain = molid2chain;

            // small structure with all atoms
            // show surface options
            $("#" + ic.pre + "accordion5").show();

            //ic.loadAtomDataCls.loadAtomDataIn(data, id, 'mmdbid', undefined, type);
        }

        loadMmdbPrms(mmdbid, bGi, bCalpha) { let ic = this.icn3d, me = ic.icn3dui;

            let url;

            // b: b-factor, s: water, ft: pdbsite
            //&ft=1
            if(bGi) {
                url = me.htmlCls.baseUrl + "mmdb/mmdb_strview.cgi?v=2&program=icn3d&b=1&s=1&ft=1&bu=" + me.cfg.bu + "&simple=1&gi=" + mmdbid;
            }
            else {
                url = me.htmlCls.baseUrl + "mmdb/mmdb_strview.cgi?v=2&program=icn3d&b=1&s=1&ft=1&bu=" + me.cfg.bu + "&simple=1&uid=" + mmdbid;
            }

            // use asymmetric unit for BLAST search, e.g., https://www.ncbi.nlm.nih.gov/Structure/icn3d/?from=blast&blast_rep_id=5XZC_B&query_id=1TUP_A&command=view+annotations;set+annotation+cdd;set+annotation+site;set+view+detailed+view;select+chain+5XZC_B;show+selection&log$=align&blast_rank=1&RID=EPUCYNVV014&bu=0
            if(me.cfg.blast_rep_id !== undefined) url += '&bu=0';

            //ic.bCid = undefined;

            if(me.cfg.inpara !== undefined) {
                url += me.cfg.inpara;
            }

            if(bCalpha) url += '&complexity=2';

            if(ic.chainids2resids === undefined) ic.chainids2resids = {}; // ic.chainids2resids[chainid1][chainid2] = [resid, resid]

            return me.getAjaxPromise(url, 'jsonp', true);
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class BcifParser {
        constructor(icn3d) {
            this.icn3d = icn3d;

            this.mElem2Radius = {};

            // http://en.wikipedia.org/wiki/Covalent_radius
            this.mElem2Radius["H"] = 0.31;
            this.mElem2Radius["HE"] = 0.28;
            this.mElem2Radius["LI"] = 1.28;
            this.mElem2Radius["BE"] = 0.96;
            this.mElem2Radius["B"] = 0.84;
            this.mElem2Radius["C"] = 0.76;
            this.mElem2Radius["N"] = 0.71;
            this.mElem2Radius["O"] = 0.66;
            this.mElem2Radius["F"] = 0.57;
            this.mElem2Radius["NE"] = 0.58;
            this.mElem2Radius["NA"] = 1.66;
            this.mElem2Radius["MG"] = 1.41;
            this.mElem2Radius["AL"] = 1.21;
            this.mElem2Radius["SI"] = 1.11;
            this.mElem2Radius["P"] = 1.07;
            this.mElem2Radius["S"] = 1.05;
            this.mElem2Radius["CL"] = 1.02;
            this.mElem2Radius["AR"] = 1.06;
            this.mElem2Radius["K"] = 2.03;
            this.mElem2Radius["CA"] = 1.76;
            this.mElem2Radius["SC"] = 1.70;
            this.mElem2Radius["TI"] = 1.60;
            this.mElem2Radius["V"] = 1.53;
            this.mElem2Radius["CR"] = 1.39;
            this.mElem2Radius["MN"] = 1.39;
            this.mElem2Radius["FE"] = 1.32;
            this.mElem2Radius["CO"] = 1.26;
            this.mElem2Radius["NI"] = 1.24;
            this.mElem2Radius["CU"] = 1.32;
            this.mElem2Radius["ZN"] = 1.22;
            this.mElem2Radius["GA"] = 1.22;
            this.mElem2Radius["GE"] = 1.20;
            this.mElem2Radius["AS"] = 1.19;
            this.mElem2Radius["SE"] = 1.20;
            this.mElem2Radius["BR"] = 1.20;
            this.mElem2Radius["KR"] = 1.16;
            this.mElem2Radius["RB"] = 2.20;
            this.mElem2Radius["SR"] = 1.95;
            this.mElem2Radius["Y"] = 1.90;
            this.mElem2Radius["ZR"] = 1.75;
            this.mElem2Radius["NB"] = 1.64;
            this.mElem2Radius["MO"] = 1.54;
            this.mElem2Radius["TC"] = 1.47;
            this.mElem2Radius["RU"] = 1.46;
            this.mElem2Radius["RH"] = 1.42;
            this.mElem2Radius["PD"] = 1.39;
            this.mElem2Radius["AG"] = 1.45;
            this.mElem2Radius["CD"] = 1.44;
            this.mElem2Radius["IN"] = 1.42;
            this.mElem2Radius["SN"] = 1.39;
            this.mElem2Radius["SB"] = 1.39;
            this.mElem2Radius["TE"] = 1.38;
            this.mElem2Radius["I"] = 1.39;
            this.mElem2Radius["XE"] = 1.40;
            this.mElem2Radius["CS"] = 2.44;
            this.mElem2Radius["BA"] = 2.15;
            this.mElem2Radius["LA"] = 2.07;
            this.mElem2Radius["CE"] = 2.04;
            this.mElem2Radius["PR"] = 2.03;
            this.mElem2Radius["ND"] = 2.01;
            this.mElem2Radius["PM"] = 1.99;
            this.mElem2Radius["SM"] = 1.98;
            this.mElem2Radius["EU"] = 1.98;
            this.mElem2Radius["GD"] = 1.96;
            this.mElem2Radius["TB"] = 1.94;
            this.mElem2Radius["DY"] = 1.92;
            this.mElem2Radius["HO"] = 1.92;
            this.mElem2Radius["ER"] = 1.89;
            this.mElem2Radius["TM"] = 1.90;
            this.mElem2Radius["YB"] = 1.87;
            this.mElem2Radius["LU"] = 1.87;
            this.mElem2Radius["HF"] = 1.75;
            this.mElem2Radius["TA"] = 1.70;
            this.mElem2Radius["W"] = 1.62;
            this.mElem2Radius["RE"] = 1.51;
            this.mElem2Radius["OS"] = 1.44;
            this.mElem2Radius["IR"] = 1.41;
            this.mElem2Radius["PT"] = 1.36;
            this.mElem2Radius["AU"] = 1.36;
            this.mElem2Radius["HG"] = 1.32;
            this.mElem2Radius["TL"] = 1.45;
            this.mElem2Radius["PB"] = 1.46;
            this.mElem2Radius["BI"] = 1.48;
            this.mElem2Radius["PO"] = 1.40;
            this.mElem2Radius["AT"] = 1.50;
            this.mElem2Radius["RN"] = 1.50;
            this.mElem2Radius["FR"] = 2.60;
            this.mElem2Radius["RA"] = 2.21;
            this.mElem2Radius["AC"] = 2.15;
            this.mElem2Radius["TH"] = 2.06;
            this.mElem2Radius["PA"] = 2.00;
            this.mElem2Radius["U"] = 1.96;
            this.mElem2Radius["NP"] = 1.90;
            this.mElem2Radius["PU"] = 1.87;
            this.mElem2Radius["AM"] = 1.80;
            this.mElem2Radius["CM"] = 1.69;
        }

        // https://github.com/dsehnal/CIFTools.js
        // https://github.com/molstar/BinaryCIF
        async downloadBcif(bcifid) { let ic = this.icn3d, me = ic.icn3dui;
            ic.ParserUtilsCls.setYourNote(bcifid.toUpperCase() + '(BCIF) in iCn3D');
            //ic.bCid = undefined;

            let url = 'https://models.rcsb.org/' + bcifid + '.bcif';
            let bcifArrayBuffer = await me.getXMLHttpRqstPromise(url, 'GET', 'arraybuffer', 'bcif');

            if(bcifArrayBuffer.length == 0) {
                alert('This PDB structure is not found at RCSB...');
                return;
            }

            let bText = false;
            // let bcifData = this.getBcifJson(bcifArrayBuffer, bcifid, bText);
            // let bcifJson = JSON.parse(bcifData);
            // await ic.mmcifParserCls.loadMmcifData(bcifJson, bcifid);

            await ic.opmParserCls.loadOpmData(bcifArrayBuffer, bcifid, undefined, 'bcif', undefined, bText);
        }

        getBcifJson(bcifData, bcifid, bText, bNoCoord) { let ic = this.icn3d, me = ic.icn3dui;
            let text = "";

            let pmid = "", title = "", keyword = "", emd = "", organism = "";

            // bcifData could be binary or text
            let parsed = (bText) ? CIFTools.Text.parse(bcifData) : CIFTools.Binary.parse(bcifData);

            if (parsed.isError) {
                // report error:
                alert("The Binary CIF data can NOT be parsed: " + parsed.toString());
                return;
            }

            let block = parsed.result.dataBlocks[0];

            if(!bcifid) {
                if(block.getCategory("_entry")) {
                    bcifid = block.getCategory("_entry").getColumn("id").getString(0);
                }
                if(bcifid == "") bcifid = "stru";
            }

            if(block.getCategory("_citation")) {
                pmid = block.getCategory("_citation").getColumn("pdbx_database_id_PubMed").getString(0);
            }

            if(block.getCategory("_struct")) {
                title = block.getCategory("_struct").getColumn("title").getString(0);
                title = title.replace(/"/, "'");
            }

            if(block.getCategory("_struct_keywords")) {
                keyword = block.getCategory("_struct_keywords").getColumn("pdbx_keywords").getString(0);
            }
            
            if(block.getCategory("_entity_src_gen")) {
                organism = block.getCategory("_entity_src_gen").getColumn("gene_src_common_name").getString(0);
            }

            let sSSBegin = {}, sSSEnd = {};
            let mResId2SS = {};

            if(block.getCategory("_database_2")) {
                let database_2 = block.getCategory("_database_2");

                // Iterate through every row in the table
                let db2Size = database_2.rowCount ;
                for (let i = 0; i < db2Size; ++i) {
                    let db_id = database_2.getColumn("database_id").getString(i);
                    let db_code = database_2.getColumn("database_code").getString(i);

                    if(db_id == "EMDB") {
                        emd = db_code;
                        break;
                    }
                }
            }
            if(block.getCategory("_struct_conf")) {
                // Retrieve the table corresponding to the struct_conf category, which delineates mainly helix
                let struct_conf = block.getCategory("_struct_conf");

                let conf_type_idArray = struct_conf.getColumn("conf_type_id");

                let chain1Array = struct_conf.getColumn("beg_auth_asym_id");
                // let resi1Array = struct_conf.getColumn("beg_label_seq_id");
                let resi1Array = struct_conf.getColumn("beg_auth_seq_id");

                let chain2Array = struct_conf.getColumn("end_auth_asym_id");
                // let resi2Array = struct_conf.getColumn("end_label_seq_id");
                let resi2Array = struct_conf.getColumn("end_auth_seq_id");

                // Iterate through every row in the struct_conf category table, where each row delineates an interatomic connection
                let confSize = struct_conf.rowCount;
                for (let i = 0; i < confSize; ++i) {
                    let conf_type_id = conf_type_idArray.getString(i);

                    let chain1 = chain1Array.getString(i);
                    let resi1 = resi1Array.getString(i);
                    let id1 = chain1 + "_" + resi1;

                    let chain2 = chain2Array.getString(i);
                    let resi2 = resi2Array.getString(i);
                    let id2 = chain2 + "_" + resi2;

                    let ss;
                    if(conf_type_id.substr(0, 4) == "HELX") {
                        ss = "helix";

                        sSSBegin[id1] = 1;
                        sSSEnd[id2] = 1;
                    }
                    else if(conf_type_id.substr(0, 4) == "STRN") {
                        ss = "sheet";

                        sSSBegin[id1] = 1;
                        sSSEnd[id2] = 1;
                    }

                    if(ss == "helix" || ss == "sheet") {
                        for(let j = parseInt(resi1); j <= parseInt(resi2); ++j) {
                            let id = chain1 + "_" + j;
                            mResId2SS[id] = ss;
                        }
                    }
                }

                conf_type_idArray = chain1Array = resi1Array = chain2Array = resi2Array = [];
            }

            if(block.getCategory("_struct_sheet_range")) {
                // Retrieve the table corresponding to the struct_sheet_range category, which delineates mainly beta sheet
                let struct_sheet_range = block.getCategory("_struct_sheet_range");

                let chain1Array = struct_sheet_range.getColumn("beg_auth_asym_id");
                // let resi1Array = struct_sheet_range.getColumn("beg_label_seq_id");
                let resi1Array = struct_sheet_range.getColumn("beg_auth_seq_id");

                let chain2Array = struct_sheet_range.getColumn("end_auth_asym_id");
                // let resi2Array = struct_sheet_range.getColumn("end_label_seq_id");
                let resi2Array = struct_sheet_range.getColumn("end_auth_seq_id");

                // Iterate through every row in the struct_sheet_range category table, where each row delineates an interatomic connection
                let sheetSize = struct_sheet_range.rowCount;
                for (let i = 0; i < sheetSize; ++i) {
                    let chain1 = chain1Array.getString(i);
                    let resi1 = resi1Array.getString(i);
                    let id1 = chain1 + "_" + resi1;

                    sSSBegin[id1] = 1;

                    let chain2 = chain2Array.getString(i);
                    let resi2 = resi2Array.getString(i);
                    let id2 = chain2 + "_" + resi2;

                    sSSEnd[id2] = 1;

                    let ss = "sheet";

                    for(let j = parseInt(resi1); j <= parseInt(resi2); ++j) {
                        let id = chain1 + "_" + j;
                        mResId2SS[id] = ss;
                    }
                }

                chain1Array = resi1Array = chain2Array = resi2Array = [];
            }

            // Iterate through every row in the struct_conn category table, where each row delineates an interatomic connection
            let mId2Set = {};
            let vBonds = [];
            let vDisulfides = [];

            if(block.getCategory("_struct_conn")) {
                // Retrieve the table corresponding to the struct_conn category, which delineates connections1
                let struct_conn = block.getCategory("_struct_conn");

                let conn_type_idArray = struct_conn.getColumn("conn_type_id");

                let chain1Array = struct_conn.getColumn("ptnr1_auth_asym_id");
                let name1Array = struct_conn.getColumn("ptnr1_label_atom_id");
                let resi1Array = struct_conn.getColumn("ptnr1_label_seq_id");

                let chain2Array = struct_conn.getColumn("ptnr2_auth_asym_id");
                let name2Array = struct_conn.getColumn("ptnr2_label_atom_id");
                let resi2Array = struct_conn.getColumn("ptnr2_label_seq_id");

                let connSize = struct_conn.rowCount;
                for (let i = 0; i < connSize; ++i) {
                    let conn_type_id = conn_type_idArray.getString(i);

                    let chain1 = chain1Array.getString(i);
                    let name1 = name1Array.getString(i);
                    let resi1 = resi1Array.getString(i);
                    let id1 = chain1 + "_" + resi1 + "_" + name1;

                    let chain2 = chain2Array.getString(i);
                    let name2 = name2Array.getString(i);
                    let resi2 = resi2Array.getString(i);
                    let id2 = chain2 + "_" + resi2 + "_" + name2;

                    // Verify that the linkage is covalent, as indicated by the conn_type_id attribute2

                    if (conn_type_id == "covale") {
                        vBonds.push(id1);
                        vBonds.push(id2);
                    }
                    else if(conn_type_id == "disulf") {
                        vDisulfides.push(bcifid + "_" + chain1 + "_" + resi1);
                        vDisulfides.push(bcifid + "_" + chain2 + "_" + resi2);
                    }
                }

                conn_type_idArray = chain1Array = name1Array = resi1Array = chain2Array = name2Array = resi2Array = [];
            }

            // Retrieve the table corresponding to the atom_site category, which delineates atomic constituents
            let atom_site = block.getCategory("_atom_site");

            // set the map from atom name to serial
            let mName2Serial = {};

            let prevC = {};
            // let atom = {};
            prevC.id = "";

            let prevResi = "", currResi;
            let mResi2Atoms = {};

            let sChain = {};
            let prevResn = "";
            let atomSize = atom_site.rowCount;
            let serial = 1;

            let bFull = (atomSize * 10 > ic.maxatomcnt) ? false : true;

            let atom_hetatmArray, resnArray, elemArray, nameArray, chainArray, resiArray, resiOriArray, altArray, bArray, xArray, yArray, zArray, autochainArray, modelNumArray;

            if(!bNoCoord) {
                atom_hetatmArray = atom_site.getColumn("group_PDB");
                resnArray = atom_site.getColumn("label_comp_id");
                elemArray = atom_site.getColumn("type_symbol");
                nameArray = atom_site.getColumn("label_atom_id");

                chainArray = atom_site.getColumn("auth_asym_id");
                
                resiArray = atom_site.getColumn("label_seq_id");
                resiOriArray = atom_site.getColumn("auth_seq_id");
                altArray = atom_site.getColumn("label_alt_id");

                bArray = atom_site.getColumn("B_iso_or_equiv");

                xArray = atom_site.getColumn("Cartn_x");
                yArray = atom_site.getColumn("Cartn_y");
                zArray = atom_site.getColumn("Cartn_z");

                autochainArray = atom_site.getColumn("label_asym_id");
                modelNumArray = atom_site.getColumn("pdbx_PDB_model_num");

                // get the bond info
                let ligSeqHash = {}, prevAutochain = '';
                for (let i = 0; i < atomSize; ++i) {
                    let atom_hetatm = atom_hetatmArray.getString(i);
                    let resn = resnArray.getString(i);
                    let elem = elemArray.getString(i);
                    let name = nameArray.getString(i);
            // use the chain name from author, and use seq id from standardized seq id
                    //let chain = atom_site.getColumn("label_asym_id").getString(i);
                    let chain = chainArray.getString(i);
                    let resi = resiArray.getString(i);
                    let oriResi = resiOriArray.getString(i); 
                    let alt = altArray.getString(i);

                    let autochain = autochainArray.getString(i);

                    resi = oriResi;

                    let molecueType;
                    if(atom_hetatm == "ATOM") {
                        if(resn.length == 3) {
                            molecueType = "protein"; //"p"; // protein
                        }
                        else {
                            molecueType = "nucleotide"; //"n"; // nucleotide
                        }
                    }
                    else {
                        if(resn == "WAT" || resn == "HOH") {
                            molecueType = "solvent"; //"s"; // solvent
                            chain = 'Misc';
                        }
                        else {
                            molecueType = "ligand"; //"l"; // ligands or ions
                            chain = resn;
                        }
                    }

                    // C-alpha only for large structure
                    if(!bFull && ((molecueType == "protein" && !(elem == 'C' && name == 'CA')) 
                        || (molecueType == "nucleotide" && !(name == "P")) ) ) continue;
                    // skip alternative atoms
                    if(alt == "B") continue;

                    sChain[chain] = 1;

                    if(resi == "?" || resi == "." || resi == "0") {
                        resi = oriResi;
                        // if(resn.length != 3 || resn == "HOH" || resn == "WAT") {
                        //     if(resn.length != 3 || (elem == 'O' && (resn == "HOH" || resn == "WAT"))) {
                        //         resi = (++tmpResi).toString();
                        //     }
                        // }
                        // else {
                        //     if(chain + "_" + resn != prevResn || prevAutochain != autochain) {
                        //         resi = (++tmpResi).toString();
                        //     }
                        //     else {
                        //         resi = (tmpResi).toString();
                        //     }
                        // }
                    }
        
                    if(molecueType == 'solvent' || molecueType == "ligand") {
                        let seq = {};
                        if(!ligSeqHash.hasOwnProperty(chain)) {
                            ligSeqHash[chain] = [];
                        }
        
                        if(resn.length != 3 || resn == "HOH" || resn == "WAT") {
                            if(resn.length != 3 || (elem == 'O' && (resn == "HOH" || resn == "WAT"))) {
                                seq.resi = resi;
                                seq.name = me.utilsCls.residueName2Abbr(resn);
                                ligSeqHash[chain].push(seq);
                            }
                        }
                        else {
                            if(chain + "_" + resn != prevResn || prevAutochain != autochain) {
                                seq.resi = resi;
                                seq.name = me.utilsCls.residueName2Abbr(resn);
                                ligSeqHash[chain].push(seq);
                            }
                        }
                    }

                    let x = xArray.getFloat(i);
                    let y = yArray.getFloat(i);
                    let z = zArray.getFloat(i);

                    let id = serial.toString();

                    let atomname = chain + "_" + resi + "_" + name;

                    mName2Serial[atomname] = id;

                    let atom = {};

                    atom.id = id;
                    atom.elem = elem;
                    atom.x = x;
                    atom.y = y;
                    atom.z = z;
                    atom.alt = alt;

                    currResi = chain + "_" + resi;

                    let para = 1.3;
                    // let para = (atom_hetatm == "HETATM") ? 1.3 : 1;

                    if(currResi != prevResi || prevAutochain != autochain) {
                        mResi2Atoms = {};

                        mResi2Atoms[currResi] = {};
                        mResi2Atoms[currResi][atom.id] = atom;
                    }
                    else {
                        // bond between this atom and all other atom in the same residue
                        for(let j in mResi2Atoms[currResi]) { // j is atom.id
                            if(this.hasCovalentBond(atom, mResi2Atoms[currResi][j], para)) {
                                if(!mId2Set.hasOwnProperty(atom.id)) mId2Set[atom.id] = {};
                                if(!mId2Set.hasOwnProperty(mResi2Atoms[currResi][j].id)) mId2Set[mResi2Atoms[currResi][j].id] = {};
                                mId2Set[atom.id][mResi2Atoms[currResi][j].id] = 1;
                                mId2Set[mResi2Atoms[currResi][j].id][atom.id] = 1;
                            }
                        }

                        mResi2Atoms[currResi][atom.id] = atom;
                    }

                    // bond between N and previous C
                    if(name == "N" && prevC.id != "") {
                        if(this.hasCovalentBond(atom, prevC, para)) {
                            if(!mId2Set.hasOwnProperty(atom.id)) mId2Set[atom.id] = {};
                            if(!mId2Set.hasOwnProperty(prevC.id)) mId2Set[prevC.id] = {};
                            mId2Set[atom.id][prevC.id] = 1;
                            mId2Set[prevC.id][atom.id] = 1;
                        }
                    }

                    if(name == "C") {
                        prevC = atom;
                    }

                    prevResi = currResi;
                    prevResn = chain + "_" + resn;

                    prevAutochain = autochain;

                    ++serial;
                }

                /// add the defined bonds
                for(let i = 0; i < vBonds.length; i = i + 2) {
                    let id1 = mName2Serial[vBonds[i]];
                    let id2 = mName2Serial[vBonds[i+1]];

                    if(!mId2Set.hasOwnProperty(id1)) mId2Set[id1] = {};
                    if(!mId2Set.hasOwnProperty(id2)) mId2Set[id2] = {};
                    mId2Set[id1][id2] = 1;
                    mId2Set[id2][id1] = 1;
                }
            }

            let emdStr = (emd != "") ? "\"emd\":\"" + emd + "\"," : "";
            let organismStr = (organism != "") ? "\"organism\":\"" + organism + "\"," : "";

            text += "{\"bcif\":\"" + bcifid + "\", " + emdStr + organismStr + "\"pubmedid\":\"" + pmid + "\", \"descr\": {\"name\": \"" + title + "\", \"class\": \"" + keyword + "\"}";
            
            if(!bNoCoord) {
                text += ", \"atoms\":[\n";
                prevResn = "";
                serial = 1;
                let structure = bcifid;

                for (let i = 0; i < atomSize; ++i) {
                    let modelNum = modelNumArray.getString(i);
                    if(modelNum != "1" && modelNum != "") {
                        structure = bcifid + modelNum;
                    }

                    let atom_hetatm = atom_hetatmArray.getString(i);
                    let resn = resnArray.getString(i);
                    let elem = elemArray.getString(i);
                    let name = nameArray.getString(i);
            // use the chain name from author, and use seq id from standardized seq id
                    //let chain = atom_site.getColumn("label_asym_id").getString(i);
                    let chain = chainArray.getString(i);
                    let resi = resiArray.getString(i);
                    let oriResi = resiOriArray.getString(i); 
                    let alt = altArray.getString(i);

                    let autochain = autochainArray.getString(i);

                    resi = oriResi;

                    let molecueType;
                    if(atom_hetatm == "ATOM") {
                        if(resn.length == 3) {
                            molecueType = "protein"; // protein
                        }
                        else {
                            molecueType = "nucleotide"; // nucleotide
                        }
                    }
                    else {
                        if(resn == "WAT" || resn == "HOH") {
                            molecueType = "solvent"; // solvent
                            chain = 'Misc';
                        }
                        else {
                            molecueType = "ligand"; // ligands or ions
                            chain = resn;
                        }
                    }

                    // C-alpha only for large structure
                    if(!bFull && ((molecueType == "protein" && !(elem == 'C' && name == 'CA')) 
                        || (molecueType == "nucleotide" && !(name == "P")) ) ) continue;
                    // skip alternative atoms
                    if(alt == "B") continue;

                    if(resi == "?" || resi == "." || resi == "0") {
                        resi = oriResi;

                        // if(resn.length != 3 || resn == "HOH" || resn == "WAT") {
                        //     if(resn.length != 3 || (elem = 'O' && (resn == "HOH" || resn == "WAT"))) {
                        //         resi = (++tmpResi).toString();
                        //     }
                        // }
                        // else {
                        //     if(chain + "_" + resn != prevResn || prevAutochain != autochain) {
                        //         resi = (++tmpResi).toString();
                        //     }
                        //     else {
                        //         resi = (tmpResi).toString();
                        //     }
                        // }
                    }

                    let b = bArray.getString(i);

                    let x = xArray.getFloat(i);
                    let y = yArray.getFloat(i);
                    let z = zArray.getFloat(i);
                    //int serial = parseInt(atom_site(i, "id"));

                    //let id = chain + "_" + resi + "_" + name;
                    let id = serial.toString();
                    let resId = chain + "_" + resi;

                    let het = (atom_hetatm == "HETATM") ? "1" : "0";

                    text += "{";
                    text += "\"het\":" + het + ", ";
                    text += "\"serial\":" + serial + ", ";
                    text += "\"name\":\"" + name + "\", ";
                    text += "\"resn\":\"" + resn + "\", ";
                    text += "\"structure\":\"" + structure + "\", ";
                    text += "\"chain\":\"" + chain + "\", ";
                    text += "\"resi\":" + resi + ", ";
                    text += "\"coord\":{\"x\":" + x + ", \"y\":" + y + ", \"z\":" + z + "}, ";
                    text += "\"b\":\"" + b + "\", ";
                    text += "\"elem\":\"" + elem + "\", ";
                    text += "\"bonds\":[";

                    let sConnId = {};

                    if(mId2Set.hasOwnProperty(id)) sConnId = mId2Set[id];

                    let vConnId = Object.keys(sConnId);
                    
                    for(let j = 0, jl = vConnId.length; j < jl; ++j) {
                        if(vConnId[j] === 'undefined') continue;

                        text += vConnId[j];

                        // if(j < jl - 1 && vConnId[j]) text += ", ";
                        text += ", ";
                    }
                    if(vConnId.length > 0) text = text.substr(0, text.length - 2);

                    text += "], ";

                    if(mResId2SS.hasOwnProperty(resId)) {
                        let ss = mResId2SS[resId];
                        text += "\"ss\":\"" + ss + "\", ";
                    }
                    else {
                        text += "\"ss\":\"coil\", ";
                    }

                    if(sSSBegin.hasOwnProperty(resId)) {
                        text += "\"ssbegin\":1, ";
                    }
                    else {
                        text += "\"ssbegin\":0, ";
                    }

                    if(sSSEnd.hasOwnProperty(resId)) {
                        text += "\"ssend\":1, ";
                    }
                    else {
                        text += "\"ssend\":0, ";
                    }

                    //text += "\"color\":\"#FFF\", ";
                    text += "\"mt\":\"" + molecueType + "\"";

                    text += "}";

                    // if(i < atomSize - 1) text += ",\n";
                    text += ",\n";

                    prevResn = chain + "_" + resn;
                    prevAutochain = autochain;

                    ++serial;
                }
                // remove the last comma and new line
                if(serial > 1) text = text.substr(0, text.length - 2);

                text += "]";
            }

            atom_hetatmArray = resnArray = elemArray = nameArray = chainArray = resiArray = resiOriArray 
            = altArray = bArray = xArray = yArray = zArray = autochainArray = [];

            let mChainSeq = {};
            if(block.getCategory("_pdbx_poly_seq_scheme")) {
                let poly_seq_scheme = block.getCategory("_pdbx_poly_seq_scheme");

                let resiArray = poly_seq_scheme.getColumn("seq_id");
                let oriResiArray = poly_seq_scheme.getColumn("pdb_seq_num");
                let resnArray = poly_seq_scheme.getColumn("mon_id");
                let chainArray = poly_seq_scheme.getColumn("pdb_strand_id");

                let seqSize = poly_seq_scheme.rowCount;
                let prevChain = "";
                let seq = "";
                for (let i = 0; i < seqSize; ++i) {
                    resiArray.getString(i);
                    let oriResi = oriResiArray.getString(i);
                    let resn = resnArray.getString(i);
                    let chain = chainArray.getString(i);

                    if(chain != prevChain) {
                        if(i == 0) {
                            seq = "[";
                        }
                        else {
                            seq = seq.substr(0, seq.length - 2);

                            seq += "]";

                            mChainSeq[prevChain] = seq;

                            seq = "[";
                        }
                    }

                    // seq += "[" + resi + ", \"" + resn + "\"]";
                    seq += "[" + oriResi + ", \"" + resn + "\"]";

                    if(i < seqSize - 1) seq += ", ";

                    prevChain = chain;
                }

                seq += "]";

                mChainSeq[prevChain] = seq;

                resiArray = oriResiArray = resnArray = chainArray = [];
            }

            // print sequences
            text += ", \"sequences\":{";
            let bData = false;
            // need to consider different models in NMR structures
            // But this function is only used for meta data, 
            for(let chain in sChain) {
                let seq;
                if(ligSeqHash.hasOwnProperty(chain)) {
                    seq = "[" + ligSeqHash[chain] + "]";
                }
                else {
                    seq = mChainSeq[chain];
                }

                // if(seq != "") {
                if(seq !== "" && seq !== undefined) {
                    text += "\"" + chain + "\": " + seq + ", ";
                    bData = true;
                }
            }

            if(bData) text = text.substr(0, text.length - 2);

            text += "}";

            if(block.getCategory("_pdbx_struct_oper_list")) {
                // Retrieve the table corresponding to the struct_oper_list category, which delineates assembly
                let struct_oper_list = block.getCategory("_pdbx_struct_oper_list");

                text += ", \"assembly\":[";

                let pmatrix = ", \"pmatrix\":";
                let bPmatrix = false;

                let assemblySize = struct_oper_list.rowCount;
                
                // could be one or more rows, struct_oper_list.getColumn("id").data is unavailable if one row
                for (let i = 0; i < assemblySize; ++i) {
                    let struct_oper_id = struct_oper_list.getColumn("id").getString(i);
                    if(struct_oper_id == "X0") continue;

                    let m11 = struct_oper_list.getColumn("matrix[1][1]").getFloat(i);
                    let m12 = struct_oper_list.getColumn("matrix[1][2]").getFloat(i);
                    let m13 = struct_oper_list.getColumn("matrix[1][3]").getFloat(i);
                    let m14 = struct_oper_list.getColumn("vector[1]").getFloat(i);
        
                    let m21 = struct_oper_list.getColumn("matrix[2][1]").getFloat(i);
                    let m22 = struct_oper_list.getColumn("matrix[2][2]").getFloat(i);
                    let m23 = struct_oper_list.getColumn("matrix[2][3]").getFloat(i);
                    let m24 = struct_oper_list.getColumn("vector[2]").getFloat(i);
        
                    let m31 = struct_oper_list.getColumn("matrix[3][1]").getFloat(i);
                    let m32 = struct_oper_list.getColumn("matrix[3][2]").getFloat(i);
                    let m33 = struct_oper_list.getColumn("matrix[3][3]").getFloat(i);
                    let m34 = struct_oper_list.getColumn("vector[3]").getFloat(i);

                    let matrix = "[" + m11 + "," + m21 + "," + m31 + ", 0, "
                        + m12 + "," + m22 + "," + m32 + ", 0, "
                        + m13 + "," + m23 + "," + m33 + ", 0, "
                        + m14 + "," + m24 + "," + m34 + ", 1"
                        + "]";

                    if(struct_oper_id == "P") {
                        pmatrix += matrix;
                        bPmatrix = true;
                    }
                    else {
                        text += matrix;

                        if(i < assemblySize - 1) text += ", ";
                    }
                }

                text += "]";

                if(bPmatrix) text += pmatrix;
            }

            if(vDisulfides.length > 0) {
                text += ", \"disulfides\":[";

                for(let i = 0; i < vDisulfides.length; i += 2) {
                    text += "[";
                    text += "\"" + vDisulfides[i] + "\", \"" + vDisulfides[i+1] + "\"";
                    text += "]";

                    if(i < vDisulfides.length - 2) text += ", ";
                }

                text += "]";
            }

            text += "}";
            
            return text;
        }

        hasCovalentBond(atom1, atom2, para) { let ic = this.icn3d; ic.icn3dui;
            let r = this.mElem2Radius[atom1.elem] + this.mElem2Radius[atom2.elem];

            let dx = (atom1.x - atom2.x);
            let dy = (atom1.y - atom2.y);
            let dz = (atom1.z - atom2.z);

            let dist2 = dx * dx + dy * dy + dz * dz;

            return dist2 < para * r * r;
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Mol2Parser {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        async loadMol2Data(data) { let ic = this.icn3d, me = ic.icn3dui;
            let bResult = this.loadMol2AtomData(data);

            if(me.cfg.align === undefined && Object.keys(ic.structures).length == 1) {
                $("#" + ic.pre + "alternateWrapper").hide();
            }

            if(!bResult) {
              alert('The Mol2 file has the wrong format...');
            }
            else {
              ic.setStyleCls.setAtomStyleByOptions(ic.opts);
              ic.setColorCls.setColorByOptions(ic.opts, ic.atoms);

              await ic.ParserUtilsCls.renderStructure();

              if(me.cfg.rotate !== undefined) ic.resizeCanvasCls.rotStruc(me.cfg.rotate, true);

              //if(me.deferred !== undefined) me.deferred.resolve(); /// if(ic.deferred2 !== undefined) ic.deferred2.resolve();
            }
        }

        loadMol2AtomData(data) { let ic = this.icn3d; ic.icn3dui;
            let lines = data.split(/\r?\n|\r/);
            if(lines.length < 4) return false;

            ic.init();

            let structure = 1;
            let chain = 'A';
            let resn = 'LIG';
            let resi = 1;

            let AtomHash = {};
            let moleculeNum = 1, chainNum = '1_A', residueNum = '1_A_1';
            let atomCount, bondCount, atomIndex = 0, bondIndex = 0;
            let serial=1;

            let bAtomSection = false, bBondSection = false;

            let atomid2serial = {};
            let skipAtomids = {};

            for(let i = 0, il = lines.length; i < il; ++i) {
                let line = lines[i].trim();
                if(line === '') continue;
                if(line.substr(0, 1) === '#') continue;

                if(line == '@<TRIPOS>MOLECULE') {
                    ic.molTitle = lines[i + 1].trim();
                    let atomCnt_bondCnt = lines[i + 2].trim().replace(/\s+/g, " ").split(" ");
                    atomCount = atomCnt_bondCnt[0];
                    bondCount = atomCnt_bondCnt[1];
                    i = i + 4;
                }
                else if(line == '@<TRIPOS>ATOM') { // 1    C1    1.207    2.091    0.000    C.ar    1    BENZENE    0.000
                    serial = 1;

                    bAtomSection = true;

                    ++i;
                }
                else if(line == '@<TRIPOS>BOND') { // 1    1    2    ar
                    bBondSection = true;
                    bAtomSection = false;

                    ++i;
                }
                else if(line == '@<TRIPOS>SUBSTRUCTURE') { // 1    1    2    ar
                    bBondSection = false;

                    ++i;
                }

                line = lines[i].trim();
                if(line === '') continue;
                if(line.substr(0, 1) === '#') continue;

                if(bAtomSection && atomIndex < atomCount) {
                    // 1    C1    1.207    2.091    0.000    C.ar    1    BENZENE    0.000
                    let atomArray = line.replace(/\s+/g, " ").split(" ");

                    let atomid = parseInt(atomArray[0]);
                    atomid2serial[atomid] = serial;

                    let name = atomArray[1];
                    let x = parseFloat(atomArray[2]);
                    let y = parseFloat(atomArray[3]);
                    let z = parseFloat(atomArray[4]);
                    let coord = new THREE.Vector3(x, y, z);

                    let elemFull = atomArray[5];
                    let pos = elemFull.indexOf('.');

                    let elem;
                    if(pos === -1) {
                        elem = elemFull;
                    }
                    else {
                        elem = elemFull.substr(0, pos);
                    }

                    // skip H, but keep H.spc, H.t3p, etc
                    if(elem === 'H' && elem === elemFull) {
                        skipAtomids[atomid] = 1;
                    }
                    else {
                        let atomDetails = {
                            het: true,              // optional, used to determine chemicals, water, ions, etc
                            serial: serial,         // required, unique atom id
                            name: name,             // required, atom name
                            resn: resn,             // optional, used to determine protein or nucleotide
                            structure: structure,   // optional, used to identify structure
                            chain: chain,           // optional, used to identify chain
                            resi: resi,             // optional, used to identify residue ID
                            coord: coord,           // required, used to draw 3D shape
                            b: 0,                   // optional, used to draw B-factor tube
                            elem: elem,             // optional, used to determine hydrogen bond
                            bonds: [],              // required, used to connect atoms
                            ss: 'coil',             // optional, used to show secondary structures
                            ssbegin: false,         // optional, used to show the beginning of secondary structures
                            ssend: false,           // optional, used to show the end of secondary structures

                            bondOrder: []           // optional, specific for chemicals
                        };

                        ic.atoms[serial] = atomDetails;
                        AtomHash[serial] = 1;

                        ++serial;
                    }

                    ++atomIndex;
                }

                if(bBondSection && bondIndex < bondCount) {
                    // 1    1    2    ar
                    let bondArray = line.replace(/\s+/g, " ").split(" ");
                    let fromAtomid = parseInt(bondArray[1]);
                    let toAtomid = parseInt(bondArray[2]);
                    let bondType = bondArray[3];
                    let finalBondType = bondType;

                    // 1 = single  2 = double  3 = triple  am = amide  ar = aromatic  du = dummy  un = unknown(cannot be determined from the parameter tables)  nc = not connected
                    if(bondType === 'am') {
                        finalBondType = '1';
                    }

                    if(bondType === 'ar') {
                        finalBondType = '1.5';
                    }

                    if(!skipAtomids.hasOwnProperty(fromAtomid) && !skipAtomids.hasOwnProperty(toAtomid) &&(finalBondType === '1' || finalBondType === '2' || finalBondType === '3' || finalBondType === '1.5') ) {
                        let order = finalBondType;
                        let from = atomid2serial[fromAtomid];
                        let to = atomid2serial[toAtomid];

                        // skip all bonds between H and C
                        //if( !(ic.atoms[from].elem === 'H' && ic.atoms[to].elem === 'C') && !(ic.atoms[from].elem === 'C' && ic.atoms[to].elem === 'H') ) {
                            ic.atoms[from].bonds.push(to);
                            ic.atoms[from].bondOrder.push(order);
                            ic.atoms[to].bonds.push(from);
                            ic.atoms[to].bondOrder.push(order);

                            if(order == '2') {
                                ic.doublebonds[from + '_' + to] = 1;
                                ic.doublebonds[to + '_' + from] = 1;
                            }
                            else if(order == '3') {
                                ic.triplebonds[from + '_' + to] = 1;
                                ic.triplebonds[to + '_' + from] = 1;
                            }
                            else if(order == '1.5') {
                                ic.aromaticbonds[from + '_' + to] = 1;
                                ic.aromaticbonds[to + '_' + from] = 1;
                            }
                        //}
                    }

                    ++bondIndex;
                }
            }

            ic.dAtoms = AtomHash;
            ic.hAtoms= AtomHash;
            ic.structures[moleculeNum] = [chainNum]; //AtomHash;
            ic.chains[chainNum] = AtomHash;
            ic.residues[residueNum] = AtomHash;

            ic.residueId2Name[residueNum] = resn;

            if(ic.chainsSeq[chainNum] === undefined) ic.chainsSeq[chainNum] = [];

            let resObject = {};
            resObject.resi = resi;
            resObject.name = resn;

            ic.chainsSeq[chainNum].push(resObject);

            ic.ParserUtilsCls.setMaxD();

            ic.saveFileCls.showTitle();

            return true;
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class OpmParser {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        async downloadOpm(opmid) { let ic = this.icn3d, me = ic.icn3dui;
            ic.ParserUtilsCls.setYourNote(opmid.toUpperCase() + '(OPM) in iCn3D');
     
            //ic.bCid = undefined;
            // no rotation
            ic.bStopRotate = true;

            let url = "https://opm-assets.storage.googleapis.com/pdb/" + opmid.toLowerCase()+ ".pdb";
            let data = await me.getAjaxPromise(url, 'text', true, 'This is probably not a transmembrane protein. It has no data in Orientations of Proteins in Membranes(OPM) database.');

            ic.bOpm = true;
            await ic.pdbParserCls.loadPdbData(data, opmid, ic.bOpm);

            $("#" + ic.pre + "selectplane_z1").val(ic.halfBilayerSize);
            $("#" + ic.pre + "selectplane_z2").val(-ic.halfBilayerSize);

            $("#" + ic.pre + "extra_mem_z").val(ic.halfBilayerSize);
            $("#" + ic.pre + "intra_mem_z").val(-ic.halfBilayerSize);
        }


        async loadOpmData(data, pdbid, bFull, type, pdbid2, bText) { let ic = this.icn3d, me = ic.icn3dui;
            try {
                 if(!pdbid) pdbid = ic.defaultPdbId;
                let url = me.htmlCls.baseUrl + "mmdb/mmdb_strview.cgi?v=2&program=icn3d&opm&uid=" + pdbid.toLowerCase();

                let opmdata = await me.getAjaxPromise(url, 'jsonp', false);
        
                this.setOpmData(opmdata); // set ic.bOpm

                await this.parseAtomData(data, pdbid, bFull, type, pdbid2, bText);
            }
            catch(err) {
                await this.parseAtomData(data, pdbid, bFull, type, pdbid2, bText);
            }
        }

        setOpmData(data) { let ic = this.icn3d; ic.icn3dui;
            if(data.opm !== undefined && data.opm.rot !== undefined) {
                ic.bOpm = true;

                ic.halfBilayerSize = data.opm.thickness;
                ic.rmsd_supr = {};
                ic.rmsd_supr.rot = data.opm.rot;
                ic.rmsd_supr.trans1 = new THREE.Vector3(data.opm.trans1[0], data.opm.trans1[1], data.opm.trans1[2]);
                ic.rmsd_supr.trans2 = new THREE.Vector3(data.opm.trans2[0], data.opm.trans2[1], data.opm.trans2[2]);
                ic.rmsd_supr.rmsd = data.opm.rmsd;

              $("#" + ic.pre + "selectplane_z1").val(ic.halfBilayerSize);
              $("#" + ic.pre + "selectplane_z2").val(-ic.halfBilayerSize);

              $("#" + ic.pre + "extra_mem_z").val(ic.halfBilayerSize);
              $("#" + ic.pre + "intra_mem_z").val(-ic.halfBilayerSize);
            }
            else {
                ic.bOpm = false;
            }
        }

        modifyUIMapAssembly() { let ic = this.icn3d, me = ic.icn3dui;
            if(!me.bNode) {
                if(ic.emd !== undefined) {
                    $("#" + ic.pre + "mapWrapper1").hide();
                    $("#" + ic.pre + "mapWrapper2").hide();
                    $("#" + ic.pre + "mapWrapper3").hide();
                  }
                  else {
                    $("#" + ic.pre + "emmapWrapper1").hide();
                    $("#" + ic.pre + "emmapWrapper2").hide();
                    $("#" + ic.pre + "emmapWrapper3").hide();
                  }
      
                  if(Object.keys(ic.structures).length == 1) {
                      $("#" + ic.pre + "alternateWrapper").hide();
                  }
      /*    
                  // load assembly info
                  if(type === 'mmcif') {
                      let assembly =(data.assembly !== undefined) ? data.assembly : [];
                      for(let i = 0, il = assembly.length; i < il; ++i) {
                          if(ic.biomtMatrices[i] == undefined) ic.biomtMatrices[i] = new THREE.Matrix4().identity();
              
                          for(let j = 0, jl = assembly[i].length; j < jl; ++j) {
                              ic.biomtMatrices[i].elements[j] = assembly[i][j];
                          }
                      }
                  }
      */        
                  if(ic.biomtMatrices !== undefined && ic.biomtMatrices.length > 1) {
                      $("#" + ic.pre + "assemblyWrapper").show();
          
                      ic.asuCnt = ic.biomtMatrices.length;
                  }
            }
        }

        async parseAtomData(data, pdbid, bFull, type, pdbid2, bText) { let ic = this.icn3d, me = ic.icn3dui;
            /*
            if(type === 'mmtf') {
                await ic.bcifParserCls.parseBcifData(data, pdbid, bFull);
            }
            else 
            */

            if(type === 'mmcif' || type === 'bcif') {
                // if(type === 'mmcif') {
                //     ic.loadAtomDataCls.loadAtomDataIn(data, data.mmcif, 'mmcifid', undefined, undefined);
                // }
                // else if(type === 'bcif') {
                    ic.loadCIFCls.loadCIF(data, pdbid, bText);
                // }

                this.modifyUIMapAssembly();
        
                ic.setStyleCls.setAtomStyleByOptions(ic.opts);
                ic.setColorCls.setColorByOptions(ic.opts, ic.atoms);

                await ic.ParserUtilsCls.renderStructure();

                if(me.cfg.rotate !== undefined) ic.resizeCanvasCls.rotStruc(me.cfg.rotate, true);

                /// if(ic.deferredOpm !== undefined) ic.deferredOpm.resolve();
            }
            else if(type === 'pdb') {
                await ic.pdbParserCls.loadPdbData(data, pdbid);
            }
            else if(type === 'align') {
                if(ic.bOpm) {
                    await ic.alignParserCls.downloadAlignmentPart2(pdbid);
                    /// if(ic.deferredOpm !== undefined) ic.deferredOpm.resolve();
                }
                else {
                    if(pdbid2 !== undefined) {
                        await this.loadOpmData(data, pdbid2, bFull, type);
                    }
                    else {
                        await ic.alignParserCls.downloadAlignmentPart2(pdbid);
                        /// if(ic.deferredOpm !== undefined) ic.deferredOpm.resolve();
                    }
                }
            }
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class PdbParser {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Ajax call was used to get the atom data from the "pdbid". This function was deferred so that
        //it can be chained together with other deferred functions for sequential execution. A wrapper
        //was added to support both http and https.
        async downloadPdb(pdbid, bAf) { let ic = this.icn3d, me = ic.icn3dui;
            let url;

            if(bAf) {
                url = "https://alphafold.ebi.ac.uk/files/AF-" + pdbid + "-F1-model_" + ic.AFUniprotVersion + ".pdb";
                if(me.cfg.refseqid) {
                    ic.ParserUtilsCls.setYourNote(me.cfg.refseqid.toUpperCase() + '(NCBI Protein Acc.) in iCn3D');
                }
                else if(me.cfg.protein) {
                    ic.ParserUtilsCls.setYourNote(me.cfg.protein + '(NCBI Protein/Gene) in iCn3D');
                }
                else {
                    ic.ParserUtilsCls.setYourNote(pdbid.toUpperCase() + '(AlphaFold) in iCn3D');
                }
            }
            else {
                // url = "https://files.rcsb.org/view/" + pdbid + ".pdb";
                url = "https://files.rcsb.org/download/" + pdbid + ".pdb";
                pdbid = pdbid.toUpperCase();
                ic.ParserUtilsCls.setYourNote(pdbid + '(PDB) in iCn3D');
            }

            //ic.bCid = undefined;

            let data = await me.getAjaxPromise(url, 'text', true, 'The ID ' + pdbid + ' can not be found in the server ' + url + '...');

            if(bAf) {
                // add UniProt ID into the header
                let header = 'HEADER                                                        ' + pdbid + '\n';
                data = header + data;          
                await ic.opmParserCls.parseAtomData(data, pdbid, undefined, 'pdb', undefined);
            }
            else {
                await ic.opmParserCls.loadOpmData(data, pdbid, undefined, 'pdb');
            }
        }

        //Load structures from a "URL". Due to the same domain policy of Ajax call, the URL should be in the same
        //domain. "type" could be "pdb", "mol2", "sdf", "xyz", "icn3dpng", or "pae" 
        //for pdb file, mol2file, sdf file, xyz file, iCn3D PNG image, and ALphaFold PAE file, respectively.
        async downloadUrl(url, type, command, template) { let ic = this.icn3d, me = ic.icn3dui;
            let pos = url.lastIndexOf('/');
            if(pos != -1) {
                let posDot = url.lastIndexOf('.');
                ic.filename = url.substr(pos + 1, posDot - pos - 1);
            }
            else {
                let posDot = url.lastIndexOf('.');
                ic.filename = url.substr(0, posDot);
            }

            //ic.bCid = undefined;

            let data = await me.getAjaxPromise(url, 'text', true);

            ic.InputfileData = (ic.InputfileData) ? ic.InputfileData + '\nENDMDL\n' + data : data;
            ic.InputfileType = type;

            // append
            ic.hAtoms = {};
            ic.dAtoms = {};

            ic.resetConfig();
            ic.bResetAnno = true;
            ic.bResetSets = true;

            if(type === 'pdb') {
                // await this.loadPdbData(data);
                let bAppend = true;
                let id = (template) ? template.replace(/_/g, '').substr(0, 4) : undefined;
                await this.loadPdbData(data, id, undefined, bAppend);
            }
            else if(type === 'mmcif') {
                // let url = me.htmlCls.baseUrl + "mmcifparser/mmcifparser.cgi";
                // let dataObj = {'mmciffile': data};
                // let data2 = await me.getAjaxPostPromise(url, dataObj, true);
                // await ic.mmcifParserCls.loadMmcifData(data2, undefined);

                let bText = true;
                // let bcifData = ic.bcifParserCls.getBcifJson(data, undefined, bText);
                // let bcifJson = JSON.parse(bcifData);

                // await ic.mmcifParserCls.loadMmcifData(bcifJson, undefined);
                await ic.opmParserCls.loadOpmData(data, undefined, undefined, 'mmcif', undefined, bText);
            }
            else if(type === 'mol2') {
                await ic.mol2ParserCls.loadMol2Data(data);
            }
            else if(type === 'sdf') {
                await ic.sdfParserCls.loadSdfData(data);
            }
            else if(type === 'xyz') {
                await ic.xyzParserCls.loadXyzData(data);
            }
            else if(type === 'mmcif') {
                await ic.mmcifParserCls.loadMmcifData(data);
            }
            else if(type === 'icn3dpng') {
                await me.htmlCls.setHtmlCls.loadPng(data, command, true);
            }
            else if(type === 'pae') {
                me.htmlCls.dialogCls.openDlg('dl_alignerrormap', 'Show Predicted Aligned Error (PAE) map');
                let bFull = true;
                ic.contactMapCls.processAfErrorMap(JSON.parse(data), bFull);
            }

            //append
            if(ic.bSetChainsAdvancedMenu) ic.definedSetsCls.showSets();

            ic.bResetAnno = true;

            if(ic.bAnnoShown) {
                await ic.showAnnoCls.showAnnotations();

                ic.annotationCls.resetAnnoTabAll();
            }
        }

        //Atom "data" from PDB file was parsed to set up parameters for the 3D viewer. The deferred parameter
        //was resolved after the parsing so that other javascript code can be executed.
        async loadPdbData(data, pdbid, bOpm, bAppend, type, bLastQuery, bNoDssp, bEsmfold) { let ic = this.icn3d, me = ic.icn3dui;
            if(!bAppend && (type === undefined || type === 'target')) {
                // if a command contains "load...", the commands should not be cleared with init()
                let bKeepCmd = (ic.bCommandLoad) ? true : false;
                if(!ic.bStatefile) ic.init(bKeepCmd);
            }

            let hAtoms = await ic.loadPDBCls.loadPDB(data, pdbid, bOpm, undefined, undefined, bAppend, type, bEsmfold); // defined in the core library

            if(me.cfg.opmid === undefined) ic.ParserUtilsCls.transformToOpmOri(pdbid);

            if(ic.biomtMatrices !== undefined && ic.biomtMatrices.length > 1) {
              if(!me.bNode) $("#" + ic.pre + "assemblyWrapper").show();

              ic.asuCnt = ic.biomtMatrices.length;
            }

            if(!me.bNode) {
                if(ic.emd !== undefined) {
                    $("#" + ic.pre + "mapWrapper1").hide();
                    $("#" + ic.pre + "mapWrapper2").hide();
                    $("#" + ic.pre + "mapWrapper3").hide();
                }
                else {
                    $("#" + ic.pre + "emmapWrapper1").hide();
                    $("#" + ic.pre + "emmapWrapper2").hide();
                    $("#" + ic.pre + "emmapWrapper3").hide();
                }
            }

            await this.addSecondary(bAppend, bNoDssp);

            return hAtoms;
        }

        async addSecondary(bAppend, bNoDssp) { let ic = this.icn3d, me = ic.icn3dui;
            // calculate secondary structures if not available
            // DSSP only works for structures with all atoms. The Calpha only structures didn't work
            //if(!ic.bSecondaryStructure && !bCalphaOnly) {
            let bCalcSecondary = false;
            if(ic.bSecondaryStructure && Object.keys(ic.structures).length == 1) {
                bCalcSecondary = false;
            }
            else if(!me.cfg.mmtfid && !me.cfg.pdbid && !me.cfg.opmid && !me.cfg.mmdbid && !me.cfg.gi && !me.cfg.uniprotid && !me.cfg.blast_rep_id && !me.cfg.cid && !me.cfg.mmcifid && !me.cfg.align && !me.cfg.chainalign) {
                bCalcSecondary = true;
            }

    //        if(!ic.bSecondaryStructure && Object.keys(ic.proteins).length > 0) {
            if((!ic.bSecondaryStructure || bCalcSecondary) && Object.keys(ic.proteins).length > 0 && !bNoDssp) {    
                await this.applyCommandDssp(bAppend);
            }
            else {
                await this.loadPdbDataRender(bAppend);
                if(!me.bNode) await ic.ParserUtilsCls.checkMemProteinAndRotate();

                /// if(ic.deferredOpm !== undefined) ic.deferredOpm.resolve();
            }
        }

        async applyCommandDssp(bAppend) { let ic = this.icn3d, me = ic.icn3dui;
            // ic.deferredSecondary = $.Deferred(function() {
            //     let bCalphaOnly = me.utilsCls.isCalphaPhosOnly(me.hashUtilsCls.hash2Atoms(ic.proteins, ic.atoms));//, 'CA');
            //     ic.dsspCls.applyDssp(bCalphaOnly, bAppend);
            // }); // end of me.deferred = $.Deferred(function() {

            // return ic.deferredSecondary.promise();

            let bCalphaOnly = me.utilsCls.isCalphaPhosOnly(me.hashUtilsCls.hash2Atoms(ic.proteins, ic.atoms));//, 'CA');
            await ic.dsspCls.applyDssp(bCalphaOnly, bAppend);
        }

        async loadPdbDataRender(bAppend) { let ic = this.icn3d, me = ic.icn3dui;
            //ic.pmid = ic.pmid;

            if(me.cfg.align === undefined && Object.keys(ic.structures).length == 1) {
                $("#" + ic.pre + "alternateWrapper").hide();
            }

            //if(me.cfg.afid && !ic.bAfMem && !me.cfg.blast_rep_id) {
            if( (me.cfg.afid && !ic.bAfMem) || ic.bEsmfold) {
                ic.opts['color'] = 'confidence';
            }

            ic.setStyleCls.setAtomStyleByOptions(ic.opts);
    //        ic.setColorCls.setColorByOptions(ic.opts, ic.atoms);
            ic.setColorCls.setColorByOptions(ic.opts, ic.hAtoms);

            await ic.ParserUtilsCls.renderStructure();

            ic.saveFileCls.showTitle();

            if(me.cfg.rotate !== undefined) ic.resizeCanvasCls.rotStruc(me.cfg.rotate, true);

            if(bAppend && !me.bNode) {
                // show all
                ic.definedSetsCls.setModeAndDisplay('all');
            }

            if(ic.struct_statefile) {
                for(let i = 0, il = ic.struct_statefile.length; i < il; ++i) {
                    await this.execStatefile(ic.struct_statefile[i].structure, ic.struct_statefile[i].statefile);
                }
            }

        //    if(me.deferred !== undefined) me.deferred.resolve(); /// if(ic.deferred2 !== undefined) ic.deferred2.resolve();
        }

        async execStatefile(structure, statefile) {let ic = this.icn3d, me = ic.icn3dui;
            if(!statefile) return;

            let commandArray = statefile.trim().split('\n');
            commandArray = ['select $' + structure].concat(commandArray);
            ic.STATENUMBER = commandArray.length;
            ic.CURRENTNUMBER = 0;
            let bStrict = true;

            let hAtoms = me.hashUtilsCls.cloneHash(ic.hAtoms);
            let commands = ic.commands;

            // reset ic.hAtoms
            ic.hAtoms = {};
            ic.commands = commandArray;
            
            await ic.loadScriptCls.execCommands(ic.CURRENTNUMBER, ic.STATENUMBER-1, ic.STATENUMBER, bStrict);

            // revert back to the original set
            ic.hAtoms = me.hashUtilsCls.cloneHash(hAtoms);
            ic.commands = commands.concat(ic.commands);
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class SdfParser {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Ajax call was used to get the atom data from the PubChem "cid". This function was
        //deferred so that it can be chained together with other deferred functions for sequential execution.
        async downloadCid(cid) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            ic.ParserUtilsCls.setYourNote('PubChem CID ' + cid + ' in iCn3D');

            ic.bCid = true;

            // get parent CID
            let urlParent = "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" + ic.inputid + "/cids/JSONP?cids_type=parent";
            let dataParent = await me.getAjaxPromise(urlParent, 'jsonp', true, "Can not retrieve the parent CID...");

            let cidParent = dataParent.IdentifierList.CID[0];

            let url = "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" + cidParent + "/record/SDF/?record_type=3d&response_type=display";
            let data = await me.getAjaxPromise(url, 'text', true, "This CID may not have 3D structure...");

            let bResult = thisClass.loadSdfAtomData(data, cid);

            if(me.cfg.align === undefined && Object.keys(ic.structures).length == 1) {
                $("#" + ic.pre + "alternateWrapper").hide();
            }

            if(!bResult) {
                alert('The SDF of CID ' + cid + ' has the wrong format...');
            }
            else {
                ic.setStyleCls.setAtomStyleByOptions(ic.opts);
                ic.setColorCls.setColorByOptions(ic.opts, ic.atoms);

                await ic.ParserUtilsCls.renderStructure();

                if(me.cfg.rotate !== undefined) ic.resizeCanvasCls.rotStruc(me.cfg.rotate, true);
            }
        }

        async downloadSmiles(smiles) { let ic = this.icn3d, me = ic.icn3dui;
            let urlSmiles = me.htmlCls.baseUrl + "openbabel/openbabel.cgi?smiles2sdf=" + smiles;
            let sdfStr = await me.getAjaxPromise(urlSmiles, 'text');

            ic.init();
            //ic.bInputfile = true;
            ic.InputfileData = (ic.InputfileData) ? ic.InputfileData + '\nENDMDL\n' + sdfStr : sdfStr;
            ic.InputfileType = 'sdf';
            await ic.sdfParserCls.loadSdfData(sdfStr);
        }

        async loadSdfData(data) { let ic = this.icn3d, me = ic.icn3dui;
            let bResult = this.loadSdfAtomData(data);

            if(me.cfg.align === undefined && Object.keys(ic.structures).length == 1) {
                $("#" + ic.pre + "alternateWrapper").hide();
            }

            if(!bResult) {
              alert('The SDF file has the wrong format...');
            }
            else {
              ic.setStyleCls.setAtomStyleByOptions(ic.opts);
              ic.setColorCls.setColorByOptions(ic.opts, ic.atoms);

              await ic.ParserUtilsCls.renderStructure();

              if(me.cfg.rotate !== undefined) ic.resizeCanvasCls.rotStruc(me.cfg.rotate, true);

              //if(ic.deferred !== undefined) ic.deferred.resolve(); /// if(ic.deferred2 !== undefined) ic.deferred2.resolve();
            }
        }

        //Atom "data" from SDF file was parsed to set up parameters for the 3D viewer.
        //The deferred parameter was resolved after the parsing so that other javascript code can be executed.
        loadSdfAtomData(data, cid) { let ic = this.icn3d; ic.icn3dui;
            let lines = data.split(/\r?\n|\r/);
            if(lines.length < 4) return false;

            ic.init();

            let structure = cid ? cid : 1;
            let chain = 'A';
            let resi = 1;
            let resn = 'LIG';

            let moleculeNum = structure;
            let chainNum = structure + '_' + chain;
            let residueNum = chainNum + '_' + resi;

            let atomCount = parseInt(lines[3].substr(0, 3));
            if(isNaN(atomCount) || atomCount <= 0) return false;

            let bondCount = parseInt(lines[3].substr(3, 3));
            let offset = 4;
            if(lines.length < offset + atomCount + bondCount) return false;

            let start = 0;
            let end = atomCount;
            let i, line;

            let atomid2serial = {};
            let HAtomids = {};

            let AtomHash = {};
            let serial = 1;
            for(i = start; i < end; i++) {
                line = lines[offset];
                offset++;

                //var name = line.substr(31, 3).replace(/ /g, "");
                let name = line.substr(31, 3).trim();

                //if(name !== 'H') {
                    let x = parseFloat(line.substr(0, 10));
                    let y = parseFloat(line.substr(10, 10));
                    let z = parseFloat(line.substr(20, 10));
                    let coord = new THREE.Vector3(x, y, z);

                    let atomDetails = {
                        het: true,              // optional, used to determine chemicals, water, ions, etc
                        serial: serial,         // required, unique atom id
                        name: name,             // required, atom name
                        resn: resn,             // optional, used to determine protein or nucleotide
                        structure: structure,   // optional, used to identify structure
                        chain: chain,           // optional, used to identify chain
                        resi: resi,             // optional, used to identify residue ID
                        coord: coord,           // required, used to draw 3D shape
                        b: 0,                   // optional, used to draw B-factor tube
                        elem: name,             // optional, used to determine hydrogen bond
                        bonds: [],              // required, used to connect atoms
                        ss: 'coil',             // optional, used to show secondary structures
                        ssbegin: false,         // optional, used to show the beginning of secondary structures
                        ssend: false,           // optional, used to show the end of secondary structures

                        bondOrder: []           // optional, specific for chemicals
                    };

                    ic.atoms[serial] = atomDetails;
                    AtomHash[serial] = 1;

                    atomid2serial[i] = serial;

                    ++serial;
                //}
                //else {
                    if(name == 'H') HAtomids[i] = 1;
                //}
            }

            ic.dAtoms = AtomHash;
            ic.hAtoms= AtomHash;
            ic.structures[moleculeNum] = [chainNum]; //AtomHash;
            ic.chains[chainNum] = AtomHash;
            ic.residues[residueNum] = AtomHash;

            ic.residueId2Name[residueNum] = resn;

            if(ic.chainsSeq[chainNum] === undefined) ic.chainsSeq[chainNum] = [];

            let resObject = {};
            resObject.resi = resi;
            resObject.name = resn;

            ic.chainsSeq[chainNum].push(resObject);

            for(i = 0; i < bondCount; i++) {
                line = lines[offset];
                offset++;
                let fromAtomid = parseInt(line.substr(0, 3)) - 1 + start;
                let toAtomid = parseInt(line.substr(3, 3)) - 1 + start;
                //var order = parseInt(line.substr(6, 3));
                let order = line.substr(6, 3).trim();

                //if(!HAtomids.hasOwnProperty(fromAtomid) && !HAtomids.hasOwnProperty(toAtomid)) {
                    let from = atomid2serial[fromAtomid];
                    let to = atomid2serial[toAtomid];

                    ic.atoms[from].bonds.push(to);
                    ic.atoms[from].bondOrder.push(order);
                    ic.atoms[to].bonds.push(from);
                    ic.atoms[to].bondOrder.push(order);

                    if(!HAtomids.hasOwnProperty(fromAtomid) && !HAtomids.hasOwnProperty(toAtomid)) {
                        if(order == '2') {
                            ic.doublebonds[from + '_' + to] = 1;
                            ic.doublebonds[to + '_' + from] = 1;
                        }
                        else if(order == '3') {
                            ic.triplebonds[from + '_' + to] = 1;
                            ic.triplebonds[to + '_' + from] = 1;
                        }
                    }
            }

            // read partial charge
            let bCrg = false;
            for(let il = lines.length; offset < il; ++offset) {
                if(lines[offset].indexOf('PARTIAL_CHARGES') != -1) {
                    bCrg = true;
                    break;
                }
                else {
                    continue;
                }
            }

            if(bCrg) {
                ++offset;
                let crgCnt = parseInt(lines[offset]);

                ++offset;
                for(i = 0; i < crgCnt; ++i, ++offset) {
                    line = lines[offset];
                    let serial_charge = line.split(' ');
                    let sTmp = parseInt(serial_charge[0]);
                    let crg = parseFloat(serial_charge[1]);
                    ic.atoms[sTmp].crg = crg;
                }
            }

            // backup bonds
            for(i in ic.atoms) {
                if(ic.atoms[i].name !== 'H') { // only need to deal with non-hydrogen atoms
                    ic.atoms[i].bonds2 = ic.atoms[i].bonds.concat();
                    ic.atoms[i].bondOrder2 = ic.atoms[i].bondOrder.concat();
                }
            }

            ic.ParserUtilsCls.setMaxD();

            ic.saveFileCls.showTitle();

            return true;
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class XyzParser {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        async loadXyzData(data) { let ic = this.icn3d, me = ic.icn3dui;
            let bResult = this.loadXyzAtomData(data);

            if(me.cfg.align === undefined && Object.keys(ic.structures).length == 1) {
                $("#" + ic.pre + "alternateWrapper").hide();
            }

            if(!bResult) {
              alert('The XYZ file has the wrong format...');
            }
            else {
              ic.setStyleCls.setAtomStyleByOptions(ic.opts);
              ic.setColorCls.setColorByOptions(ic.opts, ic.atoms);

              await ic.ParserUtilsCls.renderStructure();

              if(me.cfg.rotate !== undefined) ic.resizeCanvasCls.rotStruc(me.cfg.rotate, true);

              //if(me.deferred !== undefined) me.deferred.resolve(); /// if(ic.deferred2 !== undefined) ic.deferred2.resolve();
            }
        }

        setXyzAtomSeq(AtomHash, moleculeNum, chainNum, residueNum) { let ic = this.icn3d, me = ic.icn3dui;
            ic.dAtoms = me.hashUtilsCls.unionHash(ic.dAtoms, AtomHash);
            ic.hAtoms= me.hashUtilsCls.unionHash(ic.hAtoms, AtomHash);

            ic.structures[moleculeNum] = [chainNum]; //AtomHash;
            ic.chains[chainNum] = AtomHash;
            ic.residues[residueNum] = AtomHash;

            ic.residueId2Name[residueNum] = 'LIG';

            if(ic.chainsSeq[chainNum] === undefined) ic.chainsSeq[chainNum] = [];

            let resObject = {};
            resObject.resi = 1;
            resObject.name = 'LIG';

            ic.chainsSeq[chainNum].push(resObject);

            // determine bonds
            let serialArray = Object.keys(AtomHash);
            for(let j = 0, jl = serialArray.length; j < jl; ++j) {
                let atom0 = ic.atoms[serialArray[j]];

                for(let k = j + 1, kl = serialArray.length; k < kl; ++k) {
                    let atom1 = ic.atoms[serialArray[k]];
                    let maxR = 1.2 *(me.parasCls.covalentRadii[atom0.elem.toUpperCase()] + me.parasCls.covalentRadii[atom1.elem.toUpperCase()]);
                    if(Math.abs(atom0.coord.x - atom1.coord.x) > maxR) continue;
                    if(Math.abs(atom0.coord.y - atom1.coord.y) > maxR) continue;
                    if(Math.abs(atom0.coord.z - atom1.coord.z) > maxR) continue;

                    if(me.utilsCls.hasCovalentBond(atom0, atom1)) {
                        ic.atoms[serialArray[j]].bonds.push(serialArray[k]);
                        ic.atoms[serialArray[k]].bonds.push(serialArray[j]);
                    }
                }
            }
        }

        loadXyzAtomData(data) { let ic = this.icn3d; ic.icn3dui;
            let lines = data.split(/\r?\n|\r/);
            if(lines.length < 3) return false;

            ic.init();

            let chain = 'A';
            let resn = 'LIG';
            let resi = 1;

            let AtomHash = {};
            let moleculeNum = 0, chainNum, residueNum;
            let structure, serial=1, offset = 2;

            ic.molTitle = "";

            for(let i = 0, il = lines.length; i < il; ++i) {
                let line = lines[i].trim();
                if(line === '') continue;

                if(line !== '' && !isNaN(line)) { // start a new molecule
                    if(i !== 0) {
                        this.setXyzAtomSeq(AtomHash, moleculeNum, chainNum, residueNum);
                    }

                    ++moleculeNum;
                    AtomHash = {};

                    structure = moleculeNum;
                    chainNum = structure + '_' + chain;
                    residueNum = chainNum + '_' + resi;
                    if(moleculeNum > 1) {
                        ic.molTitle += "; ";
                    }
                    ic.molTitle += lines[i+1].trim();

                    i = i + offset;
                }

                line = lines[i].trim();
                if(line === '') continue;

                let name_x_y_z = line.replace(/,/, " ").replace(/\s+/g, " ").split(" ");

                let name = name_x_y_z[0];
                let x = parseFloat(name_x_y_z[1]);
                let y = parseFloat(name_x_y_z[2]);
                let z = parseFloat(name_x_y_z[3]);
                let coord = new THREE.Vector3(x, y, z);

                let atomDetails = {
                    het: true,              // optional, used to determine chemicals, water, ions, etc
                    serial: serial,         // required, unique atom id
                    name: name,             // required, atom name
                    resn: resn,             // optional, used to determine protein or nucleotide
                    structure: structure,   // optional, used to identify structure
                    chain: chain,           // optional, used to identify chain
                    resi: resi,             // optional, used to identify residue ID
                    coord: coord,           // required, used to draw 3D shape
                    b: 0,                   // optional, used to draw B-factor tube
                    elem: name,             // optional, used to determine hydrogen bond
                    bonds: [],              // required, used to connect atoms
                    ss: 'coil',             // optional, used to show secondary structures
                    ssbegin: false,         // optional, used to show the beginning of secondary structures
                    ssend: false,           // optional, used to show the end of secondary structures

                    bondOrder: []           // optional, specific for chemicals
                };

                ic.atoms[serial] = atomDetails;
                AtomHash[serial] = 1;

                ++serial;
            }

            this.setXyzAtomSeq(AtomHash, moleculeNum, chainNum, residueNum);

            ic.ParserUtilsCls.setMaxD();

            ic.saveFileCls.showTitle();

            return true;
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class MsaParser {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        async loadMsaData(data, type) { let ic = this.icn3d, me = ic.icn3dui;
            let bResult = await this.loadMsaSeqData(data, type);

            if(me.cfg.align === undefined && Object.keys(ic.structures).length == 1) {
                $("#" + ic.pre + "alternateWrapper").hide();
            }

            let typeStr = type.toUpperCase();

            if(!bResult) {
              alert('The ' + typeStr + ' file has the wrong format...');
            }
            else {
                // retrieve the structures
                me.cfg.bu = 0; // show all chains
                await ic.chainalignParserCls.downloadMmdbAf(ic.struArray.join(','));
                me.htmlCls.clickMenuCls.setLogCmd('load mmdbaf0 ' + ic.struArray.join(','), true);

                // get the position of the first MSA residue in the full sequence
                let startPosArray = []; 
                for(let i = 0, il = ic.inputChainidArray.length; i < il; ++i) {
                    let chainid = ic.inputChainidArray[i];
                    let inputSeqNoGap = ic.inputSeqArray[i].replace(/-/g, '');

                    // get the full seq
                    let fullSeq = '';
                    for(let j = 0, jl = ic.chainsSeq[chainid].length; j < jl; ++j) {
                        fullSeq += ic.chainsSeq[chainid][j].name;
                    }

                    // find the starting position of "inputSeq" in "fullSeq" 
                    let pos = fullSeq.toUpperCase().indexOf(inputSeqNoGap.substr(0, 20).toUpperCase());
                    if(pos == -1) {
                        console.log("The sequence of the aligned chain " + chainid + " (" + inputSeqNoGap.toUpperCase() + ") is different from the sequence from the structure (" + fullSeq.toUpperCase() + "), and is thus not aligned correctly...");
                        pos = 0;
                    }
                    startPosArray.push(pos);
                }

                // define residue mapping
                // The format is ": "-separated pairs: "1,5,10-50 | 1,5,10-50: 2,6,11-51 | 1,5,10-50"
                let predefinedres = '';

                let chainid1 = ic.inputChainidArray[0], inputSeq1 = ic.inputSeqArray[0], pos1 = startPosArray[0];
                // loop through 2nd and forward
                for(let i = 1, il = ic.inputChainidArray.length; i < il; ++i) {
                    let chainid2 = ic.inputChainidArray[i];
                    let inputSeq2 = ic.inputSeqArray[i];
                    let pos2 = startPosArray[i];

                    let index1 = pos1, index2 = pos2;
                    let resiArray1 = [], resiArray2 = [];
                    for(let j = 0, jl = inputSeq2.length; j < jl; ++j) {
                        if(inputSeq1[j] != '-' && inputSeq2[j] != '-' && ic.chainsSeq[chainid1][index1] && ic.chainsSeq[chainid2][index2]) {
                            let resi1 = ic.chainsSeq[chainid1][index1].resi;
                            let resi2 = ic.chainsSeq[chainid2][index2].resi;
                            if(ic.residues[chainid1 + '_' + resi1] && ic.residues[chainid2 + '_' + resi2]) {
                                resiArray1.push(ic.chainsSeq[chainid1][index1].resi);
                                resiArray2.push(ic.chainsSeq[chainid2][index2].resi);
                            }
                        }
                        
                        if(inputSeq1[j] != '-') ++index1;
                        if(inputSeq2[j] != '-') ++index2;
                    }
                    let resiRangeStr1 = ic.resid2specCls.resi2range(resiArray1, true);
                    let resiRangeStr2 = ic.resid2specCls.resi2range(resiArray2, true);

                    predefinedres += resiRangeStr1 + ' | ' + resiRangeStr2;
                    if(i < il -1) predefinedres += ': ';
                }

                // realign based on residue by residue
                let alignment_final = ic.inputChainidArray.join(',');

                if(predefinedres && (alignment_final.split(',').length - 1) != predefinedres.split(': ').length) {
                    alert("Please make sure the number of chains and the lines of predefined residues are the same...");
                    return;
                }

                me.cfg.resdef = predefinedres.replace(/:/gi, ';');

                let bRealign = true, bPredefined = true;
                let chainidArray = alignment_final.split(',');
                await ic.realignParserCls.realignChainOnSeqAlign(undefined, chainidArray, bRealign, bPredefined);
     
                me.htmlCls.clickMenuCls.setLogCmd("realign predefined " + alignment_final + " " + predefinedres, true);


                ic.opts['color'] = 'identity';
                ic.setColorCls.setColorByOptions(ic.opts, ic.hAtoms);
                me.htmlCls.clickMenuCls.setLogCmd("color identity", true);

                // show selection
                ic.selectionCls.showSelection();
                me.htmlCls.clickMenuCls.setLogCmd("show selection", true);
            }
        }

        async loadMsaSeqData(data, type) { let ic = this.icn3d; ic.icn3dui;
            let lines = data.split(/\r?\n|\r/);
            if(lines.length < 2) return false;

            ic.init();

            ic.molTitle = "";

            let seqHash = {};

            let bStart = false, bSecBlock = false, chainid = '', seq = '', bFound = false;

            if(type == 'clustalw' && lines[0].substr(0,7) != 'CLUSTAL') { // CLUSTAL W or CLUSTALW
                return false;
            }

            let startLineNum = (type == 'clustalw') ? 1 : 0;

            // 1. parse input msa
            for(let i = startLineNum, il = lines.length; i < il; ++i) {
                let line = lines[i].trim();
                if(line === '') {
                    if(bStart) bSecBlock = true;
                    bStart = false;
                    continue;
                }

                if(!bStart) { // first line
                    if(type == 'fasta' && line.substr(0,1) != '>') {
                        return false;
                    }
                    bStart = true;
                }

                if(type == 'clustalw') {
                    if(line.substr(0, 1) != ' ' && line.substr(0, 1) != '\t') {
                        let chainid_seq = line.split(/\s+/);
                        let idArray = chainid_seq[0].split('|');
                        let result = this.getChainid(idArray, bStart && !bSecBlock);
                        bFound = result.bFound;
                        chainid = result.chainid;

                        if(bFound) {
                            if(!seqHash.hasOwnProperty(chainid)) {
                                seqHash[chainid] = chainid_seq[1];
                            }
                            else {
                                seqHash[chainid] += chainid_seq[1];
                            }
                        }
                    }
                }
                else if(type == 'fasta') {
                    if(line.substr(0,1) == ">") {
                        // add the previous seq
                        if(chainid && seq && bFound) seqHash[chainid] = seq;
                        chainid = '';
                        seq = '';

                        let pos = line.indexOf(' ');
                        let idArray = line.substr(1, pos).split('|');
                        
                        if(idArray.length == 1) {
                            chainid = idArray[0];
                        }
                        else {
                            let result = this.getChainid(idArray, true);
                            bFound = result.bFound;
                            chainid = result.chainid;
                        }
                    }
                    else {
                        seq += line;
                    }
                }
            }

            // add the last seq
            if(type == 'fasta' && chainid && seq && bFound) seqHash[chainid] = seq;

            // 2. get the PDB ID or RefSeqID or AlphaFold ID
            ic.inputChainidArray = [];
            ic.inputSeqArray = [];
            ic.struArray = [];

            // find the tempate where the first residue is not gap
            let template = '';
            for(let chainid in seqHash) {
                let seq = seqHash[chainid];
                if(seq.substr(0,1) != '-') {
                    template = chainid;
                    await this.processOneChain(chainid, seqHash);
                    break;
                }
            }
            if(!template) template = Object.keys(seqHash)[0];

            for(let chainid in seqHash) {
                if(chainid != template) await this.processOneChain(chainid, seqHash);
            }

            return true;
        }

        async processOneChain(chainid, seqHash) { let ic = this.icn3d, me = ic.icn3dui;
            ic.inputSeqArray.push(seqHash[chainid]);
            // ic.inputSeqArray.push(seqHash[chainid].replace(/-/g, '')); // remove the gaps in seq

            if(chainid.lastIndexOf('_') == 2) { // refseq ID
                // convert refseq to uniprot id
                let url = me.htmlCls.baseUrl + "vastdyn/vastdyn.cgi?refseq2uniprot=" + chainid;
        
                let data = await me.getAjaxPromise(url, 'jsonp', false, 'The protein accession ' + chainid + ' can not be mapped to AlphaFold UniProt ID...');
                if(data && data.uniprot) {
                    if(!ic.uniprot2acc) ic.uniprot2acc = {};
                    let uniprot = data.uniprot;
                    ic.uniprot2acc[uniprot] = chainid;
                    ic.struArray.push(uniprot);
                    ic.inputChainidArray.push(uniprot + '_A');
                }
                else {
                    console.log('The accession ' + refseqid + ' can not be mapped to AlphaFold UniProt ID. It will be treated as a UniProt ID instead.');
                    ic.struArray.push(chainid);
                    ic.inputChainidArray.push(chainid + '_A');
                }
            }
            else if(chainid.indexOf('_') != -1) { // PDB ID
                let stru = chainid.substr(0, chainid.indexOf('_')).substr(0, 4);
                ic.struArray.push(stru);
                ic.inputChainidArray.push(chainid);
            }
            else if(chainid.length > 5) { // UniProt ID
                ic.struArray.push(chainid);
                ic.inputChainidArray.push(chainid + '_A');
            }
        }

        getChainid(idArray, bWarning) { let ic = this.icn3d; ic.icn3dui;
            let bFound = false;
            let chainid = idArray[0];

            for(let j = 0, jl = idArray.length; j < jl; ++j) {
                if(idArray[j] == 'pdb') {
                    chainid = idArray[j+1] + '_' + idArray[j+2];
                    bFound = true;
                    break;
                }
                else if(idArray[j] == 'ref') { // refseq
                    let refseq = idArray[j+1].split('.')[0];
                    chainid = refseq; // + '_A';
                    bFound = true;
                    break;
                }
                else if(idArray[j] == 'sp' || idArray[j] == 'tr') { // uniprot
                    let uniprot = idArray[j+1];
                    chainid = uniprot;
                    bFound = true;
                    break;
                }
            }

            if(!bFound && bWarning) {
                alert("The sequence ID " + idArray.join('|') + " does not have the correctly formatted PDB, UniProt or RefSeq ID...");
            }

            return {chainid: chainid, bFound: bFound};
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class RealignParser {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        // realign, residue by residue
        realign() { let ic = this.icn3d, me = ic.icn3dui;
            ic.selectionCls.saveSelectionPrep();

            let index = Object.keys(ic.defNames2Atoms).length + Object.keys(ic.defNames2Residues).length + 1;
            let name = 'alseq_' + index;

            ic.selectionCls.saveSelection(name, name);

            me.htmlCls.clickMenuCls.setLogCmd("realign", true);

            let structHash = {}, struct2chain = {};
            ic.realignResid = {};
            let lastStruResi = '';
            for(let serial in ic.hAtoms) {
                let atom = ic.atoms[serial];
                let chainid = atom.structure + '_' + atom.chain;
                if((ic.proteins.hasOwnProperty(serial) && atom.name == "CA")
                  ||(ic.nucleotides.hasOwnProperty(serial) &&(atom.name == "O3'" || atom.name == "O3*")) ) {
                    if(atom.structure + '_' + atom.resi == lastStruResi) continue; // e.g., Alt A and B

                    if(!structHash.hasOwnProperty(atom.structure)) {
                        structHash[atom.structure] = [];
                    }
                    structHash[atom.structure].push(atom.coord.clone());

                    if(!ic.realignResid.hasOwnProperty(chainid)) {
                        ic.realignResid[chainid] = [];
                    }

                    ic.realignResid[chainid].push({'resid': chainid + '_' + atom.resi, 'resn': me.utilsCls.residueName2Abbr(atom.resn.substr(0, 3)).substr(0, 1)});

                    struct2chain[atom.structure] = atom.structure + '_' + atom.chain;

                    lastStruResi = atom.structure + '_' + atom.resi;
                }
            }

            let structArray = Object.keys(structHash);

            let toStruct = structArray[0];

            let chainidArray = [];
            ic.qt_start_end = []; // reset the alignment

            chainidArray.push(struct2chain[toStruct]);
            for(let i = 1, il = structArray.length; i < il; ++i) {
                let fromStruct = structArray[i];

                // transform from the second structure to the first structure
                let coordsFrom = structHash[fromStruct];
                let coordsTo = structHash[toStruct];

                let bKeepSeq = true;
                //ic.ParserUtilsCls.alignCoords(coordsFrom, coordsTo, fromStruct, bKeepSeq);
                ic.ParserUtilsCls.alignCoords(coordsFrom, coordsTo, fromStruct, bKeepSeq, struct2chain[toStruct], struct2chain[fromStruct]);
                chainidArray.push(struct2chain[fromStruct]);
            }

            // align seq
            //ic.hAtoms = ic.chainalignParserCls.setMsa(chainidArray, undefined, true);
            ic.hAtoms = ic.chainalignParserCls.setMsa(chainidArray);

            name = 'protein_aligned';
            ic.selectionCls.saveSelection(name, name);
          
            ic.transformCls.zoominSelection();

            ic.hlUpdateCls.updateHlAll();
        }

        async parseChainRealignPredefined(chainidArray, struct2SeqHash, struct2CoorHash, struct2resid) { let ic = this.icn3d, me = ic.icn3dui;

          let toStruct = chainidArray[0].substr(0, chainidArray[0].indexOf('_')); //.toUpperCase();

          let hAtoms = {}, rmsd;

          ic.realignResid = {};

          ic.opts['color'] = 'grey';
          ic.setColorCls.setColorByOptions(ic.opts, ic.dAtoms);
          
          // reinitialize
          ic.qt_start_end = [];

          let chainidHash = {};
          for(let index = 0, indexl = chainidArray.length - 1; index < indexl; ++index) {         
              let fromStruct = chainidArray[index + 1].substr(0, chainidArray[index + 1].indexOf('_')); //.toUpperCase();

              //if(toStruct == fromStruct) fromStruct += me.htmlCls.postfix;

              let chainTo = toStruct + chainidArray[0].substr(chainidArray[0].indexOf('_'));
              let chainFrom = fromStruct + chainidArray[index + 1].substr(chainidArray[index + 1].indexOf('_'));
              chainidHash[chainTo] = 1;
              chainidHash[chainFrom] = 1;

              chainidArray[0] = chainTo;
              chainidArray[index + 1] = chainFrom;

              let chainpair =  chainTo + ',' + chainFrom;

              if(!struct2SeqHash[chainpair]) continue;

              let seq1 = struct2SeqHash[chainpair][toStruct];
              let seq2 = struct2SeqHash[chainpair][fromStruct];

              let coord1 = struct2CoorHash[chainpair][toStruct];
              let coord2 = struct2CoorHash[chainpair][fromStruct];

              let residArray1 = struct2resid[chainpair][toStruct];
              let residArray2 = struct2resid[chainpair][fromStruct];

              ic.realignResid[chainTo] = [];
              ic.realignResid[chainFrom] = [];

              for(let i = 0, il = seq1.length; i < il; ++i) {
                  ic.realignResid[chainTo].push({'resid':residArray1[i], 'resn':seq1[i]});
                  ic.realignResid[chainFrom].push({'resid':residArray2[i], 'resn':seq2[i]});
              }

              let bChainAlign = true;
              // set ic.qt_start_end in alignCoords()

              let result = ic.ParserUtilsCls.alignCoords(coord2, coord1, fromStruct, undefined, chainTo, chainFrom, index + 1, bChainAlign);

              hAtoms = me.hashUtilsCls.unionHash(hAtoms, result.hAtoms);
              rmsd = parseFloat(result.rmsd);
          }

          // If rmsd from vastsrv is too large, realign the chains
          //if(me.cfg.chainalign && !me.cfg.usepdbnum && me.cfg.resdef && rmsd > 5) {  
          // redo algnment only for VAST serv page 
          if(!me.cfg.usepdbnum && me.cfg.resdef && rmsd > 5 && me.cfg.chainalign) {    
            console.log("RMSD from VAST is larger than 5. Realign the chains with TM-align."); 
            //let nameArray = me.cfg.chainalign.split(',');
            let nameArray = Object.keys(chainidHash);
            if(nameArray.length > 0) {
                ic.hAtoms = ic.definedSetsCls.getAtomsFromNameArray(nameArray);
            }

            me.cfg.aligntool = 'tmalign';
            await ic.realignParserCls.realignOnStructAlign();
            // if(nameArray.length > 0) {
            //     me.htmlCls.clickMenuCls.setLogCmd("realign on tmalign | " + nameArray, true);
            // }
            // else {
            //     me.htmlCls.clickMenuCls.setLogCmd("realign on tmalign", true);
            // }
          }
          else {
            // align seq
            //ic.hAtoms = ic.chainalignParserCls.setMsa(chainidArray, undefined, true);
            ic.hAtoms = ic.chainalignParserCls.setMsa(chainidArray);

            ic.transformCls.zoominSelection();

            await ic.chainalignParserCls.downloadChainalignmentPart3(undefined, chainidArray, ic.hAtoms);
          }
        }

        async parseChainRealignData(dataArray, chainresiCalphaHash2, chainidArray, struct2SeqHash, struct2CoorHash, struct2resid, bRealign) { let ic = this.icn3d, me = ic.icn3dui;
          //var dataArray =(chainidArray.length == 2) ? [ajaxData] : ajaxData;

          let toStruct = chainidArray[0].substr(0, chainidArray[0].indexOf('_')); //.toUpperCase();
          if(!bRealign) toStruct = toStruct.toUpperCase();


          let hAtoms = {};

          ic.realignResid = {};

          ic.opts['color'] = 'grey';
          ic.setColorCls.setColorByOptions(ic.opts, ic.dAtoms);

          // reinitialize
          ic.qt_start_end = [];

          // Each argument is an array with the following structure: [ data, statusText, jqXHR ]
          //var data2 = v2[0];
          for(let index = 0, indexl = dataArray.length; index < indexl; ++index) {
        //  for(let index = 1, indexl = dataArray.length; index < indexl; ++index) {
            //   let data = (me.bNode) ? dataArray[index] : dataArray[index].value;//[0];
              let data = dataArray[index].value;//[0];
              if(!data) continue;

              let fromStruct = chainidArray[index + 1].substr(0, chainidArray[index + 1].indexOf('_')); //.toUpperCase();
              if(!bRealign) fromStruct = fromStruct.toUpperCase();

              //if(toStruct == fromStruct) fromStruct += me.htmlCls.postfix;

              let chainTo = toStruct + chainidArray[0].substr(chainidArray[0].indexOf('_'));
              let chainFrom = fromStruct + chainidArray[index + 1].substr(chainidArray[index + 1].indexOf('_'));

              chainidArray[0] = chainTo;
              chainidArray[index + 1] = chainFrom;

              let seq1 = struct2SeqHash[chainTo];
              let seq2 = struct2SeqHash[chainFrom];

              let coord1 = struct2CoorHash[chainTo];
              let coord2 = struct2CoorHash[chainFrom];

              let residArray1 = struct2resid[chainTo];
              let residArray2 = struct2resid[chainFrom];

              let query, target;

              if(data.data !== undefined) {
                  query = data.data[0].query;
                  let targetName = Object.keys(data.data[0].targets)[0];
                  target = data.data[0].targets[targetName];

                  target = target.hsps[0];
              }

              if(query !== undefined && target !== undefined) {
                  // transform from the second structure to the first structure
                  let coordsTo = [];
                  let coordsFrom = [];

                  let seqto = '', seqfrom = '';

                  ic.realignResid[chainTo] = [];
                  ic.realignResid[chainFrom] = [];

                  let segArray = target.segs;
                  for(let i = 0, il = segArray.length; i < il; ++i) {
                      let seg = segArray[i];
                      let prevChain1 = '', prevChain2 = '';
                      for(let j = 0; j <= seg.orito - seg.orifrom; ++j) {
                          let chainid1 = residArray1[j + seg.orifrom].substr(0, residArray1[j + seg.orifrom].lastIndexOf('_'));
                          let chainid2 = residArray2[j + seg.from].substr(0, residArray2[j + seg.from].lastIndexOf('_'));

                          if(!coord1[j + seg.orifrom] || !coord2[j + seg.from]) continue;

                          coordsTo.push(coord1[j + seg.orifrom]);
                          coordsFrom.push(coord2[j + seg.from]);

                          seqto += seq1[j + seg.orifrom];
                          seqfrom += seq2[j + seg.from];

                          // one chaincould be longer than the other
                          if(j == 0 ||(prevChain1 == chainid1 && prevChain2 == chainid2) ||(prevChain1 != chainid1 && prevChain2 != chainid2)) {
                              ic.realignResid[chainTo].push({'resid':residArray1[j + seg.orifrom], 'resn':seq1[j + seg.orifrom]});
                              ic.realignResid[chainFrom].push({'resid':residArray2[j + seg.from], 'resn':seq2[j + seg.from]});
                          }

                          prevChain1 = chainid1;
                          prevChain2 = chainid2;
                      }
                  }

                  //let chainTo = chainidArray[0];
                  //let chainFrom = chainidArray[index + 1];

                  let bChainAlign = true, result;

                  if(ic.bAfMem) { // align to the query (membrane)
                    result = ic.ParserUtilsCls.alignCoords(coordsFrom, coordsTo, toStruct, undefined, chainTo, chainFrom, index + 1, bChainAlign);
                  }
                  else {
                    result = ic.ParserUtilsCls.alignCoords(coordsFrom, coordsTo, fromStruct, undefined, chainTo, chainFrom, index + 1, bChainAlign);
                  }
                  
                  hAtoms = me.hashUtilsCls.unionHash(hAtoms, result.hAtoms);

        //          ic.opts['color'] = 'identity';
        //          ic.setColorCls.setColorByOptions(ic.opts, ic.hAtoms);

                  //ic.hlUpdateCls.updateHlAll();
              }
              else {
                  if(fromStruct === undefined && !me.cfg.command) {
                    if(ic.bRender) alert('Please do not align residues in the same structure');
                  }
                  else if(seq1 && seq2) {
                    if((seq1.length < 6 || seq2.length < 6) && !me.cfg.command) {
                        if(ic.bRender) alert('These sequences are too short for alignment');
                    }
                    else if(seq1.length >= 6 && seq2.length >= 6 && !me.cfg.command) {
                        if(ic.bRender) alert('These sequences can not be aligned to each other');
                    }
                  }
              }

              // update all residue color

              ///// if(ic.deferredRealign !== undefined) ic.deferredRealign.resolve();
          }

          if(bRealign) {
            // align seq
            //ic.hAtoms = ic.chainalignParserCls.setMsa(chainidArray, undefined, bRealign);
            ic.hAtoms = ic.chainalignParserCls.setMsa(chainidArray);
            let name = 'protein_aligned';
            ic.selectionCls.saveSelection(name, name);

            if(ic.bAfMem) {
                ic.selectionCls.selectAll_base();

                ic.opts['chemicals'] = 'stick';  
                ic.opts['color'] = 'confidence'; //'structure';

                ic.setColorCls.setColorByOptions(ic.opts, ic.atoms);
            }
            else {
                ic.transformCls.zoominSelection();

                ic.dAtoms = me.hashUtilsCls.cloneHash(ic.hAtoms); //hAtoms;
        
                ic.opts['color'] = 'identity';

                ic.setColorCls.setColorByOptions(ic.opts, ic.hAtoms);
            }

            ic.drawCls.draw();
            ic.hlUpdateCls.updateHlAll();

            if(ic.bAfMem) {
                let axis = new THREE.Vector3(1,0,0);
                let angle = -90 / 180.0 * Math.PI;

                ic.transformCls.setRotation(axis, angle);
            }
                   
            /// if(ic.deferredMmdbaf !== undefined) ic.deferredMmdbaf.resolve();
            /// if(ic.deferredRealign !== undefined) ic.deferredRealign.resolve();
          }
          else {
            // align seq
            ic.hAtoms = ic.chainalignParserCls.setMsa(chainidArray);
            
            ic.transformCls.zoominSelection();

            await ic.chainalignParserCls.downloadChainalignmentPart3(chainresiCalphaHash2, chainidArray, ic.hAtoms);
          }
        }

        async realignOnSeqAlign(pdbidTemplate) { let ic = this.icn3d; ic.icn3dui;
            let chainidHash = ic.firstAtomObjCls.getChainsFromAtoms(ic.hAtoms);

            let chainidArrayTmp = Object.keys(chainidHash);
            let chainidArray = [];

            let prevChainid = '';
            for(let i = 0, il = chainidArrayTmp.length; i < il; ++i) {
                if(chainidArrayTmp[i] != prevChainid) chainidArray.push(chainidArrayTmp[i]);
                prevChainid = chainidArrayTmp[i];
            }
            
            // use the model from Membranome as template
            // if(ic.bAfMem && chainidArray.length == 2) {
            //     if(chainidArray[1].split('_')[0] == pdbidTemplate) {
            //         let tmp = chainidArray[0];
            //         chainidArray[0] = chainidArray[1]; 
            //         chainidArray[1] = tmp;
            //     }
            // }
            
            let bRealign = true;
            ic.qt_start_end = []; // reset the alignment

            await this.realignChainOnSeqAlign(undefined, chainidArray, bRealign);
        }

        async realignOnStructAlign(bReverse, bVastsearch) { let ic = this.icn3d, me = ic.icn3dui;
            // each 3D domain should have at least 3 secondary structures
            let minSseCnt = (me.cfg.aligntool != 'tmalign') ? 3 : 0;

            /*
    let resRangeArray = (me.cfg.resrange) ? decodeURIComponent(me.cfg.resrange).split(' | ') : [];

                    let atomSet_t = (me.cfg.resrange) ? ic.realignParserCls.getSeqCoorResid([resRangeArray[0]], ic.chainidArray[0], true).hAtoms : ic.chains[chainidArray[0]];
                    for(let index = 1, indexl = chainidArray.length; index < indexl; ++index) {
                        let atomSet_q = (me.cfg.resrange) ? ic.realignParserCls.getSeqCoorResid([resRangeArray[index]], ic.chainidArray[index], true).hAtoms : ic.chains[chainidArray[index]];
                    // end of new version to be done for VASTsrv ==============
    */
            let ajaxArray = [], chainidPairArray = [];
            let urlalign = me.htmlCls.baseUrl + "vastdyn/vastdyn.cgi";
            let urltmalign = me.htmlCls.baseUrl + "tmalign/tmalign.cgi";

            let struct2domain = {};
            if(bVastsearch && me.cfg.resrange) {
                let resRangeArray = decodeURIComponent(me.cfg.resrange).split(' | ');

                let atomSet_t = ic.realignParserCls.getSeqCoorResid([resRangeArray[0]], ic.chainidArray[0], true).hAtoms;
                for(let index = 1, indexl = ic.chainidArray.length; index < indexl; ++index) {
                    let atomSet_q = ic.realignParserCls.getSeqCoorResid([resRangeArray[index]], ic.chainidArray[index], true).hAtoms;

                    let alignAjax;
                    if(me.cfg.aligntool != 'tmalign') {
                        let jsonStr_q = ic.domain3dCls.getDomainJsonForAlign(atomSet_q);
                        let jsonStr_t = ic.domain3dCls.getDomainJsonForAlign(atomSet_t);
                            
                        let dataObj = {'domains1': jsonStr_q, 'domains2': jsonStr_t};
                        alignAjax = me.getAjaxPostPromise(urlalign, dataObj);
                    }
                    else {
                        let pdb_query = ic.saveFileCls.getAtomPDB(atomSet_q);
                        let pdb_target= ic.saveFileCls.getAtomPDB(atomSet_t);

                        let dataObj = {'pdb_query': pdb_query, 'pdb_target': pdb_target};
                        alignAjax = me.getAjaxPostPromise(urltmalign, dataObj);                
                    }

                    ajaxArray.push(alignAjax);
                    
                    chainidPairArray.push(ic.chainidArray[0] + ',' + ic.chainidArray[index]); 
                }
            }
            else {
                for(let struct in ic.structures) {
                    struct2domain[struct] = {};
                    let chainidArray = ic.structures[struct];
                    for(let i = 0, il = chainidArray.length; i < il; ++i) {
                        let chainid = chainidArray[i];
                        let atoms = me.hashUtilsCls.intHash(ic.hAtoms, ic.chains[chainid]);               
                        let sseCnt = 0;
                        for(let serial in atoms) {
                            if(ic.atoms[serial].ssbegin) ++sseCnt;
                            if(sseCnt > minSseCnt) {
                                struct2domain[struct][chainid] = atoms;
                                break;
                            }
                        }
                    }
                }

                //let cnt = 0;
                let structArray = Object.keys(struct2domain);
                if(bReverse) structArray = structArray.reverse();

                for(let s = 0, sl = structArray.length; s < sl; ++s) {
                    let struct1 = structArray[s];

                    let chainidArray1 = Object.keys(struct2domain[struct1]);
                    if(chainidArray1.length == 0) continue;

                    for(let i = 0, il = chainidArray1.length; i < il; ++i) {
                        let chainid1 = chainidArray1[i];
                        let jsonStr_t = ic.domain3dCls.getDomainJsonForAlign(struct2domain[struct1][chainid1]);

                        for(let t = s+1, tl = structArray.length; t < tl; ++t) {
                            let struct2 = structArray[t];

                            let chainidArray2 = Object.keys(struct2domain[struct2]);
                            if(chainidArray2.length == 0) continue;

                            for(let j = 0, jl = chainidArray2.length; j < jl; ++j) {
                                let chainid2 = chainidArray2[j];

                                let alignAjax;
                                if(me.cfg.aligntool != 'tmalign') {
                                    let jsonStr_q = ic.domain3dCls.getDomainJsonForAlign(struct2domain[struct2][chainid2]);
                
                                    let dataObj = {'domains1': jsonStr_q, 'domains2': jsonStr_t};
                                    alignAjax = me.getAjaxPostPromise(urlalign, dataObj);
                                }
                                else {
                                    let pdb_target = ic.saveFileCls.getAtomPDB(struct2domain[struct1][chainid1], undefined, undefined, undefined, undefined, struct1);
                                    let pdb_query = ic.saveFileCls.getAtomPDB(struct2domain[struct2][chainid2], undefined, undefined, undefined, undefined, struct2);
        
                                    // let pdb_target = ic.saveFileCls.getAtomPDB(ic.chains[chainid1], undefined, undefined, undefined, undefined, struct1);
                                    // let pdb_query = ic.saveFileCls.getAtomPDB(ic.chains[chainid2], undefined, undefined, undefined, undefined, struct2);
            
                                    let dataObj = {'pdb_query': pdb_query, 'pdb_target': pdb_target};
                                    alignAjax = me.getAjaxPostPromise(urltmalign, dataObj);                    
                                }

                                ajaxArray.push(alignAjax);
                                chainidPairArray.push(chainid1 + ',' + chainid2); 
                                //++cnt;
                            }
                        }
                    }
                }
            }

            let allPromise = Promise.allSettled(ajaxArray);
            // try {
                let dataArray = await allPromise;
              
                ic.qt_start_end = []; // reset the alignment
                await ic.chainalignParserCls.downloadChainalignmentPart2bRealign(dataArray, chainidPairArray, bReverse);  
            // }
            // catch(err) {
            //     if(ic.bRender) alert("These structures can NOT be aligned to each other...");
            // }                   
        }

        async realignOnStructAlignMsa(nameArray) { let ic = this.icn3d, me = ic.icn3dui;
            // each 3D domain should have at least 3 secondary structures
            let minSseCnt = (me.cfg.aligntool != 'tmalign') ? 3 : 0;
            let chainid2domain = {};

            for(let i = 0, il = nameArray.length; i < il; ++i) {
                let chainid = nameArray[i];
                let atoms = me.hashUtilsCls.intHash(ic.hAtoms, ic.chains[chainid]);               
                let sseCnt = 0;
                for(let serial in atoms) {
                    if(ic.atoms[serial].ssbegin) ++sseCnt;
                    if(sseCnt > minSseCnt) {
                        chainid2domain[chainid] = atoms;
                        break;
                    }
                }
            }

            let ajaxArray = [], indexArray = [], struArray = [];
            let urlalign = me.htmlCls.baseUrl + "vastdyn/vastdyn.cgi";
            let urltmalign = me.htmlCls.baseUrl + "tmalign/tmalign.cgi";

            let chainid1 = nameArray[0];
            let struct1 = chainid1.substr(0, chainid1.indexOf('_'));
            let jsonStr_t = ic.domain3dCls.getDomainJsonForAlign(chainid2domain[chainid1]);

            for(let i = 1, il = nameArray.length; i < il; ++i) {
                let chainid2 = nameArray[i];
                let struct2 = chainid2.substr(0, chainid2.indexOf('_'));

                let alignAjax;

                if(me.cfg.aligntool != 'tmalign') {
                    let jsonStr_q = ic.domain3dCls.getDomainJsonForAlign(chainid2domain[chainid2]);
                
                    let dataObj = {'domains1': jsonStr_q, 'domains2': jsonStr_t};
                    alignAjax = me.getAjaxPostPromise(urlalign, dataObj);
                }
                else {
                    // let pdb_target = ic.saveFileCls.getAtomPDB(chainid2domain[chainid1], undefined, undefined, undefined, undefined, struct1);
                    // let pdb_query = ic.saveFileCls.getAtomPDB(chainid2domain[chainid2], undefined, undefined, undefined, undefined, struct2);

                    let pdb_target = ic.saveFileCls.getAtomPDB(ic.chains[chainid1], undefined, undefined, undefined, undefined, struct1);
                    let pdb_query = ic.saveFileCls.getAtomPDB(ic.chains[chainid2], undefined, undefined, undefined, undefined, struct2);

                    let dataObj = {'pdb_query': pdb_query, 'pdb_target': pdb_target};
                    alignAjax = me.getAjaxPostPromise(urltmalign, dataObj);                    
                }

                ajaxArray.push(alignAjax);
                //chainidPairArray.push(chainid1 + ',' + chainid2); 

                indexArray.push(i - 1);
                struArray.push(struct2);

                //++cnt;
            }

            let allPromise = Promise.allSettled(ajaxArray);
            // try {
                let dataArray = await allPromise;

                // set trans and rotation matrix
                ic.t_trans_add = [];
                ic.q_trans_sub = [];

                if(me.cfg.aligntool == 'tmalign') ic.q_trans_add = [];

                ic.q_rotation = [];
                ic.qt_start_end = [];

                await ic.chainalignParserCls.downloadChainalignmentPart2b(undefined, nameArray, undefined, dataArray, 
                    indexArray, struct1, struArray);
            // }
            // catch(err) {
            //     if(ic.bRender) alert("These structures can NOT be aligned to each other...");
            // }                   
        }

        async realignChainOnSeqAlign(chainresiCalphaHash2, chainidArray, bRealign, bPredefined) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            me.cfg.aligntool = 'seqalign';

            //bRealign: realign based on seq alignment
            //bPredefined: chain alignment with predefined matching residues

            let struct2SeqHash = {};
            let struct2CoorHash = {};
            let struct2resid = {};

            let mmdbid_t, chainid_t;
            let ajaxArray = [];
            let url = me.htmlCls.baseUrl + 'pwaln/pwaln.fcgi?from=chainalign';

            let predefinedResArray, predefinedResPair;

            if(bPredefined) {
                // predefinedResArray = decodeURIComponent(me.cfg.resdef).trim().replace(/\+/gi, ' ').split(': ');
                predefinedResArray = decodeURIComponent(me.cfg.resdef).trim().replace(/\+/gi, ' ').split('; ');
                
                if(predefinedResArray.length != chainidArray.length - 1) {
                   alert("Please make sure the number of chains and the lines of predefined residues are the same...");
                   return;
                }
            }

            let result, resiArray;
            for(let i = 0, il = chainidArray.length; i < il; ++i) {
                //if(bPredefined) predefinedRes = predefinedResArray[i].trim();

                let pos = chainidArray[i].indexOf('_');
                let mmdbid = chainidArray[i].substr(0, pos); //.toUpperCase();

                // if(!bRealign) mmdbid =  mmdbid.toUpperCase();

                if(i == 0) {
                    mmdbid_t = mmdbid;
                }

                let chainid = mmdbid + chainidArray[i].substr(pos);
                if(i == 0) chainid_t = chainid;
                
                if(!ic.chainsSeq || !ic.chainsSeq[chainid]) {
                    //alert("Please select one chain per structure and try it again...");
                    //return;
                    continue;
                }

                if(!struct2SeqHash.hasOwnProperty(chainid) && !bPredefined) {
                    struct2SeqHash[chainid] = '';
                    struct2CoorHash[chainid] = [];
                    struct2resid[chainid] = [];
                }
     
                if(bPredefined) {             
                    //base = parseInt(ic.chainsSeq[chainid][0].resi);

                    if(i == 0) ;
                    else {
                        let hAtoms = {};

                        predefinedResPair = predefinedResArray[i - 1].split(' | ');

                        let chainidpair = chainid_t + ',' + chainid;
                        if(!struct2SeqHash[chainidpair]) struct2SeqHash[chainidpair] = {};
                        if(!struct2CoorHash[chainidpair]) struct2CoorHash[chainidpair] = {};
                        if(!struct2resid[chainidpair]) struct2resid[chainidpair] = {};

                        // master
                        resiArray = predefinedResPair[0].split(",");        

                        result = thisClass.getSeqCoorResid(resiArray, chainid_t);

                        hAtoms = me.hashUtilsCls.unionHash(hAtoms, result.hAtoms);

                        if(!struct2SeqHash[chainidpair][mmdbid_t]) struct2SeqHash[chainidpair][mmdbid_t] = '';
                        if(!struct2CoorHash[chainidpair][mmdbid_t]) struct2CoorHash[chainidpair][mmdbid_t] = [];
                        if(!struct2resid[chainidpair][mmdbid_t]) struct2resid[chainidpair][mmdbid_t] = [];

                        struct2SeqHash[chainidpair][mmdbid_t] += result.seq;
                        struct2CoorHash[chainidpair][mmdbid_t] = struct2CoorHash[chainidpair][mmdbid_t].concat(result.coor);
                        struct2resid[chainidpair][mmdbid_t] = struct2resid[chainidpair][mmdbid_t].concat(result.resid);

                        // slave
                        resiArray = predefinedResPair[1].split(",");

                        result = thisClass.getSeqCoorResid(resiArray, chainid); 
                        hAtoms = me.hashUtilsCls.unionHash(hAtoms, result.hAtoms);

                        if(!struct2SeqHash[chainidpair][mmdbid]) struct2SeqHash[chainidpair][mmdbid] = '';
                        if(!struct2CoorHash[chainidpair][mmdbid]) struct2CoorHash[chainidpair][mmdbid] = [];
                        if(!struct2resid[chainidpair][mmdbid]) struct2resid[chainidpair][mmdbid] = [];

                        struct2SeqHash[chainidpair][mmdbid] += result.seq;
                        struct2CoorHash[chainidpair][mmdbid] = struct2CoorHash[chainidpair][mmdbid].concat(result.coor);
                        struct2resid[chainidpair][mmdbid] = struct2resid[chainidpair][mmdbid].concat(result.resid);

                        // let residueHash = ic.firstAtomObjCls.getResiduesFromAtoms(hAtoms);
                        // let residueArray = Object.keys(residueHash);
            
                        // let commandname = chainidpair;
                        // let commanddescr = 'aligned ' + chainidpair;
                        // let select = "select " + ic.resid2specCls.residueids2spec(residueArray);
            
                        // ic.selectionCls.addCustomSelection(residueArray, commandname, commanddescr, select, true);
            
                        // me.htmlCls.clickMenuCls.setLogCmd(select + " | name " + commandname, true);
                        // me.htmlCls.clickMenuCls.setLogCmd("realign", true);
                    }
                }
                else {           
                    if(i == 0) { // master
                        //base = parseInt(ic.chainsSeq[chainid][0].resi);

                        resiArray = [];
                        if(bRealign) {
                            //resiArray = [resRange];
                            let residHash = ic.firstAtomObjCls.getResiduesFromAtoms(ic.hAtoms);

                            for(var resid in residHash) {
                                let resi = resid.substr(resid.lastIndexOf('_') + 1);

                                let chainidTmp = resid.substr(0, resid.lastIndexOf('_'));
                                if(chainidTmp == chainid) resiArray.push(resi);
                            }
                        }
                        else if(me.cfg.resnum) {
                            resiArray = me.cfg.resnum.split(",");
                        }
                        
                        //if(!bPredefined) {
                            result = thisClass.getSeqCoorResid(resiArray, chainid);   
                            struct2SeqHash[chainid] += result.seq;

                            struct2CoorHash[chainid] = struct2CoorHash[chainid].concat(result.coor);
                            struct2resid[chainid] = struct2resid[chainid].concat(result.resid);
                        //}
                    }
                    else {
                        // if selected both chains
                        let bSelectedBoth = false;
                        if(bRealign) {
                            //resiArray = [resRange];
                            let residHash = ic.firstAtomObjCls.getResiduesFromAtoms(ic.hAtoms);
                            for(var resid in residHash) {
                                //let resi = resid.substr(resid.lastIndexOf('_') + 1);
                                let chainidTmp = resid.substr(0, resid.lastIndexOf('_'));
                                if(chainidTmp == chainid) {
                                    bSelectedBoth = true;

                                    let resn = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid]).resn;
                                    struct2SeqHash[chainid] += me.utilsCls.residueName2Abbr(resn);

                                    struct2CoorHash[chainid] = struct2CoorHash[chainid].concat(this.getResCoorArray(resid));

                                    struct2resid[chainid].push(resid);
                                }
                            }
                        }

                        if(!bSelectedBoth) {
                            for(let j = 0, jl = ic.chainsSeq[chainid].length; j < jl; ++j) {
                                struct2SeqHash[chainid] += ic.chainsSeq[chainid][j].name;
                                let resid = chainid + '_' + ic.chainsSeq[chainid][j].resi;

                                struct2CoorHash[chainid] = struct2CoorHash[chainid].concat(this.getResCoorArray(resid));

                                struct2resid[chainid].push(resid);
                            }
                        }

                        let seq1 = struct2SeqHash[chainid_t];
                        let seq2 = struct2SeqHash[chainid];
                        
                        let dataObj = {'targets': seq1, 'queries': seq2};
                        let queryAjax = me.getAjaxPostPromise(url, dataObj);

                        ajaxArray.push(queryAjax);
                    }  
                }        
            } // for

            if(bPredefined) {
                await thisClass.parseChainRealignPredefined(chainidArray, struct2SeqHash, struct2CoorHash, struct2resid);
            }
            else {
                let allPromise = Promise.allSettled(ajaxArray);
                try {
                    let dataArray = await allPromise;
                    //thisClass.parseChainRealignData(Array.from(dataArray), chainresiCalphaHash2, chainidArray, struct2SeqHash, struct2CoorHash, struct2resid, bRealign);
                    await thisClass.parseChainRealignData(dataArray, chainresiCalphaHash2, chainidArray, struct2SeqHash, struct2CoorHash, struct2resid, bRealign);

                    ///// if(ic.deferredAfMem !== undefined) ic.deferredAfMem.resolve();
                    /// if(ic.deferredMmdbaf !== undefined) ic.deferredMmdbaf.resolve();
                    /// if(ic.deferredOpm !== undefined) ic.deferredOpm.resolve();
                }
                catch(err) {
                    alert("The realignment did not work...");
                    ///// if(ic.deferredAfMem !== undefined) ic.deferredAfMem.resolve();
                    /// if(ic.deferredMmdbaf !== undefined) ic.deferredMmdbaf.resolve();
                    /// if(ic.deferredOpm !== undefined) ic.deferredOpm.resolve();

                    return;
                }              
            }
        }

        getSeqCoorResid(resiArray, chainid, bNCBIResi) { let ic = this.icn3d, me = ic.icn3dui;
            let seq = '', coorArray = [], residArray = [];
            let hAtoms = {};

            for(let j = 0, jl = resiArray.length; j < jl; ++j) {
                if(resiArray[j].indexOf('-') != -1) {
                    let startEnd = resiArray[j].split('-');
                    for(let k = parseInt(startEnd[0]); k <= parseInt(startEnd[1]); ++k) {
                        let seqIndex = (bNCBIResi) ? k : ic.setSeqAlignCls.getPosFromResi(chainid, k);

                        // don't align solvent or chemicals
                        if(!ic.chainsSeq[chainid] || !ic.chainsSeq[chainid][seqIndex] || me.parasCls.b62ResArray.indexOf(ic.chainsSeq[chainid][seqIndex].name.toUpperCase()) == -1) continue;

                        seq += ic.chainsSeq[chainid][seqIndex].name.toUpperCase();

                        let resid = (bNCBIResi) ? ic.ncbi2resid[chainid + '_' + k] : chainid + '_' + k;
                        coorArray = coorArray.concat(this.getResCoorArray(resid));

                        residArray.push(resid);
                    }            
                }
                else if(resiArray[j] == 0) { // 0 means the whole chain
                    let residueHash = ic.firstAtomObjCls.getResiduesFromAtoms(ic.chains[chainid]);
                    residArray = Object.keys(residueHash);
                }
                else { // one residue
                    let k = resiArray[j];

                    let seqIndex = (bNCBIResi) ? k : ic.setSeqAlignCls.getPosFromResi(chainid, k);

                    if(!ic.chainsSeq[chainid][seqIndex]) continue;

                    let resid = (bNCBIResi) ? ic.ncbi2resid[chainid + '_' + k] : chainid + '_' + k;
                    let resCoorArray = this.getResCoorArray(resid);
                    //if(resCoorArray.length == 1 && resCoorArray[0] === undefined) continue;

                    seq += ic.chainsSeq[chainid][seqIndex].name.toUpperCase();

                    coorArray = coorArray.concat(resCoorArray);

                    residArray.push(resid);
                }
            }

            for(let i = 0, il = residArray.length; i < il; ++i) {
                hAtoms = me.hashUtilsCls.unionHash(hAtoms, ic.residues[residArray[i]]);
            }

            return {seq: seq, coor: coorArray, resid: residArray, hAtoms: hAtoms};
        }

        getResCoorArray(resid) { let ic = this.icn3d; ic.icn3dui;
            let struct2CoorArray = [];

            let bFound = false;
            for(let serial in ic.residues[resid]) {
                let atom = ic.atoms[serial];

                //if((ic.proteins.hasOwnProperty(serial) && atom.name == "CA" && atom.elem == "C")
                //  ||(ic.nucleotides.hasOwnProperty(serial) &&(atom.name == "O3'" || atom.name == "O3*") && atom.elem == "O") ) {
                if((atom.name == "CA" && atom.elem == "C")
                  ||((atom.name == "O3'" || atom.name == "O3*") && atom.elem == "O") ) {
                    struct2CoorArray.push(atom.coord.clone());
                    bFound = true;
                    break;
                }
            }
            if(!bFound) struct2CoorArray.push(undefined);

            return struct2CoorArray;
        }
    }

    /**
     * @file Density Cif Parser
     * @author David Sehnal dsehnal <alexander.rose@weirdbyte.de>
     * Modified by Jiyao Wang / https://github.com/ncbi/icn3d
     */

    class DensityCifParser {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        async densityCifParser(pdbid, type, sigma, emd, bOutput) { let ic = this.icn3d, me = ic.icn3dui;
           let thisClass = this;

           let url;
           let detail = (me.utilsCls.isMobile() || me.cfg.notebook) ? 0 : 4; // max 6

           //https://www.ebi.ac.uk/pdbe/densities/doc.html
           if(type == '2fofc' || type == 'fofc') {
                //detail = 0;

                //    url = "https://www.ebi.ac.uk/pdbe/densities/x-ray/" + pdbid.toLowerCase() + "/cell?detail=" + detail;
                let min_max = ic.contactCls.getExtent(ic.atoms); 
                url = "https://www.ebi.ac.uk/pdbe/volume-server/x-ray/" + pdbid.toLowerCase() + "/box/" + min_max[0][0] + "," + min_max[0][1] + "," + min_max[0][2] + "/" + min_max[1][0] + "," + min_max[1][1] + "," + min_max[1][2] + "?detail=" + detail;
           }
           else if(type == 'em') {
               detail = (me.utilsCls.isMobile() || me.cfg.notebook) ? 0: 5; // max 6
               url = "https://www.ebi.ac.uk/pdbe/densities/emd/" + emd.toLowerCase() + "/cell?detail=" + detail;
           }

           //var bCid = undefined;

            //https://stackoverflow.com/questions/33902299/using-jquery-ajax-to-download-a-binary-file
            if(type == '2fofc' && ic.bAjax2fofc) {
                ic.mapData.sigma2 = sigma;
                ic.setOptionCls.setOption('map', type);
            }
            else if(type == 'fofc' && ic.bAjaxfofc) {
                ic.mapData.sigma = sigma;
                ic.setOptionCls.setOption('map', type);
            }
            else if(type == 'em' && ic.bAjaxEm) {
                ic.mapData.sigmaEm = sigma;
                ic.setOptionCls.setOption('emmap', type);
            }
            else {
                let arrayBuffer = await me.getXMLHttpRqstPromise(url, 'GET', 'arraybuffer', type);

                thisClass.parseChannels(arrayBuffer, type, sigma);

                if(type == '2fofc' || type == 'fofc') {
                    ic.bAjax2fofc = true;
                    ic.bAjaxfofc = true;

                    ic.setOptionCls.setOption('map', type);
                }
                else if(type == 'em') {
                    ic.bAjaxEm = true;

                    ic.setOptionCls.setOption('emmap', type);
                }
            }
        }

        async densityCifParserBase(url, type, sigma, location, bInputSigma) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            //https://stackoverflow.com/questions/33902299/using-jquery-ajax-to-download-a-binary-file
            if(type == '2fofc' && ic.bAjax2fofc) {
                ic.mapData.sigma2 = sigma;
                ic.setOptionCls.setOption('map', type);
            }
            else if(type == 'fofc' && ic.bAjaxfofc) {
                ic.mapData.sigma = sigma;
                ic.setOptionCls.setOption('map', type);
            }
            else {
                let arrayBuffer = await me.getXMLHttpRqstPromise(url, 'GET', 'arraybuffer', type);
                
                thisClass.parseChannels(arrayBuffer, type, sigma);

                if(type == '2fofc' || type == 'fofc') {
                    ic.bAjax2fofc = true;
                    ic.bAjaxfofc = true;

                    ic.setOptionCls.setOption('map', type);
                }
                else if(type == 'em') {
                    ic.bAjaxEm = true;

                    ic.setOptionCls.setOption('emmap', type);
                }
            }

            // return sigma;
        }

        setMatrix(density) { let ic = this.icn3d; ic.icn3dui;
            let sampleCount = density.box.sampleCount;
            let header = {xExtent: sampleCount[0], yExtent: sampleCount[1], zExtent: sampleCount[2], mean: density.valuesInfo.mean, sigma: density.valuesInfo.sigma, max: density.valuesInfo.max, min: density.valuesInfo.min};
            for(let i = 0; i < density.data.length; ++i) {
                density.data[i];
            }

            let origin = density.box.origin;
            let dimensions = density.box.dimensions;
            let basis = density.spacegroup.basis;
            let scale = new THREE.Matrix4().makeScale(
                dimensions[0] / (sampleCount[0] ),
                dimensions[1] / (sampleCount[1] ),
                dimensions[2] / (sampleCount[2] ));
            let translate = new THREE.Matrix4().makeTranslation(origin[0], origin[1], origin[2]);
            let fromFrac = new THREE.Matrix4().set(
                basis.x[0], basis.y[0], basis.z[0], 0.0,
                0.0, basis.y[1], basis.z[1], 0.0,
                0.0, 0.0, basis.z[2], 0.0,
                0.0, 0.0, 0.0, 1.0);

            //var toFrac = new LiteMol.Visualization.THREE.Matrix4().getInverse(fromFrac);
            let matrix = fromFrac.multiply(translate).multiply(scale);

            return {matrix: matrix, header: header};
        }

        parseChannels(densitydata, type, sigma) { let ic = this.icn3d; ic.icn3dui;
            let cif = this.BinaryParse(densitydata);

            if(type == '2fofc' || type == 'fofc') {
                let twoDensity = this.getChannel(cif, '2FO-FC');
                let oneDensity = this.getChannel(cif, 'FO-FC');

                // '2fofc'
                let density = twoDensity;
                let result = this.setMatrix(density);

                ic.mapData.matrix2 = result.matrix;
                ic.mapData.header2 = result.header;

                ic.mapData.data2 = density.data;
                ic.mapData.type2 = type;
                ic.mapData.sigma2 = sigma;

                // 'fofc'
                density = oneDensity;
                result = this.setMatrix(density);

                ic.mapData.matrix = result.matrix;
                ic.mapData.header = result.header;

                ic.mapData.data = density.data;
                ic.mapData.type = type;
                ic.mapData.sigma = sigma;
            }
            else if(type == 'em') {
                let density = this.getChannel(cif, 'EM');

                let result = this.setMatrix(density);

                ic.mapData.matrixEm = result.matrix;
                ic.mapData.headerEm = result.header;

                ic.mapData.dataEm = density.data;
                ic.mapData.typeEm = type;
                ic.mapData.sigmaEm = sigma;
            }
        }

        getChannel(data, name) { let ic = this.icn3d; ic.icn3dui;
            //var block = data.dataBlocks.filter(b => b.header === name)[0];
            //var block = data.dataBlocks.filter(b => b.id === name)[0];

            let jsonData = data.toJSON();

            let block;
            for(let i = 0, il = jsonData.length; i < il; ++i) {
                if(jsonData[i].id == name) block = data.dataBlocks[i];
            }

            let density = this.CIFParse(block);

            return density;
        }

        CIFParse(block) { let ic = this.icn3d; ic.icn3dui;
            let info = block.getCategory('_volume_data_3d_info');

            if (!info) {
                conole.log('_volume_data_3d_info category is missing.');
                return undefined;
            }
            if (!block.getCategory('_volume_data_3d')) {
                conole.log('_volume_data_3d category is missing.');
                return undefined;
            }

            function getVector3(name) {
                let ret = [0, 0, 0];
                for (let i = 0; i < 3; i++) {
                    ret[i] = info.getColumn(name + '[' + i + ']').getFloat(0);
                }
                return ret;
            }

            function getNum(name) { return info.getColumn(name).getFloat(0); }

            let header = {
                name: info.getColumn('name').getString(0),
                axisOrder: getVector3('axis_order'),

                origin: getVector3('origin'),
                dimensions: getVector3('dimensions'),

                sampleCount: getVector3('sample_count'),

                spacegroupNumber: getNum('spacegroup_number') | 0,
                cellSize: getVector3('spacegroup_cell_size'),
                cellAngles: getVector3('spacegroup_cell_angles'),

                mean: getNum('mean_sampled'),
                sigma: getNum('sigma_sampled')
            };

            let indices = [0, 0, 0];
            indices[header.axisOrder[0]] = 0;
            indices[header.axisOrder[1]] = 1;
            indices[header.axisOrder[2]] = 2;

            function normalizeOrder(xs) {
                return [xs[indices[0]], xs[indices[1]], xs[indices[2]]];
            }

            function readValues(col, xyzSampleCount, sampleCount, axisIndices) {
                let data = new Float32Array(xyzSampleCount[0] * xyzSampleCount[1] * xyzSampleCount[2]);
                let coord = [0, 0, 0];
                let iX = axisIndices[0], iY = axisIndices[1], iZ = axisIndices[2];
                let mX = sampleCount[0], mY = sampleCount[1], mZ = sampleCount[2];


                xyzSampleCount[0];
                xyzSampleCount[0] * xyzSampleCount[1];

                let zSize = xyzSampleCount[2];
                let yzSize = xyzSampleCount[1] * xyzSampleCount[2];

                let offset = 0;
                let min = col.getFloat(0), max = min;

                for (let cZ = 0; cZ < mZ; cZ++) {
                    coord[2] = cZ;
                    for (let cY = 0; cY < mY; cY++) {
                        coord[1] = cY;
                        for (let cX = 0; cX < mX; cX++) {
                            coord[0] = cX;
                            let v = col.getFloat(offset);
                            offset += 1;
                            //data[coord[iX] + coord[iY] * xSize + coord[iZ] * xySize] = v;
                            data[coord[iZ] + coord[iY] * zSize + coord[iX] * yzSize] = v;
                            if (v < min) min = v;
                            else if (v > max) max = v;
                        }
                    }
                }

                return { data: data, min: min, max: max };
            }

            function createSpacegroup(number, size, angles) {
                let alpha = (Math.PI / 180.0) * angles[0], beta = (Math.PI / 180.0) * angles[1], gamma = (Math.PI / 180.0) * angles[2];
                let xScale = size[0], yScale = size[1], zScale = size[2];

                let z1 = Math.cos(beta),
                      z2 = (Math.cos(alpha) - Math.cos(beta) * Math.cos(gamma)) / Math.sin(gamma),
                      z3 = Math.sqrt(1.0 - z1 * z1 - z2 * z2);

                let x = [xScale, 0.0, 0.0];
                let y = [Math.cos(gamma) * yScale, Math.sin(gamma) * yScale, 0.0];
                let z = [z1 * zScale, z2 * zScale, z3 * zScale];

                return {
                    number: number,
                    size: size,
                    angles: angles,
                    basis: { x: x, y: y, z: z }
                };
            }

            let sampleCount = normalizeOrder(header.sampleCount);

            let rawData = readValues(block.getCategory('_volume_data_3d').getColumn('values'), sampleCount, header.sampleCount, indices);
            //var field = new Field3DZYX(rawData.data, sampleCount);

            let data = {
                name: header.name,
                spacegroup: createSpacegroup(header.spacegroupNumber, header.cellSize, header.cellAngles),
                box: {
                    origin: normalizeOrder(header.origin),
                    dimensions: normalizeOrder(header.dimensions),
                    sampleCount: sampleCount
                },
                //data: field,
                data: rawData.data,
                valuesInfo: { min: rawData.min, max: rawData.max, mean: header.mean, sigma: header.sigma }
            };

            return data;
        }

        BinaryParse(data) { let ic = this.icn3d; ic.icn3dui;
        //    let minVersion = [0, 3];
        //    try {
                let array = new Uint8Array(data);

                let unpacked = this.MessagePackParse({
                            buffer: array,
                            offset: 0,
                            dataView: new DataView(array.buffer)
                });

                let DataBlock = (function () {
                    function DataBlock(data) {
                        this.additionalData = {};
                        this.header = data.header;
                        this.categoryList = data.categories.map(function (c) { return new Category(c); });
                        this.categoryMap = new Map();
                        for (let _i = 0, _a = this.categoryList; _i < _a.length; _i++) {
                            let c = _a[_i];
                            this.categoryMap.set(c.name, c);
                        }
                    }
                    Object.defineProperty(DataBlock.prototype, "categories", {
                        get: function () { return this.categoryList; },
                        enumerable: true,
                        configurable: true
                    });
                    DataBlock.prototype.getCategory = function (name) { return this.categoryMap.get(name); };
                    DataBlock.prototype.toJSON = function () {
                        return {
                            id: this.header,
                            categories: this.categoryList.map(function (c) { return c.toJSON(); }),
                            additionalData: this.additionalData
                        };
                    };
                    return DataBlock;
                }());

                let Category = (function () {
                    function Category(data) {
                        this.name = data.name;
                        this.columnCount = data.columns.length;
                        this.rowCount = data.rowCount;
                        this.columnNameList = [];
                        this.encodedColumns = new Map();
                        for (let _i = 0, _a = data.columns; _i < _a.length; _i++) {
                            let c = _a[_i];
                            this.encodedColumns.set(c.name, c);
                            this.columnNameList.push(c.name);
                        }
                    }
                    Object.defineProperty(Category.prototype, "columnNames", {
                        get: function () { return this.columnNameList; },
                        enumerable: true,
                        configurable: true
                    });

                    let _UndefinedColumn = (function () {
                        function _UndefinedColumn() {
                            this.isDefined = false;
                        }
                        _UndefinedColumn.prototype.getString = function (row) { return null; };
                        _UndefinedColumn.prototype.getInteger = function (row) { return 0; };
                        _UndefinedColumn.prototype.getFloat = function (row) { return 0.0; };
                        _UndefinedColumn.prototype.getValuePresence = function (row) { return 1 /* NotSpecified */; };
                        _UndefinedColumn.prototype.areValuesEqual = function (rowA, rowB) { return true; };
                        _UndefinedColumn.prototype.stringEquals = function (row, value) { return value === null; };
                        return _UndefinedColumn;
                    }());

                    Category.prototype.getColumn = function (name) {
                        let w = this.encodedColumns.get(name);
                        if (w)
                            return wrapColumn(w);
                        return _UndefinedColumn;
                    };
                    Category.prototype.toJSON = function () {
                        let _this = this;
                        let rows = [];
                        let columns = this.columnNameList.map(function (name) { return ({ name: name, column: _this.getColumn(name) }); });
                        for (let i = 0; i < this.rowCount; i++) {
                            let item = {};
                            for (let _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
                                let c = columns_1[_i];
                                let d = c.column.getValuePresence(i);
                                if (d === 0 /* Present */)
                                    item[c.name] = c.column.getString(i);
                                else if (d === 1 /* NotSpecified */)
                                    item[c.name] = '.';
                                else
                                    item[c.name] = '?';
                            }
                            rows[i] = item;
                        }
                        return { name: this.name, columns: this.columnNames, rows: rows };
                    };
                    return Category;
                }());

                function getIntArray(type, size) {
                    switch (type) {
                        case 1 /* Int8 */: return new Int8Array(size);
                        case 2 /* Int16 */: return new Int16Array(size);
                        case 3 /* Int32 */: return new Int32Array(size);
                        case 4 /* Uint8 */: return new Uint8Array(size);
                        case 5 /* Uint16 */: return new Uint16Array(size);
                        case 6 /* Uint32 */: return new Uint32Array(size);
                        default: throw new Error('Unsupported integer data type.');
                    }
                }
                function getFloatArray(type, size) {
                    switch (type) {
                        case 32 /* Float32 */: return new Float32Array(size);
                        case 33 /* Float64 */: return new Float64Array(size);
                        default: throw new Error('Unsupported floating data type.');
                    }
                }
                // http://stackoverflow.com/questions/7869752/javascript-typed-arrays-and-endianness
                let isLittleEndian = (function () {
                    let arrayBuffer = new ArrayBuffer(2);
                    let uint8Array = new Uint8Array(arrayBuffer);
                    let uint16array = new Uint16Array(arrayBuffer);
                    uint8Array[0] = 0xAA;
                    uint8Array[1] = 0xBB;
                    if (uint16array[0] === 0xBBAA)
                        return true;
                    return false;
                })();
                function int8(data) { return new Int8Array(data.buffer, data.byteOffset); }
                function flipByteOrder(data, bytes) {
                    let buffer = new ArrayBuffer(data.length);
                    let ret = new Uint8Array(buffer);
                    for (let i = 0, n = data.length; i < n; i += bytes) {
                        for (let j = 0; j < bytes; j++) {
                            ret[i + bytes - j - 1] = data[i + j];
                        }
                    }
                    return buffer;
                }
                function view(data, byteSize, c) {
                    if (isLittleEndian)
                        return new c(data.buffer);
                    return new c(flipByteOrder(data, byteSize));
                }
                function int16(data) { return view(data, 2, Int16Array); }
                function uint16(data) { return view(data, 2, Uint16Array); }
                function int32(data) { return view(data, 4, Int32Array); }
                function uint32(data) { return view(data, 4, Uint32Array); }
                function float32(data) { return view(data, 4, Float32Array); }
                function float64(data) { return view(data, 8, Float64Array); }
                function fixedPoint(data, encoding) {
                    let n = data.length;
                    let output = getFloatArray(encoding.srcType, n);
                    let f = 1 / encoding.factor;
                    for (let i = 0; i < n; i++) {
                        output[i] = f * data[i];
                    }
                    return output;
                }
                function intervalQuantization(data, encoding) {
                    let n = data.length;
                    let output = getFloatArray(encoding.srcType, n);
                    let delta = (encoding.max - encoding.min) / (encoding.numSteps - 1);
                    let min = encoding.min;
                    for (let i = 0; i < n; i++) {
                        output[i] = min + delta * data[i];
                    }
                    return output;
                }
                function runLength(data, encoding) {
                    let output = getIntArray(encoding.srcType, encoding.srcSize);
                    let dataOffset = 0;
                    for (let i = 0, il = data.length; i < il; i += 2) {
                        let value = data[i]; // value to be repeated
                        let length_7 = data[i + 1]; // number of repeats
                        for (let j = 0; j < length_7; ++j) {
                            output[dataOffset++] = value;
                        }
                    }
                    return output;
                }
                function delta(data, encoding) {
                    let n = data.length;
                    let output = getIntArray(encoding.srcType, n);
                    if (!n)
                        return output;
                    output[0] = data[0] + (encoding.origin | 0);
                    for (let i = 1; i < n; ++i) {
                        output[i] = data[i] + output[i - 1];
                    }
                    return output;
                }
                function integerPackingSigned(data, encoding) {
                    let upperLimit = encoding.byteCount === 1 ? 0x7F : 0x7FFF;
                    let lowerLimit = -upperLimit - 1;
                    let n = data.length;
                    let output = new Int32Array(encoding.srcSize);
                    let i = 0;
                    let j = 0;
                    while (i < n) {
                        let value = 0, t = data[i];
                        while (t === upperLimit || t === lowerLimit) {
                            value += t;
                            i++;
                            t = data[i];
                        }
                        value += t;
                        output[j] = value;
                        i++;
                        j++;
                    }
                    return output;
                }
                function integerPackingUnsigned(data, encoding) {
                    let upperLimit = encoding.byteCount === 1 ? 0xFF : 0xFFFF;
                    let n = data.length;
                    let output = new Int32Array(encoding.srcSize);
                    let i = 0;
                    let j = 0;
                    while (i < n) {
                        let value = 0, t = data[i];
                        while (t === upperLimit) {
                            value += t;
                            i++;
                            t = data[i];
                        }
                        value += t;
                        output[j] = value;
                        i++;
                        j++;
                    }
                    return output;
                }
                function integerPacking(data, encoding) {
                    return encoding.isUnsigned ? integerPackingUnsigned(data, encoding) : integerPackingSigned(data, encoding);
                }
                function stringArray(data, encoding) {
                    let str = encoding.stringData;
                    let offsets = decode({ encoding: encoding.offsetEncoding, data: encoding.offsets });
                    let indices = decode({ encoding: encoding.dataEncoding, data: data });
                    let cache = Object.create(null);
                    let result = new Array(indices.length);
                    let offset = 0;
                    for (let _i = 0, indices_1 = indices; _i < indices_1.length; _i++) {
                        let i = indices_1[_i];
                        if (i < 0) {
                            result[offset++] = null;
                            continue;
                        }
                        let v = cache[i];
                        if (v === void 0) {
                            v = str.substring(offsets[i], offsets[i + 1]);
                            cache[i] = v;
                        }
                        result[offset++] = v;
                    }
                    return result;
                }

                function decodeStep(data, encoding) {
                    switch (encoding.kind) {
                        case 'ByteArray': {
                            switch (encoding.type) {
                                case 4 /* Uint8 */: return data;
                                case 1 /* Int8 */: return int8(data);
                                case 2 /* Int16 */: return int16(data);
                                case 5 /* Uint16 */: return uint16(data);
                                case 3 /* Int32 */: return int32(data);
                                case 6 /* Uint32 */: return uint32(data);
                                case 32 /* Float32 */: return float32(data);
                                case 33 /* Float64 */: return float64(data);
                                default: throw new Error('Unsupported ByteArray type.');
                            }
                        }
                        case 'FixedPoint': return fixedPoint(data, encoding);
                        case 'IntervalQuantization': return intervalQuantization(data, encoding);
                        case 'RunLength': return runLength(data, encoding);
                        case 'Delta': return delta(data, encoding);
                        case 'IntegerPacking': return integerPacking(data, encoding);
                        case 'StringArray': return stringArray(data, encoding);
                    }
                }

                function decode(data) {
                    let current = data.data;
                    for (let i = data.encoding.length - 1; i >= 0; i--) {
                        current = decodeStep(current, data.encoding[i]);
                    }
                    return current;
                }

                function wrapColumn(column) {
                    if (!column.data.data)
                        return _UndefinedColumn;
                    let data = decode(column.data);
                    let mask = void 0;
                    if (column.mask)
                        mask = decode(column.mask);
                    if (data.buffer && data.byteLength && data.BYTES_PER_ELEMENT) {
                        return mask ? new MaskedNumericColumn(data, mask) : new NumericColumn(data);
                    }
                    return mask ? new MaskedStringColumn(data, mask) : new StringColumn(data);
                }
                //var fastParseInt = CIFTools.me.utilsCls.FastNumberParsers.parseInt;
                function fastParseInt(str, start, end) {
                    let ret = 0, neg = 1;
                    if (str.charCodeAt(start) === 45 /* - */) {
                        neg = -1;
                        start++;
                    }
                    for (; start < end; start++) {
                        let c = str.charCodeAt(start) - 48;
                        if (c > 9 || c < 0)
                            return (neg * ret) | 0;
                        else
                            ret = (10 * ret + c) | 0;
                    }
                    return neg * ret;
                }
                //var fastParseFloat = CIFTools.me.utilsCls.FastNumberParsers.parseFloat;
                function fastParseFloat(str, start, end) {
                    let neg = 1.0, ret = 0.0, point = 0.0, div = 1.0;
                    if (str.charCodeAt(start) === 45) {
                        neg = -1.0;
                        ++start;
                    }
                    while (start < end) {
                        let c = str.charCodeAt(start) - 48;
                        if (c >= 0 && c < 10) {
                            ret = ret * 10 + c;
                            ++start;
                        }
                        else if (c === -2) {
                            ++start;
                            while (start < end) {
                                c = str.charCodeAt(start) - 48;
                                if (c >= 0 && c < 10) {
                                    point = 10.0 * point + c;
                                    div = 10.0 * div;
                                    ++start;
                                }
                                else if (c === 53 || c === 21) {
                                    return parseScientific(neg * (ret + point / div), str, start + 1, end);
                                }
                                else {
                                    return neg * (ret + point / div);
                                }
                            }
                            return neg * (ret + point / div);
                        }
                        else if (c === 53 || c === 21) {
                            return parseScientific(neg * ret, str, start + 1, end);
                        }
                        else
                            break;
                    }
                    return neg * ret;
                }

                let NumericColumn = (function () {
                    function NumericColumn(data) {
                        this.data = data;
                        this.isDefined = true;
                    }
                    NumericColumn.prototype.getString = function (row) { return "" + this.data[row]; };
                    NumericColumn.prototype.getInteger = function (row) { return this.data[row] | 0; };
                    NumericColumn.prototype.getFloat = function (row) { return 1.0 * this.data[row]; };
                    NumericColumn.prototype.stringEquals = function (row, value) { return this.data[row] === fastParseFloat(value, 0, value.length); };
                    NumericColumn.prototype.areValuesEqual = function (rowA, rowB) { return this.data[rowA] === this.data[rowB]; };
                    NumericColumn.prototype.getValuePresence = function (row) { return 0 /* Present */; };
                    return NumericColumn;
                }());
                let MaskedNumericColumn = (function () {
                    function MaskedNumericColumn(data, mask) {
                        this.data = data;
                        this.mask = mask;
                        this.isDefined = true;
                    }
                    MaskedNumericColumn.prototype.getString = function (row) { return this.mask[row] === 0 /* Present */ ? "" + this.data[row] : null; };
                    MaskedNumericColumn.prototype.getInteger = function (row) { return this.mask[row] === 0 /* Present */ ? this.data[row] : 0; };
                    MaskedNumericColumn.prototype.getFloat = function (row) { return this.mask[row] === 0 /* Present */ ? this.data[row] : 0; };
                    MaskedNumericColumn.prototype.stringEquals = function (row, value) { return this.mask[row] === 0 /* Present */ ? this.data[row] === fastParseFloat(value, 0, value.length) : value === null || value === void 0; };
                    MaskedNumericColumn.prototype.areValuesEqual = function (rowA, rowB) { return this.data[rowA] === this.data[rowB]; };
                    MaskedNumericColumn.prototype.getValuePresence = function (row) { return this.mask[row]; };
                    return MaskedNumericColumn;
                }());
                let StringColumn = (function () {
                    function StringColumn(data) {
                        this.data = data;
                        this.isDefined = true;
                    }
                    StringColumn.prototype.getString = function (row) { return this.data[row]; };
                    StringColumn.prototype.getInteger = function (row) { let v = this.data[row]; return fastParseInt(v, 0, v.length); };
                    StringColumn.prototype.getFloat = function (row) { let v = this.data[row]; return fastParseFloat(v, 0, v.length); };
                    StringColumn.prototype.stringEquals = function (row, value) { return this.data[row] === value; };
                    StringColumn.prototype.areValuesEqual = function (rowA, rowB) { return this.data[rowA] === this.data[rowB]; };
                    StringColumn.prototype.getValuePresence = function (row) { return 0 /* Present */; };
                    return StringColumn;
                }());
                let MaskedStringColumn = (function () {
                    function MaskedStringColumn(data, mask) {
                        this.data = data;
                        this.mask = mask;
                        this.isDefined = true;
                    }
                    MaskedStringColumn.prototype.getString = function (row) { return this.mask[row] === 0 /* Present */ ? this.data[row] : null; };
                    MaskedStringColumn.prototype.getInteger = function (row) { if (this.mask[row] !== 0 /* Present */)
                        return 0; let v = this.data[row]; return fastParseInt(v || '', 0, (v || '').length); };
                    MaskedStringColumn.prototype.getFloat = function (row) { if (this.mask[row] !== 0 /* Present */)
                        return 0; let v = this.data[row]; return fastParseFloat(v || '', 0, (v || '').length); };
                    MaskedStringColumn.prototype.stringEquals = function (row, value) { return this.data[row] === value; };
                    MaskedStringColumn.prototype.areValuesEqual = function (rowA, rowB) { return this.data[rowA] === this.data[rowB]; };
                    MaskedStringColumn.prototype.getValuePresence = function (row) { return this.mask[row]; };
                    return MaskedStringColumn;
                }());

                let File = (function () {
                            function File(data) {
                                this.dataBlocks = data.dataBlocks.map(function (b) { return new DataBlock(b); });
                            }
                            File.prototype.toJSON = function () {
                                return this.dataBlocks.map(function (b) { return b.toJSON(); });
                            };
                            return File;
                }());

                let file = new File(unpacked);
                return file;

        //    }
        //    catch (e) {
        //        return CIFTools.ParserResult.error('' + e);
        //    }
        }

        MessagePackParse(state) { let ic = this.icn3d; ic.icn3dui;
            let thisClass = this;

            /*
             * Adapted from https://github.com/rcsb/mmtf-javascript
             * by Alexander Rose <alexander.rose@weirdbyte.de>, MIT License, Copyright (c) 2016
             */
            /**
             * decode all key-value pairs of a map into an object
             * @param  {Integer} length - number of key-value pairs
             * @return {Object} decoded map
             */
            function map(state, length) {
                let value = {};
                for (let i = 0; i < length; i++) {
                    let key = thisClass.MessagePackParse(state);
                    value[key] = thisClass.MessagePackParse(state);
                }
                return value;
            }
            /**
             * decode binary array
             * @param  {Integer} length - number of elements in the array
             * @return {Uint8Array} decoded array
             */
            function bin(state, length) {
                // This approach to binary parsing wastes a bit of memory to trade for speed compared to:
                //
                //   let value = buffer.subarray(offset, offset + length); //new Uint8Array(buffer.buffer, offset, length);
                //
                // It turns out that using the view created by subarray probably uses DataView
                // in the background, which causes the element access to be several times slower
                // than creating the new byte array.
                let value = new Uint8Array(length);
                let o = state.offset;
                for (let i = 0; i < length; i++)
                    value[i] = state.buffer[i + o];
                state.offset += length;
                return value;
            }
            /**
                 * decode array
                 * @param  {Integer} length - number of array elements
                 * @return {Array} decoded array
                 */
            function array(state, length) {
                let value = new Array(length);
                for (let i = 0; i < length; i++) {
                    value[i] = thisClass.MessagePackParse(state);
                }
                return value;
            }

            /**
             * decode string
             * @param  {Integer} length - number string characters
             * @return {String} decoded string
             */
            function str(state, length) {
                let value = utf8Read(state.buffer, state.offset, length);
                state.offset += length;
                return value;
            }

            let __chars = function () {
                let data = [];
                for (let i = 0; i < 1024; i++)
                    data[i] = String.fromCharCode(i);
                return data;
            }();

            function utf8Read(data, offset, length) {
                let chars = __chars;
                let str = void 0, chunk = [], chunkSize = 512, chunkOffset = 0;
                for (let i = offset, end = offset + length; i < end; i++) {
                    let byte = data[i];
                    // One byte character
                    if ((byte & 0x80) === 0x00) {
                        chunk[chunkOffset++] = chars[byte];
                    }
                    else if ((byte & 0xe0) === 0xc0) {
                        chunk[chunkOffset++] = chars[((byte & 0x0f) << 6) | (data[++i] & 0x3f)];
                    }
                    else if ((byte & 0xf0) === 0xe0) {
                        chunk[chunkOffset++] = String.fromCharCode(((byte & 0x0f) << 12) |
                            ((data[++i] & 0x3f) << 6) |
                            ((data[++i] & 0x3f) << 0));
                    }
                    else if ((byte & 0xf8) === 0xf0) {
                        chunk[chunkOffset++] = String.fromCharCode(((byte & 0x07) << 18) |
                            ((data[++i] & 0x3f) << 12) |
                            ((data[++i] & 0x3f) << 6) |
                            ((data[++i] & 0x3f) << 0));
                    }
                    else
                        throwError("Invalid byte " + byte.toString(16));
                    if (chunkOffset === chunkSize) {
                        str = str || [];
                        str[str.length] = chunk.join('');
                        chunkOffset = 0;
                    }
                }
                if (!str)
                    return chunk.slice(0, chunkOffset).join('');
                if (chunkOffset > 0) {
                    str[str.length] = chunk.slice(0, chunkOffset).join('');
                }
                return str.join('');
            }

            let type = state.buffer[state.offset];

            let value, length;
            // Positive FixInt
            if ((type & 0x80) === 0x00) {
                state.offset++;
                return type;
            }
            // FixMap
            if ((type & 0xf0) === 0x80) {
                length = type & 0x0f;
                state.offset++;
                return map(state, length);
            }
            // FixArray
            if ((type & 0xf0) === 0x90) {
                length = type & 0x0f;
                state.offset++;
                return array(state, length);
            }
            // FixStr
            if ((type & 0xe0) === 0xa0) {
                length = type & 0x1f;
                state.offset++;
                return str(state, length);
            }
            // Negative FixInt
            if ((type & 0xe0) === 0xe0) {
                value = state.dataView.getInt8(state.offset);
                state.offset++;
                return value;
            }
            switch (type) {
                // nil
                case 0xc0:
                    state.offset++;
                    return null;
                // false
                case 0xc2:
                    state.offset++;
                    return false;
                // true
                case 0xc3:
                    state.offset++;
                    return true;
                // bin 8
                case 0xc4:
                    length = state.dataView.getUint8(state.offset + 1);
                    state.offset += 2;
                    return bin(state, length);
                // bin 16
                case 0xc5:
                    length = state.dataView.getUint16(state.offset + 1);
                    state.offset += 3;
                    return bin(state, length);
                // bin 32
                case 0xc6:
                    length = state.dataView.getUint32(state.offset + 1);
                    state.offset += 5;
                    return bin(state, length);
                // float 32
                case 0xca:
                    value = state.dataView.getFloat32(state.offset + 1);
                    state.offset += 5;
                    return value;
                // float 64
                case 0xcb:
                    value = state.dataView.getFloat64(state.offset + 1);
                    state.offset += 9;
                    return value;
                // uint8
                case 0xcc:
                    value = state.buffer[state.offset + 1];
                    state.offset += 2;
                    return value;
                // uint 16
                case 0xcd:
                    value = state.dataView.getUint16(state.offset + 1);
                    state.offset += 3;
                    return value;
                // uint 32
                case 0xce:
                    value = state.dataView.getUint32(state.offset + 1);
                    state.offset += 5;
                    return value;
                // int 8
                case 0xd0:
                    value = state.dataView.getInt8(state.offset + 1);
                    state.offset += 2;
                    return value;
                // int 16
                case 0xd1:
                    value = state.dataView.getInt16(state.offset + 1);
                    state.offset += 3;
                    return value;
                // int 32
                case 0xd2:
                    value = state.dataView.getInt32(state.offset + 1);
                    state.offset += 5;
                    return value;
                // str 8
                case 0xd9:
                    length = state.dataView.getUint8(state.offset + 1);
                    state.offset += 2;
                    return str(state, length);
                // str 16
                case 0xda:
                    length = state.dataView.getUint16(state.offset + 1);
                    state.offset += 3;
                    return str(state, length);
                // str 32
                case 0xdb:
                    length = state.dataView.getUint32(state.offset + 1);
                    state.offset += 5;
                    return str(state, length);
                // array 16
                case 0xdc:
                    length = state.dataView.getUint16(state.offset + 1);
                    state.offset += 3;
                    return array(state, length);
                // array 32
                case 0xdd:
                    length = state.dataView.getUint32(state.offset + 1);
                    state.offset += 5;
                    return array(state, length);
                // map 16:
                case 0xde:
                    length = state.dataView.getUint16(state.offset + 1);
                    state.offset += 3;
                    return map(state, length);
                // map 32
                case 0xdf:
                    length = state.dataView.getUint32(state.offset + 1);
                    state.offset += 5;
                    return map(state, length);
            }
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class ParserUtils {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        alignCoords(coordsFrom, coordsTo, secondStruct, bKeepSeq, chainid_t, chainid, chainIndex, bChainAlign) { let ic = this.icn3d, me = ic.icn3dui;
          //var n = coordsFrom.length;
          let n =(coordsFrom.length < coordsTo.length) ? coordsFrom.length : coordsTo.length;

          let hAtoms = {}, rmsd;

          if(n < 4) alert("Please select at least four residues in each structure...");
          if(n >= 4) {
              if(ic.bAfMem) { // align to the query (membrane)
                ic.rmsd_suprTmp = me.rmsdSuprCls.getRmsdSuprCls(coordsTo, coordsFrom, n);
              }
              else {
                ic.rmsd_suprTmp = me.rmsdSuprCls.getRmsdSuprCls(coordsFrom, coordsTo, n);
              }

              // apply matrix for each atom
              if(ic.rmsd_suprTmp.rot !== undefined) {
                  let rot = ic.rmsd_suprTmp.rot;
                  if(rot[0] === null) alert("Please select more residues in each structure...");

                  let centerFrom = ic.rmsd_suprTmp.trans1;
                  let centerTo = ic.rmsd_suprTmp.trans2;
                  rmsd = ic.rmsd_suprTmp.rmsd;

                  if(rmsd) {
                      me.htmlCls.clickMenuCls.setLogCmd("realignment RMSD: " + rmsd.toPrecision(4), false);
                      let html = "<br><b>Realignment RMSD</b>: " + rmsd.toPrecision(4) + " &#8491;<br><br>";

                      if(ic.bAfMem && !me.cfg.chainalign) {
                        //if(window.dialog && window.dialog.hasClass('ui-dialog-content')) window.dialog.dialog( "close" );
                        html += me.utilsCls.getMemDesc();
                      }
                      $("#" + ic.pre + "dl_rmsd_html").html(html);
                      if(!me.cfg.bSidebyside) me.htmlCls.dialogCls.openDlg('dl_rmsd', 'Realignment RMSD');
                  }

                  let chainDone = {};
                  for(let i = 0, il = ic.structures[secondStruct].length; i < il; ++i) {
                      let chainidTmp = ic.structures[secondStruct][i];
                      // some chains were pushed twice in some cases
                      if(chainDone.hasOwnProperty(chainidTmp)) continue;

                      for(let j in ic.chains[chainidTmp]) {
                        let atom = ic.atoms[j];
                        atom.coord = ic.surfaceCls.transformMemPro(atom.coord, rot, centerFrom, centerTo);
                      }

                      chainDone[chainidTmp] = 1;
                  }

                  ic.bRealign = true;

                  if(!bChainAlign) {
                    ic.opts['color'] = 'identity';
                    ic.setColorCls.setColorByOptions(ic.opts, ic.hAtoms);
                  }

    /*
                  //if(!bKeepSeq) ic.setSeqAlignCls.setSeqAlignForRealign(chainid_t, chainid, chainIndex);
                  ic.setSeqAlignCls.setSeqAlignForRealign(chainid_t, chainid, chainIndex);
             
                  let bShowHighlight = false;
                  let seqObj = me.htmlCls.alignSeqCls.getAlignSequencesAnnotations(Object.keys(ic.alnChains), undefined, undefined, bShowHighlight);

                  let oriHtml =(chainIndex === 1) ? '' : $("#" + ic.pre + "dl_sequence2").html();
                  $("#" + ic.pre + "dl_sequence2").html(oriHtml + seqObj.sequencesHtml);
                  $("#" + ic.pre + "dl_sequence2").width(me.htmlCls.RESIDUE_WIDTH * seqObj.maxSeqCnt + 200);

                  me.htmlCls.dialogCls.openDlg('dl_alignment', 'Select residues in aligned sequences');
    */
                  // assign ic.qt_start_end
                  if(!ic.qt_start_end) ic.qt_start_end = [];

                  let curr_qt_start_end = this.getQtStartEndFromRealignResid(chainid_t, chainid);
                  ic.qt_start_end.push(curr_qt_start_end);

                  hAtoms = ic.hAtoms;
              }
          }

          return {hAtoms: hAtoms, rmsd: rmsd};
        }

        getQtStartEndFromRealignResid(chainid_t, chainid_q) { let ic = this.icn3d; ic.icn3dui;
            chainid_t.substr(0, chainid_t.indexOf('_')); 
            chainid_q.substr(0, chainid_q.indexOf('_')); 

            let qt_start_end = [];

            let resi2pos_t = {};
            for(let i = 0, il = ic.chainsSeq[chainid_t].length; i < il; ++i) {
                let resi = ic.chainsSeq[chainid_t][i].resi;
                resi2pos_t[resi] = i + 1;
            }

            let resi2pos_q = {};
            for(let i = 0, il = ic.chainsSeq[chainid_q].length; i < il; ++i) {
                let resi = ic.chainsSeq[chainid_q][i].resi;
                resi2pos_q[resi] = i + 1;
            }

            for(let i = 0, il = ic.realignResid[chainid_t].length; i < il && i < ic.realignResid[chainid_q].length; ++i) {
                let resid_t = ic.realignResid[chainid_t][i].resid;
                if(!resid_t) continue;

                let pos_t = resid_t.lastIndexOf('_');
                let resi_t = parseInt(resid_t.substr(pos_t + 1));
                let resid_q = ic.realignResid[chainid_q][i].resid;
                if(!resid_q) continue;

                let pos_q = resid_q.lastIndexOf('_');
                let resi_q = parseInt(resid_q.substr(pos_q + 1));

                let resiPos_t = resi2pos_t[resi_t];
                let resiPos_q = resi2pos_q[resi_q];

                qt_start_end.push({"q_start": resiPos_q, "q_end": resiPos_q, "t_start": resiPos_t, "t_end": resiPos_t}); 
            }

            return qt_start_end;
        }

        getMissingResidues(seqArray, type, chainid) { let ic = this.icn3d, me = ic.icn3dui;
            ic.chainsSeq[chainid] = [];

            // find the offset of MMDB sequence
            let offset = 0;
            if(type === 'mmdbid' || type === 'align') {
                for(let i = 0, il = seqArray.length; i < il; ++i) {
                    if(seqArray[i][0] != 0) {
                        offset = seqArray[i][0] - (i + 1);
                        break;
                    }
                }
            }

            //let prevResi = 0;
            let prevResi = offset;
            for(let i = 0, il = seqArray.length; i < il; ++i) {
                let seqName, resiPos;
                // mmdbid: ["0","R","ARG"],["502","V","VAL"]; mmcifid: [1, "ARG"]; align: ["0","R","ARG"] //align: [1, "0","R","ARG"]
                if(type === 'mmdbid') {
                    seqName = seqArray[i][1];
                    resiPos = 0;
                }
                else if(type === 'mmcifid') {
                    seqName = seqArray[i][1];
                    seqName = me.utilsCls.residueName2Abbr(seqName);
                    resiPos = 0;
                }
                else if(type === 'align') {
                    seqName = seqArray[i][1];
                    resiPos = 0;
                }

                // fix some missing residue names such as residue 6 in 5C1M_A
                if(seqName === '') {
                    seqName = 'x';
                }

                let resObject = {};

                if(!ic.bUsePdbNum) {
                    resObject.resi = i + 1;
                }
                else {
                    //if(type === 'mmdbid' || type === 'align') {
                    //    resObject.resi =(seqArray[i][resiPos] == '0') ? i + 1 + offset : seqArray[i][resiPos];
                    //}
                    //else {
                        resObject.resi =(seqArray[i][resiPos] == '0') ? parseInt(prevResi) + 1 : seqArray[i][resiPos];
                    //}
                }

                //resObject.resi =(seqArray[i][resiPos] == '0') ? i + 1 + offset : seqArray[i][resiPos];

                resObject.name = (type === 'align') ? seqName.toLowerCase() : seqName;

                ic.chainsSeq[chainid].push(resObject);

                prevResi = resObject.resi;
            }
        }

        //Generate the 2D interaction diagram for the structure "mmdbid", which could be PDB ID. The 2D
        //interaction diagram is only available when the input is NCBI MMDB ID, i.e., the URL is something like "&mmdbid=...".
        async set2DDiagramsForAlign(mmdbid1, mmdbid2) { let ic = this.icn3d, me = ic.icn3dui;
            me.htmlCls.dialogCls.openDlg('dl_2ddgm', 'Interactions');

        ///       mmdbid1 = mmdbid1.substr(0, 4);
        ///       mmdbid2 = mmdbid2.substr(0, 4);

            let url1 = me.htmlCls.baseUrl + "mmdb/mmdb_strview.cgi?v=2&program=icn3d&uid="+mmdbid1+"&intrac=1";
            let url2 = me.htmlCls.baseUrl + "mmdb/mmdb_strview.cgi?v=2&program=icn3d&uid="+mmdbid2+"&intrac=1";

            if(me.cfg.inpara !== undefined) {
                url1 += me.cfg.inpara;
                url2 += me.cfg.inpara;
            }

            let prms1 = me.getAjaxPromise(url1, 'jsonp');
            let prms2 = me.getAjaxPromise(url2, 'jsonp');

            let allPromise = Promise.allSettled([prms1, prms2]);
            let dataArray = await allPromise;
            
            // ic.interactionData1 = (me.bNode) ? dataArray[0] : dataArray[0].value;
            ic.interactionData1 = dataArray[0].value;
            ic.html2ddgm = '';
            ic.diagram2dCls.draw2Ddgm(ic.interactionData1, mmdbid1, 0);
            if(me.cfg.show2d) me.htmlCls.dialogCls.openDlg('dl_2ddgm', 'Interactions');


            // ic.interactionData2 = (me.bNode) ? dataArray[1] : dataArray[1].value;
            ic.interactionData2 = dataArray[1].value;
            ic.diagram2dCls.draw2Ddgm(ic.interactionData2, mmdbid2, 1);

            ic.html2ddgm += "<br>" + ic.diagram2dCls.set2DdgmNote(true);
            $("#" + ic.pre + "dl_2ddgm_html").html(ic.html2ddgm);

            ic.b2DShown = true;

            /// if(ic.deferredViewinteraction !== undefined) ic.deferredViewinteraction.resolve();
        }

        async set2DDiagramsForChainalign(chainidArray) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            me.htmlCls.dialogCls.openDlg('dl_2ddgm', 'Interactions');

            let ajaxArray = [];
            for(let index = 0, indexLen = chainidArray.length; index < indexLen; ++index) {
               let pos = chainidArray[index].indexOf('_');
               let mmdbid = chainidArray[index].substr(0, pos).toUpperCase();

               let url = me.htmlCls.baseUrl + "mmdb/mmdb_strview.cgi?v=2&program=icn3d&uid="+mmdbid+"&intrac=1";

               if(me.cfg.inpara !== undefined) url += me.cfg.inpara;

               let twodAjax = me.getAjaxPromise(url, 'jsonp');

               ajaxArray.push(twodAjax);
            }

            let allPromise = Promise.allSettled(ajaxArray);
            try {
                let dataArray = await allPromise;
                thisClass.parse2DDiagramsData(dataArray, chainidArray);
            }
            catch(err) {
                
            }          
        }

        parse2DDiagramsData(dataArray, chainidArray) { let ic = this.icn3d, me = ic.icn3dui;
            //var dataArray =(chainidArray.length == 1) ? [dataInput] : dataInput;

            ic.html2ddgm = '';

            // Each argument is an array with the following structure: [ data, statusText, jqXHR ]
            //var data2 = v2[0];
            for(let index = 0, indexl = chainidArray.length; index < indexl; ++index) {
                // let data = (me.bNode) ? dataArray[index] : dataArray[index].value;//[0];
                let data = dataArray[index].value;//[0];
                let mmdbid = chainidArray[index].substr(0, chainidArray[index].indexOf('_'));

                ic.diagram2dCls.draw2Ddgm(data, mmdbid, 0);
            }

            ic.html2ddgm += "<br>" + ic.diagram2dCls.set2DdgmNote(true);

            ic.b2DShown = true;
            $("#" + ic.pre + "dl_2ddgm_html").html(ic.html2ddgm);
            if(me.cfg.show2d) me.htmlCls.dialogCls.openDlg('dl_2ddgm', 'Interactions');

            /// if(ic.deferredViewinteraction !== undefined) ic.deferredViewinteraction.resolve();
        }

        download2Ddgm(mmdbid, structureIndex) {        this.set2DDiagrams(mmdbid);
        }

        set2DDiagrams(mmdbid) { let ic = this.icn3d, me = ic.icn3dui;
            me.htmlCls.dialogCls.openDlg('dl_2ddgm', 'Interactions');

            if(ic.b2DShown === undefined || !ic.b2DShown) {
                ic.html2ddgm = '';

                ic.diagram2dCls.draw2Ddgm(ic.interactionData, mmdbid);

                ic.html2ddgm += "<br>" + ic.diagram2dCls.set2DdgmNote();
                $("#" + ic.pre + "dl_2ddgm_html").html(ic.html2ddgm);
            }

            ic.b2DShown = true;
        }

        showLoading() { let ic = this.icn3d; ic.icn3dui;
              if($("#" + ic.pre + "wait")) $("#" + ic.pre + "wait").show();
              if($("#" + ic.pre + "canvas")) $("#" + ic.pre + "canvas").hide();
              if($("#" + ic.pre + "cmdlog")) $("#" + ic.pre + "cmdlog").hide();
        }

        hideLoading() { let ic = this.icn3d; ic.icn3dui;
            //if(ic.bCommandLoad === undefined || !ic.bCommandLoad) {
              if($("#" + ic.pre + "wait")) $("#" + ic.pre + "wait").hide();
              if($("#" + ic.pre + "canvas")) $("#" + ic.pre + "canvas").show();
              if($("#" + ic.pre + "cmdlog")) $("#" + ic.pre + "cmdlog").show();
            //}
        }

        setYourNote(yournote) { let ic = this.icn3d, me = ic.icn3dui;
            ic.yournote = yournote;
            $("#" + ic.pre + "yournote").val(ic.yournote);
            if(me.cfg.shownote) document.title = ic.yournote;
        }

        transformToOpmOri(pdbid) { let ic = this.icn3d; ic.icn3dui;
          // apply matrix for each atom
          if(ic.rmsd_supr !== undefined && ic.rmsd_supr.rot !== undefined) {
              let rot = ic.rmsd_supr.rot;
              let centerFrom = ic.rmsd_supr.trans1;
              let centerTo = ic.rmsd_supr.trans2;
              ic.rmsd_supr.rmsd;

              let dxymaxsq = 0;
              for(let i in ic.atoms) {
                let atom = ic.atoms[i];

                atom.coord = ic.surfaceCls.transformMemPro(atom.coord, rot, centerFrom, centerTo);
                let xysq = atom.coord.x * atom.coord.x + atom.coord.y * atom.coord.y;
                if(Math.abs(atom.coord.z) <= 25 && xysq > dxymaxsq) {
                    dxymaxsq = xysq;
                }
              }

              //ic.center = chainresiCalphaHash2.center;
              //ic.oriCenter = ic.center.clone();

              // add membranes
              // the membrane atoms belongs to the structure "pdbid"
              this.addMemAtoms(ic.halfBilayerSize, pdbid, Math.sqrt(dxymaxsq));

              // no rotation
              ic.bStopRotate = true;

              ic.bOpm = true;

              // show transmembrane features
              $("#" + ic.pre + "togglememli").show();
              $("#" + ic.pre + "adjustmemli").show();
              $("#" + ic.pre + "selectplaneli").show();
              //$("#" + ic.pre + "anno_transmemli").show();
          }
          else {
              ic.bOpm = false;
          }
        }

        transformToOpmOriForAlign(pdbid, chainresiCalphaHash2, bResi_ori) { let ic = this.icn3d, me = ic.icn3dui;
          if(chainresiCalphaHash2 !== undefined) {
              let chainresiCalphaHash1 = ic.loadPDBCls.getChainCalpha(ic.chains, ic.atoms, bResi_ori, pdbid);

              let bOneChain =(Object.keys(chainresiCalphaHash1.chainresiCalphaHash).length == 1 || Object.keys(chainresiCalphaHash2.chainresiCalphaHash).length == 1) ? true : false;

              let coordsFrom = [], coordsTo = [];
              for(let chain in chainresiCalphaHash1.chainresiCalphaHash) {
                  if(chainresiCalphaHash2.chainresiCalphaHash.hasOwnProperty(chain)) {
                      let coord1 = chainresiCalphaHash1.chainresiCalphaHash[chain];
                      let coord2 = chainresiCalphaHash2.chainresiCalphaHash[chain];

                      if(coord1.length == coord2.length || bOneChain) {
                          coordsFrom = coordsFrom.concat(coord1);
                          coordsTo = coordsTo.concat(coord2);
                      }

                      if(coordsFrom.length > 500) break; // no need to use all c-alpha
                  }
              }

              //var n = coordsFrom.length;
              let n =(coordsFrom.length < coordsTo.length) ? coordsFrom.length : coordsTo.length;

              if(n >= 4) {
                  ic.rmsd_supr = me.rmsdSuprCls.getRmsdSuprCls(coordsFrom, coordsTo, n);

                  // apply matrix for each atom
                  if(ic.rmsd_supr.rot !== undefined && ic.rmsd_supr.rmsd < 0.1) {
                      let rot = ic.rmsd_supr.rot;
                      let centerFrom = ic.rmsd_supr.trans1;
                      let centerTo = ic.rmsd_supr.trans2;
                      let rmsd = ic.rmsd_supr.rmsd;

                      me.htmlCls.clickMenuCls.setLogCmd("RMSD of alignment to OPM: " + rmsd.toPrecision(4), false);
                      //$("#" + ic.pre + "dl_rmsd_html").html("<br><b>RMSD of alignment to OPM</b>: " + rmsd.toPrecision(4) + " &#8491;<br><br>");
                      //if(!me.cfg.bSidebyside) me.htmlCls.dialogCls.openDlg('dl_rmsd', 'RMSD of alignment to OPM');

                      let dxymaxsq = 0;
                      for(let i in ic.atoms) {
                        let atom = ic.atoms[i];

                        atom.coord = ic.surfaceCls.transformMemPro(atom.coord, rot, centerFrom, centerTo);
                        let xysq = atom.coord.x * atom.coord.x + atom.coord.y * atom.coord.y;
                        if(Math.abs(atom.coord.z) <= 25 && xysq > dxymaxsq) {
                            dxymaxsq = xysq;
                        }
                      }

                      ic.center = chainresiCalphaHash2.center;
                      ic.oriCenter = ic.center.clone();

                      // add membranes
                      this.addMemAtoms(ic.halfBilayerSize, pdbid, Math.sqrt(dxymaxsq));

                      // no rotation
                      ic.bStopRotate = true;

                      ic.bOpm = true;

                      // show transmembrane features
                      $("#" + ic.pre + "togglememli").show();
                      $("#" + ic.pre + "adjustmemli").show();
                      $("#" + ic.pre + "selectplaneli").show();
                      //$("#" + ic.pre + "anno_transmemli").show();
                  }
                  else {
                      ic.bOpm = false;
                  }
              }
              else {
                  ic.bOpm = false;
              }
          }
        }

        addOneDumAtom(pdbid, atomName, x, y, z, lastSerial) { let ic = this.icn3d, me = ic.icn3dui;
          let resn = 'DUM';
          let chain = 'MEM';
          let resi = 1;
          let coord = new THREE.Vector3(x, y, z);

          let atomDetails = {
              het: true, // optional, used to determine chemicals, water, ions, etc
              serial: ++lastSerial,         // required, unique atom id
              name: atomName,             // required, atom name
              alt: undefined,               // optional, some alternative coordinates
              resn: resn,             // optional, used to determine protein or nucleotide
              structure: pdbid,   // optional, used to identify structure
              chain: chain,           // optional, used to identify chain
              resi: resi,             // optional, used to identify residue ID
              coord: coord,           // required, used to draw 3D shape
              b: undefined, // optional, used to draw B-factor tube
              elem: atomName,             // optional, used to determine hydrogen bond
              bonds: [],              // required, used to connect atoms
              ss: '',             // optional, used to show secondary structures
              ssbegin: false,         // optional, used to show the beginning of secondary structures
              ssend: false,            // optional, used to show the end of secondary structures
              color: me.parasCls.atomColors[atomName]
          };
          ic.atoms[lastSerial] = atomDetails;

          ic.chains[pdbid + '_MEM'][lastSerial] = 1;
          ic.residues[pdbid + '_MEM_1'][lastSerial] = 1;

          ic.chemicals[lastSerial] = 1;

          ic.dAtoms[lastSerial] = 1;
          ic.hAtoms[lastSerial] = 1;

          return lastSerial;
        }

        addMemAtoms(dmem, pdbid, dxymax) { let ic = this.icn3d; ic.icn3dui;
          if(!pdbid) return;

          let npoint=40; // points in radius
          let step = 2;
          let maxpnt=2*npoint+1; // points in diameter
          let fn=step*npoint; // center point

          //var dxymax = npoint / 2.0 * step;

          pdbid =(pdbid) ? pdbid.toUpperCase() : ic.defaultPdbId;

          ic.structures[pdbid].push(pdbid + '_MEM');
          ic.chains[pdbid + '_MEM'] = {};
          ic.residues[pdbid + '_MEM_1'] = {};

          ic.chainsSeq[pdbid + '_MEM'] = [{'name':'DUM', 'resi': 1}];
          let lastSerial = Object.keys(ic.atoms).length;
          for(let i = 0; i < 1000; ++i) {
              if(!ic.atoms.hasOwnProperty(lastSerial + i)) {
                  lastSerial = lastSerial + i - 1;
                  break;
              }
          }

          for(let i=0; i < maxpnt; ++i) {
             for(let j=0; j < maxpnt; ++j) {
                let a=step*i-fn;
                let b=step*j-fn;
                let dxy=Math.sqrt(a*a+b*b);
                if(dxy < dxymax) {
                      let c=-dmem-0.4;
                      // Resn: DUM, name: N, a,b,c
                      lastSerial = this.addOneDumAtom(pdbid, 'N', a, b, c, lastSerial);

                      c=dmem+0.4;
                      // Resn: DUM, name: O, a,b,c
                      lastSerial = this.addOneDumAtom(pdbid, 'O', a, b, c, lastSerial);
                }
             }
          }
        }

        setMaxD() { let ic = this.icn3d; ic.icn3dui;
            let pmin = new THREE.Vector3( 9999, 9999, 9999);
            let pmax = new THREE.Vector3(-9999,-9999,-9999);
            let psum = new THREE.Vector3();
            let cnt = 0;
            // assign atoms
            for(let i in ic.atoms) {
                let atom = ic.atoms[i];
                let coord = atom.coord;
                psum.add(coord);
                pmin.min(coord);
                pmax.max(coord);
                ++cnt;

                if(atom.het) {
                  //if($.inArray(atom.elem, me.parasCls.ionsArray) !== -1) {
                  if(atom.bonds.length == 0) {
                    ic.ions[atom.serial] = 1;
                  }
                  else {
                    ic.chemicals[atom.serial] = 1;
                  }
                }
            } // end of for


            ic.pmin = pmin;
            ic.pmax = pmax;

            ic.cnt = cnt;

            //ic.maxD = ic.pmax.distanceTo(ic.pmin);
            //ic.center = psum.multiplyScalar(1.0 / ic.cnt);
            ic.center = this.getGeoCenter(ic.pmin, ic.pmax);

            ic.maxD = this.getStructureSize(ic.atoms, ic.pmin, ic.pmax, ic.center);

            if(ic.maxD < 5) ic.maxD = 5;
            ic.oriMaxD = ic.maxD;
            ic.oriCenter = ic.center.clone();
        }

        //Update the dropdown menu and show the structure by calling the function "draw()".
        async renderStructure() { let ic = this.icn3d, me = ic.icn3dui;
          if(ic.bInitial) {
              //$.extend(ic.opts, ic.opts);
              if(ic.bOpm &&(me.cfg.align !== undefined || me.cfg.chainalign !== undefined)) { // show membrane
                  let resid = ic.selectedPdbid + '_MEM_1';
                  for(let i in ic.residues[resid]) {
                      let atom = ic.atoms[i];
                      atom.style = 'stick';
                      atom.color = me.parasCls.atomColors[atom.name];
                      ic.atomPrevColors[i] = atom.color;
                      ic.dAtoms[i] = 1;
                  }
              }
              if(me.cfg.command !== undefined && me.cfg.command !== '') {
                  ic.bRender = false;
                  ic.drawCls.draw();
              }
              else {
                  ic.selectionCls.oneStructurePerWindow(); // for alignment
                  ic.drawCls.draw();
              }

              if(ic.bOpm) {
                  let axis = new THREE.Vector3(1,0,0);
                  let angle = -0.5 * Math.PI;
                  ic.transformCls.setRotation(axis, angle);
              }
              //if(Object.keys(ic.structures).length > 1) {
              //    $("#" + ic.pre + "alternate").show();
              //}
              //else {
              //    $("#" + ic.pre + "alternate").hide();
              //}

              $("#" + ic.pre + "alternate").show();
          }
          else {
              ic.selectionCls.saveSelectionIfSelected();
              ic.drawCls.draw();
          }
          
          // set defined sets before loadScript
          if(ic.bInitial) {
            // if(me.cfg.mobilemenu) {
            //     me.htmlCls.shownMenus = me.hashUtilsCls.cloneHash(me.htmlCls.simpleMenus);
            //     let bNoSave = true;
            //     me.htmlCls.clickMenuCls.applyShownMenus(bNoSave);
            // }

            // else {
            //     me.htmlCls.shownMenus = me.hashUtilsCls.cloneHash(me.htmlCls.allMenus);
            //     me.htmlCls.clickMenuCls.applyShownMenus();
            // }
            
            if(me.cfg.showsets) {
                 ic.definedSetsCls.showSets();
            }
          }

          //      if(ic.bInitial && me.cfg.command !== undefined && me.cfg.command !== '') {
          if(!ic.bCommandLoad && ic.bInitial && me.cfg.command !== undefined && me.cfg.command !== '') {
            this.processCommand();
            // final step resolved ic.deferred
            //await ic.loadScriptCls.loadScript(me.cfg.command, undefined, true);
            //ic.loadScriptCls.loadScript(me.cfg.command);
          }

          //if(me.cfg.align !== undefined || me.cfg.chainalign !== undefined || ic.bRealign ||( ic.bInputfile && ic.InputfileType == 'pdb' && Object.keys(ic.structures).length >= 2) ) {
          if(Object.keys(ic.structures).length >= 2) {
              $("#" + ic.pre + "mn2_alternateWrap").show();
              //$("#" + ic.pre + "mn2_realignWrap").show();
          }
          else {
              $("#" + ic.pre + "mn2_alternateWrap").hide();
              //$("#" + ic.pre + "mn2_realignWrap").hide();
          }
     
          // display the structure right away. load the mns and sequences later
          setTimeout(async function(){
                if(ic.bInitial) {
                // if(ic.bInitial && (!ic.bAnnoShown || ic.bResetAnno)) {
                  if(me.cfg.align !== undefined || me.cfg.chainalign !== undefined) {
                      // expand the toolbar
                      let id = ic.pre + 'selection';
                      $("#" + id).show();
                      $("#" + id + "_expand").hide();
                      $("#" + id + "_shrink").show();

                      if(me.cfg.align !== undefined && me.cfg.atype != 2) { // atype = 2: dynamic VAST+
                          let bShowHighlight = false;                  
                          let seqObj = me.htmlCls.alignSeqCls.getAlignSequencesAnnotations(Object.keys(ic.alnChains), undefined, undefined, bShowHighlight);
                          $("#" + ic.pre + "dl_sequence2").html(seqObj.sequencesHtml);
                          $("#" + ic.pre + "dl_sequence2").width(me.htmlCls.RESIDUE_WIDTH * seqObj.maxSeqCnt + 200);
                      }
                  }
                  //ic.definedSetsCls.setProtNuclLigInMenu();
                  if(me.cfg.showanno) {
                       let cmd = "view annotations";
                       me.htmlCls.clickMenuCls.setLogCmd(cmd, true);
                       await ic.showAnnoCls.showAnnotations(); 
                  }

                  if(me.cfg.closepopup || me.cfg.imageonly) {
                      ic.resizeCanvasCls.closeDialogs();
                  }
              }
              else {
                  ic.hlUpdateCls.updateHlAll();
              }
              if($("#" + ic.pre + "atomsCustom").length > 0) $("#" + ic.pre + "atomsCustom")[0].blur();
              ic.bInitial = false;

              if(me.cfg.imageonly) ic.saveFileCls.saveFile(undefined, 'png', undefined, true);
          }, 0);
        }

        processCommand() { let ic = this.icn3d, me = ic.icn3dui;
            if(Object.keys(ic.structures).length == 1) {
                let id = Object.keys(ic.structures)[0];
                me.cfg.command = me.cfg.command.replace(new RegExp('!','g'), id + '_');
            }
        }

        getMassCenter(psum, cnt) { let ic = this.icn3d; ic.icn3dui;
            return psum.multiplyScalar(1.0 / cnt);
        }

        getGeoCenter(pmin, pmax) { let ic = this.icn3d; ic.icn3dui;
            return pmin.clone().add(pmax).multiplyScalar(0.5);
        }

        getStructureSize(atoms, pmin, pmax, center) { let ic = this.icn3d; ic.icn3dui;
            let maxD = 0;
            for(let i in atoms) {
                let coord = ic.atoms[i].coord;
                if(Math.round(pmin.x) == Math.round(coord.x) || Math.round(pmin.y) == Math.round(coord.y)
                  || Math.round(pmin.z) == Math.round(coord.z) || Math.round(pmax.x) == Math.round(coord.x)
                  || Math.round(pmax.y) == Math.round(coord.y) || Math.round(pmax.z) == Math.round(coord.z)) {
                    let dist = coord.distanceTo(center) * 2;
                    if(dist > maxD) {
                        maxD = dist;
                    }
                }
            }

            return maxD;
        }

        async checkMemProteinAndRotate() { let ic = this.icn3d, me = ic.icn3dui;
            if(!ic.bCheckMemProtein) {
                ic.bCheckMemProtein = true;

                let afid = (me.cfg.afid) ? me.cfg.afid : me.cfg.mmdbafid;

                await ic.ParserUtilsCls.checkMemProtein(afid);
            //}

                // rotate for links from Membranome
                if(me.cfg.url && me.cfg.url.indexOf('membranome') != -1) {
                    let axis = new THREE.Vector3(1,0,0);
                    let angle = -90 / 180.0 * Math.PI;

                    ic.transformCls.setRotation(axis, angle);
                }
            }
        }

        async checkMemProtein(afid) { let ic = this.icn3d, me = ic.icn3dui;
          //ic.deferredAfMem = $.Deferred(function() {
            try {
                let url = me.htmlCls.baseUrl + "vastdyn/vastdyn.cgi?afid2mem=" + afid;
                let data = await me.getAjaxPromise(url, 'jsonp');

                if(data && data.pdbid) {
                  let question = "This is a single-spanning (bitopic) transmembrane protein according to the Membranome database. Do you want to align the protein with the model from Membranome? If you click \"OK\", you can press the letter \"a\" to alternate the structures.";

                  if (me.bNode) return;

                  if (me.cfg.afmem == 'off') {
                    // do nothing
                    /// if(ic.deferredOpm !== undefined) ic.deferredOpm.resolve();
                  }
                  else if (me.cfg.afmem == 'on' || confirm(question)) {     
                    try {  
                        let url2 = "https://storage.googleapis.com/membranome-assets/pdb_files/proteins/" + data.pdbid + ".pdb";
                        let afMemdata = await me.getAjaxPromise(url2, 'text');

                        ic.bAfMem = true;
                        if(!me.bNode) $("#" + me.pre + "togglememli").show(); // show the menu "View > Toggle Membrane"

                        // append the PDB
                        let pdbid = data.pdbid.substr(0, data.pdbid.indexOf('_'));
                        let bOpm = true, bAppend = true;
                        await ic.pdbParserCls.loadPdbData(afMemdata, pdbid, bOpm, bAppend);

                        if(bAppend) {
                            if(ic.bSetChainsAdvancedMenu) ic.definedSetsCls.showSets();
                            if(ic.bAnnoShown) {
                                await ic.showAnnoCls.showAnnotations();
                                ic.annotationCls.resetAnnoTabAll();
                            }
                        }

                        // Realign by sequence alignment with the residues in "segment", i.e., transmembrane helix
                        let segment = data.segment;   // e.g., " 361- 379 ( 359- 384)", the first range is trnasmembrane range, 
                                                    //the second range is the range of the helix
                        let range = segment.replace(/ /gi, '').split('(')[0]; //361-379
                        ic.afmem_start_end = range.split('-');

                        ic.hAtoms = {};
                        ic.dAtoms = {};

                        // get the AlphaFold structure
                        for(let i in ic.atoms) {
                            if(ic.atoms[i].structure != pdbid) {
                                ic.hAtoms[i] = 1;
                            }
                            ic.dAtoms[i] = 1;
                        }

                        // get the transmembrane from the model of Membranome
                        for(let i = parseInt(ic.afmem_start_end[0]); i <= parseInt(ic.afmem_start_end[1]); ++i) {
                            ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.residues[pdbid + '_A_' + i]);
                        }

                        await ic.realignParserCls.realignOnSeqAlign(pdbid);
                    }
                    catch(err) {
                          console.log("Error in retrieving matched PDB from Membranome...");
                          ///// if(ic.deferredAfMem !== undefined) ic.deferredAfMem.resolve();
                          /// if(ic.deferredMmdbaf !== undefined) ic.deferredMmdbaf.resolve();
                          /// if(ic.deferredOpm !== undefined) ic.deferredOpm.resolve();
                          return;
                    }
                  }
                }
                else {
                    /// if(ic.deferredMmdbaf !== undefined) ic.deferredMmdbaf.resolve();
                    /// if(ic.deferredOpm !== undefined) ic.deferredOpm.resolve();
                }
            }
            catch(err) {
                  console.log("Error in finding matched PDB in Membranome...");
                  ///// if(ic.deferredAfMem !== undefined) ic.deferredAfMem.resolve();
                  /// if(ic.deferredMmdbaf !== undefined) ic.deferredMmdbaf.resolve();
                  /// if(ic.deferredOpm !== undefined) ic.deferredOpm.resolve();
                  return;
            }
          //});

          //return ic.deferredAfMem.promise();
        }

        getResi(chainid, resiPos) { let ic = this.icn3d; ic.icn3dui;
            // let resi;

            // if(bRealign) {
            //     resi = resiPos;
            // }
            // else {
            //     if(!ic.chainsSeq[chainid] || !ic.chainsSeq[chainid][resiPos]) {
            //         resi = '';
            //     }
            //     else {
            //         resi = ic.chainsSeq[chainid][resiPos].resi;
            //     }
            // }
            let resid = ic.ncbi2resid[chainid + '_' + (resiPos+1).toString()];
            let resi = (resid) ? resid.substr(resid.lastIndexOf('_') + 1) : '';

            return resi;
        }

        getResiNCBI(chainid, resi) { let ic = this.icn3d; ic.icn3dui;
            let residNCBI = ic.resid2ncbi[chainid + '_' + resi];
            let resiNCBI = (residNCBI) ? parseInt(residNCBI.substr(residNCBI.lastIndexOf('_') + 1)) : 0;
                
            return resiNCBI;
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class LoadAtomData {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //type: "mmdbid", "mmcifid", "align"
        //alignType: "query", "target" for chain to chain 3D alignment

        //This function was used to parse atom "data" to set up parameters for the 3D viewer. "type" is mmcifid or mmdbid.
        //"id" is the MMDB ID or mmCIF ID.
        // thi sfunction is NOT used for mmCIF loading any more
        loadAtomDataIn(data, id, type, seqalign, alignType, chainidInput, chainIndex, bLastQuery, bNoSeqalign) { let ic = this.icn3d, me = ic.icn3dui;
            //ic.init();
            ic.pmin = new THREE.Vector3( 9999, 9999, 9999);
            ic.pmax = new THREE.Vector3(-9999,-9999,-9999);
            ic.psum = new THREE.Vector3();

            let atoms = data.atoms;

            //let serialBase =(alignType === undefined || alignType === 'target') ? 0 : ic.lastTargetSerial;
            let serialBase = (ic.atoms) ? Object.keys(ic.atoms).length : 0;

            let serial = serialBase;

            let serial2structure = {}; // for "align" only
            let mmdbid2pdbid = {}; // for "align" only
    /*
            if(alignType === undefined || alignType === 'target') {
                ic.pmid = data.pubmedId;

                ic.chainid2title = {};
                ic.chainid2sid = {};
            }
            else {
                ic.pmid2 = data.pubmedId;
            }
    */

            ic.pmid = data.pubmedId;
            if(ic.chainid2title === undefined) ic.chainid2title = {};
            if(ic.chainid2sid === undefined) ic.chainid2sid = {};

            let chainid2kind = {}, chainid2color = {};

            if(type === 'align') {
              //serial2structure
              ic.pmid = "";
              ic.molTitle = "";
              if(me.cfg.inpara && me.cfg.inpara.indexOf('atype=1') !== -1) {
                ic.molTitle = 'Invariant Core Structure Alignment (VAST) of ';
              }
              else if(me.cfg.inpara && me.cfg.inpara.indexOf('atype=2') !== -1) {
                ic.molTitle = 'Structure Alignment (TM-align) of ';
              }
              else {
                ic.molTitle = 'Structure Alignment (VAST) of ';
              }
              

              let bTitle = false;
              for(let i = 0, il = data.alignedStructures[0].length; i < il; ++i) {
                  let structure = data.alignedStructures[0][i];

                  if(i === 1) {
                      ic.secondId = structure.pdbId; // set the second pdbid to add indent in the structure and chain mns
                  }

                  let pdbidTmp = structure.pdbId;
                  let mmdbidTmp = structure.mmdbId;

                  for(let j = structure.serialInterval[0], jl = structure.serialInterval[1]; j <= jl; ++j) {
                      serial2structure[j] = pdbidTmp.toString();
                      mmdbid2pdbid[mmdbidTmp] = pdbidTmp;
                  }
                  
                  for(let j = 0, jl = structure.molecules.length; j < jl; ++j) {
                      let chain = structure.molecules[j].chain;
                      chain = chain.replace(/_/g, ''); // change "A_1" to "A1"

                      let kind = structure.molecules[j].kind;
                      let title = structure.molecules[j].name;
                      //var seq = structure.molecules[j].sequence;
                      let sid = structure.molecules[j].sid;

                      let chainid = pdbidTmp + '_' + chain;

                      //if(ic.bFullUi) chainid2seq[chainid] = seq;
                      chainid2kind[chainid] = kind;

                      ic.chainid2title[chainid] = title;
                      if(sid !== undefined) ic.chainid2sid[chainid] = sid;
                  }

                  ic.molTitle +=  "<a href=\"" + me.htmlCls.baseUrl + "mmdb/mmdbsrv.cgi?uid=" + structure.pdbId.toUpperCase() + "\" target=\"_blank\">" + structure.pdbId.toUpperCase() + "</a>";

                  if(structure.descr !== undefined) ic.pmid += structure.descr.pubmedid;
                  if(i === 0) {
                      ic.molTitle += " and ";
                      if(structure.descr !== undefined) ic.pmid += "_";
                  }

                  bTitle = true;
              }

              ic.molTitle += ' from VAST+';

              if(!bTitle) ic.molTitle = '';
            }
            else { // mmdbid or mmcifid
                if(data.descr !== undefined) ic.molTitle = data.descr.name;
                if(type === 'mmdbid') {
                  let pdbidTmp = (isNaN(id)) ? id : data.pdbId;
                  let chainHash = {};

                  if(ic.alignmolid2color === undefined) ic.alignmolid2color = [];

                  let molidCnt = 1;
               
                  for(let molid in data.moleculeInfor) {
                      if(Object.keys(data.moleculeInfor[molid]).length === 0) continue;

                      let chain = data.moleculeInfor[molid].chain.trim();

                      // remove "_" in chain name
                    //   if(parseInt(me.cfg.date) >= 20231001 || (!me.cfg.date && parseInt(me.utilsCls.getDateDigitStr()) >= 20231001)) {
                        chain = chain.replace(/_/g, '');
                    //   }

                      let chainid = pdbidTmp + '_' + chain;

                      if(chainHash.hasOwnProperty(chain)) {
                          ++chainHash[chain];
                          chainid += chainHash[chain];
                      }
                      else {
                          chainHash[chain] = 1;
                      }

                      if(((ic.mmdbid_q !== undefined && ic.mmdbid_q === ic.mmdbid_t)) && alignType === 'query') ;

                      //if(chainidInput && chainidInput.substr(chainidInput.indexOf('_') + 1) == chain) chainid = chainidInput;
     
                      let kind = data.moleculeInfor[molid].kind;
                      let color = data.moleculeInfor[molid].color;
                      let sid = data.moleculeInfor[molid].sid;

                      chainid2kind[chainid] = kind;
                      chainid2color[chainid] = color;

                      if(kind == 'protein') ic.organism = data.moleculeInfor[molid].taxonomyName.toLowerCase();

                      if(sid !== undefined) ic.chainid2sid[chainid] = sid;

                      if(ic.pdbid_chain2title === undefined) ic.pdbid_chain2title = {};
                      ic.pdbid_chain2title[chainid] = data.moleculeInfor[molid].name;

                      if(chain == chainid.substr(chainid.lastIndexOf('_')) ) {
                          let tmpHash = {};
                          tmpHash[molid] = molidCnt.toString();
                          ic.alignmolid2color.push(tmpHash);
                      }

                      ++molidCnt;
                  }
                }
            }

            if(type === 'mmdbid') {
                if(!ic.molTitleHash) ic.molTitleHash = {};
                ic.molTitleHash[id] = ic.molTitle;
            }
            
            let atomid2serial = {};
            let prevStructureNum = '', prevChainNum = '', prevResidueNum = '';
            let structureNum = '', chainNum = '', residueNum = '';
            let prevResi = 0, prevResiOri = 0, prevResn = ''; // continuous from 1 for each chain
            let bChainSeqSet = true;
            let bAddedNewSeq = false;
            let molid, prevMolid = '';

            let bPhosphorusOnly = me.utilsCls.isCalphaPhosOnly(atoms); //, "O3'", "O3*") || me.utilsCls.isCalphaPhosOnly(atoms, "P");
            let miscCnt = 0;
            let CSerial, prevCSerial, OSerial, prevOSerial;

            let biopolymerChainsHash = {};

            for(let i in atoms) {
                ++serial;

                atomid2serial[i] = serial;

                let atm = atoms[i];
                atm.serial = serial;

                let mmdbId;

                if(type === 'mmdbid' || type === 'mmcifid') {
                  mmdbId = id; // here mmdbId is pdbid or mmcif id
                }
                else if(type === 'align') {
                  mmdbId = serial2structure[serial]; // here mmdbId is pdbid
                }

                let bSetResi = false;

                //if(mmdbId !== prevmmdbId) resiArray = [];
                if(atm.chain === undefined && (type === 'mmdbid' || type === 'align')) {
                    if(type === 'mmdbid') {
                      molid = atm.ids.m;

                      if(ic.molid2chain[molid] !== undefined) {
                          let pos = ic.molid2chain[molid].indexOf('_');
                          atm.chain = ic.molid2chain[molid].substr(pos + 1);
                      }
                      else {
                            let miscName = 'Misc';

                            //if(atm.resn != prevResn || chainid2kind[chainNum] === 'solvent' || atm.resn === 'HOH' || atm.name == atm.elem) {
                            if((chainid2kind[chainNum] === 'protein' && chainid2kind[chainNum] === 'nucleotide' && atm.resi != prevResiOri)
                                ||(chainid2kind[chainNum] !== 'protein' && chainid2kind[chainNum] !== 'nucleotide'
                                &&(atm.resn.substr(0,3) != prevResn.substr(0,3) || atm.resi != prevResiOri || chainid2kind[chainNum] === 'solvent' || atm.resn === 'HOH')) ) {
                                ++miscCnt;
                            }

                            atm.resi_ori = atm.resi;
                            atm.resi = miscCnt;
                            bSetResi = true;

                            //if all are defined in the chain section, no "Misc" should appear
                            atm.chain = miscName;
                      }

                      //if(ic.mmdbid_q !== undefined && ic.mmdbid_q === ic.mmdbid_t && alignType === 'query') {
                          //atm.chain += me.htmlCls.postfix;
                      //}
                    }
                    else if(type === 'align') {
                      molid = atm.ids.m;

                      if(ic.pdbid_molid2chain[mmdbId + '_' + molid] !== undefined) {
                          atm.chain = ic.pdbid_molid2chain[mmdbId + '_' + molid];
                      }
                      else {
                          let miscName = 'Misc';

                          //if(atm.resn != prevResn || chainid2kind[chainNum] === 'solvent' || atm.resn === 'HOH' || atm.name == atm.elem) {
                          if((chainid2kind[chainNum] === 'protein' && chainid2kind[chainNum] === 'nucleotide' && atm.resi != prevResiOri)
                            ||(chainid2kind[chainNum] !== 'protein' && chainid2kind[chainNum] !== 'nucleotide'
                            &&(atm.resn.substr(0,3) != prevResn.substr(0,3) || atm.resi != prevResiOri || chainid2kind[chainNum] === 'solvent' || atm.resn === 'HOH')) ) {
                              ++miscCnt;

                              atm.resi_ori = atm.resi;
                              atm.resi = miscCnt;
                              bSetResi = true;
                          }

                          // chemicals do not have assigned chains.
                          atm.chain = miscName;
                      }
                    }
                }
                else {
                  atm.chain =(atm.chain === '') ? 'Misc' : atm.chain;
                }

                atm.chain = atm.chain.trim(); //.replace(/_/g, '');

                // remove "_" in chain name
                // if(parseInt(me.cfg.date) >= 20231001 || (!me.cfg.date && parseInt(me.utilsCls.getDateDigitStr()) >= 20231001)) {
                    atm.chain = atm.chain.replace(/_/g, '');
                // }

                // mmcif has pre-assigned structure in mmcifparser.cgi output
                if(type === 'mmdbid' || type === 'align') {
                    atm.structure = mmdbId;

                    if(type === 'mmdbid' &&((ic.mmdbid_q !== undefined && ic.mmdbid_q === ic.mmdbid_t))
                      && alignType === 'query') ;
                }

                structureNum = atm.structure;

                chainNum = structureNum + '_' + atm.chain;

                //if(ic.mmdbid_q !== undefined && ic.mmdbid_q === ic.mmdbid_t && alignType === 'query') chainNum += me.htmlCls.postfix;

                //var resiCorrection = 0;
                if(type === 'mmdbid' || type === 'align') {
                    if(!bSetResi) {
                        atm.resi_ori = atm.resi; //parseInt(atm.resi); // original PDB residue number, has to be integer
                        if(!ic.bUsePdbNum) {
                            atm.resi = atm.ids.r; // corrected for residue insertion code
                        }
                        else {
                            // make MMDB residue number consistent with PDB residue number
                            atm.resi = atm.resi_ori; // corrected for residue insertion code
                            //if(ic.chainid2offset && !ic.chainid2offset[chainNum]) ic.chainid2offset[chainNum] = atm.resi_ori - atm.ids.r;
                        }
                    }

                    //resiCorrection = atm.resi - atm.resi_ori;

                    let pos = atm.resn.indexOf(' ');
                    if(pos !== -1 && pos != 0) atm.resn = atm.resn.substr(0, pos);

                    // remember NCBI residue number
                    // atm.resiNCBI = atm.ids.r;
                    // ic.ncbi2resid[chainNum + '_' + atm.resiNCBI] = chainNum + '_' + atm.resi;
                    // ic.resid2ncbi[chainNum + '_' + atm.resi] = chainNum + '_' + atm.resiNCBI;
                }
                
                if(chainNum !== prevChainNum) {
                    prevResi = 0;
                }

                if(atm.resi !== prevResi) {
                    if(chainNum !== prevChainNum) {
                        prevCSerial = undefined;
                        prevOSerial = undefined;
                    }
                    else {
                        prevCSerial = CSerial;
                        prevOSerial = OSerial;
                    }
                }

                if(type === 'mmdbid') {
                    atm.coord = new THREE.Vector3(atm.coord[0], atm.coord[1], atm.coord[2]);
                    //if(ic.q_rotation !== undefined && ic.t_trans_add.length > 0 && !me.cfg.resnum && !me.cfg.resdef && chainIndex) {
                    //    atm = ic.chainalignParserCls.transformAtom(atm, chainIndex, alignType);
                    //}
                }
                else {
                    atm.coord = new THREE.Vector3(atm.coord.x, atm.coord.y, atm.coord.z);
                }

                let oneLetterRes = me.utilsCls.residueName2Abbr(atm.resn.substr(0, 3));

                if((type === 'mmdbid' || type === 'align') && ic.bFullUi ) {
                    // set ic.mmdbMolidResid2mmdbChainResi
                    if(ic.mmdbMolidResid2mmdbChainResi === undefined) ic.mmdbMolidResid2mmdbChainResi = {};
                    ic.mmdbMolidResid2mmdbChainResi[mmdbId + '_' + atm.ids.m + '_' + atm.ids.r] = mmdbId + '_' + atm.chain + '_' + atm.resi;
                }

                ic.pmin.min(atm.coord);
                ic.pmax.max(atm.coord);
                ic.psum.add(atm.coord);
                let bProtein = chainid2kind[chainNum] === 'protein' ;
                let bNucleotide = chainid2kind[chainNum] === 'nucleotide' ;
                let bSolvent = chainid2kind[chainNum] === 'solvent' ;
                // in vastplus.cgi, ions arenotlisted in alignedStructures...molecules, thus chainid2kind[chainNum] === undefined is used.
                // ions will be separated from chemicals later.
                // here "ligand" is used in the cgi output
                //var bChemicalIons =(me.cfg.mmcifid === undefined) ?(chainid2kind[chainNum] === 'ligand' || chainid2kind[chainNum] === 'otherPolymer' || chainid2kind[chainNum] === undefined) : atm.mt === 'l';
                // kind: other, otherPolymer, etc
                let bChemicalIons = (chainid2kind[chainNum] === 'ligand' ||(chainid2kind[chainNum] !== undefined && chainid2kind[chainNum].indexOf('other') !== -1) || chainid2kind[chainNum] === undefined) ;

                if((atm.chain === 'Misc' || chainid2kind[chainNum] === 'other') && biopolymerChainsHash[chainNum] !== 'protein' && biopolymerChainsHash[chainNum] !== 'nucleotide') { // biopolymer, could be protein or nucleotide
                    if(atm.name === 'CA' && atm.elem === 'C') {
                        biopolymerChainsHash[chainNum] = 'protein';
                    }
                    else if(atm.name === 'P' && atm.elem === 'P') {
                        biopolymerChainsHash[chainNum] = 'nucleotide';
                    }
                    else {
                        biopolymerChainsHash[chainNum] = 'chemical';
                    }
                }

                if(bProtein || bNucleotide) {
                    if(bProtein) {
                      ic.proteins[serial] = 1;

                      if(atm.name === 'CA') ic.calphas[serial] = 1;
                      if(atm.name !== 'N' && atm.name !== 'H' && atm.name !== 'CA' && atm.name !== 'HA' && atm.name !== 'C' && atm.name !== 'O') ic.sidec[serial] = 1;
                    }
                    else if(bNucleotide) {
                      ic.nucleotides[serial] = 1;

                      //if(atm.name == 'P') ic.nucleotidesO3[serial] = 1;
                      if(atm.name == "O3'" || atm.name == "O3*" ||(bPhosphorusOnly && atm.name == 'P') ) {
                          ic.nucleotidesO3[serial] = 1;
                      }

                      if(me.parasCls.nuclMainArray.indexOf(atm.name) === -1) {
                          ic.ntbase[serial] = 1;
                      }
                    }

                    atm.het = false;
                }
                else if(bSolvent) { // solvent
                  ic.water[serial] = 1;

                  atm.het = true;
                }
                else if(bChemicalIons) { // chemicals and ions
                  //if(atm.bonds.length === 0) ic.ions[serial] = 1;
                  if(atm.resn === 'HOH' || atm.resn === 'O') {
                      ic.water[serial] = 1;
                  }
                  else if(atm.elem === atm.resn) {
                      ic.ions[serial] = 1;
                  }
                  else {
                      ic.chemicals[serial] = 1;
                  }

                  atm.het = true;
                }

                if(type === 'mmdbid') {
                    if(!atm.het) {
                        atm.color =(chainid2color[chainNum] !== undefined) ? me.parasCls.thr(chainid2color[chainNum]) : me.parasCls.chargeColors[atm.resn];
                    }
                    else {
                        atm.color = me.parasCls.atomColors[atm.elem] || me.parasCls.defaultAtomColor;
                    }
                }
                else {
                    if(atm.color !== undefined) atm.color = me.parasCls.thr(atm.color);
                }

                if(atm.resn.charAt(0) !== ' ' && atm.resn.charAt(1) === ' ') {
                  atm.resn = atm.resn.charAt(0);
                }

                if(!atm.het && atm.name === 'C') {
                    CSerial = serial;
                }
                if(!atm.het && atm.name === 'O') {
                    OSerial = serial;
                }

                // from DSSP C++ code
                if(!atm.het && atm.name === 'N' && prevCSerial !== undefined && prevOSerial !== undefined) {
                    let dist = ic.atoms[prevCSerial].coord.distanceTo(ic.atoms[prevOSerial].coord);

                    let x2 = atm.coord.x +(ic.atoms[prevCSerial].coord.x - ic.atoms[prevOSerial].coord.x) / dist;
                    let y2 = atm.coord.y +(ic.atoms[prevCSerial].coord.y - ic.atoms[prevOSerial].coord.y) / dist;
                    let z2 = atm.coord.z +(ic.atoms[prevCSerial].coord.z - ic.atoms[prevOSerial].coord.z) / dist;

                    atm.hcoord = new THREE.Vector3(x2, y2, z2);
                }

                // double check
                if(atm.resn == 'HOH') ic.water[serial] = 1;

                ic.atoms[serial] = atm;
                ic.dAtoms[serial] = 1;
                ic.hAtoms[serial] = 1;

                // chain level
                let chainid = atm.structure + '_' + atm.chain;
                //if(ic.mmdbid_q !== undefined && ic.mmdbid_q === ic.mmdbid_t && alignType === 'query') chainid += me.htmlCls.postfix;

                if(ic.chains[chainid] === undefined) ic.chains[chainid] = {};
                ic.chains[chainid][serial] = 1;

                // residue level
                let residueid = chainid + '_' + atm.resi;
                if(ic.residues[residueid] === undefined) ic.residues[residueid] = {};
                ic.residues[residueid][serial] = 1;

                residueNum = chainNum + '_' + atm.resi;

                // different residue
                if(residueNum !== prevResidueNum) {
                    // different chain
                    if(chainNum !== prevChainNum) {
                        bChainSeqSet = true;

                        //if(serial !== 1) {
                        if(prevStructureNum !== '') {
                            if(ic.structures[prevStructureNum] === undefined) ic.structures[prevStructureNum] = [];
                            ic.structures[prevStructureNum].push(prevChainNum);
                        }
                    }
                }

                ic.residueId2Name[residueid] = oneLetterRes;

                let secondaries = '-';
                if(atm.ss === 'helix') {
                    secondaries = 'H';
                }
                else if(atm.ss === 'sheet') {
                    secondaries = 'E';
                }
                else if(atm.het || bNucleotide ) {
                    secondaries = 'o';
                }
                else if(!atm.het && me.parasCls.residueColors.hasOwnProperty(atm.resn.toUpperCase()) ) {
                    secondaries = 'c';
                }
                else if(atm.ss === 'coil') {
                    secondaries = 'c';
                }

                ic.secondaries[atm.structure + '_' + atm.chain + '_' + atm.resi] = secondaries;

                if((atm.resi != prevResi || molid != prevMolid) && ic.bFullUi) { // mmdbid 1tup has different molid, same resi
                  if(ic.chainsSeq[chainid] === undefined) {
                      ic.chainsSeq[chainid] = [];
                      bChainSeqSet = false;
                  }

                  // ic.chainsSeq[chainid][atm.resi - 1] should have been defined for major chains
                  if(!isNaN(atm.resi) && atm.resi !== null) {
                      if( bChainSeqSet && !bAddedNewSeq && ic.chainsSeq[chainid][atm.resi - 1] !== undefined) {
                          ic.chainsSeq[chainid][atm.resi - 1].name = oneLetterRes;
                      }
                      else if(!bChainSeqSet || !ic.chainsSeq[chainid].hasOwnProperty(atm.resi - 1)) {
                          let resObject = {};
                          resObject.resi = atm.resi;
                          resObject.name = oneLetterRes;
                          if(atm.resi % 10 === 0) atm.resi.toString();

                          ic.chainsSeq[chainid].push(resObject);

                          bAddedNewSeq = true;
                      }
                  }
                }

                prevResi = atm.resi;
                prevResiOri = atm.resi_ori;
                prevResn = atm.resn;

                prevStructureNum = structureNum;
                prevChainNum = chainNum;
                prevResidueNum = residueNum;

                prevMolid = molid;
            }

            //ic.lastTargetSerial = serial;

            // remove P-P bonds in PDB 3FGU
            for(let i in ic.chemicals) {
                let atom = ic.atoms[i];
                if(atom.elem == 'P' && atom.bonds.length >= 4) {
                    // remove the bonds with another 'P'
                    for(let j = atom.bonds.length - 1; j >= 0; --j) {
                        let atom2 = ic.atoms[atom.bonds[j]];
                        if(atom2.elem == 'P') {
                            atom.bonds.splice(j, 1);
                        }
                    }
                }
            }

            // adjust biopolymer type
            for(let chainid in biopolymerChainsHash) {
                if(Object.keys(ic.chains[chainid]).length < 10) continue;

                if(biopolymerChainsHash[chainid] === 'chemical') continue;

                for(let serial in ic.chains[chainid]) {
                    let atm = ic.atoms[serial];

                    delete ic.chemicals[serial];
                    atm.het = false;

                    if(biopolymerChainsHash[chainid] === 'protein') {
                      ic.proteins[serial] = 1;

                      if(atm.name === 'CA') ic.calphas[serial] = 1;
                      if(atm.name !== 'N' && atm.name !== 'H' && atm.name !== 'CA' && atm.name !== 'HA' && atm.name !== 'C' && atm.name !== 'O') ic.sidec[serial] = 1;
                    }
                    else if(biopolymerChainsHash[chainid] === 'nucleotide') {
                      ic.nucleotides[serial] = 1;
                      //atm.style = 'nucleotide cartoon';

                      if(atm.name == "O3'" || atm.name == "O3*" ||(bPhosphorusOnly && atm.name == 'P') ) {
                          ic.nucleotidesO3[serial] = 1;
                      }

                      if(me.parasCls.nuclMainArray.indexOf(atm.name) === -1) {
                        ic.ntbase[serial] = 1;
                      }
                    }
                }
            }

            // ic.loadPDBCls.adjustSeq(ic.chainMissingResidueArray);

            // add the last residue set
            if(ic.structures[structureNum] === undefined) ic.structures[structureNum] = [];
            ic.structures[structureNum].push(chainNum);

            //ic.countNextresiArray = {}
            //ic.chainMissingResidueArray = {}
            if(ic.bFullUi) {
                if(type === 'mmdbid' || type === 'mmcifid') {
                    for(let chain in data.sequences) {
                        let seqArray = data.sequences[chain];
                        let chainid = id + '_' + chain;

                        if(((ic.mmdbid_q !== undefined && ic.mmdbid_q === ic.mmdbid_t)) && alignType === 'query') ;

                        ic.ParserUtilsCls.getMissingResidues(seqArray, type, chainid); // assign ic.chainsSeq
                    }
                }
                else if(type === 'align') {
                    //for(let chainid in chainid2seq) {
                    for(let chainid in ic.chainid2seq) {
                        let seqArray = ic.chainid2seq[chainid];

                        ic.ParserUtilsCls.getMissingResidues(seqArray, type, chainid);
                    }
                }
            }

            // set ResidMapping after ic.chainsSeq is assigned in the above paragraph
            ic.loadPDBCls.setResidMapping();

            // update bonds info
            if(type !== 'mmcifid') {
                //for(let i in ic.atoms) {
                for(let i in atoms) {
                    let currSerial = atomid2serial[i];

                    let bondLength =(ic.atoms[currSerial].bonds === undefined) ? 0 : ic.atoms[currSerial].bonds.length;

                    for(let j = 0; j < bondLength; ++j) {
                        ic.atoms[currSerial].bonds[j] = atomid2serial[ic.atoms[currSerial].bonds[j]];
                    }
                }
            }
            // remove the reference
            data.atoms = {};

            //ic.cnt =(alignType === undefined || alignType === 'target') ? serial : serial - ic.lastTargetSerial;
            ic.cnt = serial;

            if(ic.cnt > ic.maxatomcnt ||(ic.biomtMatrices !== undefined && ic.biomtMatrices.length * ic.cnt > 10 * ic.maxatomcnt) ) {
                ic.opts['proteins'] = 'c alpha trace'; //ribbon, strand, cylinder and plate, schematic, c alpha trace, b factor tube, lines, stick, ball and stick, sphere, nothing
                ic.opts['nucleotides'] = 'o3 trace'; //nucleotide cartoon, o3 trace, schematic, lines, stick,
            }

            //ic.maxD = ic.pmax.distanceTo(ic.pmin);
            //ic.center = ic.psum.multiplyScalar(1.0 / ic.cnt);
            ic.center = ic.ParserUtilsCls.getGeoCenter(ic.pmin, ic.pmax);
            ic.maxD = ic.ParserUtilsCls.getStructureSize(ic.atoms, ic.pmin, ic.pmax, ic.center);

            if(ic.maxD < 5) ic.maxD = 5;

            ic.oriMaxD = ic.maxD;

            // set up disulfide bonds
            if(type === 'align' || bLastQuery) { // calculate disulfide bonds
                ic.ssbondpnts = {};

                ic.loadPDBCls.setSsbond();
            }
            
            if(type === 'mmdbid' && Object.keys(ic.structures).length == 1) {
                let disulfideArray = data.disulfides;

                if(disulfideArray !== undefined) {
                    for(let i = 0, il = disulfideArray.length; i < il; ++i) {
                        let serial1 = disulfideArray[i][0].ca;
                        let serial2 = disulfideArray[i][1].ca;

                        let atom1 = ic.atoms[serial1];
                        let atom2 = ic.atoms[serial2];

                        let chain1 = atom1.chain;
                        let chain2 = atom2.chain;

                        let resid1 = atom1.structure + '_' + chain1 + '_' + atom1.resi;
                        let resid2 = atom2.structure + '_' + chain2 + '_' + atom2.resi;

                        if(ic.ssbondpnts[atom1.structure] === undefined) ic.ssbondpnts[atom1.structure] = [];

                        ic.ssbondpnts[atom1.structure].push(resid1);
                        ic.ssbondpnts[atom1.structure].push(resid2);
                    }
                }
            }
            else if(type === 'mmcifid' && Object.keys(ic.structures).length == 1) {
                let disulfideArray = data.disulfides;

                if(disulfideArray !== undefined) {
                    if(ic.ssbondpnts[id] === undefined) ic.ssbondpnts[id] = [];

                    for(let i = 0, il = disulfideArray.length; i < il; ++i) {
                        let resid1 = disulfideArray[i][0];
                        let resid2 = disulfideArray[i][1];
                      
                        ic.ssbondpnts[id].push(resid1);
                        ic.ssbondpnts[id].push(resid2);
                    }

                    // copy disulfide bonds
                    let structureArray = Object.keys(ic.structures);
                    for(let s = 0, sl = structureArray.length; s < sl; ++s) {
                        let structure = structureArray[s];

                        if(structure == id) continue;

                        if(ic.ssbondpnts[structure] === undefined) ic.ssbondpnts[structure] = [];

                        for(let j = 0, jl = ic.ssbondpnts[id].length; j < jl; ++j) {
                            let ori_resid = ic.ssbondpnts[id][j];
                            let pos = ori_resid.indexOf('_');
                            let resid = structure + ori_resid.substr(pos);
                            ic.ssbondpnts[structure].push(resid);
                        }
                    }
                }
            }

            if(type === 'mmcifid') {
                ic.ParserUtilsCls.transformToOpmOri(id);
            }
            else if(type === 'mmdbid' && alignType === undefined) {
                ic.ParserUtilsCls.transformToOpmOri(id);
            }

            // set up sequence alignment
            // display the structure right away. load the mns and sequences later
        //        setTimeout(function(){
            let hAtoms = {};

            if(type === 'align' && seqalign !== undefined && ic.bFullUi) {
                ic.setSeqAlignCls.setSeqAlign(seqalign, data.alignedStructures);
            } // if(align
            else if(type === 'mmdbid' && alignType === 'query' && ic.bFullUi && ic.q_rotation !== undefined 
                && !me.cfg.resnum && !me.cfg.resdef && !bNoSeqalign) {

                if(chainIndex) {
                    ic.setSeqAlignCls.setSeqAlignChain(chainidInput, chainIndex);

                    let bReverse = false;
                    let seqObj = me.htmlCls.alignSeqCls.getAlignSequencesAnnotations(Object.keys(ic.alnChains), undefined, undefined, false, undefined, bReverse);
                    let oriHtml = $("#" + ic.pre + "dl_sequence2").html();

                    hAtoms = ic.hAtoms;

                    $("#" + ic.pre + "dl_sequence2").html(oriHtml + seqObj.sequencesHtml);
                    $("#" + ic.pre + "dl_sequence2").width(me.htmlCls.RESIDUE_WIDTH * seqObj.maxSeqCnt + 200);
                }
                else {            
                    hAtoms = ic.hAtoms;
                }
            }
            else { //if(type === 'mmdbid' && alignType === 'target') {
                hAtoms = ic.hAtoms;
            }

            if(!me.cfg.mmdbafid && type === 'mmdbid' && (alignType === 'target' || alignType === 'query') && ic.q_rotation === undefined) {
                if(alignType === 'target' || alignType === 'query') {
                    for(let i in atoms) {
                        let atom = atoms[i];
                        atom.coord.x -= ic.center.x;
                        atom.coord.y -= ic.center.y;
                        atom.coord.z -= ic.center.z;
                    }
                }

                if(alignType === 'target') {
                    //ic.maxD1 = ic.maxD;
                    ic.oriMaxD = ic.maxD;
                    ic.center1 = ic.center;
                }
                else if(alignType === 'query') {
                    //ic.maxD2 = ic.maxD;
                    //if(ic.maxD2 < ic.maxD1) ic.maxD = ic.maxD1;
                    if(ic.oriMaxD < ic.maxD) ic.oriMaxD = ic.maxD;

                    ic.center2 = ic.center;
                    ic.center = new THREE.Vector3(0,0,0);
                }
            }

            //ic.oriMaxD = ic.maxD;
            ic.oriCenter = ic.center.clone();

            ic.saveFileCls.showTitle();

            data = {};

            return hAtoms;
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class SetSeqAlign {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        setSeqAlign(seqalign, alignedStructures) { let ic = this.icn3d, me = ic.icn3dui;
              let mmdbid1 = alignedStructures[0][0].pdbId;
              let mmdbid2 = alignedStructures[0][1].pdbId;
              let chainid1, chainid2;

              ic.conservedName1 = mmdbid1 + '_cons';
              ic.nonConservedName1 = mmdbid1 + '_ncons';
              ic.notAlignedName1 = mmdbid1 + '_nalign';

              ic.conservedName2 = mmdbid2 + '_cons';
              ic.nonConservedName2 = mmdbid2 + '_ncons';
              ic.notAlignedName2 = mmdbid2 + '_nalign';

              ic.consHash1 = {};
              ic.nconsHash1 = {};
              ic.nalignHash1 = {};

              ic.consHash2 = {};
              ic.nconsHash2 = {};
              ic.nalignHash2 = {};

              for(let i = 0, il = seqalign.length; i < il; ++i) {
                  // first sequence
                  let alignData = seqalign[i][0];
                  let molid1 = alignData.moleculeId;

                  let chain1 = ic.pdbid_molid2chain[mmdbid1 + '_' + molid1];
                  chainid1 = mmdbid1 + '_' + chain1;

                  let id2aligninfo = {};
                  let start = alignData.sequence.length, end = -1;
                  let bStart = false;
                  for(let j = 0, jl = alignData.sequence.length; j < jl; ++j) {
                      // 0: internal resi id, 1: pdb resi id, 2: resn, 3: aligned or not
                      //let offset =(ic.chainid2offset[chainid1]) ? ic.chainid2offset[chainid1] : 0;
                      //let resi =(ic.bUsePdbNum) ? alignData.sequence[j][0] + offset : alignData.sequence[j][0];
                      let resi =(ic.bUsePdbNum) ? ic.ParserUtilsCls.getResi(chainid1, alignData.sequence[j][0] - 1) : alignData.sequence[j][0];
                      let resn =(alignData.sequence[j][2] === '~') ? '-' : alignData.sequence[j][2];
                      resn =(resn === ' ' || resn === '') ? 'X' : resn;
                      //resn = resn.toUpperCase();

                      let aligned =(alignData.sequence[j][3]) ? 1 : 0; // alignData.sequence[j][3]: 0, false, 1, true

                      if(aligned == 1) {
                          if(j < start && !bStart) {
                              start = j;
                              bStart = true; // set start just once
                          }
                          if(j > end) end = j;
                      }

                      id2aligninfo[j] = {"resi": resi, "resn": resn, "aligned": aligned};
                  }

                  // second sequence
                  alignData = seqalign[i][1];
                  let molid2 = alignData.moleculeId;

                  let chain2 = ic.pdbid_molid2chain[mmdbid2 + '_' + molid2];
                  chainid2 = mmdbid2 + '_' + chain2;

                  // annotation title for the master seq only
                  if(ic.alnChainsAnTtl[chainid1] === undefined ) ic.alnChainsAnTtl[chainid1] = [];
                  if(ic.alnChainsAnTtl[chainid1][0] === undefined ) ic.alnChainsAnTtl[chainid1][0] = [];
                  if(ic.alnChainsAnTtl[chainid1][1] === undefined ) ic.alnChainsAnTtl[chainid1][1] = [];
                  if(ic.alnChainsAnTtl[chainid1][2] === undefined ) ic.alnChainsAnTtl[chainid1][2] = [];
                  if(ic.alnChainsAnTtl[chainid1][3] === undefined ) ic.alnChainsAnTtl[chainid1][3] = [];
                  if(ic.alnChainsAnTtl[chainid1][4] === undefined ) ic.alnChainsAnTtl[chainid1][4] = [];
                  if(ic.alnChainsAnTtl[chainid1][5] === undefined ) ic.alnChainsAnTtl[chainid1][5] = [];
                  if(ic.alnChainsAnTtl[chainid1][6] === undefined ) ic.alnChainsAnTtl[chainid1][6] = [];

                  // two annotations without titles
                  ic.alnChainsAnTtl[chainid1][0].push(chainid2);
                  ic.alnChainsAnTtl[chainid1][1].push(chainid1);
                  ic.alnChainsAnTtl[chainid1][2].push("");
                  ic.alnChainsAnTtl[chainid1][3].push("");

                  // 2nd chain title
                  ic.alnChainsAnTtl[chainid1][4].push(chainid2);
                  // master chain title
                  ic.alnChainsAnTtl[chainid1][5].push(chainid1);
                  // empty line
                  ic.alnChainsAnTtl[chainid1][6].push("");

                  let alignIndex = 1;
                  if(!ic.chainsMapping[chainid1]) ic.chainsMapping[chainid1] = {};
                  if(!ic.chainsMapping[chainid2]) ic.chainsMapping[chainid2] = {};
                  //for(let j = 0, jl = alignData.sseq.length; j < jl; ++j) {
                  for(let j = start; j <= end; ++j) {
                      // 0: internal resi id, 1: pdb resi id, 2: resn, 3: aligned or not
                      //let offset =(ic.chainid2offset[chainid2]) ? ic.chainid2offset[chainid2] : 0;
                      //let resi =(ic.bUsePdbNum) ? alignData.sequence[j][0] + offset : alignData.sequence[j][0];
                      let resi =(ic.bUsePdbNum) ? ic.ParserUtilsCls.getResi(chainid2, alignData.sequence[j][0] - 1) : alignData.sequence[j][0];
                      let resn =(alignData.sequence[j][2] === '~') ? '-' : alignData.sequence[j][2];
                      //resn = resn.toUpperCase();

                      let alignedTmp =(alignData.sequence[j][3]) ? 1 : 0; // alignData.sequence[j][3]: 0, false, 1, true

                      let aligned = id2aligninfo[j].aligned + alignedTmp; // 0 or 2

                      let color, color2, classname;
                      if(aligned === 2) { // aligned
                          if(id2aligninfo[j].resn === resn) {
                              color = '#FF0000';
                              classname = 'icn3d-cons';

                              ic.consHash1[chainid1 + '_' + id2aligninfo[j].resi] = 1;
                              ic.consHash2[chainid2 + '_' + resi] = 1;
                          }
                          else {
                              color = '#0000FF';
                              classname = 'icn3d-ncons';

                              ic.nconsHash1[chainid1 + '_' + id2aligninfo[j].resi] = 1;
                              ic.nconsHash2[chainid2 + '_' + resi] = 1;
                          }

                          // mapping, use the firstsequence as the reference structure
                          ic.chainsMapping[chainid1][chainid1 + '_' + id2aligninfo[j].resi] = id2aligninfo[j].resn + id2aligninfo[j].resi;
                          ic.chainsMapping[chainid2][chainid2 + '_' + resi] = id2aligninfo[j].resn + id2aligninfo[j].resi;

                          color2 = '#' + ic.showAnnoCls.getColorhexFromBlosum62(id2aligninfo[j].resn, resn);

                          // expensive and thus remove
                          //alignedAtoms = me.hashUtilsCls.unionHash(alignedAtoms, ic.residues[chainid1 + '_' + id2aligninfo[j].resi]);
                          //alignedAtoms = me.hashUtilsCls.unionHash(alignedAtoms, ic.residues[chainid2 + '_' + resi]);
                      }
                      else {
                          color = me.htmlCls.GREY8;
                          classname = 'icn3d-nalign';

                          ic.nalignHash1[chainid1 + '_' + id2aligninfo[j].resi] = 1;
                          ic.nalignHash2[chainid2 + '_' + resi] = 1;
                      }

                      // chain1
                      if(ic.alnChainsSeq[chainid1] === undefined) ic.alnChainsSeq[chainid1] = [];

                      let resObject = {};
                      resObject.mmdbid = mmdbid1;
                      resObject.chain = chain1;
                      resObject.resi = id2aligninfo[j].resi;
                      // resi will be empty if there is no coordinates
                      resObject.resn =(resObject.resi === '' || classname === 'icn3d-nalign') ? id2aligninfo[j].resn.toLowerCase() : id2aligninfo[j].resn;
                      resObject.aligned = aligned;
                      // resi will be empty if there is no coordinates
                      resObject.color =(resObject.resi === '') ? me.htmlCls.GREYC : color; // color by identity
                      resObject.color2 =(resObject.resi === '') ? me.htmlCls.GREYC : color2; // color by conservation
                      resObject.class = classname;

                      ic.alnChainsSeq[chainid1].push(resObject);

                      if(id2aligninfo[j].resi !== '') {
                          if(ic.alnChains[chainid1] === undefined) ic.alnChains[chainid1] = {};
                          $.extend(ic.alnChains[chainid1], ic.residues[chainid1 + '_' + id2aligninfo[j].resi] );
                      }

                      // chain2
                      if(ic.alnChainsSeq[chainid2] === undefined) ic.alnChainsSeq[chainid2] = [];

                      resObject = {};
                      resObject.mmdbid = mmdbid2;
                      resObject.chain = chain2;
                      resObject.resi = resi;
                      // resi will be empty if there is no coordinates
                      resObject.resn =(resObject.resi === '' || classname === 'icn3d-nalign') ? resn.toLowerCase() : resn;
                      resObject.aligned = aligned;
                      // resi will be empty if there is no coordinates
                      resObject.color =(resObject.resi === '') ? me.htmlCls.GREYC : color; // color by identity
                      resObject.color2 =(resObject.resi === '') ? me.htmlCls.GREYC : color2; // color by conservation
                      resObject.class = classname;

                      ic.alnChainsSeq[chainid2].push(resObject);

                      if(resObject.resi !== '') {
                          if(ic.alnChains[chainid2] === undefined) ic.alnChains[chainid2] = {};
                          $.extend(ic.alnChains[chainid2], ic.residues[chainid2 + '_' + resi] );
                      }

                      // annotation is for the master seq only
                      if(ic.alnChainsAnno[chainid1] === undefined ) ic.alnChainsAnno[chainid1] = [];
                      if(ic.alnChainsAnno[chainid1][0] === undefined ) ic.alnChainsAnno[chainid1][0] = [];
                      if(ic.alnChainsAnno[chainid1][1] === undefined ) ic.alnChainsAnno[chainid1][1] = [];
                      if(ic.alnChainsAnno[chainid1][2] === undefined ) ic.alnChainsAnno[chainid1][2] = [];
                      if(ic.alnChainsAnno[chainid1][3] === undefined ) ic.alnChainsAnno[chainid1][3] = [];
                      if(j === start) {
                          // empty line
                          // 2nd chain title
                          if(ic.alnChainsAnno[chainid1][4] === undefined ) ic.alnChainsAnno[chainid1][4] = [];
                          // master chain title
                          if(ic.alnChainsAnno[chainid1][5] === undefined ) ic.alnChainsAnno[chainid1][5] = [];
                          // empty line
                          if(ic.alnChainsAnno[chainid1][6] === undefined ) ic.alnChainsAnno[chainid1][6] = [];

                          ic.alnChainsAnno[chainid1][4].push(ic.pdbid_chain2title[chainid2]);
                          ic.alnChainsAnno[chainid1][5].push(ic.pdbid_chain2title[chainid1]);
                          ic.alnChainsAnno[chainid1][6].push('');
                      }

                      let residueid1 = chainid1 + '_' + id2aligninfo[j].resi;
                      let residueid2 = chainid2 + '_' + resi;
                      let ss1 = ic.secondaries[residueid1];
                      let ss2 = ic.secondaries[residueid2];
                      if(ss2) {
                          ic.alnChainsAnno[chainid1][0].push(ss2);
                      }
                      else {
                          ic.alnChainsAnno[chainid1][0].push('-');
                      }

                      if(ss1) {
                          ic.alnChainsAnno[chainid1][1].push(ss1);
                      }
                      else {
                          ic.alnChainsAnno[chainid1][1].push('-');
                      }

                      let symbol = '.';
                      if(alignIndex % 5 === 0) symbol = '*';
                      if(alignIndex % 10 === 0) symbol = '|';
                      ic.alnChainsAnno[chainid1][2].push(symbol); // symbol: | for 10th, * for 5th, . for rest

                      let numberStr = '';
                      if(alignIndex % 10 === 0) numberStr = alignIndex.toString();
                      ic.alnChainsAnno[chainid1][3].push(numberStr); // symbol: 10, 20, etc, empty for rest

                      ++alignIndex;
                  } // end for(let j
                  
                  this.setMsaFormat([chainid1, chainid2]);
              } // end for(let i

              seqalign = {};
        }

        getPosFromResi(chainid, resi) { let ic = this.icn3d; ic.icn3dui;
            let residNCBI = ic.resid2ncbi[chainid + '_' + resi];
            let pos = undefined;
            
            if(residNCBI) {
                let resiNCBI = residNCBI.substr(residNCBI.lastIndexOf('_') + 1);
                pos = resiNCBI - 1;
            }
            // else {
            //     //let il = ic.chainsSeq[chainid].length;
            //     let il = (ic.chainsSeq[chainid]) ? ic.chainsSeq[chainid].length : 0;
            //     for(let i = 0; i < il; ++i) {
            //         if(ic.chainsSeq[chainid][i].resi == resi) {
            //             pos = i;
            //             break;
            //         }
            //     }
            // }

            return pos;
        }

        getResnFromResi(chainid, resi) { let ic = this.icn3d; ic.icn3dui;
            /*
            let pos = this.getPosFromResi(chainid, resi);
            if(!pos) return '?';

            let resid = chainid + '_' + resi;
            let resn = '';

            if(ic.residues[resid] === undefined) {
                resn = (ic.chainsSeq[chainid][pos]) ? ic.chainsSeq[chainid][pos].name : '?';
            }
            else {
                resn = me.utilsCls.residueName2Abbr(ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid]).resn.substr(0, 3));
            }

            return resn;
            */

            let resid = chainid + '_' + resi;
            let resn = ic.residueId2Name[resid];
            if(!resn) {
                resn = '?';
            }

            return resn;
        }

        getResiAferAlign(chainid, bRealign, pos) { let ic = this.icn3d, me = ic.icn3dui;
            let resi;
            if(bRealign && me.cfg.aligntool == 'tmalign') {
              resi = pos;
            }
            else {
            //   if(ic.posid2resid) {
            //       let resid = ic.posid2resid[chainid + '_' + pos];
            //       resi = resid.substr(resid.lastIndexOf('_') + 1);
            //   }
            //   else {
                //   resi = (ic.chainsSeq[chainid][pos].resi) ? ic.chainsSeq[chainid][pos].resi : pos;
                  if(pos > ic.chainsSeq[chainid].length - 1) {
                    console.log("Error: the position " + pos + " exceeds the max index " + (ic.chainsSeq[chainid].length - 1));
                    pos = ic.chainsSeq[chainid].length - 1;
                  }

                  resi = ic.chainsSeq[chainid][pos].resi;
            //   }
            }

            return resi;
        }

        setSeqAlignChain(chainid, chainIndex, chainidArray) { let ic = this.icn3d, me = ic.icn3dui;
              let hAtoms = {};

              let bRealign = (chainidArray) ? true : false;
              let mmdbid1, mmdbid2, chain1, chain2, chainid1, chainid2, pos1, pos2;

              if(bRealign) { 
                // originally chainid2 is target,chainid1 is query
                // switch them so that chainid1 is the target
                chainid1 = chainidArray[1];
                chainid2 = chainidArray[0];

                chainIndex = chainidArray[2];

                pos1 = chainid1.indexOf('_');
                pos2 = chainid2.indexOf('_');

                mmdbid1 = chainid1.substr(0, pos1).toUpperCase();
                mmdbid2 = chainid2.substr(0, pos2).toUpperCase();

                chain1 = chainid1.substr(pos1 + 1);
                chain2 = chainid2.substr(pos1 + 1);

                if(mmdbid1 == mmdbid2 && chain1 == chain2) {
                    let chainLen = ic.chainsSeq[mmdbid2 + '_' + chain2].length;
                    ic.qt_start_end[chainIndex] =  {"q_start":1, "q_end": chainLen, "t_start":1, "t_end": chainLen};
                }
              }
              else {
                //var chainidArray = me.cfg.chainalign.split(',');
                let pos1 = chainidArray[0].indexOf('_');
                let pos2 = chainid.indexOf('_');

                mmdbid1 = ic.mmdbid_t; //ic.chainidArray[0].substr(0, pos1).toUpperCase();
                mmdbid2 = chainid.substr(0, pos2).toUpperCase();

                chain1 = chainidArray[0].substr(pos1 + 1);
                chain2 = chainid.substr(pos2 + 1);

                if(mmdbid1 == mmdbid2 && chain1 == chain2) {
                    let chainLen = ic.chainsSeq[ic.mmdbid_q + '_' + ic.chain_q].length;
                    ic.qt_start_end[chainIndex] =  {"q_start":1, "q_end": chainLen, "t_start":1, "t_end": chainLen};
                }

                chainid1 = mmdbid1 + "_" + chain1;
                chainid2 = mmdbid2 + "_" + chain2;

                if(mmdbid2 !== undefined && mmdbid2 === ic.mmdbid_t) ;
             }

              ic.conservedName1 = chainid1 + '_cons';
              ic.nonConservedName1 = chainid1 + '_ncons';
              ic.notAlignedName1 = chainid1 + '_nalign';

              ic.conservedName2 = chainid2 + '_cons';
              ic.nonConservedName2 = chainid2 + '_ncons';
              ic.notAlignedName2 = chainid2 + '_nalign';

              ic.consHash1 = {};
              ic.nconsHash1 = {};
              ic.nalignHash1 = {};

              ic.consHash2 = {};
              ic.nconsHash2 = {};
              ic.nalignHash2 = {};

              ic.alnChains = {};

              ic.alnChainsSeq[chainid1] = [];
              ic.alnChains[chainid1] = {};

              ic.alnChainsSeq[chainid2] = [];
              ic.alnChains[chainid2] = {};
              
              ic.alnChainsAnno[chainid1] = [];
              ic.alnChainsAnTtl[chainid1] = [];

              if(ic.alnChainsAnTtl[chainid1] === undefined ) ic.alnChainsAnTtl[chainid1] = [];
              for(let i = 0; i < 7; ++i) {
                  if(ic.alnChainsAnTtl[chainid1][i] === undefined ) ic.alnChainsAnTtl[chainid1][i] = [];
              }

              // two annotations without titles
              ic.alnChainsAnTtl[chainid1][0].push(chainid2);
              ic.alnChainsAnTtl[chainid1][1].push(chainid1);
              ic.alnChainsAnTtl[chainid1][2].push("");
              ic.alnChainsAnTtl[chainid1][3].push("");

              // 2nd chain title
              ic.alnChainsAnTtl[chainid1][4].push(chainid2);
              // master chain title
              ic.alnChainsAnTtl[chainid1][5].push(chainid1);
              // empty line
              ic.alnChainsAnTtl[chainid1][6].push("");

              let color, color2, classname;
              let prevIndex1 = 0, prevIndex2 = 0;

              if(ic.qt_start_end[chainIndex] === undefined) return;

              let alignIndex = 1; // number of residues displayed in seq alignment
              if(!ic.chainsMapping[chainid1]) ic.chainsMapping[chainid1] = {};
              if(!ic.chainsMapping[chainid2]) ic.chainsMapping[chainid2] = {};

              let posChain1 = {}, posChain2 = {};

              for(let i = 0, il = ic.qt_start_end[chainIndex].length; i < il; ++i) {
                let start1, start2, end1, end2;
                if(bRealign && me.cfg.aligntool == 'tmalign') { // real residue numbers are stored, could be "100a"
                    start1 = parseInt(ic.qt_start_end[chainIndex][i].t_start);
                    start2 = parseInt(ic.qt_start_end[chainIndex][i].q_start);
                    end1 = parseInt(ic.qt_start_end[chainIndex][i].t_end);
                    end2 = parseInt(ic.qt_start_end[chainIndex][i].q_end); 
                }
                else {
                  start1 = parseInt(ic.qt_start_end[chainIndex][i].t_start - 1);
                  start2 = parseInt(ic.qt_start_end[chainIndex][i].q_start - 1);
                  end1 = parseInt(ic.qt_start_end[chainIndex][i].t_end - 1);
                  end2 = parseInt(ic.qt_start_end[chainIndex][i].q_end - 1);  
                }

                posChain1[start1] = 1;
                posChain1[end1] = 1;

                posChain2[start2] = 1;
                posChain2[end2] = 1;
              }

              for(let i = 0, il = ic.qt_start_end[chainIndex].length; i < il; ++i) {
                  let start1, start2, end1, end2;
                  if(bRealign && me.cfg.aligntool == 'tmalign') { // real residue numbers are stored
                    start1 = parseInt(ic.qt_start_end[chainIndex][i].t_start);
                    start2 = parseInt(ic.qt_start_end[chainIndex][i].q_start);
                    end1 = parseInt(ic.qt_start_end[chainIndex][i].t_end);
                    end2 = parseInt(ic.qt_start_end[chainIndex][i].q_end); 
                  }
                  else {
                    start1 = parseInt(ic.qt_start_end[chainIndex][i].t_start - 1);
                    start2 = parseInt(ic.qt_start_end[chainIndex][i].q_start - 1);
                    end1 = parseInt(ic.qt_start_end[chainIndex][i].t_end - 1);
                    end2 = parseInt(ic.qt_start_end[chainIndex][i].q_end - 1);  
                  }

                  if(i > 0) {
                      let index1 = alignIndex;
                      
                      for(let j = prevIndex1 + 1, jl = start1; j < jl; ++j) {
                          //if(posChain1[j]) continue;
                          posChain1[j] = 1;

                          //if(ic.chainsSeq[chainid1] === undefined || ic.chainsSeq[chainid1][j] === undefined) break;

                          //let resi = this.getResiAferAlign(chainid1, bRealign, j + 1);
                          let resi = this.getResiAferAlign(chainid1, bRealign, j);
                          //   let resn = (bRealign && me.cfg.aligntool == 'tmalign') ? this.getResnFromResi(chainid1, j).toLowerCase() : ic.chainsSeq[chainid1][j].name.toLowerCase();
                          let resn = this.getResnFromResi(chainid1, resi).toLowerCase();
                          
                          if(resn == '?') continue;

                          color = me.htmlCls.GREY8;
                          classname = 'icn3d-nalign';
                          
                          ic.nalignHash1[chainid1 + '_' + resi] = 1;
                          this.setSeqPerResi(chainid1, chainid1, chainid2, resi, resn, false, color, undefined, classname, true, false, index1);
                          ++index1;
                      }

                      let index2 = alignIndex;

                      for(let j = prevIndex2 + 1, jl = start2; j < jl; ++j) {
                          //if(posChain2[j]) continue;
                          posChain2[j] = 1;

                          //if(ic.chainsSeq[chainid2] === undefined || ic.chainsSeq[chainid2] === undefined) break;

                          //let resi = this.getResiAferAlign(chainid2, bRealign, j + 1);
                          let resi = this.getResiAferAlign(chainid2, bRealign, j);
                          //   let resn = (bRealign && me.cfg.aligntool == 'tmalign') ? this.getResnFromResi(chainid2, j).toLowerCase() : ic.chainsSeq[chainid2][j].name.toLowerCase();
                          let resn = this.getResnFromResi(chainid2, resi).toLowerCase();

                          if(resn == '?') continue;

                          color = me.htmlCls.GREY8;
                          classname = 'icn3d-nalign';

                          ic.nalignHash2[chainid2 + '_' + resi] = 1;
                          this.setSeqPerResi(chainid2, chainid1, chainid2, resi, resn, false, color, undefined, classname, false, false, index2);
                          ++index2; // count just once
                      }

                      if(index1 < index2) {
                          alignIndex = index2;

                          for(let j = 0; j < index2 - index1; ++j) {
                              let resi = '';
                              let resn = '-';

                              color = me.htmlCls.GREY8;
                              classname = 'icn3d-nalign';

                              this.setSeqPerResi(chainid1, chainid1, chainid2, resi, resn, false, color, undefined, classname, true, false, index1 + j);
                          }
                      }
                      else {
                          alignIndex = index1;

                          for(let j = 0; j < index1 - index2; ++j) {
                              let resi = '';
                              let resn = '-';

                              color = me.htmlCls.GREY8;
                              classname = 'icn3d-nalign';

                              this.setSeqPerResi(chainid2, chainid1, chainid2, resi, resn, false, color, undefined, classname, false, false, index2 + j);
                          }
                      }
                  }
                
                  for(let j = 0; j <= end1 - start1; ++j) {
                      ///if(ic.chainsSeq[chainid1] === undefined || ic.chainsSeq[chainid2] === undefined) break;

                      let resi1, resi2, resn1, resn2;
                      if(bRealign && me.cfg.aligntool == 'tmalign') { // tmalign: just one residue in this for loop
                        resi1 = ic.qt_start_end[chainIndex][i].t_start;
                        resi2 = ic.qt_start_end[chainIndex][i].q_start;

                        resn1 = this.getResnFromResi(chainid1, resi1).toUpperCase();
                        resn2 = this.getResnFromResi(chainid2, resi2).toUpperCase();

                        if(resn1 == '?' || resn2 == '?') continue;
                      }
                      else {
                        resi1 =  this.getResiAferAlign(chainid1, bRealign, j + start1);
                        resi2 =  this.getResiAferAlign(chainid2, bRealign, j + start2);
                        resn1 = this.getResnFromResi(chainid1, resi1).toUpperCase();
                        resn2 = this.getResnFromResi(chainid2, resi2).toUpperCase();
                      }

                      if(resn1 === resn2) {
                          color = '#FF0000';
                          classname = 'icn3d-cons';

                          ic.consHash1[chainid1 + '_' + resi1] = 1;
                          ic.consHash2[chainid2 + '_' + resi2] = 1;
                      }
                      else {
                          color = '#0000FF';
                          classname = 'icn3d-ncons';

                          ic.nconsHash1[chainid1 + '_' + resi1] = 1;
                          ic.nconsHash2[chainid2 + '_' + resi2] = 1;
                      }

                      hAtoms = me.hashUtilsCls.unionHash(hAtoms, ic.residues[chainid1 + '_' + resi1]);
                      hAtoms = me.hashUtilsCls.unionHash(hAtoms, ic.residues[chainid2 + '_' + resi2]);

                      // mapping, use the firstsequence as the reference structure
                      ic.chainsMapping[chainid1][chainid1 + '_' + resi1] = resn1 + resi1;
                      ic.chainsMapping[chainid2][chainid2 + '_' + resi2] = resn1 + resi1;

                      color2 = '#' + ic.showAnnoCls.getColorhexFromBlosum62(resn1, resn2);

                      let bFirstResi =(i === 0 && j === 0) ? true : false;
                      this.setSeqPerResi(chainid1, chainid1, chainid2, resi1, resn1, true, color, color2, classname, true, bFirstResi, alignIndex);
                      this.setSeqPerResi(chainid2, chainid1, chainid2, resi2, resn2, true, color, color2, classname, false, bFirstResi, alignIndex);

                      ++alignIndex;
                  } // end for(let j

                  prevIndex1 = end1;
                  prevIndex2 = end2;
              } // end for(let i 

              this.setMsaFormat([chainid1, chainid2]);

              return hAtoms;
        }

        setSeqAlignChainForAll(chainidArray, index_alignLen, bRealign) { let ic = this.icn3d, me = ic.icn3dui;
            let hAtoms = {};
            let chainid1 = chainidArray[0];

            ic.alnChainsAnno[chainid1] = [];

            // 1. assign ic.alnChainsAnTtl
            ic.alnChainsAnTtl[chainid1] = [];

            let n = chainidArray.length;

            // Title
            if(ic.alnChainsAnTtl[chainid1] === undefined ) ic.alnChainsAnTtl[chainid1] = [];
            for(let i = 0; i < 3 + 2*n; ++i) {
                if(ic.alnChainsAnTtl[chainid1][i] === undefined ) ic.alnChainsAnTtl[chainid1][i] = [];
            }

            for(let i = 0; i < n; ++i) {
                ic.alnChainsAnTtl[chainid1][i].push(chainidArray[n-1 - i]);
            }

            // two annotations without titles
            ic.alnChainsAnTtl[chainid1][n].push("");
            ic.alnChainsAnTtl[chainid1][n + 1].push("");

            for(let i = n + 2; i < 2*n + 2; ++i) {
                ic.alnChainsAnTtl[chainid1][i].push(chainidArray[2*n + 1 - i]);
            }

            // empty line
            ic.alnChainsAnTtl[chainid1][2*n + 2].push("");

            // 2. assign ic.alnChainsSeq and ic.alnChains for all chains
            ic.alnChainsSeq[chainid1] = [];

            ic.alnChains = {};
            ic.alnChains[chainid1] = {};      

            let resid2range_t = {}; // accumulative aligned residues in the template chain
            // start and end of MSA
            let start_t = 9999, end_t = -1;

            let baseResi = ic.chainsSeq[chainid1][0].resi - 1;

            for(let index = 1, indexl = chainidArray.length; index < indexl; ++index) { 
                let chainIndex = index - 1;
                chainidArray[index];
                if(!ic.qt_start_end[chainIndex]) continue;

                for(let i = 0, il = ic.qt_start_end[chainIndex].length; i < il; ++i) {
                    let start1, end1;
                    
                    // if(bRealign) { // real residue numbers are stored
                    //     start1 = ic.qt_start_end[chainIndex][i].t_start;
                    //     end1 = ic.qt_start_end[chainIndex][i].t_end;
                    // }
                    // else {
                        //ic.qt_start_end is zero-based
                        start1 = parseInt(ic.qt_start_end[chainIndex][i].t_start) - 1;
                        end1 = parseInt(ic.qt_start_end[chainIndex][i].t_end) - 1;
                    // }
                    for(let j = start1; j <= end1; ++j) {
                        let resi, resid;

                        // if(me.cfg.aligntool == 'tmalign') { // tmalign: just one residue in this for loop
                        //     resi = ic.qt_start_end[chainIndex][i].t_start;
                        // }
                        // else {
                            // let resiPos = (bRealign || me.cfg.aligntool != 'tmalign') ? j : j - baseResi;
                            let resiPos;
                            if(me.cfg.aligntool == 'tmalign') {
                                resiPos = j - baseResi;
                            }
                            else {
                                // resiPos = (bRealign) ? j : j - baseResi;
                                resiPos = j;
                            }
                            resi = ic.ParserUtilsCls.getResi(chainidArray[0], resiPos);
                            resid = chainidArray[0] + '_' + resi;
                        // }

                        resid2range_t[resid] = 1;
                        if(j < start_t) start_t = j;
                        if(j > end_t) end_t = j;
                    }
                }
            }

            // TM-align should use "start1 = ic.qt_start_end[chainIndex][i].t_start - 1", but the rest are the same as ""bRealign"
            if(me.cfg.aligntool == 'tmalign') bRealign = true; // real residue numbers are stored

            let resid2rangeArray = Object.keys(resid2range_t);
            resid2rangeArray.sort(function(a, b) {
                return parseInt(a.split('_')[2]) - parseInt(b.split('_')[2]);
            });

            // assign range to each resi
            let prevResi = -999, start = 0, end = 0, residArray = [], prevEnd = 0;
            for(let i = 0, il = resid2rangeArray.length; i < il; ++i) {
                let resid = resid2rangeArray[i];
                let resi = resid.split('_')[2];
                
                if(i == 0) {
                    start = resi;
                }
                else if(i > 0 && ic.resid2ncbi[resi] != ic.resid2ncbi[prevResi] + 1 && ic.resid2ncbi[resi] != ic.resid2ncbi[prevResi]) { // new start
                    end = prevResi;
                    for(let j = 0, jl = residArray.length; j < jl; ++j) {
                        resid2range_t[residArray[j]] = {resiStart: start, resiEnd: end, prevResiEnd: prevEnd};
                    }

                    residArray = [];
                    start = resi;
                    prevEnd = end;
                }

                residArray.push(resid);

                prevResi = resi;
            }

            end = prevResi;
            for(let j = 0, jl = residArray.length; j < jl; ++j) {
                resid2range_t[residArray[j]] = {resiStart: start, resiEnd: end, prevResiEnd: prevEnd};
            }

            for(let i = 0, il = chainidArray.length; i < il; ++i) { 
                let chainid = chainidArray[i];
                ic.alnChainsSeq[chainid] = [];
                ic.alnChains[chainid] = {}; 

                ic.alnChainsAnno[chainid] = []; 
            }

            // fill the template ic.alnChainsSeq[chainid1]
            for(let j = 0, jl = ic.chainsSeq[chainid1].length; j < jl; ++j) { 
                let resi = ic.chainsSeq[chainid1][j].resi;
                let resid = chainid1 + '_' + resi;

                let jAdjusted = (me.cfg.aligntool != 'tmalign') ? j : j + baseResi;

                //if(j + baseResi < start_t || j + baseResi > end_t) {
                if(jAdjusted < start_t || jAdjusted > end_t) {    
                    continue;
                }

                let resObject = {};
                let pos = chainid1.indexOf('_');
                resObject.mmdbid = chainid1.substr(0, pos);
                resObject.chain = chainid1.substr(pos+1);
                resObject.resi = resi;
                resObject.resn = (resid2range_t[resid]) ? ic.chainsSeq[chainid1][j].name.toUpperCase() : ic.chainsSeq[chainid1][j].name.toLowerCase();
                resObject.aligned = (resid2range_t[resid]) ? true : false;
                resObject.color = (resid2range_t[resid]) ? '#FF0000' : me.htmlCls.GREYC; // color by identity
                resObject.color2 = (resid2range_t[resid]) ? '#FF0000' : me.htmlCls.GREYC; // color by conservation
                // resObject.class = (resid2range_t[resid]) ? 'icn3d-align' : 'icn3d-nalign';
                resObject.class = (resid2range_t[resid]) ? 'icn3d-cons' : 'icn3d-nalign';
        
                ic.alnChainsSeq[chainid1].push(resObject);

                if(resid2range_t[resid]) {
                    $.extend(ic.alnChains[chainid1], ic.residues[chainid1 + '_' + resObject.resi] );
                    hAtoms = me.hashUtilsCls.unionHash(hAtoms, ic.residues[chainid1 + '_' + resObject.resi]);
                }
            }

            // progressively merge sequences, starting from most similar to least similar
            // assign ic.alnChainsSeq
            let alignedChainIndice = [0];
            for(let arrayIndex = 0, arrayIndexl = index_alignLen.length; arrayIndex < arrayIndexl; ++arrayIndex) { 
                let index = index_alignLen[arrayIndex].index;
                alignedChainIndice.push(index);
                let hAtomsTmp = this.mergeTwoSeqForAll(chainidArray, index, alignedChainIndice, resid2range_t, start_t, end_t, bRealign);

                hAtoms = me.hashUtilsCls.unionHash(hAtoms, hAtomsTmp);
            }   

            this.setMsaFormat(chainidArray);
              
            // 3. assign the variable ic.alnChainsAnno
            for(let i = 0; i < 3 + 2*n; ++i) {
                if(ic.alnChainsAnno[chainid1][i] === undefined ) ic.alnChainsAnno[chainid1][i] = [];
            }

            // secondary structures
            for(let i = 0; i < n; ++i) {
                let chainid = chainidArray[i];

                for(let j = 0, jl = ic.alnChainsSeq[chainid].length; j < jl; ++j) {
                    let resn = ic.alnChainsSeq[chainid][j].resn;
                    if(resn == '-') {
                        ic.alnChainsAnno[chainid1][n - 1 - i].push('-');  
                    }
                    else {
                        let resi = ic.alnChainsSeq[chainid][j].resi;
                        let residueid = chainid + '_' + resi;
                        let ss = ic.secondaries[residueid];

                        // push the annotations to the template chain
                        if(ss !== undefined) {
                            ic.alnChainsAnno[chainid1][n - 1 - i].push(ss);
                        }
                        else {
                            ic.alnChainsAnno[chainid1][n - 1 - i].push('-');
                        }
                    }
                }
            }

            // residue number 
            for(let alignIndex = 0, alignIndexl = ic.alnChainsSeq[chainid1].length; alignIndex < alignIndexl; ++alignIndex) {
                let symbol = '.';
                if(alignIndex % 5 === 0) symbol = '*';
                if(alignIndex % 10 === 0) symbol = '|';
                ic.alnChainsAnno[chainid1][n].push(symbol); // symbol: | for 10th, * for 5th, . for rest

                let numberStr = '';
                if(alignIndex % 10 === 0) numberStr = alignIndex.toString();
                ic.alnChainsAnno[chainid1][n + 1].push(numberStr); // symbol: 10, 20, etc, empty for rest
            }

            // title
            for(let i = n + 2; i < 2*n + 2; ++i) { // reverse order
                let title = ic.pdbid_chain2title && ic.pdbid_chain2title.hasOwnProperty(chainidArray[2*n + 1 - i]) ? ic.pdbid_chain2title[chainidArray[2*n + 1 - i]] : "";
                ic.alnChainsAnno[chainid1][i].push(title);
            }

            // empty line
            ic.alnChainsAnno[chainid1][2*n + 2].push("");    
            
            return hAtoms;
        }

        getResObject(chainid, bGap, bAligned, resi, resn, resn_t) { let ic = this.icn3d, me = ic.icn3dui;
            let resObject = {};
            let pos = chainid.indexOf('_');
            resObject.mmdbid = chainid.substr(0, pos);
            resObject.chain = chainid.substr(pos+1);
            resObject.resi = (bGap) ? '' : resi; // resi will be empty if there is no coordinates
            if(!resn) {
                resObject.resn = '-';
            }
            else {
                resObject.resn = (bGap) ? '-' : ((bAligned) ? resn.toUpperCase() : resn.toLowerCase());
            }
            resObject.aligned = (bGap) ? false : bAligned;
            resObject.color = (bGap || !bAligned) ? me.htmlCls.GREYC : ((resn == resn_t) ? "#FF0000" : "#0000FF"); // color by identity
            resObject.color2 = (bGap || !bAligned) ? me.htmlCls.GREYC : '#' + ic.showAnnoCls.getColorhexFromBlosum62(resn, resn_t); // color by conservation
            resObject.class = (bGap || !bAligned) ? 'icn3d-nalign' :  ((resn == resn_t) ? "icn3d-cons" : "icn3d-ncons");

            return resObject;
        }

        getResn(chainid, resiPos) { let ic = this.icn3d; ic.icn3dui;
            let resn;
      
            // if(bRealign) {
            //     let resid = chainid + '_' + resiPos;

            //     if(ic.residues[resid] === undefined) {
            //         resn = '';
            //     }
            //     else {
            //         resn = me.utilsCls.residueName2Abbr(ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid]).resn.substr(0, 3));
            //     }
            // }
            // else {
                if(!ic.chainsSeq[chainid] || !ic.chainsSeq[chainid][resiPos]) {
                    resn = '';
                }
                else {
                    resn = ic.chainsSeq[chainid][resiPos].name;
                }
            // }

            return resn;
        }

        // getResnFromResid(resid) { let ic = this.icn3d, me = ic.icn3dui;
        //     return ic.residueId2Name[resid];
        // }

        getResiPosInTemplate(chainid1, resi_t) { let ic = this.icn3d; ic.icn3dui;
            // check the number of gaps before resiStart1 (nGap), and insert 'notAlnLen2 - notAlnLen1 - nGap' gaps
            let nGap = 0;

            let pos_t; // position to add gap

            if(ic.alnChainsSeq[chainid1]) {
                for(let j = 0, jl = ic.alnChainsSeq[chainid1].length; j < jl; ++j) {
                    //add gap before the mapping region       
                    if(parseInt(ic.alnChainsSeq[chainid1][j].resi) == parseInt(resi_t)) {
                        pos_t = j;
                        break;
                    }

                    if(ic.alnChainsSeq[chainid1][j].resn == '-') {
                        ++nGap;
                    }
                    else {
                        nGap = 0;
                    }
                }
            }

            return {"pos": pos_t, "ngap": nGap};
        }

        addGapAllAlnChains(chainidArray, alignedChainIndice, chainid1, resi_t, len) { let ic = this.icn3d; ic.icn3dui;    
            let result = this.getResiPosInTemplate(chainid1, resi_t);
            result.ngap; let pos_t = result.pos;

            // add gaps for all previously aligned sequences, not the current sequence, which is the last one
            for(let j = 0, jl = alignedChainIndice.length - 1; j < jl; ++j) {
                let chainidTmp = chainidArray[alignedChainIndice[j]];
                let gapResObject = this.getResObject(chainidTmp, true);
                //for(let k = 0, kl = len - nGap; k < kl; ++k) {
                for(let k = 0, kl = len; k < kl; ++k) {
                    ic.alnChainsSeq[chainidTmp].splice(pos_t, 0, gapResObject);
                }
            }

            //return len - nGap;
        }

        insertNotAlignRes(chainid, start, len, bRealign) { let ic = this.icn3d; ic.icn3dui;
            // insert non-aligned residues in query seq
            for(let j = 0, jl = len; j < jl; ++j) {
                let resi2 = ic.ParserUtilsCls.getResi(chainid, start + j);
                let resn2 = this.getResn(chainid, start + j);
                let resn1 = '-';
                let bAlign = false;
                let resObject = this.getResObject(chainid, false, bAlign, resi2, resn2, resn1);
                ic.alnChainsSeq[chainid].push(resObject);
            }
        }

        getTemplatePosFromOriPos(chainid1, start, end, bRealign) { let ic = this.icn3d; ic.icn3dui;
            let startResi = ic.ParserUtilsCls.getResi(chainid1, start);
            let endResi = ic.ParserUtilsCls.getResi(chainid1, end);
                
            let result1 = this.getResiPosInTemplate(chainid1, startResi);
            let result2 = this.getResiPosInTemplate(chainid1, endResi);
            
            return {"pos1": result1.pos, "pos2": result2.pos};
        }

        mergeTwoSeqForAll(chainidArray, index, alignedChainIndice, resid2range_t, start_t, end_t, bRealign) { let ic = this.icn3d, me = ic.icn3dui;
            let hAtoms = {};

            let chainid = chainidArray[index];
            let chainIndex = index - 1;

            //loadSeqAlignment
            let mmdbid1, mmdbid2, chain1, chain2, chainid1, chainid2;
            let pos1, pos2;

            pos1 = chainidArray[0].indexOf('_');
            pos2 = chainid.indexOf('_');

            //mmdbid1 = ic.mmdbid_t; 
            mmdbid1 = chainidArray[0].substr(0, pos1); //.toUpperCase();
            mmdbid2 = chainid.substr(0, pos2); //.toUpperCase()mergeTwoSeqForAll;

            chain1 = chainidArray[0].substr(pos1 + 1);
            chain2 = chainid.substr(pos2 + 1);

            if(mmdbid1 == mmdbid2 && chain1 == chain2) {
                let chainLen = ic.chainsSeq[ic.mmdbid_q + '_' + ic.chain_q].length;
                ic.qt_start_end[chainIndex] =  {"q_start":1, "q_end": chainLen, "t_start":1, "t_end": chainLen};
            }

            chainid1 = mmdbid1 + "_" + chain1;
            chainid2 = mmdbid2 + "_" + chain2;

            if(mmdbid2 !== undefined && mmdbid2 === ic.mmdbid_t) ;

            //ic.alnChainsSeq[chainid2] = [];
            ic.alnChains[chainid2] = {};

            //ic.conservedName1 = chainid1 + '_cons';
            //ic.nonConservedName1 = chainid1 + '_ncons';
            //ic.notAlignedName1 = chainid1 + '_nalign';

            ic.conservedName2 = chainid2 + '_cons';
            ic.nonConservedName2 = chainid2 + '_ncons';
            ic.notAlignedName2 = chainid2 + '_nalign';

            //ic.consHash1 = {};
            //ic.nconsHash1 = {};
            //ic.nalignHash1 = {};

            ic.consHash2 = {};
            ic.nconsHash2 = {};
            ic.nalignHash2 = {};
            let prevIndex1, prevIndex2;

            if(ic.qt_start_end[chainIndex] === undefined) return;

            this.getResObject(chainid1, true);
            let gapResObject2 = this.getResObject(chainid2, true);
            // ic.chainsMapping is used for reference number
            if(!ic.chainsMapping[chainid1]) ic.chainsMapping[chainid1] = {};
            if(!ic.chainsMapping[chainid2]) ic.chainsMapping[chainid2] = {};

            let result;

            for(let i = 0, il = ic.qt_start_end[chainIndex].length; i < il; ++i) {
                let start1, start2, end1, end2, resiStart1, start1Pos, end1Pos;
                if(bRealign && me.cfg.aligntool == 'tmalign') { // real residue numbers are stored
                    start1 = parseInt(ic.qt_start_end[chainIndex][i].t_start);
                    start2 = parseInt(ic.qt_start_end[chainIndex][i].q_start);
                    end1 = parseInt(ic.qt_start_end[chainIndex][i].t_end);
                    end2 = parseInt(ic.qt_start_end[chainIndex][i].q_end);  

                    // start1 = this.getPosFromResi(chainid1, ic.qt_start_end[chainIndex][i].t_start);
                    // start2 = this.getPosFromResi(chainid2, ic.qt_start_end[chainIndex][i].q_start);
                    // end1 = this.getPosFromResi(chainid1, ic.qt_start_end[chainIndex][i].t_end);
                    // end2 = this.getPosFromResi(chainid2, ic.qt_start_end[chainIndex][i].q_end);

                    // 1. before the mapped residues
                    resiStart1 = start1;
                    start1Pos = this.getPosFromResi(chainid1, ic.qt_start_end[chainIndex][i].t_start);
                    end1Pos = this.getPosFromResi(chainid1, ic.qt_start_end[chainIndex][i].t_end);
                }
                else {
                    start1 = parseInt(ic.qt_start_end[chainIndex][i].t_start - 1);
                    start2 = parseInt(ic.qt_start_end[chainIndex][i].q_start - 1);
                    end1 = parseInt(ic.qt_start_end[chainIndex][i].t_end - 1);
                    end2 = parseInt(ic.qt_start_end[chainIndex][i].q_end - 1);  

                    // 1. before the mapped residues
                    resiStart1 = ic.ParserUtilsCls.getResi(chainid1, start1);
                    start1Pos = start1;
                    end1Pos = end1;
                }
                //let range = resid2range_t[chainid1 + '_' + resiStart1];
      
                // if the mapping does not start from start_t, add gaps to the query seq
                if(i == 0) {
                    //result = this.getTemplatePosFromOriPos(chainid1, start_t, start1, bRealign);
                    result = this.getTemplatePosFromOriPos(chainid1, start_t, start1Pos, bRealign);
                    pos1 = result.pos1;
                    pos2 = result.pos2;
                    
                    //if(start1 > start_t) {
                    if(start1Pos > start_t) {
                        for(let j = 0, jl = pos2 - pos1; j < jl; ++j) {
                            ic.alnChainsSeq[chainid2].push(gapResObject2);
                        }
                    }
                }
                else {
                    //let notAlnLen1 = start1 - (prevIndex1 + 1);
                    result = this.getTemplatePosFromOriPos(chainid1, prevIndex1, start1, bRealign);
                    pos1 = result.pos1;
                    pos2 = result.pos2;
                    let notAlnLen1 = pos2 - (pos1 + 1);
                    let notAlnLen2 = start2 - (prevIndex2 + 1);

                    // insert non-aligned residues in query seq
                    this.insertNotAlignRes(chainid2, prevIndex2+1, notAlnLen2, bRealign);

                    if(notAlnLen1 >= notAlnLen2) {
                        // add gaps before the query sequence
                        for(let j = 0, jl = notAlnLen1 - notAlnLen2; j < jl; ++j) {
                            ic.alnChainsSeq[chainid2].push(gapResObject2);
                        }                       
                    }
                    else {
                        // check the number of gaps before resiStart1 (n), and insert 'notAlnLen2 - notAlnLen1 - n' gaps
                        this.addGapAllAlnChains(chainidArray, alignedChainIndice, chainid1, resiStart1, notAlnLen2 - notAlnLen1);
                    }                           
                }

                // 2. In the mapped residues
                //result = this.getTemplatePosFromOriPos(chainid1, start1, end1, bRealign);
                result = this.getTemplatePosFromOriPos(chainid1, start1Pos, end1Pos, bRealign);
                pos1 = result.pos1;
                pos2 = result.pos2;
                
                let k = 0;    
                if(!ic.chainsMapping[chainid1]) ic.chainsMapping[chainid1] = {};
                if(!ic.chainsMapping[chainid2]) ic.chainsMapping[chainid2] = {};
                for(let j = pos1; j <= pos2; ++j) {
                    // inherit the gaps from the template
                    if(ic.alnChainsSeq[chainid1][j].resn == '-') {
                        ic.alnChainsSeq[chainid2].push(gapResObject2);
                    }
                    else {                   
                        let resi1 = (bRealign) ? start1 + k : ic.ParserUtilsCls.getResi(chainid1, start1 + k);
                        let resi2 = (bRealign) ? start2 + k : ic.ParserUtilsCls.getResi(chainid2, start2 + k);
                        let resn1 = this.getResnFromResi(chainid1, resi1); //this.getResn(chainid1, start1 + k);
                        let resn2 = this.getResnFromResi(chainid2, resi2); //this.getResn(chainid2, start2 + k);
                        
                        let bAlign = true;
                        let resObject = this.getResObject(chainid2, false, bAlign, resi2, resn2, resn1);
                        ic.alnChainsSeq[chainid2].push(resObject);
                        // update color in the template
                        ic.alnChainsSeq[chainid1][j].color = resObject.color;

                        ic.chainsMapping[chainid1][chainid1 + '_' + resi1] = resn1 + resi1;
                        ic.chainsMapping[chainid2][chainid2 + '_' + resi2] = resn1 + resi1;  

                        //if(ic.alnChains[chainid2] === undefined) ic.alnChains[chainid2] = {}
                        $.extend(ic.alnChains[chainid2], ic.residues[chainid2 + '_' + resi2] );
                        hAtoms = me.hashUtilsCls.unionHash(hAtoms, ic.residues[chainid2 + '_' + resi2]);

                        ++k;
                    }
                }
                
                prevIndex1 = end1;
                prevIndex2 = end2;  
            } 

            // add gaps at the end
            result = this.getTemplatePosFromOriPos(chainid1, prevIndex1, end_t, bRealign);
            pos1 = result.pos1;
            pos2 = result.pos2;
            for(let i = pos1; i < pos2; ++i) {
            //for(let i = pos1; i <= pos2; ++i) {
                ic.alnChainsSeq[chainid2].push(gapResObject2);      
            }     

            return hAtoms;
        }

        // used for seq MSA
        mergeTwoSeqForAllSimple(targetId, chainidArray, index, alignedChainIndice, start_t, end_t, querySeqArray) { let ic = this.icn3d; ic.icn3dui;
            let chainid1 = targetId;
            let chainid2 = chainidArray[index];

            let pos1, pos2, prevIndex1, prevIndex2;

            for(let i = 0, il = ic.qt_start_end[index].length; i < il; ++i) {
                let start1, start2, end1, end2, resiStart1, start1Pos, end1Pos;
                
                start1 = ic.qt_start_end[index][i].t_start;
                start2 = ic.qt_start_end[index][i].q_start;
                end1 = ic.qt_start_end[index][i].t_end;
                end2 = ic.qt_start_end[index][i].q_end;  

                // 1. before the mapped residues
                //resiStart1 = ic.ParserUtilsCls.getResi(chainid1, start1);
                resiStart1 = start1;
                start1Pos = start1;
                end1Pos = end1;

                // if the mapping does not start from start_t, add gaps to the query seq
                if(i == 0) {
                    pos1 = start_t;
                    pos2 = start1Pos;
                    
                    if(start1Pos > start_t) {
                        for(let j = 0, jl = pos2 - pos1; j < jl; ++j) {
                            ic.msaSeq[chainid2] += '-';
                        }
                    }
                }
                else {
                    pos1 = prevIndex1;
                    pos2 = start1;
                    let notAlnLen1 = pos2 - (pos1 + 1);
                    let notAlnLen2 = start2 - (prevIndex2 + 1);
                    
                    // insert non-aligned residues in query seq
                    // this.insertNotAlignRes(chainid2, prevIndex2+1, notAlnLen2, bRealign);

                    for(let j = 0, jl = notAlnLen2; j < jl; ++j) {
                        let resn = querySeqArray[index][prevIndex2+1 + j];
                        ic.msaSeq[chainid2] += resn;
                    }

                    if(notAlnLen1 >= notAlnLen2) {
                        // add gaps before the query sequence
                        for(let j = 0, jl = notAlnLen1 - notAlnLen2; j < jl; ++j) {
                            ic.msaSeq[chainid2] += '-';
                        }                       
                    }
                    else {
                        // check the number of gaps before resiStart1 (n), and insert 'notAlnLen2 - notAlnLen1 - n' gaps
                        // this.addGapAllAlnChains(chainidArray, alignedChainIndice, chainid1, resiStart1, notAlnLen2 - notAlnLen1);

                        // let result = this.getResiPosInTemplate(chainid1, resi_t);
                        // let nGap = result.ngap, pos_t = result.pos;

                        let pos_t = resiStart1; // position to add gap
                
                        // add gaps for all previously aligned sequences, not the current sequence, which is the last one
                        for(let j = 0, jl = alignedChainIndice.length - 1; j < jl; ++j) {
                            let chainidTmp = (j == 0) ? chainid1 : chainidArray[alignedChainIndice[j]];

                            for(let k = 0, kl = notAlnLen2 - notAlnLen1; k < kl; ++k) {
                                //ic.msaSeq[chainidTmp].splice(pos_t, 0, '-');
                                ic.msaSeq[chainidTmp] = ic.msaSeq[chainidTmp].substr(0, pos_t) + '-' + ic.msaSeq[chainidTmp].substr(pos_t);
                            }
                        }
                    }                           
                }

                // 2. In the mapped residues
                pos1 = start1Pos;
                pos2 = end1Pos;
                
                let k = 0;    
                for(let j = pos1; j <= pos2; ++j) {
                    // inherit the gaps from the template
                    if(ic.msaSeq[chainid1][j] == '-') {
                        ic.msaSeq[chainid2] += '-';
                    }
                    else {
                        //let resn1 = targetSeq[start1 + k];
                        let resn2 = querySeqArray[index][start2 + k];
                        //let resn2 = (querySeqArray[index]) ? querySeqArray[index][start2 + k] : '?';
                        
                        ic.msaSeq[chainid2] += resn2;

                        ++k;
                    }
                }
                
                prevIndex1 = end1;
                prevIndex2 = end2;  
            } 

            // add gaps at the end
            pos1 = prevIndex1;
            pos2 = end_t;
            for(let i = pos1; i < pos2; ++i) {
            //for(let i = pos1; i <= pos2; ++i) {
                ic.msaSeq[chainid2] += '-';           
            }
        }

        setSeqAlignForRealign(chainid_t, chainid, chainIndex) { let ic = this.icn3d, me = ic.icn3dui;
              //var chainid_t = ic.chainidArray[0];

        //      let structureArray = Object.keys(ic.structures);
            //   let structure1 = chainid_t.substr(0, chainid_t.indexOf('_')); //structureArray[0];
            //   let structure2 = chainid.substr(0, chainid.indexOf('_')); //structureArray[1];

            //   if(structure1 == structure2) structure2 += me.htmlCls.postfix;

              ic.conservedName1 = chainid_t + '_cons';
              ic.conservedName2 = chainid + '_cons';

              ic.consHash1 = {};
              ic.consHash2 = {};

              ic.alnChainsAnTtl = {};
              ic.alnChainsAnno = {};

              if(ic.alnChainsSeq === undefined) ic.alnChainsSeq = {};
              ic.alnChains = {};

              ic.alnChainsSeq[chainid_t] = [];
              ic.alnChains[chainid_t] = {};
              ic.alnChainsAnno[chainid_t] = [];
              ic.alnChainsAnTtl[chainid_t] = [];

              ic.alnChainsSeq[chainid] = [];
              ic.alnChains[chainid] = {};

        //      let emptyResObject = {resid: '', resn:'', resi: 0, aligned: false}

        //      let prevChainid1 = '', prevChainid2 = '', cnt1 = 0, cnt2 = 0;

              let residuesHash = {};
              if(!ic.chainsMapping[chainid_t]) ic.chainsMapping[chainid_t] = {};
              if(!ic.chainsMapping[chainid]) ic.chainsMapping[chainid] = {};

              for(let i = 0, il = ic.realignResid[chainid_t].length; i < il; ++i) {
                  let resObject1 = ic.realignResid[chainid_t][i];
                  let pos1 = resObject1.resid.lastIndexOf('_');
                  let chainid1 = resObject1.resid.substr(0, pos1);
                  let resi1 = resObject1.resid.substr(pos1 + 1);
                  resObject1.resi = resi1;
                  resObject1.aligned = true;

                  let resObject2 = ic.realignResid[chainid][i];
                  let pos2 = resObject2.resid.lastIndexOf('_');
                  let chainid2 = resObject2.resid.substr(0, pos2);
                  let resi2 = resObject2.resid.substr(pos2 + 1);
                  resObject2.resi = resi2;
                  resObject2.aligned = true;

                  residuesHash[resObject1.resid] = 1;
                  residuesHash[resObject2.resid] = 1;

                  let color;
                  if(resObject1.resn.toUpperCase() == resObject2.resn.toUpperCase()) {
                      color = "#FF0000";
                  }
                  else {
                      color = "#0000FF";
                  }

                  // mapping, use the firstsequence as the reference structure
                  ic.chainsMapping[chainid_t][chainid_t + '_' + resObject1.resi] = resObject1.resn + resObject1.resi;
                  ic.chainsMapping[chainid][chainid + '_' + resObject2.resi] = resObject1.resn + resObject1.resi;

                  let color2 = '#' + ic.showAnnoCls.getColorhexFromBlosum62(resObject1.resn, resObject2.resn);

                  resObject1.color = color;
                  resObject2.color = color;

                  resObject1.color2 = color2;
                  resObject2.color2 = color2;

                  for(let j in ic.residues[resObject1.resid]) {
                      ic.atoms[j].color = me.parasCls.thr(color);
                  }
                  for(let j in ic.residues[resObject2.resid]) {
                      ic.atoms[j].color = me.parasCls.thr(color);
                  }

                  // annotation title for the master seq only
                  if(ic.alnChainsAnTtl[chainid1] === undefined ) ic.alnChainsAnTtl[chainid1] = [];

                  for(let j = 0; j < 3; ++j) {
                      if(ic.alnChainsAnTtl[chainid1][j] === undefined ) ic.alnChainsAnTtl[chainid1][j] = [];
                  }

                  // two annotations without titles
                  for(let j = 0; j < 3; ++j) {
                      ic.alnChainsAnTtl[chainid1][j].push("");
                  }

                  if(ic.alnChainsSeq[chainid1] === undefined) ic.alnChainsSeq[chainid1] = [];
                  if(ic.alnChainsSeq[chainid2] === undefined) ic.alnChainsSeq[chainid2] = [];

                  ic.alnChainsSeq[chainid1].push(resObject1);
                  ic.alnChainsSeq[chainid2].push(resObject2);

                  if(ic.alnChains[chainid1] === undefined) ic.alnChains[chainid1] = {};
                  if(ic.alnChains[chainid2] === undefined) ic.alnChains[chainid2] = {};
                  $.extend(ic.alnChains[chainid1], ic.residues[chainid1 + '_' + resObject1.resi] );
                  $.extend(ic.alnChains[chainid2], ic.residues[chainid2 + '_' + resObject2.resi] );

                  ic.consHash1[chainid1 + '_' + resObject1.resi] = 1;
                  ic.consHash2[chainid2 + '_' + resObject2.resi] = 1;

                  // annotation is for the master seq only
                  if(ic.alnChainsAnno[chainid1] === undefined ) ic.alnChainsAnno[chainid1] = [];
                  //if(ic.alnChainsAnno[chainid2] === undefined ) ic.alnChainsAnno[chainid2] = [];

                  for(let j = 0; j < 3; ++j) {
                      if(ic.alnChainsAnno[chainid1][j] === undefined ) ic.alnChainsAnno[chainid1][j] = [];
                  }

                  let symbol = '.';
                  if(i % 5 === 0) symbol = '*';
                  if(i % 10 === 0) symbol = '|';
                  ic.alnChainsAnno[chainid1][0].push(symbol); // symbol: | for 10th, * for 5th, . for rest

                  let numberStr = '';
                  if(i % 10 === 0) numberStr = i.toString();
                  ic.alnChainsAnno[chainid1][1].push(numberStr); // symbol: 10, 20, etc, empty for rest
              }

                let commandname = 'protein_aligned';
                let commanddescr = 'protein aligned';
                let select = "select " + ic.resid2specCls.residueids2spec(Object.keys(residuesHash));
                ic.selectionCls.addCustomSelection(Object.keys(residuesHash), commandname, commanddescr, select, true);
        }

        setSeqPerResi(chainid, chainid1, chainid2, resi, resn, bAligned, color, color2, classname, bFirstChain, bFirstResi, alignIndex) { let ic = this.icn3d, me = ic.icn3dui;
            if(ic.alnChainsSeq[chainid] === undefined) ic.alnChainsSeq[chainid] = [];

            let resObject = {};
            let pos = chainid.indexOf('_');
            resObject.mmdbid = chainid.substr(0, pos);
            resObject.chain = chainid.substr(pos+1);
            resObject.resi = resi;
            // resi will be empty if there is no coordinates
            resObject.resn =(resObject.resi === '' || classname === 'icn3d-nalign') ? resn.toLowerCase() : resn;
            resObject.aligned = bAligned;
            // resi will be empty if there is no coordinates
            resObject.color =(resObject.resi === '') ? me.htmlCls.GREYC : color; // color by identity
            resObject.color2 =(resObject.resi === '') ? me.htmlCls.GREYC : color2; // color by conservation
            resObject.class = classname;

            ic.alnChainsSeq[chainid].push(resObject);

            if(resObject.resi !== '') {
                if(ic.alnChains[chainid] === undefined) ic.alnChains[chainid] = {};
                $.extend(ic.alnChains[chainid], ic.residues[chainid + '_' + resObject.resi] );
            }

            if(bFirstChain) {
                // annotation is for the master seq only
                if(ic.alnChainsAnno[chainid] === undefined ) ic.alnChainsAnno[chainid] = [];
                if(ic.alnChainsAnno[chainid][0] === undefined ) ic.alnChainsAnno[chainid][0] = [];
                if(ic.alnChainsAnno[chainid][1] === undefined ) ic.alnChainsAnno[chainid][1] = [];
                if(ic.alnChainsAnno[chainid][2] === undefined ) ic.alnChainsAnno[chainid][2] = [];
                if(ic.alnChainsAnno[chainid][3] === undefined ) ic.alnChainsAnno[chainid][3] = [];
                if(bFirstResi) {
                    // empty line
                    // 2nd chain title
                    if(ic.alnChainsAnno[chainid][4] === undefined ) ic.alnChainsAnno[chainid][4] = [];
                    // master chain title
                    if(ic.alnChainsAnno[chainid][5] === undefined ) ic.alnChainsAnno[chainid][5] = [];
                    // empty line
                    if(ic.alnChainsAnno[chainid][6] === undefined ) ic.alnChainsAnno[chainid][6] = [];

                    let title1 = ic.pdbid_chain2title && ic.pdbid_chain2title.hasOwnProperty(chainid2) ? ic.pdbid_chain2title[chainid2] : "";
                    let title2 = ic.pdbid_chain2title && ic.pdbid_chain2title.hasOwnProperty(chainid) ? ic.pdbid_chain2title[chainid] : "";
                    ic.alnChainsAnno[chainid][4].push(title1);
                    ic.alnChainsAnno[chainid][5].push(title2);
                    ic.alnChainsAnno[chainid][6].push('');
                }

                let symbol = '.';
                if(alignIndex % 5 === 0) symbol = '*';
                if(alignIndex % 10 === 0) symbol = '|';
                ic.alnChainsAnno[chainid][2].push(symbol); // symbol: | for 10th, * for 5th, . for rest

                let numberStr = '';
                if(alignIndex % 10 === 0) numberStr = alignIndex.toString();
                ic.alnChainsAnno[chainid][3].push(numberStr); // symbol: 10, 20, etc, empty for rest

                let residueid = chainid + '_' + resi;
                let ss = ic.secondaries[residueid];

                if(ss !== undefined) {
                    ic.alnChainsAnno[chainid][1].push(ss);
                }
                else {
                    ic.alnChainsAnno[chainid][1].push('-');
                }
            }
            else {
                let residueid = chainid + '_' + resi;
                let ss = ic.secondaries[residueid];

                if(ic.alnChainsAnno.hasOwnProperty(chainid1) && ic.alnChainsAnno[chainid1].length > 0) {
                    if(ss !== undefined) {
                        ic.alnChainsAnno[chainid1][0].push(ss);
                    }
                    else {
                        ic.alnChainsAnno[chainid1][0].push('-');
                    }
                }
                else {
                    console.log("Error: ic.alnChainsAnno[chainid1] is undefined");
                }
            }
        }   

        setMsaFormat(chainidArray) { let ic = this.icn3d; ic.icn3dui;
            //set MSA
            let fastaFormat = '', clustalwFormat = 'CLUSTALWW\n\n', resbyresFormat = '';
            let chainArrayClustal = [];
            
            let consArray = [], resiArrayTemplate = [];
            let chainidTemplate = chainidArray[0];
            for(let i = 0, il = chainidArray.length; i < il; ++i) { 
                let chainid = chainidArray[i];
                fastaFormat += '>' + chainid + '\n';

                let clustalwArray = [];
                let clustalwLine = chainid.padEnd(20, ' ');
                let consLine = ''.padEnd(20, ' ');

                let resiArrayTarget = [], resiArrayQuery = [];

                let cnt = 0;
                for(let j = 0, jl = ic.alnChainsSeq[chainid].length; j < jl; ++j) {
                    let resn = ic.alnChainsSeq[chainid][j].resn;
                    fastaFormat += resn;
                    clustalwLine += resn;
                    if(i == il - 1) {
                        let alignedClass = ic.alnChainsSeq[chainid][j].class;
                        if(alignedClass == 'icn3d-cons') {
                            consLine += '*';
                        }
                        else if(alignedClass == 'icn3d-ncons') {
                            consLine += '.';
                        }
                        else {
                            consLine += ' ';
                        }
                    }

                    // residue by residue 
                    if(i == 0) {
                        resiArrayTemplate.push(ic.alnChainsSeq[chainid][j].resi);
                    }
                    else {
                        // if(ic.alnChainsSeq[chainid][j].aligned) {
                        if(ic.alnChainsSeq[chainid][j].aligned && ic.alnChainsSeq[chainidTemplate][j] && ic.alnChainsSeq[chainid][j]) {
                            resiArrayTarget.push(ic.alnChainsSeq[chainidTemplate][j].resi);
                            resiArrayQuery.push(ic.alnChainsSeq[chainid][j].resi);
                        }
                    }

                    ++cnt;

                    if(cnt % 60 == 0) {
                        fastaFormat += '\n';
                        clustalwLine += ' ' + String(parseInt(cnt / 60) * 60);
                        clustalwArray.push(clustalwLine);
                        clustalwLine = chainid.padEnd(20, ' ');

                        if(i == il - 1) {
                            consArray.push(consLine);
                            consLine = ''.padEnd(20, ' ');
                        }
                    }
                }

                // add last line
                if(cnt % 60 != 0) {
                    clustalwArray.push(clustalwLine);
                    if(i == il - 1) {
                        consArray.push(consLine);
                    }
                }

                fastaFormat += '\n';

                chainArrayClustal.push(clustalwArray);
                if(i == il - 1) chainArrayClustal.push(consArray);

                // residue by residue
                let resiRangeStr1 = ic.resid2specCls.resi2range(resiArrayTarget, true);
                let resiRangeStr2 = ic.resid2specCls.resi2range(resiArrayQuery, true);

                if(i > 0) resbyresFormat += resiRangeStr1 + ' | ' + resiRangeStr2 + '\n';
            }

            // CLUSTALWW
            for(let j = 0, jl = chainArrayClustal[0].length; j < jl; ++j) {
                for(let i = 0, il = chainArrayClustal.length; i < il; ++i) {
                    clustalwFormat += chainArrayClustal[i][j] + '\n';
                }
                clustalwFormat += '\n';
            }
            
            // seq MSA
            if(!ic.msa) ic.msa = {};

            if(!ic.msa['fasta']) ic.msa['fasta'] = [];
            if(!ic.msa['clustalw']) ic.msa['clustalw'] = [];
            if(!ic.msa['resbyres']) ic.msa['resbyres'] = [];

            ic.msa['fasta'].push(fastaFormat);
            ic.msa['clustalw'].push(clustalwFormat);
            ic.msa['resbyres'].push(resbyresFormat);
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class LoadPDB {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        getStructureId(id, moleculeNum, bMutation, bNMR) { let ic = this.icn3d; ic.icn3dui;
            id = (bNMR && ic.idNMR) ? ic.idNMR : id;
            let structure = id;
        
            if(id == ic.defaultPdbId || bMutation || ic.structures.hasOwnProperty(id)) { // bMutation: side chain prediction
                structure = (moleculeNum === 1) ? id : id + moleculeNum.toString();
            }

            return structure;
        }

        // modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
        //This PDB parser feeds the viewer with the content of a PDB file, pdbData.
        // async loadPDB(src, pdbid, bOpm, bVector, bMutation, bAppend, type, bEsmfold) { let ic = this.icn3d, me = ic.icn3dui;
        loadPDB(src, pdbid, bOpm, bVector, bMutation, bAppend, type, bEsmfold) { let ic = this.icn3d, me = ic.icn3dui;
            let hAtoms = {};

            let bNMR = false;
            let lines = src.split('\n');

            let chainsTmp = {}; // serial -> atom
            let residuesTmp = {}; // serial -> atom

            if(!ic.atoms) bAppend = false;

            if(ic.statefileArray) ic.struct_statefile = [];

            let serial, moleculeNum;
            if(!bMutation && !bAppend) {
                ic.init();
                moleculeNum = 1;
                serial = 0;
            }
            else {
                // remove the last structure
                // if(ic.alertAlt) {
                //     let nStru = ic.oriNStru + 1; //Object.keys(ic.structures).length;
                //     let  chainArray = ic.structures[nStru - 1];
                //     for(let i = 0, il = (chainArray) ? chainArray.length : 0; i < il; ++i) {
                //         for(let j in ic.chains[chainArray[i]]) {
                //             delete ic.atoms[j];
                //             delete ic.hAtoms[j];
                //             delete ic.dAtoms[j];
                //         }
                //         delete ic.chains[chainArray[i]];
                //     }

                //     delete ic.structures[nStru - 1];
                // }
                // else {
                    ic.oriNStru = (ic.structures) ? Object.keys(ic.structures).length : 0;
                // }

                moleculeNum = ic.oriNStru + 1; //Object.keys(ic.structures).length + 1;
                // Concatenation of two pdbs will have several atoms for the same serial
                serial = (ic.atoms) ? Object.keys(ic.atoms).length : 0;
            }

            //let helices = [], sheets = [];
            let sheetArray = [], sheetStart = [], sheetEnd = [], helixArray = [], helixStart = [], helixEnd = [];

            let chainNum, residueNum, oriResidueNum;
            let prevChainNum = '', prevResidueNum = '', prevOriResidueNum = '';

            let oriSerial2NewSerial = {};

            //let chainMissingResidueArray = {}

            let id = (pdbid) ? pdbid : ic.defaultPdbId;
            let oriId = id;

            let structure = id;

            let prevMissingChain = '';
            let CSerial, prevCSerial, OSerial, prevOSerial;
            
            let bHeader = false, bFirstAtom = true;

            let segId, prevSegId;

            for (let i in lines) {
                let line = lines[i];
                let record = line.substr(0, 6);

                if (record === 'HEADER' && !bHeader && !pdbid) {              
                    // if(bOpm === undefined || !bOpm) ic.bSecondaryStructure = true;

                    ///id = line.substr(62, 4).trim();
                    id = line.substr(62).trim();
                    // remove "_" in the id
                    id = id.replace(/_/g, '-');
                    
                    oriId = id;

                    if(id == '') {
                        if(bAppend) {
                            id = ic.defaultPdbId;
                        }
                        else {
                            //if(!ic.inputid) ic.inputid = ic.defaultPdbId;
                            id = (ic.inputid && ic.inputid.indexOf('/') == -1) ? ic.inputid.substr(0, 10) : ic.defaultPdbId; //ic.filename.substr(0, 4);
                        }
                    }

                    structure = this.getStructureId(id, moleculeNum, bMutation, bNMR);

                    ic.molTitle = '';
                    if (ic.allData === undefined) {
                        ic.molTitleHash = {};
                    }

                    bHeader = true; // read the first header if there are multiple
                } else if (record === 'TITLE ') {
                    let name = line.substr(10).replace(/ALPHAFOLD MONOMER V2.0 PREDICTION FOR /gi, '');
                    ic.molTitle += name.trim() + " ";
                    if(bEsmfold && ic.esmTitle) ic.molTitle = ic.esmTitle;

                    if(!ic.molTitleHash) ic.molTitleHash = {};
                    ic.molTitleHash[structure] = ic.molTitle;

                } else if (record === 'HELIX ') {
                    ic.bSecondaryStructure = true;

                    //let startChain = (line.substr(19, 1) == ' ') ? 'A' : line.substr(19, 1);
                    let startChain = (line.substr(18, 2).trim() == '') ? 'A' : line.substr(18, 2).trim();
                    let startResi = parseInt(line.substr(21, 4));
                    let endResi = parseInt(line.substr(33, 4));

                    for(let j = startResi; j <= endResi; ++j) {
                      let resid = structure + "_" + startChain + "_" + j;
                      helixArray.push(resid);

                      if(j === startResi) helixStart.push(resid);
                      if(j === endResi) helixEnd.push(resid);
                    }    
                } else if (record === 'SHEET ') {
                    //ic.bSecondaryStructure = true;
                    if(bOpm === undefined || !bOpm) ic.bSecondaryStructure = true;

                    //let startChain = (line.substr(21, 1) == ' ') ? 'A' : line.substr(21, 1);
                    let startChain = (line.substr(20, 2).trim() == '') ? 'A' : line.substr(20, 2).trim();
                    let startResi = parseInt(line.substr(22, 4));
                    let endResi = parseInt(line.substr(33, 4));

                    for(let j = startResi; j <= endResi; ++j) {
                      let resid = structure + "_" + startChain + "_" + j;
                      sheetArray.push(resid);

                      if(j === startResi) sheetStart.push(resid);
                      if(j === endResi) sheetEnd.push(resid);
                    }           
                } else if (record === 'HBOND ') {
                    if(bOpm === undefined || !bOpm) ic.bSecondaryStructure = true;
                } else if (record === 'SSBOND') {
                    ic.bSsbondProvided = true;
                    //SSBOND   1 CYS E   48    CYS E   51                          2555
                    let chain1 = (line.substr(15, 1) == ' ') ? 'A' : line.substr(15, 1);
                    let resi1 = line.substr(17, 4).trim();
                    let resid1 = structure + '_' + chain1 + '_' + resi1;

                    let chain2 = (line.substr(29, 1) == ' ') ? 'A' : line.substr(29, 1);
                    let resi2 = line.substr(31, 4).trim();
                    let resid2 = structure + '_' + chain2 + '_' + resi2;

                    if(ic.ssbondpnts[structure] === undefined) ic.ssbondpnts[structure] = [];

                    ic.ssbondpnts[structure].push(resid1);
                    ic.ssbondpnts[structure].push(resid2);
                } else if (record === 'REMARK') {
                     let remarkType = parseInt(line.substr(7, 3));

                     if(line.indexOf('1/2 of bilayer thickness:') !== -1) { // OPM transmembrane protein
                        ic.halfBilayerSize = parseFloat(line.substr(line.indexOf(':') + 1).trim());
                     }
                     else if (remarkType == 210) {
                         if((line.substr(11, 32).trim() == 'EXPERIMENT TYPE') && line.substr(45).trim() == 'NMR') {
                            bNMR = true;
                            ic.idNMR = oriId;
                         }
                     }
                     else if (remarkType == 350 && line.substr(13, 5) == 'BIOMT') {
                        let n = parseInt(line[18]) - 1;
                        //var m = parseInt(line.substr(21, 2));
                        let m = parseInt(line.substr(21, 2)) - 1; // start from 1
                        if (ic.biomtMatrices[m] == undefined) ic.biomtMatrices[m] = new THREE.Matrix4().identity();
                        ic.biomtMatrices[m].elements[n] = parseFloat(line.substr(24, 9));
                        ic.biomtMatrices[m].elements[n + 4] = parseFloat(line.substr(34, 9));
                        ic.biomtMatrices[m].elements[n + 8] = parseFloat(line.substr(44, 9));
                        //ic.biomtMatrices[m].elements[n + 12] = parseFloat(line.substr(54, 10));
                        ic.biomtMatrices[m].elements[n + 12] = parseFloat(line.substr(54, 14));
                     }
                     // missing residues
                     else if (remarkType == 465 && line.substr(18, 1) == ' ' && line.substr(20, 1) == ' ' && line.substr(21, 1) != 'S') {
                        let resn = line.substr(15, 3);
                        //let chain = line.substr(19, 1);
                        let chain = line.substr(18, 2).trim();
                        //let resi = parseInt(line.substr(21, 5));
                        let resi = line.substr(21, 5).trim();

                        //var chainNum = structure + '_' + chain;
                        let chainNum = id + '_' + chain;

                        if(ic.chainMissingResidueArray[chainNum] === undefined) ic.chainMissingResidueArray[chainNum] = [];
                        let resObject = {};
                        resObject.resi = resi;
                        resObject.name = me.utilsCls.residueName2Abbr(resn).toLowerCase();

                        // not all listed residues are considered missing, e.g., PDB ID 4OR2, only the first four residues are considered missing
                        //if(!isNaN(resi) && (prevMissingChain == '' || (chain != prevMissingChain) || (chain == prevMissingChain && resi > maxMissingResi)) ) {
                        if(prevMissingChain == '' || (chain != prevMissingChain) || (chain == prevMissingChain) ) {
                            ic.chainMissingResidueArray[chainNum].push(resObject);
                            prevMissingChain = chain;
                        }

                     }
                     else if (remarkType == 900 && ic.emd === undefined && line.substr(34).trim() == 'RELATED DB: EMDB') {
                         //REMARK 900 RELATED ID: EMD-3906   RELATED DB: EMDB
                         ic.emd = line.substr(23, 11).trim();
                     }
                } else if (record === 'SOURCE' && ic.organism === undefined && line.substr(11, 15).trim() == 'ORGANISM_COMMON') {
                    ic.organism = line.substr(28).toLowerCase().trim();

                    ic.organism = ic.organism.substr(0, ic.organism.length - 1);
                } else if (record === 'ENDMDL') {
                    if(ic.statefileArray) {
                        ic.struct_statefile.push({'structure': structure, 'statefile': ic.statefileArray[moleculeNum - 1]});
                    }

                    ++moleculeNum;
                    id = ic.defaultPdbId;

                    structure = this.getStructureId(id, moleculeNum, bMutation, bNMR);
                    //helices = [];
                    //sheets = [];
                    if(!bNMR) {
                        sheetArray = [];
                        sheetStart = [];
                        sheetEnd = [];
                        helixArray = [];
                        helixStart = [];
                        helixEnd = [];
                    }

                    bHeader = false; // reinitialize to read structure name from the header
                } else if (record === 'JRNL  ') {
                    if(line.substr(12, 4) === 'PMID') {
                        ic.pmid = line.substr(19).trim();
                    }
                } else if (record === 'ATOM  ' || record === 'HETATM') {
                    //73 - 76 LString(4) segID Segment identifier, left-justified.
                    // deal with PDBs from MD trajectories
                    segId = line.substr(72, 4).trim();

                    if(bFirstAtom) {
                        structure = this.getStructureId(id, moleculeNum, bMutation, bNMR);

                        bFirstAtom = false;
                    }
                    else if(segId != prevSegId) {
                        ++moleculeNum;
                        id = ic.defaultPdbId;
        
                        structure = this.getStructureId(id, moleculeNum, bMutation, bNMR);
        
                        //helices = [];
                        //sheets = [];
                        if(!bNMR) {
                            sheetArray = [];
                            sheetStart = [];
                            sheetEnd = [];
                            helixArray = [];
                            helixStart = [];
                            helixEnd = [];
                        }
        
                        bHeader = false; // reinitialize to read structure name from the header
                    }

                    prevSegId = segId;

                    let alt = line.substr(16, 1);
                    //if (alt !== " " && alt !== "A") continue;

                    // "CA" has to appear before "O". Otherwise the cartoon of secondary structure will have breaks
                    // Concatenation of two pdbs will have several atoms for the same serial
                    ++serial;

                    let serial2 = parseInt(line.substr(6, 5));
                    oriSerial2NewSerial[serial2] = serial;

                    let elem = line.substr(76, 2).trim();
                    if (elem === '') { // for some incorrect PDB files, important to use substr(12,2), not (12,4)
                       elem = line.substr(12, 2).trim();
                    }
                    let atom = line.substr(12, 4).trim();
                    let resn = line.substr(17, 3);

                    //let chain = line.substr(21, 1);
                    //if(chain === ' ') chain = 'A';
                    let chain = line.substr(20, 2).trim();
                    if(chain === '') chain = 'A';

                    //var oriResi = line.substr(22, 4).trim();
                    let oriResi = line.substr(22, 5).trim();

                    let resi = oriResi; //parseInt(oriResi);
                    // if(oriResi != resi || bModifyResi) { // e.g., 99A and 99
                    //   bModifyResi = true;
                    // }

                    if(bOpm && resn === 'DUM') {
                        elem = atom;
                        chain = 'MEM';
                        resi = 1;
                        oriResi = 1;
                    }

                    if(bVector && resn === 'DUM') break; // just need to get the vector of the largest chain

                    chainNum = structure + "_" + chain;
                    oriResidueNum = chainNum + "_" + oriResi;

                    residueNum = chainNum + "_" + resi;

                    //let chain_resi = chain + "_" + resi;

                    let x = parseFloat(line.substr(30, 8));
                    let y = parseFloat(line.substr(38, 8));
                    let z = parseFloat(line.substr(46, 8));
                    let coord = new THREE.Vector3(x, y, z);

                    let bFactor = parseFloat(line.substr(60, 8));
                    if(bEsmfold) bFactor *= 100;

                    let atomDetails = {
                        het: record[0] === 'H', // optional, used to determine chemicals, water, ions, etc
                        serial: serial,         // required, unique atom id
                        name: atom,             // required, atom name
                        alt: alt,               // optional, some alternative coordinates
                        resn: resn,             // optional, used to determine protein or nucleotide
                        structure: structure,   // optional, used to identify structure
                        chain: chain,           // optional, used to identify chain
                        resi: resi,             // optional, used to identify residue ID
                        //insc: line.substr(26, 1),
                        coord: coord,           // required, used to draw 3D shape
                        b: bFactor,             // optional, used to draw B-factor tube
                        elem: elem,             // optional, used to determine hydrogen bond
                        bonds: [],              // required, used to connect atoms
                        ss: 'coil',             // optional, used to show secondary structures
                        ssbegin: false,         // optional, used to show the beginning of secondary structures
                        ssend: false            // optional, used to show the end of secondary structures
                    };

                    if(!atomDetails.het && atomDetails.name === 'C') {
                        CSerial = serial;
                    }
                    if(!atomDetails.het && atomDetails.name === 'O') {
                        OSerial = serial;
                    }

                    // from DSSP C++ code
                    if(!atomDetails.het && atomDetails.name === 'N' && prevCSerial !== undefined && prevOSerial !== undefined) {
                        let dist = ic.atoms[prevCSerial].coord.distanceTo(ic.atoms[prevOSerial].coord);

                        let x2 = atomDetails.coord.x + (ic.atoms[prevCSerial].coord.x - ic.atoms[prevOSerial].coord.x) / dist;
                        let y2 = atomDetails.coord.y + (ic.atoms[prevCSerial].coord.y - ic.atoms[prevOSerial].coord.y) / dist;
                        let z2 = atomDetails.coord.z + (ic.atoms[prevCSerial].coord.z - ic.atoms[prevOSerial].coord.z) / dist;

                        atomDetails.hcoord = new THREE.Vector3(x2, y2, z2);
                    }

                    ic.atoms[serial] = atomDetails;

                    ic.dAtoms[serial] = 1;
                    ic.hAtoms[serial] = 1;
                    hAtoms[serial] = 1;

                    // Assign secondary structures from the input
                    // if a residue is assigned both sheet and helix, it is assigned as sheet
                    if(this.isSecondary(residueNum, sheetArray, bNMR)) {
                      ic.atoms[serial].ss = 'sheet';
                      if(this.isSecondary(residueNum, sheetStart, bNMR)) {
                        ic.atoms[serial].ssbegin = true;
                      }

                      // do not use else if. Some residues are both start and end of secondary structure
                      if(this.isSecondary(residueNum, sheetEnd, bNMR)) {
                        ic.atoms[serial].ssend = true;
                      }
                    }
                    else if(this.isSecondary(residueNum, helixArray, bNMR)) {
                      ic.atoms[serial].ss = 'helix';

                      if(this.isSecondary(residueNum, helixStart, bNMR)) {
                        ic.atoms[serial].ssbegin = true;
                      }

                      // do not use else if. Some residues are both start and end of secondary structure
                      if(this.isSecondary(residueNum, helixEnd, bNMR)) {
                        ic.atoms[serial].ssend = true;
                      }
                    }

                    let secondaries = '-';
                    if(ic.atoms[serial].ss === 'helix') {
                        secondaries = 'H';
                    }
                    else if(ic.atoms[serial].ss === 'sheet') {
                        secondaries = 'E';
                    }
                    //else if(ic.atoms[serial].ss === 'coil') {
                    //    secondaries = 'c';
                    //}
                    else if(!ic.atoms[serial].het && me.parasCls.residueColors.hasOwnProperty(ic.atoms[serial].resn.toUpperCase()) ) {
                        secondaries = 'c';
                    }
                    else {
                        secondaries = 'o';
                    }

                    ic.secondaries[residueNum] = secondaries;

                    // different residue
                    //if(residueNum !== prevResidueNum) {
                        
                    if(oriResidueNum !== prevOriResidueNum) {
                        let residue = me.utilsCls.residueName2Abbr(resn);
                        ic.residueId2Name[residueNum] = residue;

                        if(serial !== 1 && prevResidueNum !== '') ic.residues[prevResidueNum] = residuesTmp;

                        if(residueNum !== prevResidueNum) {
                            residuesTmp = {};
                        }

                        // different chain
                        if(chainNum !== prevChainNum) {
                            prevCSerial = undefined;
                            prevOSerial = undefined;

                            // a chain could be separated in two sections
                            if(serial !== 1 && prevChainNum !== '') {
                                if(ic.chains[prevChainNum] === undefined) ic.chains[prevChainNum] = {};
                                ic.chains[prevChainNum] = me.hashUtilsCls.unionHash(ic.chains[prevChainNum], chainsTmp);
                            }

                            chainsTmp = {};

                            if(ic.structures[structure.toString()] === undefined) ic.structures[structure.toString()] = [];
                            if(!ic.structures[structure.toString()].includes(chainNum)) ic.structures[structure.toString()].push(chainNum);

                            if(ic.chainsSeq[chainNum] === undefined) ic.chainsSeq[chainNum] = [];

                            let resObject = {};
                            resObject.resi = resi;
                            resObject.name = residue;

                            ic.chainsSeq[chainNum].push(resObject);
                        }
                        else {
                            prevCSerial = CSerial;
                            prevOSerial = OSerial;

                            let resObject = {};
                            resObject.resi = resi;
                            resObject.name = residue;

                            ic.chainsSeq[chainNum].push(resObject);
                        }
                    }

                    chainsTmp[serial] = 1;
                    residuesTmp[serial] = 1;

                    prevChainNum = chainNum;
                    prevResidueNum = residueNum;
                    prevOriResidueNum = oriResidueNum;

                } else if (record === 'CONECT') {
                    let from = parseInt(line.substr(6, 5));
                    for (let j = 0; j < 4; ++j) {
                        let to = parseInt(line.substr([11, 16, 21, 26][j], 5));
                        if (isNaN(to)) continue;

                        if(ic.atoms[oriSerial2NewSerial[from]] !== undefined) ic.atoms[oriSerial2NewSerial[from]].bonds.push(oriSerial2NewSerial[to]);
                    }
                } else if (record.substr(0,3) === 'TER') ;
            }

            // add the last residue set
            ic.residues[residueNum] = residuesTmp;
            if(ic.chains[chainNum] === undefined) ic.chains[chainNum] = {};
            ic.chains[chainNum] = me.hashUtilsCls.unionHash2Atoms(ic.chains[chainNum], chainsTmp, ic.atoms);

            if(ic.statefileArray) {
                ic.struct_statefile.push({'structure': structure, 'statefile': ic.statefileArray[moleculeNum - 1]});
            }

            //if(!bMutation) this.adjustSeq(ic.chainMissingResidueArray);
            this.adjustSeq(ic.chainMissingResidueArray);

        //    ic.missingResidues = [];
        //    for(let chainid in chainMissingResidueArray) {
        //        let resArray = chainMissingResidueArray[chainid];
        //        for(let i = 0; i < resArray.length; ++i) {
        //            ic.missingResidues.push(chainid + '_' + resArray[i].resi);
        //        }
        //    }

            // copy disulfide bonds
            let structureArray = Object.keys(ic.structures);
            for(let s = 0, sl = structureArray.length; s < sl; ++s) {
                let structure = structureArray[s];

                if(structure == id) continue;

                if(ic.ssbondpnts[structure] === undefined) ic.ssbondpnts[structure] = [];

                if(ic.ssbondpnts[id] !== undefined) {
                    for(let j = 0, jl = ic.ssbondpnts[id].length; j < jl; ++j) {
                        let ori_resid = ic.ssbondpnts[id][j];
                        let pos = ori_resid.indexOf('_');
                        let resid = structure + ori_resid.substr(pos);

                        ic.ssbondpnts[structure].push(resid);
                    }
                }
            }

            // calculate disulfide bonds for PDB files
            if(!ic.bSsbondProvided) {
                this.setSsbond();
            }

            // remove the reference
            lines = null;

            let curChain, curResi, curResAtoms = [];
          
            let pmin = new THREE.Vector3( 9999, 9999, 9999);
            let pmax = new THREE.Vector3(-9999,-9999,-9999);
            let psum = new THREE.Vector3();
            let cnt = 0;

            // lipids may be considered as protein if "ATOM" instead of "HETATM" was used
            let lipidResidHash = {};

            // assign atoms
            let prevCarbonArray = []; 
            //for (let i in ic.atoms) {
            for (let i in ic.hAtoms) {    
                let atom = ic.atoms[i];
                let coord = atom.coord;
                psum.add(coord);
                pmin.min(coord);
                pmax.max(coord);
                ++cnt;

                if(cnt == 1) {
                    curChain = atom.chain;
                    curResi = atom.resi;
                    prevCarbonArray.push(atom);
                }

                if(!atom.het) {
                  if($.inArray(atom.resn, me.parasCls.nucleotidesArray) !== -1) {
                    ic.nucleotides[atom.serial] = 1;
                    //if (atom.name === 'P') {
                    if (atom.name === "O3'" || atom.name === "O3*") {
                        ic.nucleotidesO3[atom.serial] = 1;

                        ic.secondaries[atom.structure + '_' + atom.chain + '_' + atom.resi] = 'o'; // nucleotide
                    }

                    if(me.parasCls.nuclMainArray.indexOf(atom.name) === -1) {
                        ic.ntbase[atom.serial] = 1;
                    }
                  }
                  else {
                    if (atom.elem === 'P') {
                        lipidResidHash[atom.structure + '_' + atom.chain + '_' + atom.resi] = 1;
                    }

                    ic.proteins[atom.serial] = 1;
                    if (atom.name === 'CA') ic.calphas[atom.serial] = 1;
                    if (atom.name !== 'N' && atom.name !== 'H' && atom.name !== 'CA' && atom.name !== 'HA' && atom.name !== 'C' && atom.name !== 'O') ic.sidec[atom.serial] = 1;
                  }
                }
                else if(atom.het) {
                  if(atom.resn === 'HOH' || atom.resn === 'WAT' || atom.resn === 'SOL') {
                    ic.water[atom.serial] = 1;
                  }
                  //else if(bOpm && atom.resn === 'DUM') {
                  //  ic.mem[atom.serial] = 1;
                  //}
                  else if($.inArray(atom.resn, me.parasCls.ionsArray) !== -1 || atom.elem.trim() === atom.resn.trim()) {
                    ic.ions[atom.serial] = 1;
                  }
                  else {
                    ic.chemicals[atom.serial] = 1;
                  }

                  atom.color = me.parasCls.atomColors[atom.elem];
                }

                if(!(curChain === atom.chain && curResi === atom.resi)) {
                    // a new residue, add the residue-residue bond besides the regular bonds               
                    this.refreshBonds(curResAtoms, prevCarbonArray[0]);

                    prevCarbonArray.splice(0, 1); // remove the first carbon

                    curChain = atom.chain;
                    curResi = atom.resi;
                    //curInsc = atom.insc;
                    curResAtoms.length = 0;
                }
                curResAtoms.push(atom);

                if(atom.name === 'C' || atom.name === 'O3\'') {
                    prevCarbonArray.push(atom);
                }
            } // end of for

            // last residue
            //refreshBonds();
            this.refreshBonds(curResAtoms, prevCarbonArray[0]);

            // reset lipid
            for(let resid in lipidResidHash) {
                let atomHash = ic.residues[resid];
                for(serial in atomHash) {
                    let atom = ic.atoms[serial];

                    atom.het = true;
                    ic.chemicals[atom.serial] = 1;
                    ic.secondaries[resid] = 'o'; // nucleotide

                    delete ic.proteins[atom.serial];
                    if (atom.name === 'CA') delete ic.calphas[atom.serial];
                    if (atom.name !== 'N' && atom.name !== 'H' && atom.name !== 'CA' && atom.name !== 'HA' && atom.name !== 'C' && atom.name !== 'O') delete ic.sidec[atom.serial];
                }
            }

            ic.pmin = pmin;
            ic.pmax = pmax;

            ic.cnt = cnt;

            //ic.maxD = ic.pmax.distanceTo(ic.pmin);
            //ic.center = psum.multiplyScalar(1.0 / ic.cnt);
            ic.center = ic.ParserUtilsCls.getGeoCenter(ic.pmin, ic.pmax);

            ic.maxD = ic.ParserUtilsCls.getStructureSize(ic.atoms, ic.pmin, ic.pmax, ic.center);

            if (ic.maxD < 5) ic.maxD = 5;

            ic.oriMaxD = ic.maxD;
            ic.oriCenter = ic.center.clone();

            if(type === 'target') {
                ic.oriMaxD = ic.maxD;
                ic.center1 = ic.center;
            }
            else if(type === 'query') {
                if(ic.oriMaxD < ic.maxD) ic.oriMaxD = ic.maxD;

                ic.center2 = ic.center;
                ic.center = new THREE.Vector3(0,0,0);
            }

            if(bVector) { // just need to get the vector of the largest chain
                return this.getChainCalpha(ic.chains, ic.atoms);
            }
            else {
                return hAtoms;
            }
        }

        // refresh for atoms in each residue
        refreshBonds(curResAtoms, prevCarbon) { let ic = this.icn3d, me = ic.icn3dui;
            let n = curResAtoms.length;
            for (let j = 0; j < n; ++j) {
                let atom0 = curResAtoms[j];
                for (let k = j + 1; k < n; ++k) {
                    let atom1 = curResAtoms[k];
                    if (atom0.alt === atom1.alt && me.utilsCls.hasCovalentBond(atom0, atom1)) {
                    //if (me.utilsCls.hasCovalentBond(atom0, atom1)) {
                        atom0.bonds.push(atom1.serial);
                        atom1.bonds.push(atom0.serial);
                    }
                }

                //f && f(atom0);
                if (prevCarbon && (prevCarbon.name === 'C' || prevCarbon.name === 'O3\'') && (atom0.name === 'N' || atom0.name === 'P') && me.utilsCls.hasCovalentBond(atom0, prevCarbon)) {
                    atom0.bonds.push(prevCarbon.serial);
                    prevCarbon.bonds.push(atom0.serial);
                }
            }
        }

        adjustSeq(chainMissingResidueArray) { let ic = this.icn3d; ic.icn3dui;
            // adjust sequences
            for(let chainNum in ic.chainsSeq) {
                if(chainMissingResidueArray[chainNum] === undefined) continue;

                ic.chainsSeq[chainNum] = this.mergeTwoSequences(chainMissingResidueArray[chainNum], ic.chainsSeq[chainNum]);     
            }

            this.setResidMapping();
        }

        mergeTwoSequences(A, B) {
            let m = A.length; // missing residues
            let n = B.length; // residues with coord

            // inserted domain such as PRK150 in the R chain of PDB 6WW2
            let lastResiA = parseInt(A[m - 1].resi);
            let lastResiB = parseInt(B[n - 1].resi);
            let lastResi = (lastResiA >= lastResiB) ? lastResiA : lastResiB;

            let C = new Array(m + n);
            // http://www.algolist.net/Algorithms/Merge/Sorted_arrays
            // m - size of A
            // n - size of B
            // size of C array must be equal or greater than m + n
              let i = 0, j = 0, k = 0;
              let bInsertion = false;

              while (i < m && j < n) {
                    let aResi = parseInt(A[i].resi), bResi = parseInt(B[j].resi);
                    if(aResi > lastResi && bResi > lastResi) bInsertion = true;

                    if(aResi <= lastResi &&  bResi > lastResi) {
                        if (aResi > bResi || bInsertion) {
                            C[k] = B[j];
                            j++;
                        }
                        else  {
                            C[k] = A[i];
                            i++;
                        }
                    }
                    else if(aResi > lastResi &&  bResi <= lastResi) {
                        if (aResi <= bResi || bInsertion) {
                            C[k] = A[i];
                            i++;
                        }
                        else  {
                            C[k] = B[j];
                            j++;
                        }
                    }
                    else {
                        if (aResi <= bResi) {
                            C[k] = A[i];
                            i++;
                        }
                        else {
                            C[k] = B[j];
                            j++;
                        }
                    }

                    k++;
              }

              if (i < m) {
                    for (let p = i; p < m; p++) {
                          C[k] = A[p];
                          k++;
                    }
              } 
              else {
                    for (let p = j; p < n; p++) {
                          C[k] = B[p];
                          k++;
                    }
              }

              return C;
        }

        setResidMapping() { let ic = this.icn3d; ic.icn3dui;
            // set ic.ncbi2resid and ic.resid2ncbi
            for(let chainid in ic.chainsSeq) {
                for(let j = 0, jl = ic.chainsSeq[chainid].length; j < jl; ++j) {
                    // NCBI residue number starts from 1 and increases continuously
                    let residNCBI = chainid + '_' + (j+1).toString();
                    let resid = chainid + '_' + ic.chainsSeq[chainid][j].resi;
                    ic.ncbi2resid[residNCBI] = resid;
                    ic.resid2ncbi[resid] = residNCBI;
                }
            }
        }

        setSsbond(chainidHash) { let ic = this.icn3d; ic.icn3dui;
            // get all Cys residues
            let structure2cys_resid = {};

            for(let chainid in ic.chainsSeq) {
                if(chainidHash && !chainidHash.hasOwnProperty(chainid)) continue;

                let seq = ic.chainsSeq[chainid];
                let structure = chainid.substr(0, chainid.indexOf('_'));

                for(let i = 0, il = seq.length; i < il; ++i) {
                    // each seq[i] = {"resi": 1, "name":"C"}
                    if(seq[i].name == 'C') {
                        if(structure2cys_resid[structure] == undefined) structure2cys_resid[structure] = [];
                        structure2cys_resid[structure].push(chainid + '_' + seq[i].resi);
                    }
                }
            }

            // determine whether there are disulfide bonds
            // disulfide bond is about 2.05 angstrom
            let distMax = 4; //3; // https://icn3d.page.link/5KRXx6XYfig1fkye7
            let distSqrMax = distMax * distMax;
            for(let structure in structure2cys_resid) {
                let cysArray = structure2cys_resid[structure];

                for(let i = 0, il = cysArray.length; i < il; ++i) {
                    for(let j = i + 1, jl = cysArray.length; j < jl; ++j) {
                        let resid1 = cysArray[i];
                        let resid2 = cysArray[j];

                        let coord1 = undefined, coord2 = undefined;
                        for(let serial in ic.residues[resid1]) {
                            if(ic.atoms[serial].elem == 'S') {
                                coord1 = ic.atoms[serial].coord;
                                break;
                            }
                        }
                        for(let serial in ic.residues[resid2]) {
                            if(ic.atoms[serial].elem == 'S') {
                                coord2 = ic.atoms[serial].coord;
                                break;
                            }
                        }

                        if(coord1 === undefined || coord2 === undefined) continue;

                        if(Math.abs(coord1.x - coord2.x) > distMax) continue;
                        if(Math.abs(coord1.y - coord2.y) > distMax) continue;
                        if(Math.abs(coord1.z - coord2.z) > distMax) continue;
                        let distSqr = (coord1.x - coord2.x)*(coord1.x - coord2.x) + (coord1.y - coord2.y)*(coord1.y - coord2.y) + (coord1.z - coord2.z)*(coord1.z - coord2.z);

                        if(distSqr < distSqrMax) { // disulfide bond
                            if(ic.ssbondpnts[structure] === undefined) ic.ssbondpnts[structure] = [];
                            ic.ssbondpnts[structure].push(resid1);
                            ic.ssbondpnts[structure].push(resid2);
                        }
                    }
                }
            }
        }

        getChainCalpha(chains, atoms, bResi_ori, pdbid) { let ic = this.icn3d, me = ic.icn3dui;
            let chainCalphaHash = {};

            for(let chainid in chains) {
                if(pdbid !== undefined) {
                    let textArray =  chainid.split('_');
                    if(textArray[0] !== pdbid) continue; // skip different chain
                }

                let serialArray = Object.keys(chains[chainid]);

                let calphaArray = [];
                let cnt = 0;
                let lastResi = 0;
                for(let i = 0, il = serialArray.length; i < il; ++i) {
                    let atom = atoms[serialArray[i]];
                    if( (ic.proteins.hasOwnProperty(serialArray[i]) && atom.name == "CA")
                      || (ic.nucleotides.hasOwnProperty(serialArray[i]) && (atom.name == "O3'" || atom.name == "O3*")) ) {
                        if(atom.resi == lastResi) continue; // e.g., Alt A and B

                        let resn = (atom.resn.trim().length > 3) ? atom.resn.trim().substr(0, 3) : atom.resn.trim();
                        if(!me.parasCls.chargeColors.hasOwnProperty(resn)) {
                            continue; // regular residues
                        }

                        (bResi_ori) ? atom.resi_ori : atom.resi; // MMDB uses resi_ori for PDB residue number
                        //resi = resi - baseResi + 1;

                        //chainresiCalphaHash[atom.chain + '_' + resi] = atom.coord.clone();

                        calphaArray.push(atom.coord.clone());
                        ++cnt;

                        lastResi = atom.resi;
                    }
                }

                if(cnt > 0) {
                    //var chainid = atoms[serialArray[0]].structure + '_' + atoms[serialArray[0]].chain;
                    let chain = atoms[serialArray[0]].chain;
                    chainCalphaHash[chain] = calphaArray;
                }
            }

            return {'chainresiCalphaHash': chainCalphaHash, 'center': ic.center.clone()}
        }

        isSecondary(resid, residArray, bNMR, bNonFull) { let ic = this.icn3d; ic.icn3dui;
            if(bNonFull) return false;

            if(!bNMR) {
                return $.inArray(resid, residArray) != -1;
            }
            else {
                let chain_resi = resid.substr(resid.indexOf('_') + 1);

                let bFound = false;
                for(let i = 0, il = residArray.length; i < il; ++i) {
                    if(chain_resi == residArray[i].substr(residArray[i].indexOf('_') + 1)) {
                        bFound = true;
                        break;
                    }
                }

                return bFound;
            }
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class LoadCIF {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        loadCIF(bcifData, bcifid, bText, bAppend) { let ic = this.icn3d, me = ic.icn3dui;
            let hAtoms = {};

            let bNMR = false;
            // let lines = src.split('\n');

            let chainsTmp = {}; // serial -> atom
            let residuesTmp = {}; // serial -> atom

            if(!ic.atoms) bAppend = false;

            let serial, moleculeNum;
            // if(!bMutation && !bAppend) {
            if(!bAppend) {
                ic.init();
                moleculeNum = 0; //1;
                serial = 0;
            }
            else {
                ic.oriNStru = (ic.structures) ? Object.keys(ic.structures).length : 0;

                moleculeNum = ic.oriNStru; //ic.oriNStru + 1; //Object.keys(ic.structures).length + 1;
                // Concatenation of two pdbs will have several atoms for the same serial
                serial = (ic.atoms) ? Object.keys(ic.atoms).length : 0;
            }

            //let helices = [], sheets = [];
            let sheetArray = [], sheetStart = [], sheetEnd = [], helixArray = [], helixStart = [], helixEnd = [];

            let chainNum, residueNum, oriResidueNum;
            let prevChainNum = '', prevResidueNum = '', prevOriResidueNum = '';

            let id = (bcifid) ? bcifid : ic.defaultPdbId;

            let structure = id;
            let CSerial, prevCSerial, OSerial, prevOSerial;

            let cifArray = (bText) ? bcifData.split('ENDMDL\n') : [bcifData];

            for(let index = 0, indexl = cifArray.length; index  < indexl; ++index) {
                ++moleculeNum;
                id = ic.defaultPdbId;

                structure = ic.loadPDBCls.getStructureId(id, moleculeNum);

                // if(!bNMR) {
                    sheetArray = [];
                    sheetStart = [];
                    sheetEnd = [];
                    helixArray = [];
                    helixStart = [];
                    helixEnd = [];


                // bcifData could be binary or text
                let parsed = (bText) ? CIFTools.Text.parse(cifArray[index]) : CIFTools.Binary.parse(cifArray[index]);

                if (parsed.isError) {
                    // report error:
                    alert("The Binary CIF data can NOT be parsed: " + parsed.toString());
                    return;
                }

                let block = parsed.result.dataBlocks[0];
                
                if(block.getCategory("_entry")) {
                    id = block.getCategory("_entry").getColumn("id").getString(0);
                    // remove "_" in the id
                    id = id.replace(/_/g, '-');

                    if(id == '') {
                        if(bAppend) {
                            id = ic.defaultPdbId;
                        }
                        else {
                            //if(!ic.inputid) ic.inputid = ic.defaultPdbId;
                            id = (ic.inputid && ic.inputid.indexOf('/') == -1) ? ic.inputid.substr(0, 10) : ic.defaultPdbId; //ic.filename.substr(0, 4);
                        }
                    }

                    structure = ic.loadPDBCls.getStructureId(id, moleculeNum);

                    ic.molTitle = '';
                    ic.molTitleHash = {};
                }
                
                if(block.getCategory("_struct")) {
                    let title = block.getCategory("_struct").getColumn("title").getString(0);
                    title = title.replace(/"/, "'");
                    let name = title.replace(/ALPHAFOLD MONOMER V2.0 PREDICTION FOR /gi, '');
                    ic.molTitle += name.trim() + " ";
                    // if(bEsmfold && ic.esmTitle) ic.molTitle = ic.esmTitle;

                    if(!ic.molTitleHash) ic.molTitleHash = {};
                    ic.molTitleHash[structure] = ic.molTitle;

                }

                if(block.getCategory("_entity_src_gen")) {
                    ic.organism = block.getCategory("_entity_src_gen").getColumn("gene_src_common_name").getString(0);
                }
                
                if(block.getCategory("_database_2")) {
                    let database_2 = block.getCategory("_database_2");
                
                    // Iterate through every row in the table
                    let db2Size = database_2.rowCount ;
                    for (let i = 0; i < db2Size; ++i) {
                        let db_id = database_2.getColumn("database_id").getString(0);
                        let db_code = database_2.getColumn("database_code").getString(0);
                    
                        if(db_id == "EMDB") {
                            ic.emd = db_code;
                            break;
                        }
                    }
                }

                if(block.getCategory("_struct_conf")) {
                    ic.bSecondaryStructure = true;

                    // Retrieve the table corresponding to the struct_conf category, which delineates mainly helix
                    let struct_conf = block.getCategory("_struct_conf");
                
                    let conf_type_idArray = struct_conf.getColumn("conf_type_id");
                
                    let chain1Array = struct_conf.getColumn("beg_auth_asym_id");
                    // let resi1Array = struct_conf.getColumn("beg_label_seq_id");
                    let resi1Array = struct_conf.getColumn("beg_auth_seq_id");
                
                    struct_conf.getColumn("end_auth_asym_id");
                    // let resi2Array = struct_conf.getColumn("end_label_seq_id");
                    let resi2Array = struct_conf.getColumn("end_auth_seq_id");
                
                    // Iterate through every row in the struct_conf category table, where each row delineates an interatomic connection
                    let confSize = struct_conf.rowCount;
                    for (let i = 0; i < confSize; ++i) {
                        let conf_type_id = conf_type_idArray.getString(i);
                    
                        let startChain = chain1Array.getString(i);
                        let startResi = parseInt(resi1Array.getString(i));
                        let endResi = parseInt(resi2Array.getString(i));
                    
                        if(conf_type_id.substr(0, 4) == "HELX") {
                            for(let j = parseInt(startResi); j <= parseInt(endResi); ++j) {
                                let resid = structure + "_" + startChain + "_" + j;
                                helixArray.push(resid);
                
                                if(j == startResi) helixStart.push(resid);
                                if(j == endResi) helixEnd.push(resid);
                            } 
                        }
                        else if(conf_type_id.substr(0, 4) == "STRN") {
                            for(let j = startResi; j <= endResi; ++j) {
                                let resid = structure + "_" + startChain + "_" + j;
                                sheetArray.push(resid);
                
                                if(j == startResi) sheetStart.push(resid);
                                if(j == endResi) sheetEnd.push(resid);
                            } 
                        }
                    }
                
                    conf_type_idArray = chain1Array = resi1Array = resi2Array = [];
                }

                if(block.getCategory("_struct_sheet_range")) {
                    // Retrieve the table corresponding to the struct_sheet_range category, which delineates mainly beta sheet
                    let struct_sheet_range = block.getCategory("_struct_sheet_range");
                
                    let chain1Array = struct_sheet_range.getColumn("beg_auth_asym_id");
                    // let resi1Array = struct_sheet_range.getColumn("beg_label_seq_id");
                    let resi1Array = struct_sheet_range.getColumn("beg_auth_seq_id");
                
                    struct_sheet_range.getColumn("end_auth_asym_id");
                    // let resi2Array = struct_sheet_range.getColumn("end_label_seq_id");
                    let resi2Array = struct_sheet_range.getColumn("end_auth_seq_id");
                
                    // Iterate through every row in the struct_sheet_range category table, where each row delineates an interatomic connection
                    let sheetSize = struct_sheet_range.rowCount;
                    for (let i = 0; i < sheetSize; ++i) {
                        let startChain = chain1Array.getString(i);
                        let startResi = parseInt(resi1Array.getString(i));
                        let endResi = parseInt(resi2Array.getString(i));

                        for(let j = startResi; j <= endResi; ++j) {
                            let resid = structure + "_" + startChain + "_" + j;
                            sheetArray.push(resid);
            
                            if(j == startResi) sheetStart.push(resid);
                            if(j == endResi) sheetEnd.push(resid);
                        } 
                    }
                
                    chain1Array = resi1Array = resi2Array = [];
                }

                if(block.getCategory("_struct_conn")) {
                    ic.bSsbondProvided = true;

                    // Retrieve the table corresponding to the struct_conn category, which delineates connections1
                    let struct_conn = block.getCategory("_struct_conn");
                
                    let conn_type_idArray = struct_conn.getColumn("conn_type_id");
                
                    let chain1Array = struct_conn.getColumn("ptnr1_auth_asym_id");
                    let name1Array = struct_conn.getColumn("ptnr1_label_atom_id");
                    let resi1Array = struct_conn.getColumn("ptnr1_label_seq_id");
                
                    let chain2Array = struct_conn.getColumn("ptnr2_auth_asym_id");
                    let name2Array = struct_conn.getColumn("ptnr2_label_atom_id");
                    let resi2Array = struct_conn.getColumn("ptnr2_label_seq_id");
                
                    let connSize = struct_conn.rowCount;
                    for (let i = 0; i < connSize; ++i) {
                        let conn_type_id = conn_type_idArray.getString(i);
                    
                        let chain1 = chain1Array.getString(i);
                        name1Array.getString(i);
                        let resi1 = resi1Array.getString(i);
                        let id1 = structure + '_' + chain1 + "_" + resi1;
                    
                        let chain2 = chain2Array.getString(i);
                        name2Array.getString(i);
                        let resi2 = resi2Array.getString(i);
                        let id2 = structure + '_' + chain2 + "_" + resi2;
                    
                        // Verify that the linkage is covalent, as indicated by the conn_type_id attribute2
                    
                        // if (conn_type_id == "covale") {
                        //     vBonds.push(id1);
                        //     vBonds.push(id2);
                        // }
                        
                        if(conn_type_id == "disulf") {
                            if(ic.ssbondpnts[structure] === undefined) ic.ssbondpnts[structure] = [];

                            ic.ssbondpnts[structure].push(id1);
                            ic.ssbondpnts[structure].push(id2);
                        }
                    }
                
                    conn_type_idArray = chain1Array = name1Array = resi1Array = chain2Array = name2Array = resi2Array = [];
                }

                if(block.getCategory("_exptl")) {
                    let method = block.getCategory("_exptl").getColumn("method").getString(0);
                    if(method.indexOf('NMR') != -1) {
                        bNMR = true;
                    }
                }

                if(block.getCategory("_pdbx_struct_oper_list")) {
                    // Retrieve the table corresponding to the struct_oper_list category, which delineates assembly
                    let struct_oper_list = block.getCategory("_pdbx_struct_oper_list");
                
                    let struct_oper_idArray = struct_oper_list.getColumn("id");
                    let m11Array = struct_oper_list.getColumn("matrix[1][1]");
                    let m12Array = struct_oper_list.getColumn("matrix[1][2]");
                    let m13Array = struct_oper_list.getColumn("matrix[1][3]");
                    let m14Array = struct_oper_list.getColumn("vector[1]");
                
                    let m21Array = struct_oper_list.getColumn("matrix[2][1]");
                    let m22Array = struct_oper_list.getColumn("matrix[2][2]");
                    let m23Array = struct_oper_list.getColumn("matrix[2][3]");
                    let m24Array = struct_oper_list.getColumn("vector[2]");
                
                    let m31Array = struct_oper_list.getColumn("matrix[3][1]");
                    let m32Array = struct_oper_list.getColumn("matrix[3][2]");
                    let m33Array = struct_oper_list.getColumn("matrix[3][3]");
                    let m34Array = struct_oper_list.getColumn("vector[3]");
                
                    let assemblySize = struct_oper_list.rowCount;
                    for (let i = 0; i < assemblySize; ++i) {
                        let struct_oper_id = struct_oper_idArray.getString(i);
                        if(struct_oper_id == "X0") continue;

                        if (ic.biomtMatrices[i] == undefined) ic.biomtMatrices[i] = new THREE.Matrix4().identity();
                        ic.biomtMatrices[i].set(m11Array.getString(i), m12Array.getString(i), m13Array.getString(i), m14Array.getString(i), 
                            m21Array.getString(i), m22Array.getString(i), m23Array.getString(i), m24Array.getString(i), 
                            m31Array.getString(i), m32Array.getString(i), m33Array.getString(i), m34Array.getString(i), 
                            0, 0, 0, 1);
                    }
                
                    struct_oper_idArray = m11Array = m12Array = m13Array = m14Array = m21Array = m22Array = m23Array 
                    = m24Array = m31Array = m32Array = m33Array = m34Array = [];
                }

                // if (record === 'ENDMDL') {
                //     ++moleculeNum;
                //     id = ic.defaultPdbId;

                //     structure = ic.loadPDBCls.getStructureId(id, moleculeNum);

                //     //helices = [];
                //     //sheets = [];
                //     if(!bNMR) {
                //         sheetArray = [];
                //         sheetStart = [];
                //         sheetEnd = [];
                //         helixArray = [];
                //         helixStart = [];
                //         helixEnd = [];
                //     }

                //     bHeader = false; // reinitialize to read structure name from the header
                // }

                if(block.getCategory("_citation")) {
                    ic.pmid = block.getCategory("_citation").getColumn("pdbx_database_id_PubMed").getString(0);
                }

                // Retrieve the table corresponding to the atom_site category, which delineates atomic constituents
                let atom_site = block.getCategory("_atom_site");
                let atomSize = atom_site.rowCount;
                // let bFull = (atomSize * 10 > ic.maxatomcnt) ? false : true;
                let bFull = (atomSize > ic.maxatomcnt) ? false : true;

                if(!bFull) {
                    ic.opts['proteins'] = 'c alpha trace'; //ribbon, strand, cylinder and plate, schematic, c alpha trace, b factor tube, lines, stick, ball and stick, sphere, nothing
                    ic.opts['nucleotides'] = 'o3 trace'; //nucleotide cartoon, o3 trace, schematic, lines, stick,
                }

                let atom_hetatmArray = atom_site.getColumn("group_PDB");
                let resnArray = atom_site.getColumn("label_comp_id");
                let elemArray = atom_site.getColumn("type_symbol");
                let nameArray = atom_site.getColumn("label_atom_id");

                let chainArray = atom_site.getColumn("auth_asym_id");

                let resiArray = atom_site.getColumn("label_seq_id");
                let resiOriArray = atom_site.getColumn("auth_seq_id");
                let altArray = atom_site.getColumn("label_alt_id");

                let bArray = atom_site.getColumn("B_iso_or_equiv");

                let xArray = atom_site.getColumn("Cartn_x");
                let yArray = atom_site.getColumn("Cartn_y");
                let zArray = atom_site.getColumn("Cartn_z");

                let autochainArray = atom_site.getColumn("label_asym_id");
                let modelNumArray = atom_site.getColumn("pdbx_PDB_model_num");

                // get the bond info
                let ligSeqHash = {}, prevAutochain = '';
                let prevResn;
                let sChain = {};
                let prevModelNum = '';
                for (let i = 0; i < atomSize; ++i) {
                    let modelNum = modelNumArray.getString(i);
                    if(i > 0 && modelNum != prevModelNum) {
                        ++moleculeNum;

                        if(modelNum == "1") {
                            structure = id;
                        }
                        else {
                            structure = id + modelNum;
                        }
                    }
                    prevModelNum = modelNum;

                    let atom_hetatm = atom_hetatmArray.getString(i);
                    let resn = resnArray.getString(i);
                    let elem = elemArray.getString(i);
                    let atom = nameArray.getString(i);
                    let chain = chainArray.getString(i);
                    let resi = resiArray.getString(i);
                    let oriResi = resiOriArray.getString(i); 
                    let alt = altArray.getString(i);
                    let bFactor = bArray.getString(i);

                    let autochain = autochainArray.getString(i);


                    resi = oriResi;

                    let molecueType;
                    if(atom_hetatm == "ATOM") {
                        if(resn.length == 3) {
                            molecueType = "protein"; // protein
                        }
                        else {
                            molecueType = "nucleotide"; // nucleotide
                        }
                    }
                    else {
                        if(resn == "WAT" || resn == "HOH") {
                            molecueType = "solvent"; // solvent
                            chain = 'Misc';
                        }
                        else {
                            molecueType = "ligand"; // ligands or ions
                            chain = resn;
                        }
                    }
                    if(chain === '') chain = 'A';

                    // C-alpha only for large structure
                    if(!bFull && ((molecueType == "protein" && !(elem == 'C' && atom == 'CA')) || (molecueType == "nucleotide" && !(atom == "P")) ) ) continue;
                    
                    // skip alternative atoms
                    if(alt == "B") continue;

                    sChain[chain] = 1;

                    // if(bFirstAtom) {
                    //     structure = ic.loadPDBCls.getStructureId(id, moleculeNum);

                    //     bFirstAtom = false;
                    // }

                    // "CA" has to appear before "O". Otherwise the cartoon of secondary structure will have breaks
                    // Concatenation of two pdbs will have several atoms for the same serial
                    ++serial;

                    // if(oriResi != resi || bModifyResi) { // e.g., 99A and 99
                    //     bModifyResi = true;
                    // }

                    if(resi == "?" || resi == "." || resi == "0") {
                        resi = oriResi;

                        // if(resn.length != 3 || resn == "HOH" || resn == "WAT") {
                        //     if(resn.length != 3 || (elem == 'O' && (resn == "HOH" || resn == "WAT"))) {
                        //         resi = (++tmpResi).toString();
                        //     }
                        // }
                        // else {
                        //     if(chain + "_" + resn != prevResn || prevAutochain != autochain) {
                        //         resi = (++tmpResi).toString();
                        //     }
                        //     else {
                        //         resi = (tmpResi).toString();
                        //     }
                        // }
                    }

                    if(molecueType == 'solvent' || molecueType == "ligand") {
                        let seq = {};
                        if(!ligSeqHash.hasOwnProperty(chain)) {
                            ligSeqHash[chain] = [];
                        }

                        if(resn.length != 3 || resn == "HOH" || resn == "WAT") {
                            if(resn.length != 3 || (elem == 'O' && (resn == "HOH" || resn == "WAT"))) {
                                seq.resi = resi;
                                seq.name = me.utilsCls.residueName2Abbr(resn);
                                ligSeqHash[chain].push(seq);
                            }
                        }
                        else {
                            if(chain + "_" + resn != prevResn || prevAutochain != autochain) {
                                seq.resi = resi;
                                seq.name = me.utilsCls.residueName2Abbr(resn);
                                ligSeqHash[chain].push(seq);
                            }
                        }
                    }

                    // if(bOpm && resn === 'DUM') {
                    //     elem = atom;
                    //     chain = 'MEM';
                    //     resi = 1;
                    //     oriResi = 1;
                    // }

                    // if(bVector && resn === 'DUM') break; // just need to get the vector of the largest chain

                    chainNum = structure + "_" + chain;
                    oriResidueNum = chainNum + "_" + oriResi;

                    residueNum = chainNum + "_" + resi;

                    //let chain_resi = chain + "_" + resi;

                    let x = xArray.getFloat(i);
                    let y = yArray.getFloat(i);
                    let z = zArray.getFloat(i);
                    let coord = new THREE.Vector3(x, y, z);

                    let atomDetails = {
                        het: (atom_hetatm == "HETATM"), // optional, used to determine chemicals, water, ions, etc
                        serial: serial,         // required, unique atom id
                        name: atom,             // required, atom name
                        alt: alt,               // optional, some alternative coordinates
                        resn: resn,         // optional, used to determine protein or nucleotide
                        structure: structure,   // optional, used to identify structure
                        chain: chain,           // optional, used to identify chain
                        resi: resi,             // optional, used to identify residue ID
                        //insc: line.substr(26, 1),
                        coord: coord,           // required, used to draw 3D shape
                        b: bFactor,             // optional, used to draw B-factor tube
                        elem: elem,             // optional, used to determine hydrogen bond
                        bonds: [],              // required, used to connect atoms
                        ss: 'coil',             // optional, used to show secondary structures
                        ssbegin: false,         // optional, used to show the beginning of secondary structures
                        ssend: false            // optional, used to show the end of secondary structures
                    };

                    if(!atomDetails.het && atomDetails.name === 'C') {
                        CSerial = serial;
                    }
                    if(!atomDetails.het && atomDetails.name === 'O') {
                        OSerial = serial;
                    }

                    // from DSSP C++ code
                    if(!atomDetails.het && atomDetails.name === 'N' && prevCSerial !== undefined && prevOSerial !== undefined) {
                        let dist = ic.atoms[prevCSerial].coord.distanceTo(ic.atoms[prevOSerial].coord);

                        let x2 = atomDetails.coord.x + (ic.atoms[prevCSerial].coord.x - ic.atoms[prevOSerial].coord.x) / dist;
                        let y2 = atomDetails.coord.y + (ic.atoms[prevCSerial].coord.y - ic.atoms[prevOSerial].coord.y) / dist;
                        let z2 = atomDetails.coord.z + (ic.atoms[prevCSerial].coord.z - ic.atoms[prevOSerial].coord.z) / dist;

                        atomDetails.hcoord = new THREE.Vector3(x2, y2, z2);
                    }

                    ic.atoms[serial] = atomDetails;

                    ic.dAtoms[serial] = 1;
                    ic.hAtoms[serial] = 1;
                    hAtoms[serial] = 1;

                    // Assign secondary structures from the input
                    // if a residue is assigned both sheet and helix, it is assigned as sheet
                    if(ic.loadPDBCls.isSecondary(residueNum, sheetArray, bNMR, !bFull)) {
                        ic.atoms[serial].ss = 'sheet';
                        if(ic.loadPDBCls.isSecondary(residueNum, sheetStart, bNMR, !bFull)) {
                        ic.atoms[serial].ssbegin = true;
                        }

                        // do not use else if. Some residues are both start and end of secondary structure
                        if(ic.loadPDBCls.isSecondary(residueNum, sheetEnd, bNMR, !bFull)) {
                        ic.atoms[serial].ssend = true;
                        }
                    }
                    else if(ic.loadPDBCls.isSecondary(residueNum, helixArray, bNMR, !bFull)) {
                        ic.atoms[serial].ss = 'helix';

                        if(ic.loadPDBCls.isSecondary(residueNum, helixStart, bNMR, !bFull)) {
                        ic.atoms[serial].ssbegin = true;
                        }

                        // do not use else if. Some residues are both start and end of secondary structure
                        if(ic.loadPDBCls.isSecondary(residueNum, helixEnd, bNMR, !bFull)) {
                        ic.atoms[serial].ssend = true;
                        }
                    }

                    let secondaries = '-';
                    if(ic.atoms[serial].ss === 'helix') {
                        secondaries = 'H';
                    }
                    else if(ic.atoms[serial].ss === 'sheet') {
                        secondaries = 'E';
                    }
                    //else if(ic.atoms[serial].ss === 'coil') {
                    //    secondaries = 'c';
                    //}
                    else if(!ic.atoms[serial].het && me.parasCls.residueColors.hasOwnProperty(ic.atoms[serial].resn.toUpperCase()) ) {
                        secondaries = 'c';
                    }
                    else {
                        secondaries = 'o';
                    }

                    ic.secondaries[residueNum] = secondaries;

                    // different residue
                    //if(residueNum !== prevResidueNum) {
                        
                    // if(oriResidueNum !== prevOriResidueNum) {
                    if(oriResidueNum !== prevOriResidueNum || chain + "_" + resn != prevResn || prevAutochain != autochain) {
                        let residue = me.utilsCls.residueName2Abbr(resn);
                        
                        ic.residueId2Name[residueNum] = residue;

                        if(serial !== 1 && prevResidueNum !== '') {
                            ic.residues[prevResidueNum] = residuesTmp;
                        }

                        if(residueNum !== prevResidueNum) {
                            residuesTmp = {};
                        }

                        // different chain
                        if(chainNum !== prevChainNum) {
                            prevCSerial = undefined;
                            prevOSerial = undefined;

                            // a chain could be separated in two sections
                            if(serial !== 1 && prevChainNum !== '') {
                                if(ic.chains[prevChainNum] === undefined) ic.chains[prevChainNum] = {};
                                ic.chains[prevChainNum] = me.hashUtilsCls.unionHash(ic.chains[prevChainNum], chainsTmp);
                            }

                            chainsTmp = {};

                            if(ic.structures[structure.toString()] === undefined) ic.structures[structure.toString()] = [];
                            if(!ic.structures[structure.toString()].includes(chainNum)) ic.structures[structure.toString()].push(chainNum);

                            if(ic.chainsSeq[chainNum] === undefined) ic.chainsSeq[chainNum] = [];

                            let resObject = {};
                            resObject.resi = resi;
                            resObject.name = residue;

                            ic.chainsSeq[chainNum].push(resObject);
                        }
                        else {
                            prevCSerial = CSerial;
                            prevOSerial = OSerial;

                            let resObject = {};
                            resObject.resi = resi;
                            resObject.name = residue;

                            ic.chainsSeq[chainNum].push(resObject);
                        }
                    }

                    chainsTmp[serial] = 1;
                    residuesTmp[serial] = 1;

                    prevChainNum = chainNum;
                    prevResidueNum = residueNum;
                    prevOriResidueNum = oriResidueNum;

                    prevResn = chain + "_" + resn;
                    prevAutochain = autochain;
                }

                // add the last residue set
                ic.residues[residueNum] = residuesTmp;
                if(ic.chains[chainNum] === undefined) ic.chains[chainNum] = {};
                ic.chains[chainNum] = me.hashUtilsCls.unionHash2Atoms(ic.chains[chainNum], chainsTmp, ic.atoms);

                // clear memory
                atom_hetatmArray = resnArray = elemArray = nameArray = chainArray = resiArray = resiOriArray 
                    = altArray = bArray = xArray = yArray = zArray = autochainArray = [];

                let mChainSeq = {};
                if(block.getCategory("_pdbx_poly_seq_scheme")) {
                    let poly_seq_scheme = block.getCategory("_pdbx_poly_seq_scheme");

                    let resiArray = poly_seq_scheme.getColumn("seq_id");
                    let oriResiArray = poly_seq_scheme.getColumn("pdb_seq_num");
                    let resnArray = poly_seq_scheme.getColumn("mon_id");
                    let chainArray = poly_seq_scheme.getColumn("pdb_strand_id");

                    let seqSize = poly_seq_scheme.rowCount;
                    let prevChain = "";
                    let seqArray = [];
                    for (let i = 0; i < seqSize; ++i) {
                        resiArray.getString(i);
                        let oriResi = oriResiArray.getString(i);
                        let resn = resnArray.getString(i);
                        let chain = chainArray.getString(i);

                        if(chain != prevChain && i > 0) {
                            mChainSeq[prevChain] = seqArray;

                            seqArray = [];
                        }

                        // seqArray.push({"resi": resi, "name": me.utilsCls.residueName2Abbr(resn)});
                        seqArray.push({"resi": oriResi, "name": me.utilsCls.residueName2Abbr(resn)});

                        prevChain = chain;
                    }

                    mChainSeq[prevChain] = seqArray;

                    resiArray = oriResiArray = resnArray = chainArray = [];
                }
                
                this.setSeq(structure, sChain, mChainSeq, ligSeqHash);
            }

            // copy disulfide bonds
            let structureArray = Object.keys(ic.structures);
            for(let s = 0, sl = structureArray.length; s < sl; ++s) {
                let structure = structureArray[s];

                if(structure == id) continue;

                if(ic.ssbondpnts[structure] === undefined) ic.ssbondpnts[structure] = [];

                if(ic.ssbondpnts[id] !== undefined) {
                    for(let j = 0, jl = ic.ssbondpnts[id].length; j < jl; ++j) {
                        let ori_resid = ic.ssbondpnts[id][j];
                        let pos = ori_resid.indexOf('_');
                        let resid = structure + ori_resid.substr(pos);

                        ic.ssbondpnts[structure].push(resid);
                    }
                }
            }

            // calculate disulfide bonds for CIF files
            if(!ic.bSsbondProvided) {
                ic.loadPDBCls.setSsbond();
            }

            let curChain, curResi, curResAtoms = [];
          
            let pmin = new THREE.Vector3( 9999, 9999, 9999);
            let pmax = new THREE.Vector3(-9999,-9999,-9999);
            let psum = new THREE.Vector3();
            let cnt = 0;

            // lipids may be considered as protein if "ATOM" instead of "HETATM" was used
            let lipidResidHash = {};

            // assign atoms
            let prevCarbonArray = []; 
            //for (let i in ic.atoms) {
            for (let i in ic.hAtoms) {    
                let atom = ic.atoms[i];
                let coord = atom.coord;
                psum.add(coord);
                pmin.min(coord);
                pmax.max(coord);
                ++cnt;

                if(cnt == 1) {
                    curChain = atom.chain;
                    curResi = atom.resi;
                    prevCarbonArray.push(atom);
                }

                if(!atom.het) {
                  if($.inArray(atom.resn, me.parasCls.nucleotidesArray) !== -1) {
                    ic.nucleotides[atom.serial] = 1;
                    //if (atom.name === 'P') {
                    if (atom.name === "O3'" || atom.name === "O3*") {
                        ic.nucleotidesO3[atom.serial] = 1;

                        ic.secondaries[atom.structure + '_' + atom.chain + '_' + atom.resi] = 'o'; // nucleotide
                    }

                    if(me.parasCls.nuclMainArray.indexOf(atom.name) === -1) {
                        ic.ntbase[atom.serial] = 1;
                    }
                  }
                  else {
                    if (atom.elem === 'P') {
                        lipidResidHash[atom.structure + '_' + atom.chain + '_' + atom.resi] = 1;
                    }

                    ic.proteins[atom.serial] = 1;
                    if (atom.name === 'CA') ic.calphas[atom.serial] = 1;
                    if (atom.name !== 'N' && atom.name !== 'H' && atom.name !== 'CA' && atom.name !== 'HA' && atom.name !== 'C' && atom.name !== 'O') ic.sidec[atom.serial] = 1;
                  }
                }
                else if(atom.het) {
                  if(atom.resn === 'HOH' || atom.resn === 'WAT' || atom.resn === 'SOL') {
                    ic.water[atom.serial] = 1;
                  }
                  else if($.inArray(atom.resn, me.parasCls.ionsArray) !== -1 || atom.elem.trim() === atom.resn.trim()) {
                    ic.ions[atom.serial] = 1;
                  }
                  else {
                    ic.chemicals[atom.serial] = 1;
                  }

                  atom.color = me.parasCls.atomColors[atom.elem];
                }

                if(!(curChain === atom.chain && curResi === atom.resi)) {
                    // a new residue, add the residue-residue bond besides the regular bonds               
                    ic.loadPDBCls.refreshBonds(curResAtoms, prevCarbonArray[0]);

                    prevCarbonArray.splice(0, 1); // remove the first carbon

                    curChain = atom.chain;
                    curResi = atom.resi;
                    //curInsc = atom.insc;
                    curResAtoms.length = 0;
                }
                curResAtoms.push(atom);

                if(atom.name === 'C' || atom.name === 'O3\'') {
                    prevCarbonArray.push(atom);
                }
            } // end of for

            // last residue
            //refreshBonds();
            ic.loadPDBCls.refreshBonds(curResAtoms, prevCarbonArray[0]);

            // reset lipid
            for(let resid in lipidResidHash) {
                let atomHash = ic.residues[resid];
                for(serial in atomHash) {
                    let atom = ic.atoms[serial];

                    atom.het = true;
                    ic.chemicals[atom.serial] = 1;
                    ic.secondaries[resid] = 'o'; // nucleotide

                    delete ic.proteins[atom.serial];
                    if (atom.name === 'CA') delete ic.calphas[atom.serial];
                    if (atom.name !== 'N' && atom.name !== 'H' && atom.name !== 'CA' && atom.name !== 'HA' && atom.name !== 'C' && atom.name !== 'O') delete ic.sidec[atom.serial];
                }
            }

            ic.pmin = pmin;
            ic.pmax = pmax;

            ic.cnt = cnt;

            //ic.maxD = ic.pmax.distanceTo(ic.pmin);
            //ic.center = psum.multiplyScalar(1.0 / ic.cnt);
            ic.center = ic.ParserUtilsCls.getGeoCenter(ic.pmin, ic.pmax);

            ic.maxD = ic.ParserUtilsCls.getStructureSize(ic.atoms, ic.pmin, ic.pmax, ic.center);

            if (ic.maxD < 5) ic.maxD = 5;

            ic.oriMaxD = ic.maxD;
            ic.oriCenter = ic.center.clone();

            // if(type === 'target') {
            //     ic.oriMaxD = ic.maxD;
            //     ic.center1 = ic.center;
            // }
            // else if(type === 'query') {
            //     if(ic.oriMaxD < ic.maxD) ic.oriMaxD = ic.maxD;

            //     ic.center2 = ic.center;
            //     ic.center = new THREE.Vector3(0,0,0);
            // }

            // if(bVector) { // just need to get the vector of the largest chain
            //     return ic.loadPDBCls.getChainCalpha(ic.chains, ic.atoms);
            // }
            // else {
                return hAtoms;
            // }
        }

        setSeq(structure, sChain, mChainSeq, ligSeqHash) { let ic = this.icn3d; ic.icn3dui;
            for(let chain in sChain) {
                let chainNum = structure + '_' + chain;

                if(ligSeqHash.hasOwnProperty(chain)) {
                    ic.chainsSeq[chainNum] = ligSeqHash[chain];
                }
                else {
                    ic.chainsSeq[chainNum] = mChainSeq[chain];
                }
            }

            ic.loadPDBCls.setResidMapping();
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Vastplus {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Load the VAST+ structure alignment for the pair of structures "align", e.g., "align" could be "1HHO,4N7N".
        // vastplusAtype: 0: VAST, global, 1: VAST, invarant core, 2: TM-align, global
        async vastplusAlign(structArray, vastplusAtype, bRealign) { let ic = this.icn3d; ic.icn3dui;
            let thisClass = this;

            // 1. pairwise alignment
            let ajaxArray = [], chainidpairArray = [];
            if(structArray.length != 2) {
                console.log("VAST+ needs two input structures...");
                return;
            }

            let struct1 = structArray[0], struct2 = structArray[1];

            // get protein chains since TM-align doesn't work for nucleotides
            let chainidArray1 = [], chainidArray2 = [];
            for(let i = 0, il = ic.structures[struct1].length; i < il; ++i) {
                let chainid1 = ic.structures[struct1][i];
                if(!ic.proteins.hasOwnProperty(ic.firstAtomObjCls.getFirstAtomObj(ic.chains[chainid1]).serial)) continue;
                chainidArray1.push(chainid1);
            }
            for(let i = 0, il = ic.structures[struct2].length; i < il; ++i) {
                let chainid2 = ic.structures[struct2][i];
                if(!ic.proteins.hasOwnProperty(ic.firstAtomObjCls.getFirstAtomObj(ic.chains[chainid2]).serial)) continue;
                chainidArray2.push(chainid2);
            }

            let node2chainindex = {};
            let node = 0;

            // align A to A, B to B first
            for(let i = 0, il = chainidArray1.length; i < il; ++i) {
                let chainid1 = chainidArray1[i];
                for(let j = 0, jl = chainidArray2.length; j < jl; ++j) {
                    let chainid2 = chainidArray2[j];
                    if(i == j) {
                        let alignAjax = this.setAlignment(struct1, struct2, chainid1, chainid2, bRealign);

                        ajaxArray.push(alignAjax);
                        chainidpairArray.push(chainid1 + ',' + chainid2);
                        node2chainindex[node] = [i, j];

                        ++node;
                    }
                }
            }

            for(let i = 0, il = chainidArray1.length; i < il; ++i) {
                let chainid1 = chainidArray1[i];
                for(let j = 0, jl = chainidArray2.length; j < jl; ++j) {
                    let chainid2 = chainidArray2[j];
                    if(i != j) {
                        let alignAjax = this.setAlignment(struct1, struct2, chainid1, chainid2, bRealign);

                        ajaxArray.push(alignAjax);
                        chainidpairArray.push(chainid1 + ',' + chainid2);
                        node2chainindex[node] = [i, j];

                        ++node;
                    }
                }
            }

            let allPromise = Promise.allSettled(ajaxArray);
            try {
                let dataArray = await allPromise;

                // 2. cluster pairs
                thisClass.clusterAlignment(dataArray, chainidpairArray, node2chainindex, vastplusAtype);

                // 3. superpose the top selection

                ic.ParserUtilsCls.hideLoading();
                await ic.pdbParserCls.loadPdbDataRender(true);

                /// if(ic.deferredRealignByVastplus !== undefined) ic.deferredRealignByVastplus.resolve();
            }
            catch(err) {
                alert("There are some problems in aligning the chains...");
            }          
        }

        setAlignment(struct1, struct2, chainid1, chainid2, bRealign) { let ic = this.icn3d, me = ic.icn3dui;
            let urltmalign = me.htmlCls.baseUrl + "tmalign/tmalign.cgi";

            let sel_t = (bRealign) ? me.hashUtilsCls.intHash(ic.hAtoms, ic.chains[chainid1]) : ic.chains[chainid1];
            let sel_q = (bRealign) ? me.hashUtilsCls.intHash(ic.hAtoms, ic.chains[chainid2]) : ic.chains[chainid2];

            let pdb_target = ic.saveFileCls.getAtomPDB(sel_t, undefined, undefined, undefined, undefined, struct1);
            let pdb_query = ic.saveFileCls.getAtomPDB(sel_q, undefined, undefined, undefined, undefined, struct2);

            let dataObj = {'pdb_query': pdb_query, 'pdb_target': pdb_target};
            let alignAjax = me.getAjaxPostPromise(urltmalign, dataObj);

            return alignAjax;
        }

        async realignOnVastplus() { let ic = this.icn3d, me = ic.icn3dui;
            let structHash = [];
            for(let struct in ic.structures) {
                let chainidArray = ic.structures[struct];
                for(let i = 0, il = chainidArray.length; i < il; ++i) {
                    let chainid = chainidArray[i];
                    let atoms = me.hashUtilsCls.intHash(ic.hAtoms, ic.chains[chainid]);               
                    let firstAtom = ic.firstAtomObjCls.getFirstAtomObj(atoms);
                    if(firstAtom) structHash[firstAtom.structure] = 1;
                }
            }

            let bRealign = true, atype = 2; // VAST+ based on TM-align
            me.cfg.aligntool = 'tmalign';
            await ic.vastplusCls.vastplusAlign(Object.keys(structHash), atype, bRealign);
        }

        getResisFromSegs(segArray) { let ic = this.icn3d; ic.icn3dui;
            let resiArray_t = [], resiArray_q = [];
            for(let i = 0, il = segArray.length; i < il; ++i) {
                let seg = segArray[i];
                // for(let j = 0; j <= seg.t_end - seg.t_start; ++j) {
                //     resiArray_t.push(j);
                // }
                // for(let j = 0; j <= seg.q_end - seg.q_start; ++j) {
                //     resiArray_q.push(j);
                // }
                resiArray_t.push(seg.t_start + '-' + seg.t_end);
                resiArray_q.push(seg.q_start + '-' + seg.q_end);
            }

            return {resiArray_t: resiArray_t, resiArray_q: resiArray_q};
        }

        clusterAlignment(dataArray, chainidpairArray, node2chainindex, vastplusAtype) { let ic = this.icn3d, me = ic.icn3dui;

            let queryDataArray = [];
            for(let index = 0, indexl = chainidpairArray.length; index < indexl; ++index) {
                // let queryData = (me.bNode) ? dataArray[index] : dataArray[index].value; //[0];
                let queryData = dataArray[index].value; //[0];

                queryDataArray.push(queryData);
    /*
                if(queryData !== undefined && JSON.stringify(queryData).indexOf('Oops there was a problem') === -1
                    ) {
                    queryDataArray.push(queryData);
                }
                else {
                    console.log("The alignment data can NOT be retrieved for the pair " + chainidpairArray[index] + "...");
                    //return;
                    queryDataArray.push([]);
                }
    */            
            }

            //src/internal/structure/MMDBUpdateTools/Interactions/compbu/comparebuEngine.cpp
            //  Doing a new comparison; remove any existing results.
            let m_qpMatrixDist = [];

            let outlier = 1.0, maxDist = 0;

            let bAligned = false;
            for(let i = 0, il = chainidpairArray.length; i < il; ++i) {
                let vdist = [];
                if(queryDataArray[i].length > 0) bAligned = true;

                for(let j = 0, jl = chainidpairArray.length; j < jl; ++j) {
                    let result = this.RotMatrixTransDist(queryDataArray[i][0], queryDataArray[j][0], outlier, vastplusAtype);

                    // 1.0: not aligned
                    let dist = (i == j) ? 0.0 : ( (queryDataArray[i].length == 0 || queryDataArray[j].length == 0) ? 1.0 : result);
                    //if(dist < outlier && dist > maxDist) {
                    if(dist > maxDist) {
                        maxDist = dist;
                    }
                    vdist.push(dist);                
                }

                m_qpMatrixDist.push(vdist);
            }

            if(!bAligned) {
                if(ic.bRender) alert("These structures can not be aligned...");
                return;
            }

            if(maxDist < 1e-6) maxDist = 1;

            // normalize the score matrix
            for(let i = 0, il = chainidpairArray.length; i < il; ++i) {
                for(let j = 0, jl = chainidpairArray.length; j < jl; ++j) {
                    m_qpMatrixDist[i][j] = m_qpMatrixDist[i][j] / maxDist;
                }
            }
            
            // cluster
            let threshold = 1.0;

            let bLastTiedValue = false;
            let m_clusteringResult = this.clusterLinkage(threshold, m_qpMatrixDist, bLastTiedValue);

            let m_buChainMap = this.GetChainMappings(m_clusteringResult, chainidpairArray);

            //  By default, clusters populate m_buChainMap in order of increasing score.
            let allnodesHash = {};
            for (let i = 0, il = m_buChainMap.length; i < il; ++i) {
                let nodeArray = m_buChainMap[i].nodeArray;
                let allnodes = nodeArray.join(',');

                // use the sum of all pairs
                // let sum = 0;
                // for(let j = 0, jl = nodeArray.length; j < jl; ++j) {
                //     let chainindexArray = node2chainindex[parseInt(nodeArray[j])];
                //     sum += m_qpMatrixDist[chainindexArray[0]][chainindexArray[1]];
                // }

                // use the best match
                let chainindexArray = node2chainindex[parseInt(nodeArray[0])];
                let sum = m_qpMatrixDist[chainindexArray[0]][chainindexArray[1]];           

                if(!allnodesHash[allnodes]) {
                    allnodesHash[allnodes] = sum;
                }
                else if(sum < allnodesHash[allnodes]) {
                    allnodesHash[allnodes] = sum;
                }
            }

            // sort the hash by value, then sort by key
            let allnodesArray = Object.keys(allnodesHash).sort((key1, key2) => (allnodesHash[key1] < allnodesHash[key2]) ? -1 : ( (parseInt(10000*allnodesHash[key1]) == parseInt(10000*allnodesHash[key2])) ? ( (key1 < key2) ? -1 : 1 ) : 1 ));

            let badRmsd = parseInt($("#" + me.pre + "maxrmsd").val());
            if(!badRmsd) badRmsd = 30;
            
            bAligned = false;

            for(let i = 0, il = allnodesArray.length; i < il; ++i) {
                let nodeArray = allnodesArray[i].split(',');

                ic.opts['color'] = 'grey';
                ic.setColorCls.setColorByOptions(ic.opts, ic.atoms);

                // get the mapped coords
                let coor_t = [], coor_q = [];
                let chainid_t, chainid_q;
                let hAtomsAll = {};

                // reinitialize the alignment
                $("#" + ic.pre + "dl_sequence2").html('');

                for(let j = 0, jl = nodeArray.length; j < jl; ++j) {
                    let node = parseInt(nodeArray[j]);
                    let segs = queryDataArray[node][0].segs;
                    let chainidArray = chainidpairArray[node].split(',');

                    chainid_t = chainidArray[0];
                    chainid_q = chainidArray[1];

                    let resiArrays = this.getResisFromSegs(segs);
                    let resiArray_t = resiArrays.resiArray_t;
                    let resiArray_q = resiArrays.resiArray_q;

                    //let base = parseInt(ic.chainsSeq[chainid_t][0].resi);
                    let result_t = ic.realignParserCls.getSeqCoorResid(resiArray_t, chainid_t);
                    coor_t = coor_t.concat(result_t.coor);

                    //base = parseInt(ic.chainsSeq[chainid_q][0].resi);
                    let result_q = ic.realignParserCls.getSeqCoorResid(resiArray_q, chainid_q);
                    coor_q = coor_q.concat(result_q.coor);

                    // align seq 
                    ic.qt_start_end = [];
                    ic.qt_start_end.push(segs);
                    let bVastplus = true, bRealign = true;
                    let hAtomsTmp = ic.chainalignParserCls.setMsa(chainidArray, bVastplus, bRealign);
                    hAtomsAll = me.hashUtilsCls.unionHash(hAtomsAll, hAtomsTmp);
                }

                ic.hAtoms = me.hashUtilsCls.cloneHash(hAtomsAll);

                // ic.opts['color'] = 'identity';
                // ic.setColorCls.setColorByOptions(ic.opts, ic.hAtoms);

                // align residue by residue
                let n =(coor_q.length < coor_t.length) ? coor_q.length : coor_t.length;
       
                if(n < 4) continue;

                if(n >= 4) {
                    ic.rmsd_suprTmp = me.rmsdSuprCls.getRmsdSuprCls(coor_q, coor_t, n);
         
                    // superpose
                    if(ic.rmsd_suprTmp.rot !== undefined) {
                        let rot = ic.rmsd_suprTmp.rot;
                        if(rot[0] === null) continue;
          
                        let centerFrom = ic.rmsd_suprTmp.trans1;
                        let centerTo = ic.rmsd_suprTmp.trans2;
                        let rmsd = ic.rmsd_suprTmp.rmsd;

                        if(rmsd < badRmsd) {
                            bAligned = true;

                            me.htmlCls.clickMenuCls.setLogCmd("realignment RMSD: " + rmsd.toPrecision(4), false);
                            $("#" + ic.pre + "dl_rmsd_html").html("<br><b>Realignment RMSD</b>: " + rmsd.toPrecision(4) + " &#8491;<br><br>");
                            if(!me.cfg.bSidebyside) me.htmlCls.dialogCls.openDlg('dl_rmsd', 'Realignment RMSD');

                            // apply matrix for each atom                       
                            ic.q_rotation = [];
                            ic.q_trans_sub = [];
                            ic.t_trans_add = [];

                            ic.q_rotation.push({x1: rot[0], y1: rot[1], z1: rot[2], x2: rot[3], y2: rot[4], z2: rot[5], x3: rot[6], y3: rot[7], z3: rot[8]});
                            ic.q_trans_sub.push(centerFrom);
                            ic.t_trans_add.push({x: -centerTo.x, y: -centerTo.y, z: -centerTo.z});

                            me.cfg.aligntool = 'vast'; //!= 'tmalign';
                            let index = 0, alignType = 'query';
                            let mmdbid_q = chainid_q.substr(0, chainid_q.indexOf('_'));
                            let bForce = true;
                            ic.chainalignParserCls.transformStructure(mmdbid_q, index, alignType, bForce);

                            let chainpairStr = '';
                            for(let j = 0, jl = nodeArray.length; j < jl; ++j) {
                                chainpairStr += chainidpairArray[parseInt(nodeArray[j])] + '; ';
                            }
                            if(!me.bNode) console.log("Selected the alignment: " + chainpairStr);

                            break;
                        }
                        else {
                            let chainpairStr = '';
                            for(let j = 0, jl = nodeArray.length; j < jl; ++j) {
                                chainpairStr += chainidpairArray[parseInt(nodeArray[j])] + '; ';
                            }
                            if(!me.bNode) console.log("skipped the alignment: " + chainpairStr);
                        }
                    }
                }
            }

            if(!bAligned) {
                if(ic.bRender) alert("These structures can not be aligned...");
                return;
            }
        }

        // src/internal/structure/MMDBUpdateTools/Interactions/compbu/qaAlignment.cpp
        RotMatrixTransDist(qpa1, qpa2, outlier, vastplusAtype) { let ic = this.icn3d; ic.icn3dui;
            let cosval = 0.866, lenval = 8.0; 

            if(!qpa1 || !qpa2) return outlier;
            
            let rmat1 = this.GetRotMatrix(qpa1, 1.0, vastplusAtype);
            let rmat2 = this.GetRotMatrix(qpa2, 1.0, vastplusAtype);
            let tA1 = [], tA2 = [], tB1 = [], tB2 = [];
            tA1[0] = rmat1[9];  // qpa1.t1x;
            tA1[1] = rmat1[10]; // qpa1.t1y;
            tA1[2] = rmat1[11]; // qpa1.t1z;
            tA2[0] = rmat1[12]; // qpa1.t2x;
            tA2[1] = rmat1[13]; // qpa1.t2y;
            tA2[2] = rmat1[14]; // qpa1.t2z;
            tB1[0] = rmat2[9];  // qpa2.t1x;
            tB1[1] = rmat2[10]; // qpa2.t1y;
            tB1[2] = rmat2[11]; // qpa2.t1z;
            tB2[0] = rmat2[12]; // qpa2.t2x;
            tB2[1] = rmat2[13]; // qpa2.t2y;
            tB2[2] = rmat2[14]; // qpa2.t2z;
            let vecl = [], vecr = [];
            vecl[0] = tA2[0] - tB2[0];
            vecl[1] = tA2[1] - tB2[1];
            vecl[2] = tA2[2] - tB2[2];
            vecr[0] = tA1[0] - tB1[0];
            vecr[1] = tA1[1] - tB1[1];
            vecr[2] = tA1[2] - tB1[2];
        
            let sum = 0.0, l1, l2;
            sum += Math.pow(vecl[0], 2);
            sum += Math.pow(vecl[1], 2);
            sum += Math.pow(vecl[2], 2);
            l1 = Math.sqrt(sum);
            sum = 0.0;
            sum += Math.pow(vecr[0], 2);
            sum += Math.pow(vecr[1], 2);
            sum += Math.pow(vecr[2], 2);
            l2 = Math.sqrt(sum);

            // l1 == 0.0 or l2 == 0.0 may occur, if two of the molecules are the same
            if(vastplusAtype != 2) { // VAST
                if ((l1 < 1e-10) || (l2 < 1e-10)) {
                    return outlier;
                }
            }
            else {
                if (l2 < 1e-10) {
                    return outlier;
                }
            }
     
            if (Math.abs(l1 - l2) > lenval) {
                return outlier;
            }

            // additional check!
            let vecr0 = [];
            vecr0[0] = rmat1[0]*tA1[0] + rmat1[1]*tA1[1] + rmat1[2]*tA1[2];
            vecr0[1] = rmat1[3]*tA1[0] + rmat1[4]*tA1[1] + rmat1[5]*tA1[2];
            vecr0[2] = rmat1[6]*tA1[0] + rmat1[7]*tA1[1] + rmat1[8]*tA1[2];
            vecr0[0] -= rmat1[0]*tB1[0] + rmat1[1]*tB1[1] + rmat1[2]*tB1[2];
            vecr0[1] -= rmat1[3]*tB1[0] + rmat1[4]*tB1[1] + rmat1[5]*tB1[2];
            vecr0[2] -= rmat1[6]*tB1[0] + rmat1[7]*tB1[1] + rmat1[8]*tB1[2];
            let dot0 = 0.0;
            dot0 = vecl[0]*vecr0[0];
            dot0 += vecl[1]*vecr0[1];
            dot0 += vecl[2]*vecr0[2];
            dot0 /= (l1*l2);

            if (dot0 < cosval) {
                return outlier;
            }

            // additional check!
            vecr0[0] = rmat2[0]*tA1[0] + rmat2[1]*tA1[1] + rmat2[2]*tA1[2];
            vecr0[1] = rmat2[3]*tA1[0] + rmat2[4]*tA1[1] + rmat2[5]*tA1[2];
            vecr0[2] = rmat2[6]*tA1[0] + rmat2[7]*tA1[1] + rmat2[8]*tA1[2];
            vecr0[0] -= rmat2[0]*tB1[0] + rmat2[1]*tB1[1] + rmat2[2]*tB1[2];
            vecr0[1] -= rmat2[3]*tB1[0] + rmat2[4]*tB1[1] + rmat2[5]*tB1[2];
            vecr0[2] -= rmat2[6]*tB1[0] + rmat2[7]*tB1[1] + rmat2[8]*tB1[2];
            dot0 = vecl[0]*vecr0[0];
            dot0 += vecl[1]*vecr0[1];
            dot0 += vecl[2]*vecr0[2];
            dot0 /= (l1*l2);

            if (dot0 < cosval) {
                return outlier;
            }

            sum = 0.0;
            sum += Math.pow(qpa1.q_rotation.x1 - qpa2.q_rotation.x1, 2);
            sum += Math.pow(qpa1.q_rotation.y1 - qpa2.q_rotation.y1, 2);
            sum += Math.pow(qpa1.q_rotation.z1 - qpa2.q_rotation.z1, 2);
            sum += Math.pow(qpa1.q_rotation.x2 - qpa2.q_rotation.x2, 2);
            sum += Math.pow(qpa1.q_rotation.y2 - qpa2.q_rotation.y2, 2);
            sum += Math.pow(qpa1.q_rotation.z2 - qpa2.q_rotation.z2, 2);
            sum += Math.pow(qpa1.q_rotation.x3 - qpa2.q_rotation.x3, 2);
            sum += Math.pow(qpa1.q_rotation.y3 - qpa2.q_rotation.y3, 2);
            sum += Math.pow(qpa1.q_rotation.z3 - qpa2.q_rotation.z3, 2);
       
            return Math.sqrt(sum);
        }
        
        GetRotMatrix(qpa, scaleFactor, vastplusAtype) { let ic = this.icn3d; ic.icn3dui;
            let result = [];
            if (result) {
                result[0] = qpa.q_rotation.x1 / scaleFactor;
                result[1] = qpa.q_rotation.y1 / scaleFactor;
                result[2] = qpa.q_rotation.z1 / scaleFactor;
                result[3] = qpa.q_rotation.x2 / scaleFactor;
                result[4] = qpa.q_rotation.y2 / scaleFactor;
                result[5] = qpa.q_rotation.z2 / scaleFactor;
                result[6] = qpa.q_rotation.x3 / scaleFactor;
                result[7] = qpa.q_rotation.y3 / scaleFactor;
                result[8] = qpa.q_rotation.z3 / scaleFactor;
                
                if(vastplusAtype != 2) { // VAST
                    result[9] = qpa.t_trans_add.x / scaleFactor;
                    result[10] = qpa.t_trans_add.y / scaleFactor;
                    result[11] = qpa.t_trans_add.z / scaleFactor;
                    result[12] = -qpa.q_trans_sub.x / scaleFactor;
                    result[13] = -qpa.q_trans_sub.y / scaleFactor;
                    result[14] = -qpa.q_trans_sub.z / scaleFactor;
                }
                else {
                    //TM-align
                    result[9] = -qpa.q_trans_add.x / scaleFactor;
                    result[10] = -qpa.q_trans_add.y / scaleFactor;
                    result[11] = -qpa.q_trans_add.z / scaleFactor;
                    result[12] = 0;
                    result[13] = 0;
                    result[14] = 0;
                }
            }
            
            return result;
        }

        cbu_dist( v1, v2, vvDist)  {
            return (v1 < v2) ?  vvDist[v1][v2] : vvDist[v2][v1];
        }  
        
        compareFloat(cumul, node1, node2 )  {
            // let v1 = cumul[node1].joinDist;
            // let v2 = cumul[node2].joinDist;
            let v1 = cumul[node1].dist;
            let v2 = cumul[node2].dist;

            if(parseInt(10000 * v1) == parseInt(10000 * v2)) {
                return 0;
            }
            else if(parseInt(10000 * v1) < parseInt(10000 * v2)) {
                return -1;
            }
            else {
                return 1;
            }
        } 

        //  This method has been adapted from the code at:
        //  src/internal/structure/PubChem/graphicsapi/graphicsapi.cpp
        // ref: Olson CF, 1995, Parallel algorithms for hierarchical clustering.
        // http://linkinghub.elsevier.com/retrieve/pii/016781919500017I
        
        // single linkage method
        clusterLinkage(threshold, distmat, bLastTiedValue) { let ic = this.icn3d, me = ic.icn3dui;
            let cumul = [];
        
            let CBU_ROOT = -1, CBU_TERMINAL = -2;

            let i, j, n = distmat.length;

            let oriNode, selI, selJ, count;

            let distTmp, distPair, maxDist = 2.0;

            for(i = 0; i < 2*n - 1; ++i) {
                cumul[i] = {};
                cumul[i].leaves = []; // array of array
            }
        
            // make a matrix to hold the dynamic distance
            let vvDist = [];
            for(i = 0; i < 2*n - 1; ++i) {
                vvDist[i] = [];
                for(j = 0; j < 2*n - 1; ++j) {
                    vvDist[i][j] = maxDist;
                }
            }
        
            for(i = 0; i < n; ++i) {
                for(j = i; j < n; ++j) {
                    vvDist[i][j] = distmat[i][j];
                }
            }

            // for each current nodes, assign its nearest neighbor and the distance
            let mNearestNB = {}, mNearestNBCopy = {}, mNearestNBDist = {};
        
            selI = n;
            selJ = n;
            for(i = 0; i < n; ++i) {
                distTmp = maxDist;
                for(j = 0; j < n; ++j) {
                    let bComp = (bLastTiedValue) ? (parseInt(10000 * this.cbu_dist(i, j, vvDist)) <= parseInt(10000 * distTmp)) : (parseInt(10000 * this.cbu_dist(i, j, vvDist)) < parseInt(10000 * distTmp));
                    if(j != i && bComp) {
                        distTmp = this.cbu_dist(i, j, vvDist);
                        selI = i;
                        selJ = j;
                    }
                }
        
                mNearestNB[selI] = selJ;
                mNearestNBDist[selI] = distTmp;
            }

            let childDist = []; // the distance between its children
        
            for(count=0; count < n; ++count){
                cumul[count].child1     = CBU_TERMINAL;
                cumul[count].child2     = CBU_TERMINAL;
                cumul[count].parent     = count;
                cumul[count].dist       = 0.0;
                cumul[count].leaves.push([count]);
                childDist[count]     = 0.0;
            }

            let structArray = Object.keys(ic.structures);
            let nChain1 = ic.structures[structArray[0]].length;
            let nChain2 = ic.structures[structArray[1]].length;
            let nChain = (nChain1 < nChain2) ? nChain1 : nChain2;

            for(count = n; count < 2*n-1; ++count) {
                // find the min dist
                distTmp = maxDist;
                for(oriNode in mNearestNB) {
                    distPair = mNearestNBDist[oriNode];
                    if(distPair < distTmp) {
                        distTmp = distPair;
                        selI = oriNode;
                        selJ = mNearestNB[oriNode];
                    }
                }

                let distance = distTmp;

                // update the nodes
                cumul[count].child1 = (selI < n) ? selI : -selI;
                cumul[count].child2 = (selJ < n) ? selJ : -selJ;
                cumul[count].parent = -1 * count;

                // distance of its two children
                cumul[selI].dist = distance - childDist[selI];
                cumul[selJ].dist = distance - childDist[selJ];
                childDist[count] = distance;

                // update the dist matrix for the current one "count"
                for(j = 0; j < 2*n - 1; ++j) {
                    let v1 = this.cbu_dist(selI, j, vvDist);
                    let v2 = this.cbu_dist(selJ, j, vvDist);
                    if(count < j) vvDist[count][j] = (v1 < v2) ? v1 : v2;
                    else vvDist[j][count] = (v1 < v2) ? v1 : v2;
                }

                // assign the connected nodes with maxDist
                for(j = 0; j < 2*n - 1; ++j) {
                    if(selI < j) vvDist[selI][j] = maxDist;
                    else vvDist[j][selI] = maxDist;

                    if(selJ < j) vvDist[selJ][j] = maxDist;
                    else vvDist[j][selJ] = maxDist;
                }

                let factor = 4; // 2-4 fold more chains/alignments
                if(cumul[selI].leaves.length < factor * nChain && cumul[selJ].leaves.length < factor * nChain) {
                    cumul[count].leaves = [];
                    
                    for(let i = 0, il = cumul[selI].leaves.length; i < il; ++i) {
                        for(let j = 0, jl = cumul[selJ].leaves.length; j < jl; ++j) {
                            // let nodeI = cumul[selI].leaves[i][0];
                            // let nodeJ = cumul[selJ].leaves[j][0];

                            // skip non-similar alignments
                            // if(cumul[selI].dist > threshold) {
                            //     cumul[count].leaves.push(cumul[selJ].leaves[j]);
                            // } else if(cumul[selJ].dist > threshold) {
                            //     cumul[count].leaves = [];
                            // }
                            // else {
                                
                                // if(this.compareFloat(cumul, nodeI, nodeJ) == 0) {
                                //     cumul[count].leaves.push(cumul[selI].leaves[i].concat(cumul[selJ].leaves[j]));
                                //     cumul[count].leaves.push(cumul[selJ].leaves[j].concat(cumul[selI].leaves[i]));
                                // }
                                // else if(this.compareFloat(cumul, nodeI, nodeJ) == -1) {
                                //     cumul[count].leaves.push(cumul[selI].leaves[i].concat(cumul[selJ].leaves[j]));
                                // }
                                // else if(this.compareFloat(cumul, nodeI, nodeJ) == 1) {
                                //     cumul[count].leaves.push(cumul[selJ].leaves[j].concat(cumul[selI].leaves[i]));
                                // }

                                cumul[count].leaves.push(cumul[selI].leaves[i].concat(cumul[selJ].leaves[j]));
                                cumul[count].leaves.push(cumul[selJ].leaves[j].concat(cumul[selI].leaves[i]));

                            // }
                        }
                    }

                    cumul[selI].leaves = [];
                    cumul[selJ].leaves = [];
                }
                
                // update mNearestNB and mNearestNBDist
                delete mNearestNB[selI];
                delete mNearestNB[selJ];

                delete mNearestNBDist[selI];
                delete mNearestNBDist[selJ];

                // replace previous node with the new merged one
                mNearestNBCopy = me.hashUtilsCls.cloneHash(mNearestNB);
                for(oriNode in mNearestNBCopy) {
                    if(mNearestNBCopy[oriNode] == selI || mNearestNBCopy[oriNode] == selJ) {
                        delete mNearestNB[oriNode];
                        mNearestNB[oriNode] = count;
                    }
                }

                // calculate the nearest neighbor of the current node
                let selNode = 2*n;
                distTmp = maxDist;
                for(j = 0; j < 2*n - 1; ++j) {
                    if(j != count && this.cbu_dist(count, j, vvDist) < distTmp) {
                        distTmp = this.cbu_dist(count, j, vvDist);
                        selNode = j;
                    }
                }

                mNearestNB[count] = selNode;
                mNearestNBDist[count] = distTmp;
            }

            if (count == 2*n - 1) {
                cumul[count-1].parent = CBU_ROOT;
                cumul[count-1].dist = 0.0;
            }

            return cumul;
        }

        GetChainMappings(m_clusteringResult, chainidpairArray) { let ic = this.icn3d; ic.icn3dui;
            let mappings = [];
            chainidpairArray.length;
            let chain1a, chain2a;
        
            let result = this.getClusters(m_clusteringResult, true);
            //let clusterScores = result.scores;
            let clusters = result.clusters;
            let nClusters = clusters.length;

            for(let i = 0; i < nClusters; ++i) {
                //isClusterOk = true;       

                let leavesArray = clusters[i];        
                for(let j = 0, jl = leavesArray.length; j < jl; ++j) {
                    let bucm = {};
                    //bucm.score = clusterScores[i];
                    bucm.nodeArray = [];
      
                    let chainSet1 = {}, chainSet2 = {};

                    for(let k = 0, kl = leavesArray[j].length; k < kl; ++k) {
                        let node1 = leavesArray[j][k];

                        // if (node < nQpAligns) {
                            let chainArray1 = chainidpairArray[node1].split(',');
                            chain1a = chainArray1[0];
                            chain2a = chainArray1[1];
                            
                            // if (chainSet1.hasOwnProperty(chain1)) continue;
                            if (chainSet1.hasOwnProperty(chain1a) || chainSet2.hasOwnProperty(chain2a)) continue;
                            
                            bucm.nodeArray.push(node1.toString().padStart(5, '0'));
                
                            chainSet1[chain1a] = 1;
                            chainSet2[chain2a] = 1;
                        // } 
                        // else {
                        //     isClusterOk = false;
                        //     console.log("Skipping cluster");
                        //     break;
                        // }
                    }
            
                    //if (isClusterOk) {
                        mappings.push(bucm);
                    //}
                }           
            }
            
            return mappings;
        }
        
        getClusters(tree, includeSingletons) { let ic = this.icn3d; ic.icn3dui;
            let clusters = [], scores = [];
            let i = 0, n = tree.length;
            let minClusterSize = (includeSingletons) ? 0 : 1;
        
            for (; i < n; ++i) {
                if (tree[i].leaves.length > minClusterSize) {
                    clusters.push(tree[i].leaves);
                    scores.push(tree[i].dist);
                }
            }

            return {"clusters": clusters, "scores": scores};
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class ApplyCommand {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Execute a command. If the command is to load a structure, use the Method "applyCommandLoad".
        async applyCommand(commandStr) { let ic = this.icn3d, me = ic.icn3dui;
          ic.bAddCommands = false;

          let commandTransformation = commandStr.split('|||');
          let commandTransformation2 = commandTransformation[0].split('%7C%7C%7C'); // sometimes encoded transformation is also included

          let commandOri = commandTransformation2[0].replace(/\s+/g, ' ').trim();
          let command = commandOri.toLowerCase();

        // exact match =============
          //var file_pref =(ic.inputid) ? ic.inputid : "custom";
          if(command == 'share link') {
            await ic.shareLinkCls.shareLink();
          }
          else if(command == 'export state file') ;
          else if(command.indexOf('export canvas') == 0) {
            setTimeout(async function(){
                   //ic.saveFileCls.saveFile(file_pref + '_icn3d_loadable.png', 'png');
                   let scaleStr = command.substr(13).trim();
                   ic.scaleFactor = (scaleStr === '') ? 1 : parseInt(scaleStr);
                   let bPngOnly = (scaleStr === '') ? false : true;
                   await ic.shareLinkCls.shareLink(true, bPngOnly);
                }, 500);
          }
          else if(command == 'export interactions') {
            ic.viewInterPairsCls.exportInteractions();
          }
          else if(command == 'export stl file') {
            setTimeout(function(){
                   ic.export3DCls.exportStlFile('');
                }, 500);
          }
          else if(command == 'export vrml file') {
            setTimeout(function(){
                   ic.export3DCls.exportVrmlFile('');
                }, 500);
          }
          else if(command == 'export stl stabilizer file') {
            setTimeout(function(){
                   ic.threeDPrintCls.hideStabilizer();
                   ic.threeDPrintCls.resetAfter3Dprint();
                   ic.threeDPrintCls.addStabilizer();

                   ic.export3DCls.exportStlFile('_stab');
                }, 500);
          }
          else if(command == 'export vrml stabilizer file') {
            setTimeout(function(){
                   ic.threeDPrintCls.hideStabilizer();
                   ic.threeDPrintCls.resetAfter3Dprint();
                   ic.threeDPrintCls.addStabilizer();

                   ic.export3DCls.exportVrmlFile('_stab');
                }, 500);
          }
          else if(command == 'export pdb') {
             me.htmlCls.setHtmlCls.exportPdb();
          }
          else if(command == 'export pdb missing atoms') {
            await ic.scapCls.exportPdbProfix(false);
          }
          else if(command == 'export pdb hydrogen') {
            await ic.scapCls.exportPdbProfix(true);
          }
          else if(command.indexOf('export refnum ') != -1) {
            let type = command.substr(14);
            
            ic.refnumCls.exportRefnum(type);
          }
          else if(command == 'export secondary structure') {
             me.htmlCls.setHtmlCls.exportSecondary();
          }
          else if(command == 'select all') {
             ic.selectionCls.selectAll();
             //ic.hlObjectsCls.addHlObjects();
          }
          else if(command == 'show all') {
             ic.selectionCls.showAll();
          }
          else if(command == 'select complement') {
             ic.resid2specCls.selectComplement();
          }
          else if(command == 'set pk atom') {
            ic.pk = 1;
            ic.opts['pk'] = 'atom';
          }
          else if(command == 'set pk off') {
            ic.pk = 0;
            ic.opts['pk'] = 'no';
            ic.drawCls.draw();
            ic.hlObjectsCls.removeHlObjects();
          }
          else if(command == 'set pk residue') {
            ic.pk = 2;
            ic.opts['pk'] = 'residue';
          }
          else if(command == 'set pk strand') {
            ic.pk = 3;
            ic.opts['pk'] = 'strand';
          }
          else if(command == 'set pk domain') {
            ic.pk = 4;
            ic.opts['pk'] = 'domain';
          }
          else if(command == 'set pk chain') {
            ic.pk = 5;
            ic.opts['pk'] = 'chain';
          }
          else if(command == 'set surface wireframe on') {
            ic.opts['wireframe'] = 'yes';
            ic.applyMapCls.applySurfaceOptions();
          }
          else if(command == 'set surface wireframe off') {
            ic.opts['wireframe'] = 'no';
            ic.applyMapCls.applySurfaceOptions();
          }
          else if(command == 'set map wireframe on') {
            ic.opts['mapwireframe'] = 'yes';
            ic.applyMapCls.applyMapOptions();
          }
          else if(command == 'set map wireframe off') {
            ic.opts['mapwireframe'] = 'no';
            ic.applyMapCls.applyMapOptions();
          }
          else if(command == 'set emmap wireframe on') {
            ic.opts['emmapwireframe'] = 'yes';
            ic.applyMapCls.applyEmmapOptions();
          }
          else if(command == 'set emmap wireframe off') {
            ic.opts['emmapwireframe'] = 'no';
            ic.applyMapCls.applyEmmapOptions();
          }
          else if(command == 'set surface neighbors on') {
            ic.bConsiderNeighbors = true;
            ic.applyMapCls.applySurfaceOptions();
          }
          else if(command == 'set surface neighbors off') {
            ic.bConsiderNeighbors = false;
            ic.applyMapCls.applySurfaceOptions();
          }
          else if(command == 'set axis on') {
            ic.opts['axis'] = 'yes';
          }
          else if(command == 'set pc1 axis') {
            ic.pc1 = true;
            ic.axesCls.setPc1Axes();
          }
          else if(command == 'set axis off') {
            ic.opts['axis'] = 'no';
            ic.pc1 = false;
          }
          else if(command == 'set fog on') {
            ic.opts['fog'] = 'yes';
            ic.fogCls.setFog(true);
          }
          else if(command == 'set fog off') {
            ic.opts['fog'] = 'no';
            ic.fogCls.setFog(true);
          }
          else if(command == 'set slab on') {
            ic.opts['slab'] = 'yes';
          }
          else if(command == 'set slab off') {
            ic.opts['slab'] = 'no';
          }
          else if(command == 'stereo on') {
            ic.opts['effect'] = 'stereo';
          }
          else if(command == 'stereo off') {
            ic.opts['effect'] = 'none';
          }
          else if(command == 'set assembly on') {
            ic.bAssembly = true;
          }
          else if(command == 'set assembly off') {
            ic.bAssembly = false;
          }
          else if(command == 'set chemicalbinding show') {
            ic.setOptionCls.setOption('chemicalbinding', 'show');
          }
          else if(command == 'set chemicalbinding hide') {
            ic.setOptionCls.setOption('chemicalbinding', 'hide');
          }
          else if(command == 'set hbonds off') {
            ic.hBondCls.hideHbonds();
            ic.showInterCls.hideExtraBonds();
            ic.drawCls.draw();
          }
          else if(command == 'set salt bridge off') {
            ic.saltbridgeCls.hideSaltbridge();
            ic.showInterCls.hideExtraBonds();
            ic.drawCls.draw();
          }
          else if(command == 'set contact off') {
            ic.contactCls.hideContact();
            ic.showInterCls.hideExtraBonds();
            ic.drawCls.draw();
          }
          else if(command == 'set halogen pi off') {
            ic.piHalogenCls.hideHalogenPi();
            ic.showInterCls.hideExtraBonds();
            ic.drawCls.draw();
          }

          else if(command == 'hydrogens') {
            ic.showInterCls.showHydrogens();
            ic.drawCls.draw();
          }
          else if(command == 'set hydrogens off') {
            ic.showInterCls.hideHydrogens();
            ic.drawCls.draw();
          }
          else if(command == 'close popup') {
              ic.resizeCanvasCls.closeDialogs();
          }
          else if(command == 'set stabilizer off') {
            ic.threeDPrintCls.hideStabilizer();
            ic.drawCls.draw();
          }
          else if(command == 'set disulfide bonds off') {
            ic.opts["ssbonds"] = "no";
            ic.drawCls.draw();
          }
          else if(command == 'set cross linkage off') {
            //ic.bShowCrossResidueBond = false;
            //ic.setOptionCls.setStyle('proteins', 'ribbon');

            ic.opts["clbonds"] = "no";
            ic.drawCls.draw();
          }
          else if(command == 'set lines off') {
            ic.labels['distance'] = [];
            ic.lines['distance'] = [];

            ic.drawCls.draw();
          }
          else if(command == 'set labels off') {
            //ic.labels['residue'] = [];
            //ic.labels['custom'] = [];

            for(let name in ic.labels) {
               //if(name === 'residue' || name === 'custom') {
                   ic.labels[name] = [];
               //}
            }

            ic.drawCls.draw();
          }
          else if(command == 'set mode all') {
             ic.definedSetsCls.setModeAndDisplay('all');
          }
          else if(command == 'set mode selection') {
             ic.definedSetsCls.setModeAndDisplay('selection');
          }
          else if(command == 'set view detailed view') {
             ic.annotationCls.setAnnoViewAndDisplay('detailed view');
          }
          else if(command == 'set view overview') {
             ic.annotationCls.setAnnoViewAndDisplay('overview');
          }
          else if(command == 'set annotation custom') {
              ic.annotationCls.setAnnoTabCustom();
          }
          else if(command == 'set annotation interaction') {
              ic.annotationCls.setAnnoTabInteraction();
          }
          else if(command == 'set annotation ptm') {
            await ic.annotationCls.setAnnoTabPTM();
          }
          else if(command == 'set annotation cdd') {
              ic.annotationCls.setAnnoTabCdd();
          }
          else if(command == 'set annotation site') {
              ic.annotationCls.setAnnoTabSite();
          }
          else if(command == 'set annotation ssbond') {
              ic.annotationCls.setAnnoTabSsbond();
          }
          else if(command == 'set annotation crosslink') {
              ic.annotationCls.setAnnoTabCrosslink();
          }
          else if(command == 'set annotation transmembrane') {
              await ic.annotationCls.setAnnoTabTransmem();
          }
          else if(command == 'set annotation ig') {
              ic.bRunRefnumAgain = true;
              await ic.annotationCls.setAnnoTabIg();
              ic.bRunRefnumAgain = false;
          }
          else if(command == 'ig refnum on') {
            ic.bRunRefnumAgain = true;

            if(!ic.bAnnoShown) await ic.showAnnoCls.showAnnotations();
            await ic.annotationCls.setAnnoTabIg(true);

            ic.bRunRefnumAgain = false;
        }
          else if(command == 'highlight level up') {
              ic.resid2specCls.switchHighlightLevelUp();
          }
          else if(command == 'highlight level down') {
              ic.resid2specCls.switchHighlightLevelDown();
          }
          else if(command.indexOf('hide annotation') == 0) {
              let pos = command.lastIndexOf(' ');
              let type = command.substr(pos + 1);

              if(type == 'all') {
                  ic.annotationCls.hideAnnoTabAll();
              }
              else if(type == 'custom') {
                  ic.annotationCls.hideAnnoTabCustom();
              }
              else if(type == 'clinvar') {
                  ic.annotationCls.hideAnnoTabClinvar();
              }
              else if(type == 'snp') {
                  ic.annotationCls.hideAnnoTabSnp();
              }
              else if(type == 'cdd') {
                  ic.annotationCls.hideAnnoTabCdd();
              }
              else if(type == '3ddomain') {
                  ic.annotationCls.hideAnnoTab3ddomain();
              }
              else if(type == 'site') {
                  ic.annotationCls.hideAnnoTabSite();
              }
              else if(type == 'ptm') {
                ic.annotationCls.hideAnnoTabPTM();
            }
              else if(type == 'interaction') {
                  ic.annotationCls.hideAnnoTabInteraction();
              }
              else if(type == 'ssbond') {
                  ic.annotationCls.hideAnnoTabSsbond();
              }
              else if(type == 'crosslink') {
                  ic.annotationCls.hideAnnoTabCrosslink();
              }
              else if(type == 'transmembrane') {
                  ic.annotationCls.hideAnnoTabTransmem();
              }
          }
          else if(command == 'add residue labels') {
            ic.residueLabelsCls.addResidueLabels(ic.hAtoms);

            ic.drawCls.draw();
          }
          else if(command == 'add residue number labels') {
            ic.residueLabelsCls.addResidueLabels(ic.hAtoms, undefined, undefined, true);

            ic.drawCls.draw();
          }
          else if(command == 'add reference number labels') {
            ic.residueLabelsCls.addResidueLabels(ic.hAtoms, undefined, undefined, undefined, true);

            ic.drawCls.draw();
          }
          else if(command == 'add ig labels') {
            ic.residueLabelsCls.addIgLabels(ic.hAtoms);

            ic.drawCls.draw();
          }
          else if(command == 'add atom labels') {
            ic.residueLabelsCls.addAtomLabels(ic.hAtoms);

            ic.drawCls.draw();
          }
          else if(command == 'add element labels') {
            ic.residueLabelsCls.addAtomLabels(ic.hAtoms, true);

            ic.drawCls.draw();
          }
          else if(command == 'add chain labels') {
            ic.analysisCls.addChainLabels(ic.hAtoms);

            ic.drawCls.draw();
          }
          else if(command == 'add terminal labels') {
            ic.analysisCls.addTerminiLabels(ic.hAtoms);

            ic.drawCls.draw();
          }
          else if(command == 'rotate left') {
             ic.bStopRotate = false;
             ic.ROT_DIR = 'left';
             ic.transformCls.rotateCountMax = 6000;

             ic.resizeCanvasCls.rotStruc('left');
          }
          else if(command == 'rotate right') {
             ic.bStopRotate = false;
             ic.ROT_DIR = 'right';
             ic.transformCls.rotateCountMax = 6000;

             ic.resizeCanvasCls.rotStruc('right');
          }
          else if(command == 'rotate up') {
             ic.bStopRotate = false;
             ic.ROT_DIR = 'up';
             ic.transformCls.rotateCountMax = 6000;

             ic.resizeCanvasCls.rotStruc('up');
          }
          else if(command == 'rotate down') {
             ic.bStopRotate = false;
             ic.ROT_DIR = 'down';
             ic.transformCls.rotateCountMax = 6000;

             ic.resizeCanvasCls.rotStruc('down');
          }
          else if(command == 'rotate x') {
              let axis = new THREE.Vector3(1,0,0);
              let angle = 0.5 * Math.PI;

              ic.transformCls.setRotation(axis, angle);
          }
          else if(command == 'rotate y') {
              let axis = new THREE.Vector3(0,1,0);
              let angle = 0.5 * Math.PI;

              ic.transformCls.setRotation(axis, angle);
          }
          else if(command == 'rotate z') {
              let axis = new THREE.Vector3(0,0,1);
              let angle = 0.5 * Math.PI;

              ic.transformCls.setRotation(axis, angle);
          }
          else if(command === 'reset') {
              ic.selectionCls.resetAll();
          }
          else if(command === 'reset orientation') {
            ic.transformCls.resetOrientation();
            ic.drawCls.draw();
          }
          else if(command == 'reset thickness') {
            ic.threeDPrintCls.resetAfter3Dprint();
            ic.drawCls.draw();
          }
          else if(command == 'clear selection') {
            ic.hlObjectsCls.removeHlObjects();
            ic.hlUpdateCls.removeHl2D();
            // !!!ic.bShowHighlight = false;

            ic.bSelectResidue = false;
          }
          else if(command == 'zoom selection') {
            ic.transformCls.zoominSelection();
            ic.drawCls.draw();
          }
          else if(command == 'center selection') {
            ic.applyCenterCls.centerSelection();
            ic.drawCls.draw();
          }
          else if(command == 'show selection') {
            ic.selectionCls.showSelection();
          }
          else if(command == 'hide selection') {
            ic.selectionCls.hideSelection();
          }
          else if(command == 'output selection') {
              ic.threeDPrintCls.outputSelection();
          }
          else if(command == 'toggle selection') {
             ic.selectionCls.toggleSelection();
          }
          else if(command == 'toggle highlight') {
            ic.hlUpdateCls.toggleHighlight();
          }
          else if(command == 'stabilizer') {
            ic.threeDPrintCls.addStabilizer();

            ic.threeDPrintCls.prepareFor3Dprint();
            //ic.drawCls.draw();
          }
          else if(command == 'disulfide bonds') {
            ic.showInterCls.showSsbonds();
          }
          else if(command == 'cross linkage') {
            ic.showInterCls.showClbonds();
          }
          else if(command == 'back') {
            await ic.resizeCanvasCls.back();
          }
          else if(command == 'forward') {
            await ic.resizeCanvasCls.forward();
          }
          else if(command == 'clear all') {
             ic.selectionCls.selectAll();
          }
          else if(command == 'defined sets') {
             ic.definedSetsCls.showSets();
             ic.bDefinedSets = true;
          }
          else if(command == 'delete selected sets') {
             ic.definedSetsCls.deleteSelectedSets();
          }
          else if(command == 'view interactions') {
             if(me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined) {
                 ic.ParserUtilsCls.set2DDiagrams(ic.inputid);
             }
          }
          else if(command == 'show annotations all chains') {
             ic.annotationCls.showAnnoAllChains();
          }

          else if(command == 'save color') {
             ic.setOptionCls.saveColor();
          }
          else if(command == 'apply saved color') {
             ic.setOptionCls.applySavedColor();
          }
          else if(command == 'save style') {
             ic.setOptionCls.saveStyle();
          }
          else if(command == 'apply saved style') {
             ic.setOptionCls.applySavedStyle();
          }
          else if(command == 'select main chains') {
             ic.selectionCls.selectMainChains();
          }
          else if(command == 'select side chains') {
             ic.selectionCls.selectSideChains();
          }
          else if(command == 'select main side chains') {
             ic.selectionCls.selectMainSideChains();
          }
          else if(command == 'realign') {
             ic.realignParserCls.realign();
          }
          else if(command.indexOf('realign predefined ') != -1) {
            //e.g., realign predefined 1HHO_A,4M7N_A 1,5,10-50 | 1,5,10-50: 2,6,11-51 | 1,5,10-50
            let str = 'realign predefined ';
            let chainids_resdef = commandOri.substr(str.length);
            let pos = chainids_resdef.indexOf(' ');
            let chainidArray = chainids_resdef.substr(0, pos).split(',');
            me.cfg.resdef = chainids_resdef.substr(pos + 1).replace(/:/gi, ';'); // should be 1,5,10-50 | 1,5,10-50; 2,6,11-51 | 1,5,10-50

            await ic.realignParserCls.realignChainOnSeqAlign(undefined, chainidArray, true, true);
         }
          else if(command == 'area') {
             ic.analysisCls.calculateArea();
          }
          else if(command == 'table inter count only') {
             $(".icn3d-border").hide();
          }
          else if(command == 'table inter details') {
             $(".icn3d-border").show();
          }
          else if(command == 'setoption map nothing') {
             ic.setOptionCls.setOption('map', 'nothing');
          }
          else if(command == 'setoption emmap nothing') {
             ic.setOptionCls.setOption('emmap', 'nothing');
          }
          else if(command == 'setoption phimap nothing') {
             ic.setOptionCls.setOption('phimap', 'nothing');
          }
          else if(command == 'setoption phisurface nothing') {
             ic.setOptionCls.setOption('phisurface', 'nothing');
          }
          else if(command == 'clear symd symmetry') {
             ic.symdArray = [];
          }
          else if(command == 'show axis') {
             ic.bAxisOnly = true;
          }

        // start with =================
          else if(commandOri.indexOf('define helix sets') == 0) {
             let chainStr = commandOri.split(' | ')[1];
             let chainid = chainStr.split(' ')[1];

             ic.addTrackCls.defineSecondary(chainid, 'helix');
          }
          else if(commandOri.indexOf('define sheet sets') == 0) {
             let chainStr = commandOri.split(' | ')[1];
             let chainid = chainStr.split(' ')[1];

             ic.addTrackCls.defineSecondary(chainid, 'sheet');
          }
          else if(commandOri.indexOf('define coil sets') == 0) {
             let chainStr = commandOri.split(' | ')[1];
             let chainid = chainStr.split(' ')[1];

             ic.addTrackCls.defineSecondary(chainid, 'coil');
          }
          else if(commandOri.indexOf('define iganchor sets') == 0) {
            let chainStr = commandOri.split(' | ')[1];
            let chainid = chainStr.split(' ')[1];

            ic.addTrackCls.defineIgstrand(chainid, 'iganchor');
          }
          else if(commandOri.indexOf('define igstrand sets') == 0) {
            let chainStr = commandOri.split(' | ')[1];
            let chainid = chainStr.split(' ')[1];

            ic.addTrackCls.defineIgstrand(chainid, 'igstrand');
          }
          else if(commandOri.indexOf('define igloop sets') == 0) {
            let chainStr = commandOri.split(' | ')[1];
            let chainid = chainStr.split(' ')[1];

            ic.addTrackCls.defineIgstrand(chainid, 'igloop');
          }
          else if(commandOri.indexOf('select interaction') == 0) {
            let idArray = commandOri.substr(commandOri.lastIndexOf(' ') + 1).split(',');
            if(idArray !== null) {
                let mmdbid = idArray[0].split('_')[0];
                if(!ic.b2DShown) ic.ParserUtilsCls.download2Ddgm(mmdbid.toUpperCase());

                ic.diagram2dCls.selectInteraction(idArray[0], idArray[1]);
            }
          }

          else if(commandOri.indexOf('select saved atoms') == 0 || commandOri.indexOf('select sets') == 0) {
            // backward compatible: convert previous aligned_protein to protein_aligned
            commandOri = commandOri.replace(/aligned_protein/g, 'protein_aligned');

            // define chains
            if(!ic.bDefinedSets) {
              ic.definedSetsCls.setPredefinedInMenu();
              ic.bDefinedSets = true;
            }

            let paraArray = commandOri.split(' | '); // atom names might be case-sensitive

            let select = paraArray[0].replace(/,/g, ' or ');

            let pos = 19; // 'select saved atoms '
            if(commandOri.indexOf('select sets') == 0) pos = 12; // 'select sets '

            let strSets = select.substr(pos);
            
            let commandname = strSets;

            if(paraArray.length == 2) commandname = paraArray[1].substr(5); // 'name ...'
            ic.definedSetsCls.selectCombinedSets(strSets, commandname);
          }
          else if(commandOri.indexOf('select chain') !== -1) {
            let idArray = commandOri.substr(commandOri.lastIndexOf(' ') + 1).split(',');

            //if(idArray !== null) ic.changeChainid(idArray);
            for(let i = 0, il = idArray.length; i < il; ++i) {
                ic.selectionCls.selectAChain(idArray[i], idArray[i], false);
            }
          }
          else if(commandOri.indexOf('select alignChain') !== -1) {
            let idArray = commandOri.substr(commandOri.lastIndexOf(' ') + 1).split(',');

            //if(idArray !== null) ic.changeChainid(idArray);
            for(let i = 0, il = idArray.length; i < il; ++i) {
                ic.selectionCls.selectAChain(idArray[i], 'align_' + idArray[i], true);
            }
          }
          else if(commandOri.indexOf('select zone cutoff') == 0) {
            let ret = this.getThresholdNameArrays(commandOri);

            ic.showInterCls.pickCustomSphere(ret.threshold, ret.nameArray2, ret.nameArray, ret.bHbondCalc);
            ic.bSphereCalc = true;

            //ic.hlUpdateCls.updateHlAll();
          }
          else if(command.indexOf('set surface opacity') == 0) {
            ic.transparentRenderOrder = false;

            let value = command.substr(command.lastIndexOf(' ') + 1);
            ic.opts['opacity'] = parseFloat(value);
            ic.applyMapCls.applySurfaceOptions();

            if(parseInt(100*value) < 100) ic.bTransparentSurface = true;
          }
          else if(command.indexOf('set surface2 opacity') == 0) {
            ic.transparentRenderOrder = true;
            let value = command.substr(command.lastIndexOf(' ') + 1);
            ic.opts['opacity'] = parseFloat(value);
            ic.applyMapCls.applySurfaceOptions();

            if(parseInt(100*value) < 100) ic.bTransparentSurface = true;
          }
          else if(command.indexOf('set label scale') == 0) {
            let value = command.substr(command.lastIndexOf(' ') + 1);
            ic.labelScale = parseFloat(value);
          }
          else if(command.indexOf('set surface') == 0) {
            let value = command.substr(12);

            ic.opts['surface'] = value;
            ic.applyMapCls.applySurfaceOptions();
          }
          else if(command.indexOf('set camera') == 0) {
            let value = command.substr(command.lastIndexOf(' ') + 1);
            ic.opts['camera'] = value;
          }
          else if(command.indexOf('set background') == 0) {
            let value = command.substr(command.lastIndexOf(' ') + 1);
            ic.opts['background'] = value;

            if(value == 'black') {
              $("#" + ic.pre + "title").css("color", me.htmlCls.GREYD);
              $("#" + ic.pre + "titlelink").css("color", me.htmlCls.GREYD);
            }
            else {
              $("#" + ic.pre + "title").css("color", "black");
              $("#" + ic.pre + "titlelink").css("color", "black");
            }
          }
          else if(command.indexOf('set label color') == 0) {
            ic.labelcolor = command.substr(command.lastIndexOf(' ') + 1);
          }
          else if(commandOri.indexOf('set thickness') == 0) {
            let paraArray = command.split(' | ');

            ic.bSetThickness = true;

            for(let i = 1, il = paraArray.length; i < il; ++i) {
                let p1Array = paraArray[i].split(' ');

                let para = p1Array[0];
                let value = parseFloat(p1Array[1]);

                if(para == 'linerad' && !isNaN(value)) ic.lineRadius = value;
                if(para == 'coilrad' && !isNaN(value)) ic.coilWidth = value;
                if(para == 'stickrad' && !isNaN(value)) ic.cylinderRadius = value;
                if(para == 'crosslinkrad' && !isNaN(value)) ic.crosslinkRadius = value;
                if(para == 'tracerad' && !isNaN(value)) ic.traceRadius = value;
                if(para == 'ballscale' && !isNaN(value)) ic.dotSphereScale = value;

                if(para == 'ribbonthick' && !isNaN(value)) ic.ribbonthickness = value;
                if(para == 'proteinwidth' && !isNaN(value)) ic.helixSheetWidth = value;
                if(para == 'nucleotidewidth' && !isNaN(value)) ic.nucleicAcidWidth = value;
            }

            ic.drawCls.draw();
          }
          else if(commandOri.indexOf('set light') == 0) {
            let paraArray = command.split(' | ');

            for(let i = 1, il = paraArray.length; i < il; ++i) {
                let p1Array = paraArray[i].split(' ');

                let para = p1Array[0];
                let value = parseFloat(p1Array[1]);

                if(para == 'light1') ic.light1 = value;
                if(para == 'light2') ic.light2 = value;
                if(para == 'light3') ic.light3 = value;
            }

            ic.drawCls.draw();
          }
          else if(commandOri.indexOf('set shininess') == 0) {
            let pos = command.lastIndexOf(' ');

            ic.shininess = parseFloat(command.substr(pos + 1));

            ic.drawCls.draw();
          }
          else if(commandOri.indexOf('set glycan') == 0) {
            let pos = command.lastIndexOf(' ');

            ic.bGlycansCartoon = parseInt(command.substr(pos + 1));

            ic.drawCls.draw();
          }
          else if(commandOri.indexOf('set membrane') == 0) {
            let pos = command.lastIndexOf(' ');

            ic.bMembrane = parseInt(command.substr(pos + 1));

            ic.drawCls.draw();
          }
          else if(commandOri.indexOf('set cmdwindow') == 0) {
            let pos = command.lastIndexOf(' ');

            let bCmdWindow = parseInt(command.substr(pos + 1));
            me.htmlCls.setMenuCls.setLogWindow(true, bCmdWindow);
          }
          else if(command.indexOf('set highlight color') == 0) {
               let color = command.substr(20);
               if(color === 'yellow') {
                   ic.hColor = me.parasCls.thr(0xFFFF00);
                   ic.matShader = ic.setColorCls.setOutlineColor('yellow');
               }
               else if(color === 'green') {
                   ic.hColor = me.parasCls.thr(0x00FF00);
                   ic.matShader = ic.setColorCls.setOutlineColor('green');
               }
               else if(color === 'red') {
                   ic.hColor = me.parasCls.thr(0xFF0000);
                   ic.matShader = ic.setColorCls.setOutlineColor('red');
               }
               ic.drawCls.draw(); // required to make it work properly
          }
          else if(command.indexOf('set highlight style') == 0) {
                let style = command.substr(20);

               if(style === 'outline') {
                   ic.bHighlight = 1;
               }
               else if(style === '3d') {
                   ic.bHighlight = 2;
               }

               ic.drawCls.draw();
          }
          else if(command.indexOf('add line') == 0) {
            let paraArray = command.split(' | ');
            let p1Array = paraArray[1].split(' ');
            let p2Array = paraArray[2].split(' ');
            let color = paraArray[3].substr(paraArray[3].lastIndexOf(' ') + 1);
            let dashed = paraArray[4].substr(paraArray[4].lastIndexOf(' ') + 1) === 'true' ? true : false;
            let type = paraArray[5].substr(paraArray[5].lastIndexOf(' ') + 1);
            let radius = (paraArray.length > 6) ? paraArray[6].substr(paraArray[6].lastIndexOf(' ') + 1) : 0;
            let opacity = (paraArray.length > 7) ? paraArray[7].substr(paraArray[7].lastIndexOf(' ') + 1) : 1.0;

            ic.analysisCls.addLine(parseFloat(p1Array[1]), parseFloat(p1Array[3]), parseFloat(p1Array[5]), parseFloat(p2Array[1]), parseFloat(p2Array[3]), parseFloat(p2Array[5]), color, dashed, type, parseFloat(radius), parseFloat(opacity));
            ic.drawCls.draw();
          }
          else if(command.indexOf('add sphere') == 0) {
            this.addShape(commandOri, 'sphere');
            ic.shapeCmdHash[commandOri] = 1;
            //ic.drawCls.draw();
          }
          else if(command.indexOf('add cube') == 0) {
            this.addShape(commandOri, 'cube');
            ic.shapeCmdHash[commandOri] = 1;
            //ic.drawCls.draw();
          }
          else if(command.indexOf('clear shape') == 0) {
            ic.shapeCmdHash = {};
            //ic.drawCls.draw();
          }
          else if(command.indexOf('clear line between sets') == 0) {
            ic.lines['cylinder'] = []; // reset
            //ic.drawCls.draw();
          }
          else if(commandOri.indexOf('add label') == 0) {
            let paraArray = commandOri.split(' | ');
            let text = paraArray[0].substr(('add label').length + 1);

            // add label Text | x 40.45 y 24.465000000000003 z 53.48 | size 40 | color #ffff00 | background #cccccc | type custom
            let x,y,z, size, color, background, type;
            let bPosition = false;
            for(let i = 1, il = paraArray.length; i < il; ++i) {
                let wordArray = paraArray[i].split(' ');
                if(wordArray[0] == 'x') {
                    bPosition = true;
                    x = parseFloat(wordArray[1]);
                    y = parseFloat(wordArray[3]);
                    z = parseFloat(wordArray[5]);
                }
                else if(wordArray[0] == 'size') {
                    size = paraArray[i].substr(paraArray[i].lastIndexOf(' ') + 1);
                }
                else if(wordArray[0] == 'color') {
                    color = paraArray[i].substr(paraArray[i].lastIndexOf(' ') + 1);
                }
                else if(wordArray[0] == 'background') {
                    background = paraArray[i].substr(paraArray[i].lastIndexOf(' ') + 1);
                }
                else if(wordArray[0] == 'type') {
                    type = paraArray[i].substr(paraArray[i].lastIndexOf(' ') + 1);
                }
            }

            if(!bPosition) {
              let position = ic.applyCenterCls.centerAtoms(me.hashUtilsCls.hash2Atoms(ic.hAtoms, ic.atoms));
              x = parseFloat(position.center.x);
              y = parseFloat(position.center.y);
              z = parseFloat(position.center.z);
            }

            ic.analysisCls.addLabel(text, x,y,z, size, color, background, type);
            ic.drawCls.draw();
          }
          else if(commandOri.indexOf('msa') == 0) {
              //"msa | " + JSON.stringify(ic.targetGapHash)
              let paraArray = commandOri.split(' | ');

              let pos_from_toArray = paraArray[1].split(' ');

              ic.targetGapHash = {};
              for(let i = 0, il = pos_from_toArray.length; i < il; ++i) {
                  let pos_from_to = pos_from_toArray[i].split('_');
                  ic.targetGapHash[parseInt(pos_from_to[0])] = {"from": parseInt(pos_from_to[1]), "to": parseInt(pos_from_to[2])};
              }

              await ic.annotationCls.resetAnnoAll();
          }
          else if(commandOri.indexOf('add track') == 0) {
              //"add track | chainid " + chainid + " | title " + title + " | text " + text
              // + " | type " + type + " | color " + color + " | msa " + color
              let paraArray = commandOri.split(' | ');

              let chainid = paraArray[1].substr(8);
              let title = paraArray[2].substr(6);
              let text = paraArray[3].substr(5);
              let type;
              if(paraArray.length >= 5) type = paraArray[4].substr(5);
              let color;
              if(paraArray.length >= 6) color = paraArray[5].substr(6);
              let msa;
              if(paraArray.length >= 7) msa = paraArray[6].substr(4);

              if($("#" + ic.pre + "anno_custom")[0]) {
                $("#" + ic.pre + "anno_custom")[0].checked = true;
              }
              $("[id^=" + ic.pre + "custom]").show();

              if(color == '0') color = undefined;

              ic.addTrackCls.checkGiSeq(chainid, title, text, type, color, msa, 0);
          }
          else if(command.indexOf('remove one stabilizer') == 0) {
            let paraArray = command.split(' | ');
            let p1Array = paraArray[1].split(' ');

            let rmLineArray = [];
            rmLineArray.push(parseInt(p1Array[0]));
            rmLineArray.push(parseInt(p1Array[1]));

            ic.threeDPrintCls.removeOneStabilizer(rmLineArray);

            ic.drawCls.draw();
          }
          else if(command.indexOf('add one stabilizer') == 0) {
            let paraArray = command.split(' | ');
            let p1Array = paraArray[1].split(' ');

             if(ic.pairArray === undefined) ic.pairArray = [];
             ic.pairArray.push(parseInt(p1Array[0]));
             ic.pairArray.push(parseInt(p1Array[1]));

             ic.drawCls.draw();
          }
          else if(command.indexOf('select planes z-axis') == 0) {
            let paraArray = command.split(' ');
            if(paraArray.length == 5) {
                let large = parseFloat(paraArray[3]);
                let small = parseFloat(paraArray[4]);

                ic.selectionCls.selectBtwPlanes(large, small);
            }
          }
          else if(command.indexOf('adjust membrane z-axis') == 0) {
            let paraArray = command.split(' ');
            if(paraArray.length == 5) {
                let large = parseFloat(paraArray[3]);
                let small = parseFloat(paraArray[4]);

                ic.selectionCls.adjustMembrane(large, small);
            }
          }
          else if(command.indexOf('toggle membrane') == 0) {
            ic.selectionCls.toggleMembrane();
          }
          else if(commandOri.indexOf('calc buried surface') == 0) {
            let paraArray = commandOri.split(' | ');
            if(paraArray.length == 2) {
                let setNameArray = paraArray[1].split(' ');

                if(setNameArray.length == 2) {
                    let nameArray2 = setNameArray[0].split(',');
                    let nameArray = setNameArray[1].split(',');

                    ic.analysisCls.calcBuriedSurface(nameArray2, nameArray);
                }
            }
          }
          else if(commandOri.indexOf('dist ') == 0) {
            let paraArray = commandOri.split(' | ');
            if(paraArray.length == 2) {
                let setNameArray = paraArray[1].split(' ');

                if(setNameArray.length == 2) {
                    let nameArray = setNameArray[0].split(',');
                    let nameArray2 = setNameArray[1].split(',');

                    ic.analysisCls.measureDistTwoSets(nameArray, nameArray2);
                }
            }
          }
          else if(commandOri.indexOf('disttable') == 0) {
            let paraArray = commandOri.split(' | ');
            if(paraArray.length == 2) {
                let setNameArray = paraArray[1].split(' ');

                if(setNameArray.length == 2) {
                    let nameArray = setNameArray[0].split(',');
                    let nameArray2 = setNameArray[1].split(',');

                    ic.analysisCls.measureDistManySets(nameArray, nameArray2);
                    me.htmlCls.dialogCls.openDlg('dl_disttable', 'Distances among the sets');
                }
            }
          }
          else if(commandOri.indexOf('angletable') == 0) {
            let paraArray = commandOri.split(' | ');
            if(paraArray.length == 2) {
                let setNameArray = paraArray[1].split(' ');

                if(setNameArray.length == 2) {
                    let nameArray = setNameArray[0].split(',');
                    let nameArray2 = setNameArray[1].split(',');

                    ic.analysisCls.measureAngleManySets(nameArray, nameArray2);
                    me.htmlCls.dialogCls.openDlg('dl_angletable', 'Angles among the sets');
                }
            }
          }
          else if(commandOri.indexOf('display interaction 3d') == 0
              || commandOri.indexOf('view interaction pairs') == 0
              || commandOri.indexOf('save1 interaction pairs') == 0
              || commandOri.indexOf('save2 interaction pairs') == 0
              || commandOri.indexOf('line graph interaction pairs') == 0
              || commandOri.indexOf('scatterplot interaction pairs') == 0
              || commandOri.indexOf('ligplot interaction pairs') == 0
              ) {
            let paraArray = commandOri.split(' | ');
            if(paraArray.length >= 3) {
                let setNameArray = paraArray[1].split(' ');

                if(setNameArray.length == 2) {
                    let nameArray2 = setNameArray[0].split(',');
                    let nameArray = setNameArray[1].split(',');

                    let bHbond = paraArray[2].indexOf('hbonds') !== -1;
                    let bSaltbridge = paraArray[2].indexOf('salt bridge') !== -1;
                    let bInteraction = paraArray[2].indexOf('interactions') !== -1;

                    let bHalogen = paraArray[2].indexOf('halogen') !== -1;
                    let bPication = paraArray[2].indexOf('pi-cation') !== -1;
                    let bPistacking = paraArray[2].indexOf('pi-stacking') !== -1;

                    let bHbondCalc;
                    if(paraArray.length >= 4) {
                        bHbondCalc =(paraArray[3] == 'true') ? true : false;
                    }

                    if(paraArray.length >= 5) {
                       let thresholdArray = paraArray[4].split(' ');

                       if(thresholdArray.length >= 4) {
                           $("#" + ic.pre + "hbondthreshold").val(thresholdArray[1]);
                           $("#" + ic.pre + "saltbridgethreshold").val(thresholdArray[2]);
                           $("#" + ic.pre + "contactthreshold").val(thresholdArray[3]);

                           if(thresholdArray.length == 7) {
                               $("#" + ic.pre + "halogenthreshold").val(thresholdArray[4]);
                               $("#" + ic.pre + "picationthreshold").val(thresholdArray[5]);
                               $("#" + ic.pre + "pistackingthreshold").val(thresholdArray[6]);
                           }
                       }
                    }

                    let type;
                    if(commandOri.indexOf('display interaction 3d') == 0) {
                        type = '3d';
                    }
                    else if(commandOri.indexOf('view interaction pairs') == 0) {
                        type = 'view';
                    }
                    else if(commandOri.indexOf('save1 interaction pairs') == 0) {
                        type = 'save1';
                    }
                    else if(commandOri.indexOf('save2 interaction pairs') == 0) {
                        type = 'save2';
                    }
                    else if(commandOri.indexOf('line graph interaction pairs') == 0) {
                        type = 'linegraph';
                    }
                    else if(commandOri.indexOf('scatterplot interaction pairs') == 0) {
                        type = 'scatterplot';
                    }
                    else if(commandOri.indexOf('ligplot interaction pairs') == 0) {
                      type = 'ligplot';
                    }

                    await ic.viewInterPairsCls.viewInteractionPairs(nameArray2, nameArray, bHbondCalc, type, bHbond, bSaltbridge, bInteraction, bHalogen, bPication, bPistacking);
                }
            }
          }
          else if(commandOri.indexOf('export pairs') == 0) {
            let paraArray = commandOri.split(' | ');
            if(paraArray.length == 3) {
                let setNameArray = paraArray[1].split(' ');

                if(setNameArray.length == 2) {
                    let nameArray2 = setNameArray[0].split(',');
                    let nameArray = setNameArray[1].split(',');

                    let distArray = paraArray[2].split(' ');
                    let radius = distArray[1];

                    ic.showInterCls.pickCustomSphere(radius, nameArray2, nameArray, ic.bSphereCalc);
                    ic.bSphereCalc = true;
                    let text = ic.viewInterPairsCls.exportSpherePairs();
                    let file_pref = Object.keys(me.utilsCls.getHlStructures()).join(',');
                    ic.saveFileCls.saveFile(file_pref + '_sphere_pairs.html', 'html', text);
                }
            }
          }
          else if(command.indexOf('graph label') == 0) {
            let pos = command.lastIndexOf(' ');
            let className = command.substr(pos + 1);

            $("#" + me.svgid + "_label").val(className);

            $("#" + me.svgid + " text").removeClass();
            $("#" + me.svgid + " text").addClass(className);
          }
          else if(command.indexOf('cartoon label') == 0) {
            let pos = command.lastIndexOf(' ');
            let className = command.substr(pos + 1);

            $("#" + me.svgid_ct + "_label").val(className);

            $("#" + me.svgid_ct + " text").removeClass();
            $("#" + me.svgid_ct + " text").addClass(className);
          }
          else if(command.indexOf('line graph scale') == 0) {
            let pos = command.lastIndexOf(' ');
            let scale = command.substr(pos + 1);

            $("#" + me.linegraphid + "_scale").val(scale);

            $("#" + me.linegraphid).attr("width",(ic.linegraphWidth * parseFloat(scale)).toString() + "px");
          }
          else if(command.indexOf('scatterplot scale') == 0) {
            let pos = command.lastIndexOf(' ');
            let scale = command.substr(pos + 1);

            $("#" + me.scatterplotid + "_scale").val(scale);

            $("#" + me.scatterplotid).attr("width",(ic.scatterplotWidth * parseFloat(scale)).toString() + "px");
          }
          else if(command.indexOf('ligplot scale') == 0) {
            let pos = command.lastIndexOf(' ');
            let scale = command.substr(pos + 1);

            $("#" + me.ligplotid + "_scale").val(scale);
            ic.ligplotScale = parseFloat(scale);

            $("#" + me.ligplotid).attr("width",(ic.ligplotWidth * parseFloat(scale)).toString() + "px");
          }
          else if(command.indexOf('contactmap scale') == 0) {
            let pos = command.lastIndexOf(' ');
            let scale = command.substr(pos + 1);

            $("#" + me.contactmapid + "_scale").val(scale);

            $("#" + me.contactmapid).attr("width",(ic.contactmapWidth * parseFloat(scale)).toString() + "px");
          }
          else if(command.indexOf('alignerrormap scale') == 0) {
            let pos = command.lastIndexOf(' ');
            let scale = command.substr(pos + 1);

            $("#" + me.alignerrormapid + "_scale").val(scale);

            $("#" + me.alignerrormapid).attr("width",(ic.alignerrormapWidth * parseFloat(scale)).toString() + "px");
          }
          else if(command.indexOf('graph force') == 0) {
            let pos = command.lastIndexOf(' ');
            me.htmlCls.force = parseInt(command.substr(pos + 1));

            $("#" + me.svgid + "_force").val(me.htmlCls.force);

            ic.getGraphCls.handleForce();
          }
          else if(command.indexOf('hide edges') == 0) {
            let pos = command.lastIndexOf(' ');
            me.htmlCls.hideedges = parseInt(command.substr(pos + 1));

            $("#" + me.svgid + "_hideedges").val(me.htmlCls.hideedges);

            if(me.htmlCls.hideedges) {
                me.htmlCls.contactInsideColor = 'FFF';
                me.htmlCls.hbondInsideColor = 'FFF';
                me.htmlCls.ionicInsideColor = 'FFF';
            }
            else {
                me.htmlCls.contactInsideColor = 'DDD';
                me.htmlCls.hbondInsideColor = 'AFA';
                me.htmlCls.ionicInsideColor = '8FF';
            }

            if(ic.graphStr !== undefined && ic.bRender && me.htmlCls.force) {
               ic.drawGraphCls.drawGraph(ic.graphStr, ic.pre + 'dl_graph');
            }
          }
          else if(command.indexOf('reset interaction pairs') == 0) {
            ic.viewInterPairsCls.resetInteractionPairs();
          }
          else if(command.indexOf('side by side') == 0) {
            let paraArray = command.split(' | ');
            let url = paraArray[1];

            let urlTarget = '_blank';
            window.open(url, urlTarget);
          }
          else if(commandOri.indexOf('your note') == 0) {
            let paraArray = commandOri.split(' | ');
            ic.yournote = paraArray[1];

            $("#" + ic.pre + "yournote").val(ic.yournote);
            if(me.cfg.shownote) document.title = ic.yournote;
          }
          else if(command.indexOf('cross structure interaction') == 0) {
            ic.crossstrucinter = parseInt(command.substr(command.lastIndexOf(' ') + 1));

            $("#" + ic.pre + "crossstrucinter").val(ic.crossstrucinter);
          }
          else if(command == 'replay on') {
            await ic.resizeCanvasCls.replayon();
          }
          else if(command == 'replay off') {
            await ic.resizeCanvasCls.replayoff();
          }

        // start with, single word =============
          else if(command.indexOf('contact map') == 0) {
            let strArray = command.split(" | ");

            if(strArray.length === 3) {
                let contactdist = parseFloat(strArray[1].split(' ')[1]);
                let contacttype = strArray[2].split(' ')[1];

                await ic.contactMapCls.contactMap(contactdist, contacttype);
            }
          }
          else if(command.indexOf('pickatom') == 0) {
            let atomid = parseInt(command.substr(command.lastIndexOf(' ') + 1));

            ic.pAtom = ic.atoms[atomid];

            ic.pickingCls.showPicking(ic.pAtom);
          }
          else if(commandOri.indexOf('set color spectrum') == 0) {
            let paraArray = commandOri.split(' | ');
            if(paraArray.length == 2) {
                let nameArray = paraArray[1].split(',');

                let bSpectrum = true;
                ic.setColorCls.setColorAcrossSets(nameArray, bSpectrum);
            }
          }
          else if(commandOri.indexOf('set residues color spectrum') == 0) {
            let paraArray = commandOri.split(' | ');
            if(paraArray.length == 2) {
                let nameArray = paraArray[1].split(',');

                let bSpectrum = true;
                ic.setColorCls.setColorBySets(nameArray, bSpectrum);
            }
          }
          else if(commandOri.indexOf('set color rainbow') == 0) {
            let paraArray = commandOri.split(' | ');
            if(paraArray.length == 2) {
                let nameArray = paraArray[1].split(',');

                let bSpectrum = false;
                ic.setColorCls.setColorAcrossSets(nameArray, bSpectrum);
            }
          }
          else if(commandOri.indexOf('set residues color rainbow') == 0) {
            let paraArray = commandOri.split(' | ');
            if(paraArray.length == 2) {
                let nameArray = paraArray[1].split(',');

                let bSpectrum = false;
                ic.setColorCls.setColorBySets(nameArray, bSpectrum);
            }
          }
          else if(commandOri.indexOf('color') == 0) {
            let strArray = commandOri.split(" | ");
            let color = strArray[0].substr(strArray[0].indexOf(' ') + 1);
            ic.opts['color'] = color;

            if(color == "residue custom" && strArray.length == 2) {
                ic.customResidueColors = JSON.parse(strArray[1]);
                for(let res in ic.customResidueColors) {
                    ic.customResidueColors[res.toUpperCase()] = me.parasCls.thr("#" + ic.customResidueColors[res]);
                }
            }
            else if(color == "align custom" && strArray.length == 3) {
                let chainid = strArray[1];
                let resiScoreArray = strArray[2].split(', ');
                ic.queryresi2score = {};
                ic.queryresi2score[chainid] = {};
                for(let i = 0, il = resiScoreArray.length; i < il; ++i) {
                    let resi_score = resiScoreArray[i].split(' ');

                    ic.queryresi2score[chainid][resi_score[0]] = resi_score[1];
                }
            }
            else if(color == "align custom" && strArray.length >= 4) {
                // me.htmlCls.clickMenuCls.setLogCmd('color align custom | ' + chainid + ' | range ' + start + '_' + end + ' | ' + resiScoreStr, true);
                this.setQueryresi2score(strArray);
            }
            else if(color == "area" && strArray.length == 2) {
                ic.midpercent = strArray[1];
                $("#" + ic.pre + 'midpercent').val(ic.midpercent);
            }

            ic.setColorCls.setColorByOptions(ic.opts, ic.hAtoms);

            ic.hlUpdateCls.updateHlAll();

            // change graph color, was done in color command
            //ic.getGraphCls.updateGraphColor();
          }
          else if(commandOri.indexOf('remove legend') == 0) {
            $("#" + me.pre + "legend").hide();
          }
          else if(commandOri.indexOf('custom tube') == 0) {
            let strArray = commandOri.split(" | ");

            this.setQueryresi2score(strArray);

            ic.setOptionCls.setStyle('proteins', 'custom tube');
          }
          else if(command.indexOf('style') == 0) {
            let secondPart = command.substr(command.indexOf(' ') + 1);

            let selectionType = secondPart.substr(0, secondPart.indexOf(' '));
            let style = secondPart.substr(secondPart.indexOf(' ') + 1);
            
            ic.setOptionCls.setStyle(selectionType, style);
          }
          else if(command.indexOf('window') == 0) {
            let secondPart = command.substr(command.indexOf(' ') + 1);

            setTimeout(function(){
              if(secondPart == "aligned sequences") {
                me.htmlCls.dialogCls.openDlg('dl_alignment', 'Select residues in aligned sequences');
              }
              else if(secondPart == "interaction table") {
                  me.htmlCls.dialogCls.openDlg('dl_allinteraction', 'Show interactions');
              }
              else if(secondPart == "interaction graph") {
                  me.htmlCls.dialogCls.openDlg('dl_linegraph', 'Show interactions between two lines of residue nodes');
              }
              else if(secondPart == "interaction scatterplot") {
                  me.htmlCls.dialogCls.openDlg('dl_scatterplot', 'Show interactions as scatterplot');
              }
              else if(secondPart == "force-directed graph") {
                  me.htmlCls.dialogCls.openDlg('dl_graph', 'Force-directed graph');
              }
            }, 1000);
          }
          else if(command.indexOf('set theme') == 0) {
            let color = command.substr(command.lastIndexOf(' ') + 1);
            me.htmlCls.setMenuCls.setTheme(color);
          }
          else if(command.indexOf('set double color') == 0) {
            let value = command.substr(command.lastIndexOf(' ') + 1);
            if(value == 'on') {
                ic.bDoublecolor = true;
                ic.setOptionCls.setStyle('proteins', 'ribbon');
            }
            else if(value == 'off') {
                ic.bDoublecolor = false;
            }
          }
          else if(command.indexOf('adjust dialog') == 0) {
            let id = command.substr(command.lastIndexOf(' ') + 1);
            ic.scapCls.adjust2DWidth(id);
          }
          else if(command.indexOf('glycans cartoon') == 0) {
            let value = command.substr(command.lastIndexOf(' ') + 1);

            if(value == 'yes') {
                ic.bGlycansCartoon = true;
            }
            else {
                ic.bGlycansCartoon = false;
            }
          }
          else if(command.indexOf('clashed residues') == 0) {
            let value = command.substr(command.lastIndexOf(' ') + 1);

            if(value == 'show') {
              ic.bHideClashed = false;
              ic.annoDomainCls.showHideClashedResidues();
            }
            else {
              ic.bHideClashed = true;
              me.htmlCls.clickMenuCls.setClashedResidues();
              ic.annoDomainCls.showHideClashedResidues();
            }
          }
          else if(command.indexOf('save html') == 0) {
            let id = command.substr(command.lastIndexOf(' ') + 1);
            me.htmlCls.eventsCls.saveHtml(id);
          }
          else if(command.indexOf('resdef') == 0) {
            me.cfg.resdef = command.substr(command.indexOf(' ') + 1);
          }
          else if(command.indexOf('vast_search_chainid') == 0) {
            ic.chainidArray = commandOri.substr(commandOri.indexOf(' ') + 1).split(',');

            let bRealign = true, bPredefined = true;
            await ic.realignParserCls.realignChainOnSeqAlign(undefined, ic.chainidArray, bRealign, bPredefined);

            // reset annotations
            // $("#" + ic.pre + "dl_annotations").html("");
            // ic.bAnnoShown = false;
            // if($('#' + ic.pre + 'dl_selectannotations').dialog( 'isOpen' )) {
            //     $('#' + ic.pre + 'dl_selectannotations').dialog( 'close' );
            // }
          }
          else if(command.indexOf('ig refnum off') == 0) {
            await ic.refnumCls.hideIgRefNum();
          }
          else if(command.indexOf('custom refnum') == 0) {
            let paraArray = commandOri.split(' | ');
            let dataStr = paraArray[1].replace(/\\n/g, '\n');
            await ic.refnumCls.parseCustomRefFile(dataStr);
          }
          else if(command.indexOf('show ref number') == 0) {
            ic.bShownRefnum = true;
          }
          else if(command.indexOf('hide ref number') == 0) {
            ic.bShownRefnum = false;
          }
          else if(command.indexOf('translate pdb') == 0) {
            let xyz = command.substr(13 + 1).split(' ');

            ic.transformCls.translateCoord(ic.hAtoms, parseFloat(xyz[0]), parseFloat(xyz[1]), parseFloat(xyz[2]));
            ic.drawCls.draw();
          }
          else if(command.indexOf('rotate pdb') == 0) {
            let mArray = command.substr(10 + 1).split(',');
            let mArrayFloat = [];
            for(let i = 0, il = mArray.length; i < il; ++i) {
              mArrayFloat.push(parseFloat(mArray[i]));
            }

            ic.transformCls.rotateCoord(ic.hAtoms, mArrayFloat);
            ic.drawCls.draw();
          }
          else if(command.indexOf('set dssp sse') == 0) {
            await ic.pdbParserCls.applyCommandDssp();
            ic.bResetAnno = true;

            if(ic.bAnnoShown) {
                await ic.showAnnoCls.showAnnotations();

                ic.annotationCls.resetAnnoTabAll();
            }
          }

        // special, select ==========

          else if(command.indexOf('select displayed set') !== -1) {
            //ic.hAtoms = me.hashUtilsCls.cloneHash(ic.dAtoms);
            ic.hAtoms = me.hashUtilsCls.cloneHash(ic.viewSelectionAtoms);
            ic.hlUpdateCls.updateHlAll();
          }
          else if(command.indexOf('select prop') !== -1) {
            let paraArray = commandOri.split(' | ');

            let property = paraArray[0].substr('select prop'.length + 1);

            let from, to;
            if(paraArray.length == 2) {
                let from_to = paraArray[1].split('_');
                from = from_to[0];
                to = from_to[1];
            }

            ic.resid2specCls.selectProperty(property, from, to);
          }
          else if(command.indexOf('select each residue') !== -1) {
            ic.selectionCls.saveEachResiInSel();
          }
          else if(command.indexOf('select') == 0 && command.indexOf('name') !== -1) {
            let paraArray = commandOri.split(' | '); // atom names might be case-sensitive

            let select = '', commandname = '', commanddesc = '';
            for(let i = 0, il = paraArray.length; i < il; ++i) {
                let para = paraArray[i];

                if(para.indexOf('select') !== -1) {
                    select = para.substr(para.indexOf(' ') + 1);
                }
                else if(para.indexOf('name') !== -1) {
                    commandname = para.substr(para.indexOf(' ') + 1);
                }
        //        else if(para.indexOf('description') !== -1) {
        //            commanddesc = para.substr(para.indexOf(' ') + 1);
        //        }
            }

        //    if(paraArray.length < 3) commanddesc = commandname;
            commanddesc = commandname;

            await ic.selByCommCls.selectByCommand(select, commandname, commanddesc);
          }
          else if(command.indexOf('select $') !== -1 || command.indexOf('select .') !== -1 || command.indexOf('select :') !== -1 
              || command.indexOf('select %') !== -1 || command.indexOf('select @') !== -1) {
            let paraArray = commandOri.split(' | '); // atom names might be case-sensitive

            let select = paraArray[0].substr(paraArray[0].indexOf(' ') + 1);
            let commandname = '', commanddesc = '';

            if(paraArray.length > 1) {
                commandname = paraArray[1].substr(paraArray[1].indexOf(' ') + 1);
            }

            if(paraArray.length > 2) {
                commanddesc = paraArray[2].substr(paraArray[2].indexOf(' ') + 1);
            }

            if(select.indexOf(' or ') !== -1) { // "select " command without " | name"
                await ic.selByCommCls.selectByCommand(select, commandname, commanddesc);
            }
            else { // only single query from selectByCommand()
                await ic.selByCommCls.selectBySpec(select, commandname, commanddesc);
            }
          }

          {
              me.htmlCls.clickMenuCls.setLogCmd(commandOri, false);
          }

          ic.bAddCommands = true;
        }

        setStrengthPara(paraArray) { let ic = this.icn3d; ic.icn3dui;
            if(paraArray.length >= 5) {
               let thresholdArray = paraArray[4].split(' ');

               if(thresholdArray.length >= 4) {
                   $("#" + ic.pre + "hbondthreshold").val(thresholdArray[1]);
                   $("#" + ic.pre + "saltbridgethreshold").val(thresholdArray[2]);
                   $("#" + ic.pre + "contactthreshold").val(thresholdArray[3]);
                   if(thresholdArray.length >= 7) {
                       $("#" + ic.pre + "halogenthreshold").val(thresholdArray[4]);
                       $("#" + ic.pre + "picationthreshold").val(thresholdArray[5]);
                       $("#" + ic.pre + "pistackingthreshold").val(thresholdArray[6]);
                   }
               }
            }

            if(paraArray.length == 6) {
                let thicknessArray = paraArray[5].split(' ');

                if(thicknessArray.length >= 6) {
                    $("#" + ic.pre + "dist_ss").val(thicknessArray[0]);
                    $("#" + ic.pre + "dist_coil").val(thicknessArray[1]);
                    $("#" + ic.pre + "dist_hbond").val(thicknessArray[2]);
                    $("#" + ic.pre + "dist_inter").val(thicknessArray[3]);
                    $("#" + ic.pre + "dist_ssbond").val(thicknessArray[4]);
                    $("#" + ic.pre + "dist_ionic").val(thicknessArray[5]);

                    if(thicknessArray.length == 9) {
                        $("#" + ic.pre + "dist_halogen").val(thicknessArray[6]);
                        $("#" + ic.pre + "dist_pication").val(thicknessArray[7]);
                        $("#" + ic.pre + "dist_pistacking").val(thicknessArray[8]);
                    }
                }
            }
        }

        getThresholdNameArrays(commandOri) { let ic = this.icn3d, me = ic.icn3dui;
            me.htmlCls.clickMenuCls.SetChainsAdvancedMenu();

            let paraArray = commandOri.split(' | ');

            let threshold = parseFloat(paraArray[0].substr(paraArray[0].lastIndexOf(' ') + 1));
            let nameArray = [], nameArray2 = [];
            if(paraArray.length >= 2 && paraArray[1].length > 4) { //sets a,b,c e,f,g
                let setsArray = paraArray[1].split(" ");
                if(setsArray.length > 1) nameArray2 = setsArray[1].split(",");
                if(setsArray.length > 2) nameArray = setsArray[2].split(",");
            }
            else {
                nameArray2 = ['selected'];
                nameArray = ['non-selected'];
            }

            let bHbondCalc;
            if(paraArray.length == 3) {
                bHbondCalc =(paraArray[2] == 'true') ? true : false;
            }

            return {'threshold': threshold, 'nameArray2': nameArray2, 'nameArray': nameArray, 'bHbondCalc': bHbondCalc}
        }

        setQueryresi2score(strArray) { let ic = this.icn3d, me = ic.icn3dui;
            let chainid = strArray[1];
            let start_end = strArray[2].split(' ')[1].split('_');
            let resiScoreStr = strArray[3]; // score 0-9
            if(ic.queryresi2score === undefined) ic.queryresi2score = {};
            //if(ic.queryresi2score[chainid] === undefined) ic.queryresi2score[chainid] = {}
            ic.queryresi2score[chainid] = {};
            let factor = 100 / 9;
            for(let resi = parseInt(start_end[0]), i = 0; resi <= parseInt(start_end[1]); ++resi, ++i) {
                if(resiScoreStr[i] != '_') {
                    ic.queryresi2score[chainid][resi] = parseInt(resiScoreStr[i]) * factor; // convert from 0-9 to 0-100
                }
            }

            // color range
            if(strArray.length > 4) {
                let colorArray = strArray[4].split(' ');
                ic.startColor = colorArray[1];
                ic.midColor = colorArray[2];
                ic.endColor = colorArray[3];

                let legendHtml = me.htmlCls.clickMenuCls.setLegendHtml();
                //$("#" + me.pre + "legend").html(legendHtml).show();
                $("#" + me.pre + "dl_legend_html").html(legendHtml);
                me.htmlCls.dialogCls.openDlg('dl_legend', 'Color Range');
            }
        }

        addShape(command, shape) { let ic = this.icn3d, me = ic.icn3dui;
          // ic.shapeCmdHash[command] = 1;
          
          let paraArray = command.split(' | ');
          let p1Array = paraArray[1].split(' ');
          let colorStr = paraArray[2].substr(paraArray[2].lastIndexOf(' ') + 1);
          let opacity = paraArray[3].substr(paraArray[3].lastIndexOf(' ') + 1);
          let radius = paraArray[4].substr(paraArray[4].lastIndexOf(' ') + 1);

          colorStr = '#' + colorStr.replace(/\#/g, '');
          let color = me.parasCls.thr(colorStr);

          let pos1;

          if(p1Array[0] == 'x1') { // input position
            pos1 = new THREE.Vector3(parseFloat(p1Array[1]), parseFloat(p1Array[3]), parseFloat(p1Array[5]));
          }
          else { // input sets
            let nameArray = paraArray[1].split(',');
            let atomSet1 = ic.definedSetsCls.getAtomsFromNameArray(nameArray);
            let posArray1 = ic.contactCls.getExtent(atomSet1);
            pos1 = new THREE.Vector3(posArray1[2][0], posArray1[2][1], posArray1[2][2]);
          }

          if(shape == 'sphere') {
            ic.sphereCls.createSphereBase(pos1, color, parseFloat(radius), undefined, undefined, undefined, parseFloat(opacity));
          }
          else { // 'cube'
            ic.boxCls.createBox_base(pos1, parseFloat(radius), color, undefined, undefined, undefined, parseFloat(opacity));
          }
        }

        getMenuFromCmd(cmd) { let ic = this.icn3d; ic.icn3dui;
            cmd = cmd.trim();

            let seqAnnoStr = 'Windows > View Sequences & Annotations';
            let hbondIntStr = 'Analysis > Interactions';
            let forceStr = hbondIntStr + ' > 2D Graph(Force-Directed)';
            let rotStr1 = 'View > Rotate > Auto Rotation > Rotate ';
            let rotStr2 = 'View > Rotate > Rotate 90 deg > ';
            let sel3dStr = 'Select > Select on 3D > ';
            let labelStr = 'Analysis > Label > ';
            let printStr = 'File > 3D Printing > ';

            if(cmd.indexOf('load') == 0) return 'File > Retrieve by ID, Align';
            else if(cmd.indexOf('set map') == 0 && cmd.indexOf('set map wireframe') == -1) return 'Style > Electron Density';
            else if(cmd.indexOf('set emmap') == 0 && cmd.indexOf('set emmap wireframe') == -1) return 'Style > EM Density Map';
            else if(cmd.indexOf('set phi') == 0) return 'Analysis > Load Potential > URL(CORS) Phi/Cube';
            else if(cmd.indexOf('set delphi') == 0) return 'Analysis > DelPhi Potential';
            else if(cmd.indexOf('setoption map') == 0) return 'Style > Remove Map';
            else if(cmd.indexOf('setoption emmap') == 0) return 'Style > Remove EM Map';
            //else if(cmd.indexOf('setoption phimap') == 0) return 'Analysis > Remove Potential';
            else if(cmd.indexOf('view annotations') == 0) return seqAnnoStr;
            else if(cmd.indexOf('set annotation all') == 0) return seqAnnoStr + ': "All" checkbox';
            else if(cmd.indexOf('set annotation clinvar') == 0) return seqAnnoStr + ': "ClinVar" checkbox';
            else if(cmd.indexOf('set annotation snp') == 0) return seqAnnoStr + ': "SNP" checkbox';
            else if(cmd.indexOf('set annotation 3ddomain') == 0) return seqAnnoStr + ': "3D Domains" checkbox';
            else if(cmd.indexOf('view interactions') == 0) return 'Windows > View 2D Diagram';
            else if(cmd.indexOf('symmetry') == 0) return 'Analysis > Symmetry';
            else if(cmd.indexOf('realign on seq align') == 0) return 'File > Realign Selection > on Sequence Alignment';
            else if(cmd.indexOf('realign') == 0) return 'File > Realign Selection > Residue by Residue';
            else if(cmd.indexOf('graph interaction pairs') == 0) return hbondIntStr + ' > 2D Graph(Force-Directed)';
            else if(cmd.indexOf('export canvas') == 0) return 'File > Save File > iCn3D PNG Image';
            else if(cmd == 'export stl file') return printStr + 'STL';
            else if(cmd == 'export vrml file') return printStr + 'VRML(Color)';
            else if(cmd == 'export stl stabilizer file') return printStr + 'STL W/ Stabilizers';
            else if(cmd == 'export vrml stabilizer file') return printStr + 'VRML(Color, W/ Stabilizers)';
            else if(cmd == 'select all') return 'Select > All; or Toggle to "All"(next to "Help")';
            else if(cmd == 'show all') return 'View > View Full Structure';
            else if(cmd == 'select complement') return 'Select > Inverse';
            else if(cmd == 'set pk atom') return sel3dStr + 'Atom';
            else if(cmd == 'set pk residue') return sel3dStr + 'Residue';
            else if(cmd == 'set pk strand') return sel3dStr + 'Strand/Helix';
            else if(cmd == 'set pk domain') return sel3dStr + '3D Domain';
            else if(cmd == 'set pk chain') return sel3dStr + 'Chain';
            else if(cmd == 'set surface wireframe on') return 'Style > Surface Wireframe > Yes';
            else if(cmd == 'set surface wireframe off') return 'Style > Surface Wireframe > No';
            else if(cmd == 'set map wireframe on') return 'Style > Map Wireframe > Yes';
            else if(cmd == 'set map wireframe off') return 'Style > Map Wireframe > No';
            else if(cmd == 'set emmap wireframe on') return 'Style > EM Map Wireframe > Yes';
            else if(cmd == 'set emmap wireframe off') return 'Style > EM Map Wireframe > No';
            else if(cmd == 'set surface neighbors on') return 'Style > Surface Type > ... with Context';
            //else if(cmd == 'set surface neighbors off') return 'Style > Surface Type > ... without Context';
            else if(cmd == 'set axis on') return 'View > XYZ-axes > Show';
            else if(cmd == 'set axis off') return 'View > XYZ-axes > Hide';
            else if(cmd == 'set fog on') return 'View > Fog for Selection > On';
            else if(cmd == 'set fog off') return 'View > Fog for Selection > Off';
            else if(cmd == 'set slab on') return 'View > Slab for Selection > On';
            else if(cmd == 'set slab off') return 'View > Slab for Selection > Off';
            else if(cmd == 'set assembly on') return 'Analysis > Assembly > Biological Assembly';
            else if(cmd == 'set assembly off') return 'Analysis > Assembly > Asymmetric Unit';
            else if(cmd == 'set chemicalbinding show') return 'Analysis > Chem. Binding > Show';
            else if(cmd == 'set chemicalbinding hide') return 'Analysis > Chem. Binding > Hide';
            else if(cmd == 'set hbonds off' || cmd == 'set salt bridge off' || cmd == 'set contact off'
              || cmd == 'set halogen pi off') return hbondIntStr + ' > Reset';
            else if(cmd == 'hydrogens') return 'Style > Hydrogens > Show';
            else if(cmd == 'set hydrogens off') return 'Style > Hydrogens > Hide';
            else if(cmd == 'set stabilizer off') return 'File > 3D Printing > Remove All Stabilizers';
            else if(cmd == 'set disulfide bonds off') return 'Analysis > Disulfide Bonds > Hide';
            else if(cmd == 'set cross linkage off') return 'Analysis > Cross-Linkages > Hide';
            else if(cmd == 'set lines off') return 'Analysis > Distance > Hide';
            else if(cmd == 'set labels off') return 'Analysis > Label > Remove';
            else if(cmd == 'set mode all') return 'Toggle to "All"(next to "Help")';
            else if(cmd == 'set mode selection') return 'Toggle to "Selection"(next to "Help")';
            else if(cmd == 'set view detailed view') return seqAnnoStr + ': "Details" tab';
            else if(cmd== 'set view overview') return seqAnnoStr + ': "Summary" tab';
            else if(cmd == 'set annotation custom') return seqAnnoStr + ': "Custom" checkbox';
            else if(cmd == 'set annotation interaction') return seqAnnoStr + ': "Interactions" checkbox';
            else if(cmd == 'set annotation ptm') return seqAnnoStr + ': "PTM" checkbox';
            else if(cmd == 'set annotation cdd') return seqAnnoStr + ': "Conserved Domains" checkbox';
            else if(cmd == 'set annotation site') return seqAnnoStr + ': "Functional Sites" checkbox';
            else if(cmd == 'set annotation ssbond') return seqAnnoStr + ': "Disulfide Bonds" checkbox';
            else if(cmd == 'set annotation crosslink') return seqAnnoStr + ': "Cross-Linkages" checkbox';
            else if(cmd == 'set annotation transmembrane') return seqAnnoStr + ': "Transmembrane" checkbox';
            else if(cmd == 'set annotation ig') return seqAnnoStr + ': "Ig Domains" checkbox';
            else if(cmd == 'highlight level up') return 'Keyboard Arrow Up';
            else if(cmd == 'highlight level down') return 'Keyboard Arrow Down';
            else if(cmd.indexOf('hide annotation') == 0) return seqAnnoStr + ': checkboxes off';
            else if(cmd == 'add residue labels') return labelStr + 'per Residue';
            else if(cmd == 'add residue number labels') return labelStr + 'per Residue & Number';
            else if(cmd == 'add Ig domain labels') return labelStr + 'per Ig Domain';
            else if(cmd == 'add atom labels') return labelStr + 'per Atom';
            else if(cmd == 'add chain labels') return labelStr + 'per Chain';
            else if(cmd == 'add terminal labels') return labelStr + 'N- & C- Termini';
            else if(cmd == 'rotate left') return rotStr1 + 'Left; or Key l';
            else if(cmd == 'rotate right') return rotStr1 + 'Right; or Key j';
            else if(cmd == 'rotate up') return rotStr1 + 'Up; or Key i';
            else if(cmd == 'rotate down') return rotStr1 + 'Down; or Key m';
            else if(cmd == 'rotate x') return rotStr2 + 'X-axis';
            else if(cmd == 'rotate y') return rotStr2 + 'Y-axis';
            else if(cmd == 'rotate z') return rotStr2 + 'Z-axis';
            else if(cmd == 'reset') return 'View > Reset > All';
            else if(cmd == 'reset orientation') return 'View > Reset > Orientation';
            //else if(cmd == 'reset thickness') return 'File > 3D Printing > Reset Thickness';
            else if(cmd == 'clear selection') return 'Select > Clear Selection';
            else if(cmd == 'zoom selection') return 'Select > Zoom in Selection';
            else if(cmd == 'center selection') return 'Select > Center Selection';
            else if(cmd == 'show selection') return 'Select > View Only Selection';
            else if(cmd == 'hide selection') return 'Select > Hide Selection';
            else if(cmd == 'output selection') return 'Select > Clear Selection';
            else if(cmd == 'toggle highlight') return 'Select > Toggle Highlight';
            else if(cmd == 'stabilizer') return 'File > 3D Printing > Add all Stabilizers';
            else if(cmd == 'disulfide bonds') return 'Analysis > Disulfide Bonds > Show';
            else if(cmd == 'cross linkage') return 'Analysis > Cross-Linkages > Show';
            else if(cmd == 'back') return 'View > Undo';
            else if(cmd == 'forward') return 'View > Redo';
            else if(cmd == 'clear all') return 'Select > Clear Selection';
            else if(cmd == 'defined sets') return 'Windows > Defined Sets';
            else if(cmd == 'delete selected sets') return 'Windows > Defined Sets: "Delete Selected Sets" button';
            else if(cmd == 'view interactions') return 'Windows > View Interactions';
            else if(cmd == 'show annotations all chains') return seqAnnoStr + ': "Show All Chains" button';
            else if(cmd == 'save color') return 'Color > Save Color';
            else if(cmd == 'apply saved color') return 'Color > Apply Saved Color';
            else if(cmd == 'save style') return 'Style > Save Style';
            else if(cmd == 'apply saved style') return 'Style > Apply Saved Style';
            else if(cmd == 'select main chains') return 'Select > Main Chains';
            else if(cmd == 'select side chains') return 'Select > Side Chains';
            else if(cmd == 'select main side chains') return 'Select > Main & Side Chains';
            else if(cmd == 'area') return 'View > Surface Area';
            else if(cmd == 'table inter count only') return hbondIntStr + ': "Set 1" button: "Show Count Only" button';
            else if(cmd == 'table inter details') return hbondIntStr + ': "Set 1" button: "Show Details" button';
            else if(cmd.indexOf('define helix sets') == 0) return seqAnnoStr + ': "Helix Sets" button';
            else if(cmd.indexOf('define sheet sets') == 0) return seqAnnoStr + ': "Sheet Sets" button';
            else if(cmd.indexOf('define coil sets') == 0) return seqAnnoStr + ': "Coil Sets" button';
            else if(cmd.indexOf('select interaction') == 0) return 'Windows > View 2D Diagram: click on edges';
            else if(cmd.indexOf('select saved atoms') == 0 || cmd.indexOf('select sets') == 0) return 'Windows > Defined Sets: select in menu';
            else if(cmd.indexOf('select chain') !== -1) return seqAnnoStr + ': click on chain names';
            else if(cmd.indexOf('select alignChain') !== -1) return 'Windows > View Aligned Sequences: click on chain names';
            else if(cmd.indexOf('select zone cutoff') == 0) return 'Select > by Distance';
            else if(cmd.indexOf('set surface opacity') == 0) return 'Style > Surface Opacity';
            else if(cmd.indexOf('set label scale') == 0) return 'View > Label Scale';
            else if(cmd.indexOf('set surface') == 0) return 'Style > Surface Type';
            else if(cmd.indexOf('set camera') == 0) return 'View > Camera';
            else if(cmd.indexOf('set background') == 0) return 'Style > Background';
            else if(cmd.indexOf('set thickness') == 0) return 'File > 3D Printing > Set Thickness';
            else if(cmd.indexOf('set highlight color') == 0) return 'Select > Highlight Color';
            else if(cmd.indexOf('set highlight style') == 0) return 'Select > Highlight Style';
            else if(cmd.indexOf('add line') == 0) return 'Analysis > Distance > between Two Atoms';
            else if(cmd.indexOf('add label') == 0) return 'Analysis > Distance > between Two Atoms';
            else if(cmd.indexOf('dist') == 0) return 'Analysis > Distance > between Two Sets';
            else if(cmd.indexOf('msa') == 0) return seqAnnoStr + ': "Add Track" button: "FASTA Alignment" button';
            else if(cmd.indexOf('add track') == 0) return seqAnnoStr + ': "Add Track" button';
            else if(cmd.indexOf('remove one stabilizer') == 0) return 'File > 3D Printing > Remove One Stablizer';
            else if(cmd.indexOf('add one stabilizer') == 0) return 'File > 3D Printing > Add One Stablizer';
            else if(cmd.indexOf('select planes z-axis') == 0) return 'View > Select between Two X-Y Planes';
            else if(cmd.indexOf('adjust membrane z-axis') == 0) return 'View > Adjust Membrane';
            else if(cmd.indexOf('toggle membrane') == 0) return 'View > Toggle Membrane';
            else if(cmd.indexOf('calc buried surface') == 0) return hbondIntStr + ': "Buried Surface Area" button';
            else if(cmd.indexOf('display interaction 3d') == 0) return hbondIntStr + ': "3D Display Interactions" button';
            else if(cmd.indexOf('view interaction pairs') == 0) return hbondIntStr + ': "Highlight Interactions in Table" button';
            else if(cmd.indexOf('save1 interaction pairs') == 0) return hbondIntStr + ': "Set 1" button';
            else if(cmd.indexOf('save2 interaction pairs') == 0) return hbondIntStr + ': "Set 2" button';
            else if(cmd.indexOf('line graph interaction pairs') == 0) return hbondIntStr + ': "2D Interaction Network" button';
            else if(cmd.indexOf('scatterplot interaction pairs') == 0) return hbondIntStr + ': "2D Interaction Map" button';
            else if(cmd.indexOf('ligplot interaction pairs') == 0) return hbondIntStr + ': "2D Interaction for One Ligand/Residue" button';
            else if(cmd.indexOf('graph label') == 0) return forceStr + ': "Label Size" menu';
            else if(cmd.indexOf('graph force') == 0) return forceStr + ': "Force on Nodes" menu';
            else if(cmd.indexOf('hide edges') == 0) return forceStr + ': "Internal Edges" menu';
            else if(cmd.indexOf('reset interaction pairs') == 0) return hbondIntStr + ' > Reset';
            else if(cmd.indexOf('side by side') == 0) return 'View > Side by Side';
            else if(cmd.indexOf('your note') == 0) return 'Windows > Your Notes / Window Title';
            else if(cmd.indexOf('pickatom') == 0) return 'Hold Alt key and click on 3D structure';
            else if(cmd.indexOf('color') == 0) return 'Color menu';
            else if(cmd.indexOf('custom tube') == 0) return seqAnnoStr + ': "Custom Color/Tube" button: "Custom Tube" button';
            else if(cmd.indexOf('style') == 0) return 'Style menu';
            else if(cmd.indexOf('select displayed set') !== -1) return 'Select > Displayed Set';
            else if(cmd.indexOf('select prop') !== -1) return 'Select > by Property';
            else if(cmd.indexOf('select') == 0 && cmd.indexOf('name') !== -1) return seqAnnoStr + ': drag on residues to select';
            else if(cmd.indexOf('select $') !== -1 || cmd.indexOf('select .') !== -1 || cmd.indexOf('select :') !== -1 || cmd.indexOf('select @') !== -1) return 'Select > Advanced; or other selection';
            else if(cmd.indexOf('replay on') !== -1) return 'File > Replay Each Step > On';
            else if(cmd.indexOf('replay off') !== -1) return 'File > Replay Each Step > Off';
            else if(cmd.indexOf('set theme') !== -1) return 'Style > Theme Color';
            else if(cmd.indexOf('set double color') !== -1) return 'Style > Two-color Helix';
            else return '';
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class DefinedSets {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        setProtNuclLigInMenu() { let ic = this.icn3d; ic.icn3dui;
            // Initially, add proteins, nucleotides, chemicals, ions, water into the menu "custom selections"
            if(ic.proteins && Object.keys(ic.proteins).length > 0) {
              //ic.defNames2Atoms['proteins'] = Object.keys(ic.proteins);
              ic.defNames2Residues['proteins'] = Object.keys(ic.firstAtomObjCls.getResiduesFromAtoms(ic.proteins));
              ic.defNames2Descr['proteins'] = 'proteins';
              ic.defNames2Command['proteins'] = 'select :proteins';
            }

            if(ic.nucleotides && Object.keys(ic.nucleotides).length > 0) {
              //ic.defNames2Atoms['nucleotides'] = Object.keys(ic.nucleotides);
              ic.defNames2Residues['nucleotides'] = Object.keys(ic.firstAtomObjCls.getResiduesFromAtoms(ic.nucleotides));
              ic.defNames2Descr['nucleotides'] = 'nucleotides';
              ic.defNames2Command['nucleotides'] = 'select :nucleotides';
            }

            if(ic.chemicals && Object.keys(ic.chemicals).length > 0) {
              //ic.defNames2Atoms['chemicals'] = Object.keys(ic.chemicals);
              if(ic.bOpm) {
                  let chemicalResHash = {}, memResHash = {};
                  for(let serial in ic.chemicals) {
                      let atom = ic.atoms[serial];
                      let residueid = atom.structure + '_' + atom.chain + '_' + atom.resi;
                      if(atom.resn === 'DUM') {
                          memResHash[residueid] = 1;
                      }
                      else {
                          chemicalResHash[residueid] = 1;
                      }
                  }

                  if(Object.keys(chemicalResHash).length > 0) {
                      ic.defNames2Residues['chemicals'] = Object.keys(chemicalResHash);
                      ic.defNames2Descr['chemicals'] = 'chemicals';
                      ic.defNames2Command['chemicals'] = 'select :chemicals';
                  }

                  if(Object.keys(memResHash).length > 0) {
                      ic.defNames2Residues['membrane'] = Object.keys(memResHash);
                      ic.defNames2Descr['membrane'] = 'membrane';
                      ic.defNames2Command['membrane'] = 'select :membrane';
                  }
              }
              else {
                  ic.defNames2Residues['chemicals'] = Object.keys(ic.firstAtomObjCls.getResiduesFromAtoms(ic.chemicals));
                  ic.defNames2Descr['chemicals'] = 'chemicals';
                  ic.defNames2Command['chemicals'] = 'select :chemicals';
              }
            }

            if(ic.ions && Object.keys(ic.ions).length > 0) {
              //ic.defNames2Atoms['ions'] = Object.keys(ic.ions);
              ic.defNames2Residues['ions'] = Object.keys(ic.firstAtomObjCls.getResiduesFromAtoms(ic.ions));
              ic.defNames2Descr['ions'] = 'ions';
              ic.defNames2Command['ions'] = 'select :ions';
            }

            if(ic.water && Object.keys(ic.water).length > 0) {
              //ic.defNames2Atoms['water'] = Object.keys(ic.water);
              ic.defNames2Residues['water'] = Object.keys(ic.firstAtomObjCls.getResiduesFromAtoms(ic.water));
              ic.defNames2Descr['water'] = 'water';
              ic.defNames2Command['water'] = 'select :water';
            }

            this.setTransmemInMenu(ic.halfBilayerSize, -ic.halfBilayerSize);
        }

        setPredefinedInMenu() { let ic = this.icn3d, me = ic.icn3dui;
              // predefined sets: all chains
              this.setChainsInMenu();

              // predefined sets: proteins,nucleotides, chemicals
              this.setProtNuclLigInMenu();

              // show 3d domains for mmdbid
              if(me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined  || me.cfg.chainalign !== undefined || me.cfg.mmdbafid !== undefined) {
                  for(let tddomainName in ic.tddomains) {
                      ic.selectionCls.selectResidueList(ic.tddomains[tddomainName], tddomainName, tddomainName, false, false);
                  }
              }

              //if((me.cfg.align !== undefined || me.cfg.chainalign !== undefined) && ic.bFullUi) {
              // deal with multiple chain align separately
              if((me.cfg.align !== undefined ||(me.cfg.chainalign !== undefined && ic.chainidArray.length == 2) ) && ic.bFullUi) {
                ic.selectionCls.selectResidueList(ic.consHash1, ic.conservedName1, ic.conservedName1, false, false);
                ic.selectionCls.selectResidueList(ic.consHash2, ic.conservedName2, ic.conservedName2, false, false);

                ic.selectionCls.selectResidueList(ic.nconsHash1, ic.nonConservedName1, ic.nonConservedName1, false, false);
                ic.selectionCls.selectResidueList(ic.nconsHash2, ic.nonConservedName2, ic.nonConservedName2, false, false);

                ic.selectionCls.selectResidueList(ic.nalignHash1, ic.notAlignedName1, ic.notAlignedName1, false, false);
                ic.selectionCls.selectResidueList(ic.nalignHash2, ic.notAlignedName2, ic.notAlignedName2, false, false);

                // for alignment, show aligned residues, chemicals, and ions
                let dAtoms = {};
                for(let alignChain in ic.alnChains) {
                    dAtoms = me.hashUtilsCls.unionHash(dAtoms, ic.alnChains[alignChain]);
                }

                let residuesHash = ic.firstAtomObjCls.getResiduesFromAtoms(dAtoms);

                let commandname = 'protein_aligned';
                let commanddescr = 'aligned protein and nucleotides';
                let select = "select " + ic.resid2specCls.residueids2spec(Object.keys(residuesHash));

                //ic.selectionCls.addCustomSelection(Object.keys(residuesHash), Object.keys(dAtoms), commandname, commanddescr, select, true);
                ic.selectionCls.addCustomSelection(Object.keys(residuesHash), commandname, commanddescr, select, true);
              }
        }

        //Set the menu of defined sets with an array of defined names "commandnameArray".
        setAtomMenu(commandnameArray) { let ic = this.icn3d; ic.icn3dui;
          let html = "";

          let nameArray1 =(ic.defNames2Residues !== undefined) ? Object.keys(ic.defNames2Residues) : [];
          let nameArray2 =(ic.defNames2Atoms !== undefined) ? Object.keys(ic.defNames2Atoms) : [];

          let nameArrayTmp = nameArray1.concat(nameArray2).sort();

          let nameArray = [];
            //  $.each(nameArrayTmp, function(i, el){
            //       if($.inArray(el, nameArray) === -1) nameArray.push(el);
            //  });
          nameArrayTmp.forEach(elem => {
            if($.inArray(elem, nameArray) === -1) nameArray.push(elem);
          });
            
            // let structureArray = Object.keys(me.utilsCls.getStructures(ic.dAtoms));

            // nameArrayTmp.forEach((elem) => {
            //     structureArray.forEach((structure) => {
            //         if (ic.defNames2Residues[elem] && ic.defNames2Residues[elem][0] && ic.defNames2Residues[elem][0].split("_")[0].includes(structure.split("_")[0])){
            //             if ($.inArray(elem, nameArray) === -1) nameArray.push(elem);
            //         }
            //     });
            // });

          //for(let i in ic.defNames2Atoms) {
          for(let i = 0, il = nameArray.length; i < il; ++i) {
              let name = nameArray[i];

              let atom, atomHash;
              if(ic.defNames2Atoms !== undefined && ic.defNames2Atoms.hasOwnProperty(name)) {
                  let atomArray = ic.defNames2Atoms[name];

                  if(atomArray.length > 0) atom = ic.atoms[atomArray[0]];
              }
              else if(ic.defNames2Residues !== undefined && ic.defNames2Residues.hasOwnProperty(name)) {
                  let residueArray = ic.defNames2Residues[name];
                  if(residueArray.length > 0) {
                      atomHash = ic.residues[residueArray[0]];
                      if(atomHash) {
                          atom = ic.atoms[Object.keys(atomHash)[0]];
                      }
                  }
              }

              let colorStr =(atom === undefined || atom.color === undefined || atom.color.getHexString().toUpperCase() === 'FFFFFF') ? 'DDDDDD' : atom.color.getHexString();
              let color =(atom !== undefined && atom.color !== undefined) ? colorStr : '000000';

              if(commandnameArray.indexOf(name) != -1) {
                html += "<option value='" + name + "' style='color:#" + color + "' selected='selected'>" + name + "</option>";
              }
              else {
                html += "<option value='" + name + "' style='color:#" + color + "'>" + name + "</option>";
              }
          }

          return html;
        }

        setChainsInMenu() { let ic = this.icn3d; ic.icn3dui;
            for(let chainid in ic.chains) {
                // skip chains with one residue/chemical
                if(ic.chainsSeq[chainid] && ic.chainsSeq[chainid].length > 1) {
                  //ic.defNames2Atoms[chainid] = Object.keys(ic.chains[chainid]);
                  ic.defNames2Residues[chainid] = Object.keys(ic.firstAtomObjCls.getResiduesFromAtoms(ic.chains[chainid]));
                  ic.defNames2Descr[chainid] = chainid;

                  let pos = chainid.indexOf('_');
                  let structure = chainid.substr(0, pos);
                  let chain = chainid.substr(pos + 1);

                  ic.defNames2Command[chainid] = 'select $' + structure + '.' + chain;
                }
            }

            // select whole structure
            if(ic.structures && Object.keys(ic.structures) == 1) {
              let structure = Object.keys(ic.structures)[0];

              ic.defNames2Residues[structure] = Object.keys(ic.residues);
              ic.defNames2Descr[structure] = structure;

              ic.defNames2Command[structure] = 'select $' + structure;
            }
            else if(ic.residues) {
                let resArray = Object.keys(ic.residues);
                let structResHash = {};
                for(let i = 0, il = resArray.length; i < il; ++i) {
                    let resid = resArray[i];
                    let pos = resid.indexOf('_');
                    let structure = resid.substr(0, pos);
                    if(structResHash[structure] === undefined) {
                        structResHash[structure] = [];
                    }
                    structResHash[structure].push(resid);
                }

                for(let structure in structResHash) {
                  ic.defNames2Residues[structure] = structResHash[structure];
                  ic.defNames2Descr[structure] = structure;

                  ic.defNames2Command[structure] = 'select $' + structure;
                }
            }
        }

        setTransmemInMenu(posZ, negZ, bReset) { let ic = this.icn3d; ic.icn3dui;
            // set transmembrane, extracellular, intracellular
            if(ic.bOpm) {
              let transmembraneHash = {}, extracellularHash = {}, intracellularHash = {};
              for(let serial in ic.atoms) {
                  let atom = ic.atoms[serial];

                  if(atom.resn === 'DUM') continue;

                  let residueid = atom.structure + '_' + atom.chain + '_' + atom.resi;
                  if(atom.coord.z > posZ) {
                      extracellularHash[residueid] = 1;
                  }
                  else if(atom.coord.z < negZ) {
                      intracellularHash[residueid] = 1;
                  }
                  else {
                      transmembraneHash[residueid] = 1;
                  }
              }

              let extraStr =(bReset) ? '2' : '';

              if(Object.keys(transmembraneHash).length > 0) {
                  ic.defNames2Residues['transmembrane' + extraStr] = Object.keys(transmembraneHash);
                  ic.defNames2Descr['transmembrane' + extraStr] = 'transmembrane' + extraStr;
                  ic.defNames2Command['transmembrane' + extraStr] = 'select :transmembrane' + extraStr;
              }

              if(Object.keys(extracellularHash).length > 0) {
                  ic.defNames2Residues['extracellular' + extraStr] = Object.keys(extracellularHash);
                  ic.defNames2Descr['extracellular' + extraStr] = 'extracellular' + extraStr;
                  ic.defNames2Command['extracellular' + extraStr] = 'select :extracellular' + extraStr;
              }

              if(Object.keys(intracellularHash).length > 0) {
                  ic.defNames2Residues['intracellular' + extraStr] = Object.keys(intracellularHash);
                  ic.defNames2Descr['intracellular' + extraStr] = 'intracellular' + extraStr;
                  ic.defNames2Command['intracellular' + extraStr] = 'select :intracellular' + extraStr;
              }
            }
        }

        //Display the menu of defined sets. All chains and defined custom sets are listed in the menu.
        //All new custom sets will be displayed in the menu.
        showSets() { let ic = this.icn3d, me = ic.icn3dui;
            if(!me.bNode) {
                me.htmlCls.dialogCls.openDlg('dl_definedsets', 'Select sets');
                $("#" + ic.pre + "dl_setsmenu").show();
                $("#" + ic.pre + "dl_setoperations").show();

                $("#" + ic.pre + "dl_command").hide();

                $("#" + ic.pre + "atomsCustom").resizable();
            }

            let prevHAtoms = me.hashUtilsCls.cloneHash(ic.hAtoms);
            let prevDAtoms = me.hashUtilsCls.cloneHash(ic.dAtoms);

            if(ic.bSetChainsAdvancedMenu === undefined || !ic.bSetChainsAdvancedMenu || ic.bResetSets) {
               this.setPredefinedInMenu();

               ic.bSetChainsAdvancedMenu = true;
            }

            ic.hAtoms = me.hashUtilsCls.cloneHash(prevHAtoms);
            ic.dAtoms = me.hashUtilsCls.cloneHash(prevDAtoms);

            ic.hlUpdateCls.updateHlMenus();
        }

        clickCustomAtoms() { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;
            //me.myEventCls.onIds("#" + ic.pre + "atomsCustom", "change", function(e) { let ic = thisClass.icn3d;
            $("#" + ic.pre + "atomsCustom").change(function(e) { let ic = thisClass.icn3d;
               let nameArray = $(this).val();
               ic.nameArray = nameArray;

               if(nameArray !== null) {
                 // log the selection
                 //me.htmlCls.clickMenuCls.setLogCmd('select saved atoms ' + nameArray.toString(), true);

                 let bUpdateHlMenus = false;
                 thisClass.changeCustomAtoms(nameArray, bUpdateHlMenus);
                 //me.htmlCls.clickMenuCls.setLogCmd('select saved atoms ' + nameArray.join(' ' + ic.setOperation + ' '), true);
                 me.htmlCls.clickMenuCls.setLogCmd('select sets ' + nameArray.join(' ' + ic.setOperation + ' '), true);

                 ic.bSelectResidue = false;
               }
            });

            me.myEventCls.onIds("#" + ic.pre + "atomsCustom", "focus", function(e) { let ic = thisClass.icn3d;
               if(me.utilsCls.isMobile()) $("#" + ic.pre + "atomsCustom").val("");
            });
        }

        //Delete selected sets in the menu of "Defined Sets".
        deleteSelectedSets() { let ic = this.icn3d; ic.icn3dui;
           let nameArray = $("#" + ic.pre + "atomsCustom").val();

           for(let i = 0; i < nameArray.length; ++i) {
             let selectedSet = nameArray[i];

             if((ic.defNames2Atoms === undefined || !ic.defNames2Atoms.hasOwnProperty(selectedSet)) &&(ic.defNames2Residues === undefined || !ic.defNames2Residues.hasOwnProperty(selectedSet)) ) continue;

             if(ic.defNames2Atoms !== undefined && ic.defNames2Atoms.hasOwnProperty(selectedSet)) {
                 delete ic.defNames2Atoms[selectedSet];
             }

             if(ic.defNames2Residues !== undefined && ic.defNames2Residues.hasOwnProperty(selectedSet)) {
                 delete ic.defNames2Residues[selectedSet];
             }
           } // outer for

           ic.hlUpdateCls.updateHlMenus();
        }

        //HighlightAtoms are set up based on the selected custom names "nameArray" in the atom menu.
        //The corresponding atoms are neither highlighted in the sequence dialog nor in the 3D structure
        //since not all residue atom are selected.
        changeCustomAtoms(nameArray, bUpdateHlMenus) { let ic = this.icn3d, me = ic.icn3dui;
           ic.hAtoms = {};

           for(let i = 0; i < nameArray.length; ++i) {
             let selectedSet = nameArray[i];

             if((ic.defNames2Atoms === undefined || !ic.defNames2Atoms.hasOwnProperty(selectedSet)) &&(ic.defNames2Residues === undefined || !ic.defNames2Residues.hasOwnProperty(selectedSet)) ) continue;

             if(ic.defNames2Atoms !== undefined && ic.defNames2Atoms.hasOwnProperty(selectedSet)) {
                 let atomArray = ic.defNames2Atoms[selectedSet];

                 for(let j = 0, jl = atomArray.length; j < jl; ++j) {
                     ic.hAtoms[atomArray[j]] = 1;
                 }
             }

             if(ic.defNames2Residues !== undefined && ic.defNames2Residues.hasOwnProperty(selectedSet)) {
                 let residueArrayTmp = ic.defNames2Residues[selectedSet];

                 let atomHash = {};
                 for(let j = 0, jl = residueArrayTmp.length; j < jl; ++j) {
                     atomHash = me.hashUtilsCls.unionHash(atomHash, ic.residues[residueArrayTmp[j]]);
                 }

                 ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, atomHash);
             }
           } // outer for

           ic.hlUpdateCls.updateHlAll(nameArray, bUpdateHlMenus);

           // show selected chains in annotation window
           ic.annotationCls.showAnnoSelectedChains();

           // clear commmand
           $("#" + ic.pre + "command").val("");
           $("#" + ic.pre + "command_name").val("");
           //$("#" + ic.pre + "command_desc").val("");

           // update the commands in the dialog
           for(let i = 0, il = nameArray.length; i < il; ++i) {
               ic.defNames2Atoms[nameArray[i]];
               ic.defNames2Residues[nameArray[i]];
               ic.defNames2Descr[nameArray[i]];

               if(i === 0) {
                 //$("#" + ic.pre + "command").val(atomCommand);
                 $("#" + ic.pre + "command").val('saved atoms ' + nameArray[i]);
                 $("#" + ic.pre + "command_name").val(nameArray[i]);
               }
               else {
                 let prevValue = $("#" + ic.pre + "command").val();
                 $("#" + ic.pre + "command").val(prevValue + ' ' + ic.setOperation + ' ' + nameArray[i]);

                 prevValue = $("#" + ic.pre + "command_name").val();
                 $("#" + ic.pre + "command_name").val(prevValue + ' ' + ic.setOperation + ' ' + nameArray[i]);
               }
           } // outer for
        }

        setHAtomsFromSets(nameArray, type) { let ic = this.icn3d; ic.icn3dui;
           for(let i = 0; i < nameArray.length; ++i) {
             let selectedSet = nameArray[i];

             this.setHAtomsFromSets_base(selectedSet, type);

             // sometimes the "resi" changed and thus the name changed
             //"sphere." + firstAtom.chain + ":" + me.utilsCls.residueName2Abbr(firstAtom.resn.substr(0, 3)).trim() + firstAtom.resi + "-" + radius + "A";
             if(Object.keys(ic.hAtoms).length == 0 && (selectedSet.split('.')[0] == 'sphere' || selectedSet.split('.')[0] == 'interactions')) {
                let pos = selectedSet.lastIndexOf('-');
                selectedSet = selectedSet.split('.')[0] + selectedSet.substr(pos);
                this.setHAtomsFromSets_base(selectedSet, type);
             }
           } // outer for
        }

        setHAtomsFromSets_base(selectedSet, type) { let ic = this.icn3d, me = ic.icn3dui;
             if(ic.defNames2Atoms !== undefined && ic.defNames2Atoms.hasOwnProperty(selectedSet)) {

                 let atomArray = ic.defNames2Atoms[selectedSet];
                 if(type === 'or') {
                     for(let j = 0, jl = atomArray.length; j < jl; ++j) {
                         ic.hAtoms[atomArray[j]] = 1;
                     }
                 }
                 else if(type === 'and') {
                     let atomHash = {};
                     for(let j = 0, jl = atomArray.length; j < jl; ++j) {
                         atomHash[atomArray[j]] = 1;
                     }

                     ic.hAtoms = me.hashUtilsCls.intHash(ic.hAtoms, atomHash);
                 }
                 else if(type === 'not') {
                     //for(let j = 0, jl = atomArray.length; j < jl; ++j) {
                     //    ic.hAtoms[atomArray[j]] = undefined;
                     //}

                     let atomHash = {};
                     for(let j = 0, jl = atomArray.length; j < jl; ++j) {
                         atomHash[atomArray[j]] = 1;
                     }

                     ic.hAtoms = me.hashUtilsCls.exclHash(ic.hAtoms, atomHash);
                 }
             }

             if(ic.defNames2Residues !== undefined && ic.defNames2Residues.hasOwnProperty(selectedSet)) {
                 let residueArrayTmp = ic.defNames2Residues[selectedSet];

                 let atomHash = {};
                 for(let j = 0, jl = residueArrayTmp.length; j < jl; ++j) {
                     atomHash = me.hashUtilsCls.unionHash(atomHash, ic.residues[residueArrayTmp[j]]);
                 }

                 if(type === 'or') {
                     ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, atomHash);
                 }
                 else if(type === 'and') {
                     ic.hAtoms = me.hashUtilsCls.intHash(ic.hAtoms, atomHash);
                 }
                 else if(type === 'not') {
                     ic.hAtoms = me.hashUtilsCls.exclHash(ic.hAtoms, atomHash);
                 }
             }
        }

        updateAdvancedCommands(nameArray, type) { let ic = this.icn3d; ic.icn3dui;
           // update the commands in the dialog
           let separator = ' ' + type + ' ';
           for(let i = 0, il = nameArray.length; i < il; ++i) {
               if(i === 0 && type == 'or') {
                 $("#" + ic.pre + "command").val('saved atoms ' + nameArray[i]);
                 $("#" + ic.pre + "command_name").val(nameArray[i]);
               }
               else {
                 let prevValue = $("#" + ic.pre + "command").val();
                 $("#" + ic.pre + "command").val(prevValue + separator + nameArray[i]);

                 prevValue = $("#" + ic.pre + "command_name").val();
                 $("#" + ic.pre + "command_name").val(prevValue + separator + nameArray[i]);
               }
           } // outer for
        }

        combineSets(orArray, andArray, notArray, commandname) { let ic = this.icn3d, me = ic.icn3dui;
           ic.hAtoms = {};
           
           this.setHAtomsFromSets(orArray, 'or');

           if(Object.keys(ic.hAtoms).length == 0) {
               ic.hAtoms = me.hashUtilsCls.cloneHash(ic.dAtoms);
           }

           this.setHAtomsFromSets(andArray, 'and');

           this.setHAtomsFromSets(notArray, 'not');

           // expensive to update, avoid it when loading script
           //ic.hlUpdateCls.updateHlAll();
           if(!ic.bInitial) ic.hlUpdateCls.updateHlAll();

           // show selected chains in annotation window
           ic.annotationCls.showAnnoSelectedChains();

           // clear commmand
           $("#" + ic.pre + "command").val("");
           $("#" + ic.pre + "command_name").val("");

           this.updateAdvancedCommands(orArray, 'or');
           this.updateAdvancedCommands(andArray, 'and');
           this.updateAdvancedCommands(notArray, 'not');

           if(commandname !== undefined) {
               let select = "select " + $("#" + ic.pre + "command").val();

               $("#" + ic.pre + "command_name").val(commandname);
               ic.selectionCls.addCustomSelection(Object.keys(ic.hAtoms), commandname, commandname, select, false);
           }
        }

        async commandSelect(postfix) { let ic = this.icn3d, me = ic.icn3dui;
               let select = $("#" + ic.pre + "command" + postfix).val();

               let commandname = $("#" + ic.pre + "command_name" + postfix).val().replace(/;/g, '_').replace(/\s+/g, '_');

               if(select) {
                   await ic.selByCommCls.selectByCommand(select, commandname, commandname);
                   me.htmlCls.clickMenuCls.setLogCmd('select ' + select + ' | name ' + commandname, true);
               }
        }

        clickCommand_apply() { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;
            me.myEventCls.onIds("#" + ic.pre + "command_apply", "click", async function(e) { thisClass.icn3d;
               e.preventDefault();

               await thisClass.commandSelect('');
            });

            me.myEventCls.onIds("#" + ic.pre + "command_apply2", "click", async function(e) { thisClass.icn3d;
               e.preventDefault();
               await thisClass.commandSelect('2');
            });

        }

        selectCombinedSets(strSets, commandname) { let ic = this.icn3d; ic.icn3dui;
            let idArray = strSets.split(' ');

            let orArray = [], andArray = [], notArray = [];
            let prevLabel = 'or';

            for(let i = 0, il = idArray.length; i < il; ++i) {
                // replace 1CD8_A_1 with 1CD8_A1
                let tmpArray = idArray[i].split('_');
                if(tmpArray.length == 3 && !isNaN(tmpArray[2])) {
                    idArray[i] = tmpArray[0] + '_' + tmpArray[1] + tmpArray[2];
                }

                if(idArray[i] === 'or' || idArray[i] === 'and' || idArray[i] === 'not') {
                    prevLabel = idArray[i];
                    continue;
                }
                else {
                    // make it backward compatible for names of defined sets containing atom serial by replacing the serial with 'auto' 
                    // start from iCn3D 3.21.0 on Jan 2023============
                    let nameArray = ['hbonds_', 'saltbridge_', 'halogen_', 'pi-cation_', 'pi-stacking_'];
                    for(let j = 0, jl = nameArray.length; j < jl; ++j) {
                        const re = new RegExp('^' + nameArray[j] + '\\d+$'); // use '\\'

                        if(idArray[i].match(re)) {
                            idArray[i] = nameArray[j] + 'auto';
                        }
                    }
                    // end============

                    if(prevLabel === 'or') {
                        orArray.push(idArray[i]);
                    }
                    else if(prevLabel === 'and') {
                        andArray.push(idArray[i]);
                    }
                    else if(prevLabel === 'not') {
                        notArray.push(idArray[i]);
                    }
                }
            }

            if(idArray !== null) this.combineSets(orArray, andArray, notArray, commandname);
        }

        clickModeswitch() { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;
            me.myEventCls.onIds("#" + ic.pre + "modeswitch", "click", function(e) {
                if($("#" + ic.pre + "modeswitch")[0] !== undefined && $("#" + ic.pre + "modeswitch")[0].checked) { // mode: selection
                    thisClass.setModeAndDisplay('selection');
                }
                else { // mode: all
                    thisClass.setModeAndDisplay('all');
                }
            });
        }

        setModeAndDisplay(mode) { let ic = this.icn3d, me = ic.icn3dui;
            if(mode === 'all') { // mode all
                this.setMode('all');

                // remember previous selection
                ic.prevHighlightAtoms = me.hashUtilsCls.cloneHash(ic.hAtoms);

               // select all
               me.htmlCls.clickMenuCls.setLogCmd("set mode all", true);

               ic.selectionCls.selectAll();

               ic.drawCls.draw();
            }
            else { // mode selection
                this.setMode('selection');

                // get the previous hAtoms
                if(ic.prevHighlightAtoms !== undefined) {
                    ic.hAtoms = me.hashUtilsCls.cloneHash(ic.prevHighlightAtoms);
                }
                else {
                    ic.selectionCls.selectAll();
                }

                me.htmlCls.clickMenuCls.setLogCmd("set mode selection", true);

                ic.hlUpdateCls.updateHlAll();
            }
        }

        setMode(mode) { let ic = this.icn3d; ic.icn3dui;
            if(mode === 'all') { // mode all
                // set text
                $("#" + ic.pre + "modeall").show();
                $("#" + ic.pre + "modeselection").hide();

                if($("#" + ic.pre + "modeswitch")[0] !== undefined) $("#" + ic.pre + "modeswitch")[0].checked = false;

                if($("#" + ic.pre + "style").hasClass('icn3d-modeselection')) $("#" + ic.pre + "style").removeClass('icn3d-modeselection');
                if($("#" + ic.pre + "color").hasClass('icn3d-modeselection')) $("#" + ic.pre + "color").removeClass('icn3d-modeselection');
                //if($("#" + ic.pre + "surface").hasClass('icn3d-modeselection')) $("#" + ic.pre + "surface").removeClass('icn3d-modeselection');
            }
            else { // mode selection
                //if(Object.keys(ic.hAtoms).length < Object.keys(ic.atoms).length) {
                    // set text
                    $("#" + ic.pre + "modeall").hide();
                    $("#" + ic.pre + "modeselection").show();

                    if($("#" + ic.pre + "modeswitch")[0] !== undefined) $("#" + ic.pre + "modeswitch")[0].checked = true;

                    if(!$("#" + ic.pre + "style").hasClass('icn3d-modeselection')) $("#" + ic.pre + "style").addClass('icn3d-modeselection');
                    if(!$("#" + ic.pre + "color").hasClass('icn3d-modeselection')) $("#" + ic.pre + "color").addClass('icn3d-modeselection');
                    //if(!$("#" + ic.pre + "surface").hasClass('icn3d-modeselection')) $("#" + ic.pre + "surface").addClass('icn3d-modeselection');

                    // show selected chains in annotation window
                    //ic.annotationCls.showAnnoSelectedChains();
                //}
            }
        }
        getAtomsFromOneSet(commandname) {  let ic = this.icn3d, me = ic.icn3dui;  // ic.pAtom is set already
           let residuesHash = {};
           // defined sets is not set up
           if(ic.defNames2Residues['proteins'] === undefined) {
               this.showSets();
           }
           //for(let i = 0, il = nameArray.length; i < il; ++i) {
               //var commandname = nameArray[i];
               if(Object.keys(ic.chains).indexOf(commandname) !== -1) {
                   residuesHash = me.hashUtilsCls.unionHash(residuesHash, ic.chains[commandname]);
               }
               else {
                   if(ic.defNames2Residues[commandname] !== undefined && ic.defNames2Residues[commandname].length > 0) {
                       for(let j = 0, jl = ic.defNames2Residues[commandname].length; j < jl; ++j) {
                           let resid = ic.defNames2Residues[commandname][j]; // return an array of resid
                           residuesHash = me.hashUtilsCls.unionHash(residuesHash, ic.residues[resid]);
                       }
                   }
                   if(ic.defNames2Atoms[commandname] !== undefined && ic.defNames2Atoms[commandname].length > 0) {
                       for(let j = 0, jl = ic.defNames2Atoms[commandname].length; j < jl; ++j) {
                           //var resid = ic.defNames2Atoms[commandname][j]; // return an array of serial
                           //residuesHash = me.hashUtilsCls.unionHash(residuesHash, ic.residues[resid]);
                           let serial = ic.defNames2Atoms[commandname][j]; // return an array of serial
                           residuesHash[serial] = 1;
                       }
                   }
               }
           //}
           return residuesHash;
        }
        
        getAtomsFromNameArray(nameArray) {  let ic = this.icn3d, me = ic.icn3dui;
            let selAtoms = {};
            for(let i = 0, il = nameArray.length; i < il; ++i) {
                if(nameArray[i] === 'non-selected') { // select all hAtoms
                   let currAtoms = {};
                   for(let i in ic.atoms) {
                       if(!ic.hAtoms.hasOwnProperty(i) && ic.dAtoms.hasOwnProperty(i)) {
                           currAtoms[i] = ic.atoms[i];
                       }
                   }
                   selAtoms = me.hashUtilsCls.unionHash(selAtoms, currAtoms);
                }
                else if(nameArray[i] === 'selected') {
                    selAtoms = me.hashUtilsCls.unionHash(selAtoms, me.hashUtilsCls.hash2Atoms(ic.hAtoms, ic.atoms) );
                }
                else {
                    selAtoms = me.hashUtilsCls.unionHash(selAtoms, me.hashUtilsCls.hash2Atoms(this.getAtomsFromOneSet(nameArray[i]), ic.atoms) );
                }
            }
            if(nameArray.length == 0) selAtoms = ic.atoms;
            return selAtoms;
        }

    }

    /**
     * @author Jack Lin <th3linja@yahoo.com> / https://github.com/ncbi/icn3d
     */

    class SelectCollections {
      constructor(icn3d) {
        this.icn3d = icn3d;
      }

      //Set the menu of defined sets with an array of defined names "commandnameArray".
      setAtomMenu(collection) {
        let ic = this.icn3d;
        ic.icn3dui;
        let html = "";
        
        Object.entries(collection).forEach(([name, structure], index) => {
          let atomHash;
          let [id, title, description, commands, pdb] = structure;

          if (
            ic.defNames2Atoms !== undefined &&
            ic.defNames2Atoms.hasOwnProperty(name)
          ) {
            let atomArray = ic.defNames2Atoms[name];

            if (atomArray.length > 0) ic.atoms[atomArray[0]];
          } else if (
            ic.defNames2Residues !== undefined &&
            ic.defNames2Residues.hasOwnProperty(name)
          ) {
            let residueArray = ic.defNames2Residues[name];
            if (residueArray.length > 0) {
              atomHash = ic.residues[residueArray[0]];
              if (atomHash) {
                ic.atoms[Object.keys(atomHash)[0]];
              }
            }
          }

          if (index === 0) {
            html += "<option value='" + name + "' selected='selected' data-description='" + description + "'>" + title + "</option>";
          } else {
            html += "<option value='" + name + "' data-description='" + description + "'>" + title + "</option>";
          }
        });

        return html;
      }

      reset() {
        let ic = this.icn3d;

        ic.atoms = {};

        ic.proteins = {};
        ic.nucleotides = {};
        ic.chemicals = {};
        ic.ions = {};
        ic.water = {};

        ic.structures = {};
        ic.chains = {};
        ic.chainsSeq = {};
        ic.residues = {};

        ic.defNames2Atoms = {};
        ic.defNames2Residues = {};

        ic.ssbondpnts = {};

        ic.bShowHighlight = undefined;
        ic.bResetSets = true;
      }

      dictionaryDifference(dict1, dict2) {
          const difference = {};

          for (let key in dict2) {
              if (!(key in dict1)) {
                  difference[key] = dict2[key];
              }
          }

          return difference;
      }

      clickStructure(collection) {
        let ic = this.icn3d,
          me = ic.icn3dui;
        let thisClass = this;

        //me.myEventCls.onIds("#" + ic.pre + "atomsCustom", "change", function(e) { let  ic = thisClass.icn3d;
        $("#" + ic.pre + "collections_menu").on("change", async function (e) {
          let ic = thisClass.icn3d;

          let nameArray = $(this).val();
          let nameStructure = $(this).find("option:selected").text();
          let selectedIndices = Array.from(this.selectedOptions).map(option => option.index);
          nameArray.reduce((map, name, i) => {
            map[name] = selectedIndices[i];
            return map;
          }, {});

          ic.nameArray = nameArray;

          if (nameArray !== null) {
            let bNoDuplicate = true;
            thisClass.reset();
            for (const name of nameArray) {
              if (!(name in ic.allData)) {
                ic.allData['prev'] = JSON.parse(JSON.stringify(ic.allData['all']));

                ic.atoms = ic.allData['all']['atoms'];
                
                ic.proteins = ic.allData['all']['proteins'];
                ic.nucleotides = ic.allData['all']['nucleotides'];
                ic.chemicals = ic.allData['all']['chemicals'];
                ic.ions = ic.allData['all']['ions'];
                ic.water = ic.allData['all']['water'];
      
                ic.structures = ic.allData['all']['structures'];
                ic.ssbondpnts = ic.allData['all']['ssbondpnts'];
                ic.residues = ic.allData['all']['residues'];
                ic.chains = ic.allData['all']['chains'];
                ic.chainsSeq = ic.allData['all']['chainsSeq'];
                ic.defalls2Atoms = ic.allData['all']['defalls2Atoms'];
                ic.defalls2Residues = ic.allData['all']['defalls2Residues'];

                async function loadStructure(pdb) {
                  await ic.resetConfig();
                  if (pdb) {
                    let bAppend = true;
                    if (Object.keys(ic.structures).length == 0) {
                      bAppend = false;
                    }
                    await ic.pdbParserCls.loadPdbData(ic.pdbCollection[name].join('\n'), undefined, undefined, bAppend);
                  } else {
                    await ic.chainalignParserCls.downloadMmdbAf(name, undefined, undefined, bNoDuplicate);
                  }
                }
                
                await loadStructure(collection[name][4]).then(() => {
                  ic.allData['all'] = {
                    'atoms': ic.atoms,
                    'proteins': ic.proteins,
                    'nucleotides': ic.nucleotides,
                    'chemicals': ic.chemicals,
                    'ions': ic.ions,
                    'water': ic.water,
                    'structures': ic.structures, // getSSExpandedAtoms
                    'ssbondpnts': ic.ssbondpnts,
                    'residues': ic.residues, // getSSExpandedAtoms
                    'chains': ic.chains,
                    'chainsSeq': ic.chainsSeq, //Sequences and Annotation
                    'defNames2Atoms': ic.defNames2Atoms,
                    'defNames2Residues': ic.defNames2Residues
                  };

                  ic.allData[name] = {
                    'title': ic.molTitle,
                    'atoms': thisClass.dictionaryDifference(ic.allData['prev']['atoms'], ic.atoms),
                    'proteins': thisClass.dictionaryDifference(ic.allData['prev']['proteins'], ic.proteins),
                    'nucleotides': thisClass.dictionaryDifference(ic.allData['prev']['nucleotides'], ic.nucleotides),
                    'chemicals': thisClass.dictionaryDifference(ic.allData['prev']['chemicals'], ic.chemicals),
                    'ions': thisClass.dictionaryDifference(ic.allData['prev']['ions'], ic.ions),
                    'water': thisClass.dictionaryDifference(ic.allData['prev']['water'], ic.water),
                    'structures': thisClass.dictionaryDifference(ic.allData['prev']['structures'], ic.structures), // getSSExpandedAtoms
                    'ssbondpnts': thisClass.dictionaryDifference(ic.allData['prev']['ssbondpnts'], ic.ssbondpnts),
                    'residues': thisClass.dictionaryDifference(ic.allData['prev']['residues'], ic.residues), // getSSExpandedAtoms
                    'chains': thisClass.dictionaryDifference(ic.allData['prev']['chains'], ic.chains),
                    'chainsSeq': thisClass.dictionaryDifference(ic.allData['prev']['chainsSeq'], ic.chainsSeq), //Sequences and Annotation
                    'defNames2Atoms': thisClass.dictionaryDifference(ic.allData['prev']['defNames2Atoms'], ic.defNames2Atoms),
                    'defNames2Residues': thisClass.dictionaryDifference(ic.allData['prev']['defNames2Residues'], ic.defNames2Residues)
                  };

                  thisClass.reset();
                });
              }
            }

            for (const name of nameArray) {
                ic.atoms = Object.assign(ic.atoms, ic.allData[name]['atoms']);
                
                ic.proteins = Object.assign(ic.proteins, ic.allData[name]['proteins']);
                ic.nucleotides = Object.assign(ic.nucleotides, ic.allData[name]['nucleotides']);
                ic.chemicals = Object.assign(ic.chemicals, ic.allData[name]['chemicals']);
                ic.ions = Object.assign(ic.ions, ic.allData[name]['ions']);
                ic.water = Object.assign(ic.water, ic.allData[name]['water']);

                ic.structures = Object.assign(ic.structures, ic.allData[name]['structures']);
                ic.ssbondpnts = Object.assign(ic.ssbondpnts, ic.allData[name]['ssbondpnts']);
                ic.residues = Object.assign(ic.residues, ic.allData[name]['residues']);
                ic.chains = Object.assign(ic.chains, ic.allData[name]['chains']);
                ic.chainsSeq = Object.assign(ic.chainsSeq, ic.allData[name]['chainsSeq']);
                ic.defNames2Atoms = Object.assign(ic.defNames2Atoms, ic.allData[name]['defNames2Atoms']);
                ic.defNames2Residues = Object.assign(ic.defNames2Residues, ic.allData[name]['defNames2Residues']);
                ic.dAtoms = me.hashUtilsCls.cloneHash(ic.atoms);
                ic.hAtoms = me.hashUtilsCls.cloneHash(ic.atoms);
                
              ic.molTitle = ic.allData[name]['title'];
              
              if (collection[name][3] !== undefined && collection[name][3].length > 0) {
                if (ic.allData[name]['commands'] == undefined) {
                  let commands = collection[name][3];
                  ic.allData[name]['commands'] = commands;
                }
              }

               if (ic.allData[name]['commands'] !== undefined) {   
                  for (const command of ic.allData[name]['commands']) {
                    me.htmlCls.clickMenuCls.setLogCmd(command, true);
                    await ic.applyCommandCls.applyCommand(command);
                  }
                }
                
            }
            
            ic.opts["color"] = (Object.keys(ic.structures).length == 1) ? "chain" : "structure";
            ic.setColorCls.setColorByOptions(ic.opts, ic.atoms);

            ic.transformCls.zoominSelection();
            ic.definedSetsCls.showSets();

            ic.bResetAnno = true;
            if(ic.bAnnoShown) {
              await ic.showAnnoCls.showAnnotations();

              ic.hlUpdateCls.updateHlAll(nameArray);
              // show selected chains in annotation window
              ic.annotationCls.showAnnoSelectedChains();
            }
            
            await ic.drawCls.draw();
            ic.saveFileCls.showTitle();

            me.htmlCls.clickMenuCls.setLogCmd("select structure " + "[" + nameStructure + "]", false);
            me.htmlCls.clickMenuCls.setLogCmd('load mmdbaf1 ' + nameArray, true);
          }
        });

        me.myEventCls.onIds(
          "#" + ic.pre + "collections_menu",
          "focus",
          function (e) {
            let ic = thisClass.icn3d;
            if (me.utilsCls.isMobile())
              $("#" + ic.pre + "collections_menu").val("");
          }
        );
      }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class LoadScript {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Run commands one after another. The commands can be semicolon ';' or new line '\n' separated.
        async loadScript(dataStr, bStatefile, bStrict) { let ic = this.icn3d; ic.icn3dui;
          if(!dataStr) return;
          
          // allow the "loading structure..." message to be shown while loading script
          ic.bCommandLoad = true;

          ic.bRender = false;
          ic.bStopRotate = true;
          
          // firebase dynamic links replace " " with "+". So convert it back
          dataStr =(bStatefile) ? dataStr.replace(/\+/g, ' ') : dataStr.replace(/\+/g, ' ').replace(/;/g, '\n');

          let preCommands = [];
          if(!bStrict && ic.commands.length > 0) preCommands[0] = ic.commands[0];

          let commandArray = dataStr.trim().split('\n');
          ic.commands = commandArray;

          let pos = commandArray[0].indexOf('command=');
          if(bStatefile && pos != -1) {
              let commandFirst = commandArray[0].substr(0, pos - 1);
              ic.commands.splice(0, 1, commandFirst);
          }
          
          //ic.commands = dataStr.trim().split('\n');
          ic.STATENUMBER = ic.commands.length;

          ic.commands = preCommands.concat(ic.commands);
          
          ic.STATENUMBER = ic.commands.length;

        /*
          if(bStatefile || ic.bReplay) {
              ic.CURRENTNUMBER = 0;
          }
          else {
              // skip the first loading step
              ic.CURRENTNUMBER = 1;
          }
        */

          ic.CURRENTNUMBER = 0;

          if(ic.bReplay) {
              await this.replayFirstStep(ic.CURRENTNUMBER);
          }
          else {
              await this.execCommands(ic.CURRENTNUMBER, ic.STATENUMBER-1, ic.STATENUMBER, bStrict);
          }
        }

        //Execute a list of commands. "steps" is the total number of commands.
        async execCommands(start, end, steps, bStrict) { let ic = this.icn3d; ic.icn3dui;
            ic.bRender = false;

            // fresh start
            if(!bStrict) ic.reinitAfterLoad();

            //ic.opts = me.hashUtilsCls.cloneHash(ic.opts);
            await this.execCommandsBase(start, end, steps);
        }

        getNameArray(command) { let ic = this.icn3d; ic.icn3dui;
            let paraArray = command.split(' | ');
            let nameArray = [];
            if(paraArray.length == 2) {
                nameArray = paraArray[1].split(',');
                ic.hAtoms = ic.definedSetsCls.getAtomsFromNameArray(nameArray);
            }

            return nameArray;
        }

        updateTransformation(steps) { let ic = this.icn3d; ic.icn3dui;
          let commandTransformation = (ic.commands[steps-1]) ? ic.commands[steps-1].split('|||') : [];

          if(commandTransformation.length == 2) {
              let transformation = JSON.parse(commandTransformation[1]);

              ic._zoomFactor = transformation.factor;

              ic.mouseChange.x = transformation.mouseChange.x;
              ic.mouseChange.y = transformation.mouseChange.y;

              ic.quaternion._x = transformation.quaternion._x;
              ic.quaternion._y = transformation.quaternion._y;
              ic.quaternion._z = transformation.quaternion._z;
              ic.quaternion._w = transformation.quaternion._w;
          }

          // ic.bRender = true;
          ic.drawCls.draw();
        }

        async execCommandsBase(start, end, steps, bFinalStep) { let ic = this.icn3d, me = ic.icn3dui;
          let thisClass = this;
          let i;

          for(i=start; i <= end; ++i) {
              let bFinalStep =(i === steps - 1) ? true : false;

              if(!ic.commands[i] || !ic.commands[i].trim()) {
                continue;
              }

              let nAtoms = (ic.atoms) ? Object.keys(ic.atoms).length : 0;

              if(nAtoms == 0 && ic.commands[i].indexOf('load') == -1) continue;

              let strArray = ic.commands[i].split("|||");
              let command = strArray[0].trim();
              // sometimes URL has an ID input, then load a structure in commands
              //if(ic.inputid) ic.bNotLoadStructure = true;
      
              if(command.indexOf('load') !== -1) {
                  if(end === 0 && start === end) {
                        if(ic.bNotLoadStructure) {
                            ic.hAtoms = me.hashUtilsCls.cloneHash(ic.atoms);

                            // end of all commands
                            if(1 === ic.commands.length) ic.bAddCommands = true;
                            if(bFinalStep) this.renderFinalStep(steps);                  
                        }
                        else {
                            await thisClass.applyCommandLoad(ic.commands[i]);
                            
                            // end of all commands
                            if(1 === ic.commands.length) ic.bAddCommands = true;
                            if(bFinalStep) thisClass.renderFinalStep(steps);
                      }
                      return;
                  }
                  else {
                        if(ic.bNotLoadStructure) {
                            ic.hAtoms = me.hashUtilsCls.cloneHash(ic.atoms);

                            // undo/redo requires render the first step
                            if(ic.backForward) this.renderFinalStep(1);
                        }
                        else {                    
                            await thisClass.applyCommandLoad(ic.commands[i]);

                            // undo/redo requires render the first step
                            if(ic.backForward) thisClass.renderFinalStep(1);
                        }
                  }
              }
              else if(command.indexOf('set map') == 0 && command.indexOf('set map wireframe') == -1) {
                  await thisClass.applyCommandMap(strArray[0].trim());
              }
              else if(command.indexOf('set emmap') == 0 && command.indexOf('set emmap wireframe') == -1) {
                  //set emmap percentage 70
                  let str = strArray[0].trim().substr(10);
                  let paraArray = str.split(" ");

                  if(paraArray.length == 2 && paraArray[0] == 'percentage') {
                    paraArray[1];

                    await thisClass.applyCommandEmmap(strArray[0].trim());
                  }
              }
              else if(command.indexOf('set phi') == 0) {
                  await ic.delphiCls.applyCommandPhi(strArray[0].trim());
              }
              else if(command.indexOf('set delphi') == 0) {
                  await ic.delphiCls.applyCommandDelphi(strArray[0].trim());
              }
              else if(command.indexOf('view annotations') == 0) { // the command may have "|||{"factor"...
                  if(Object.keys(ic.proteins).length > 0) {
                    await thisClass.applyCommandAnnotationsAndCddSite(strArray[0].trim());
                  }
              }
              else if(command.indexOf('set annotation clinvar') == 0 ) { // the command may have "|||{"factor"...
                  if(Object.keys(ic.proteins).length > 0) {
                    await thisClass.applyCommandClinvar(strArray[0].trim());
                  }
              }
              else if(command.indexOf('set annotation snp') == 0) { // the command may have "|||{"factor"...
                  if(Object.keys(ic.proteins).length > 0 ) {
                    await thisClass.applyCommandSnp(strArray[0].trim());
                  }
              }
              else if(command.indexOf('set annotation ptm') == 0 ) { // the command may have "|||{"factor"...
                if(Object.keys(ic.proteins).length > 0) {
                    await thisClass.applyCommandPTM(strArray[0].trim());
                }
              }
              // else if(command.indexOf('ig refnum on') == 0 ) { 
              //   await ic.refnumCls.showIgRefNum();
              // }
              else if(command.indexOf('ig template') == 0 ) { 
                let template = command.substr(command.lastIndexOf(' ') + 1);
                await me.htmlCls.clickMenuCls.setIgTemplate(template);
              }
              else if(command.indexOf('set annotation 3ddomain') == 0) { // the command may have "|||{"factor"...
                  if(Object.keys(ic.proteins).length > 0) {
                      thisClass.applyCommand3ddomain(strArray[0].trim());   
                  }
              }
              else if(command.indexOf('set annotation all') == 0) { // the command may have "|||{"factor"...
                if(Object.keys(ic.proteins).length > 0) {
                    await thisClass.applyCommandClinvar(strArray[0].trim());
                    await thisClass.applyCommandSnp(strArray[0].trim());
                    thisClass.applyCommand3ddomain(strArray[0].trim());
                }

                await ic.annotationCls.setAnnoTabAll();
              }
              else if(command.indexOf('view interactions') == 0 && me.cfg.align !== undefined) { // the command may have "|||{"factor"...
                  await thisClass.applyCommandViewinteraction(strArray[0].trim());
              }
              else if(command.indexOf('view 2d depiction') == 0) { // the command may have "|||{"factor"...
                await ic.ligplotCls.drawLigplot(ic.atoms, true);
              }
              else if(command.indexOf('symmetry') == 0) {
                ic.bAxisOnly = false;

                let title = command.substr(command.indexOf(' ') + 1);
                ic.symmetrytitle =(title === 'none') ? undefined : title;

                if(title !== 'none') {
                    await ic.symdCls.retrieveSymmetry(Object.keys(ic.structures)[0]);
                }

                ic.drawCls.draw();
              }
              else if(command.indexOf('symd symmetry') == 0) {
                ic.bAxisOnly = false;

                await ic.symdCls.applyCommandSymd(command);

                ic.drawCls.draw();
              }
              else if(command.indexOf('scap') == 0) {
                await ic.scapCls.applyCommandScap(command);
              }
              else if(command.indexOf('realign on seq align') == 0) {
                this.getNameArray(command);

                await thisClass.applyCommandRealign(command);
              }
              else if(command.indexOf('realign on structure align msa') == 0) {
                let nameArray = this.getNameArray(command);

                me.cfg.aligntool = 'vast';

                await ic.realignParserCls.realignOnStructAlignMsa(nameArray);
              }
              else if(command.indexOf('realign on structure align') == 0) {
                this.getNameArray(command);

                me.cfg.aligntool = 'vast';
                await ic.realignParserCls.realignOnStructAlign();
              }
              else if(command.indexOf('realign on tmalign msa') == 0) {
                let nameArray = this.getNameArray(command);

                me.cfg.aligntool = 'tmalign';

                await ic.realignParserCls.realignOnStructAlignMsa(nameArray);
              }
              else if(command.indexOf('realign on tmalign') == 0) {
                this.getNameArray(command);

                me.cfg.aligntool = 'tmalign';

                await ic.realignParserCls.realignOnStructAlign();
              }
              else if(command.indexOf('realign on vastplus') == 0) {
                thisClass.getHAtoms(ic.commands[i]);

                await ic.vastplusCls.realignOnVastplus();
              }
              else if(command.indexOf('graph interaction pairs') == 0) {
                await thisClass.applyCommandGraphinteraction(command);
              }
              else if(command.indexOf('cartoon 2d domain') == 0) {
                ic.bRender = true;
                thisClass.updateTransformation(steps);
                await thisClass.applyCommandCartoon2d(command);
                ic.bRender = false;
              }
              else if(command.indexOf('set half pae map') == 0) {
                await thisClass.applyCommandAfmap(command);
              }
              else if(command.indexOf('set full pae map') == 0) {
                await thisClass.applyCommandAfmap(command, true);
              }
              else if(command.indexOf('export pqr') == 0) {
                await me.htmlCls.setHtmlCls.exportPqr();
              }
              else if(command.indexOf('cartoon 2d chain') == 0 || command.indexOf('cartoon 2d secondary') == 0) {
                let pos = command.lastIndexOf(' ');
                let type = command.substr(pos + 1);
        
                ic.bRender = true;
                thisClass.updateTransformation(steps);
                await ic.cartoon2dCls.draw2Dcartoon(type);
                ic.bRender = false;
              }
              else if(command.indexOf('add msa track') == 0) {
                //add msa track | chainid " + chainid + " | startpos " + startpos + " | type " + type + " | fastaList " + fastaList 
                let paraArray = command.split(' | ');
        
                let chainid = paraArray[1].substr(8);
                let startpos = paraArray[2].substr(9);
                let type = paraArray[3].substr(5);
                let fastaList = paraArray[4].substr(10);

                if($("#" + ic.pre + "anno_custom")[0]) {
                    $("#" + ic.pre + "anno_custom")[0].checked = true;
                }
                $("[id^=" + ic.pre + "custom]").show();

                await ic.addTrackCls.addMsaTracks(chainid, startpos, type, fastaList);
              }
              else if(command.indexOf('add exon track') == 0) {
                //add exon track | chainid " + chainid + " | geneid " + geneid + " | startpos " + startpos + " | type " + type
                let paraArray = command.split(' | ');

                let chainid = paraArray[1].substr(8);
                let geneid = paraArray[2].substr(7);
                let startpos = parseInt(paraArray[3].substr(9));
                let type = paraArray[4].substr(5);

                if($("#" + ic.pre + "anno_custom")[0]) {
                    $("#" + ic.pre + "anno_custom")[0].checked = true;
                }
                $("[id^=" + ic.pre + "custom]").show();

                await ic.addTrackCls.addExonTracks(chainid, geneid, startpos, type);
              }
              else {
                await ic.applyCommandCls.applyCommand(ic.commands[i]);
              }
          }

          //if(i === steps - 1) {
          if(i === steps || bFinalStep) {
              this.renderFinalStep(i);
          }
        }

        pressCommandtext() { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;
            $("#" + ic.pre + "logtext").keypress(async function(e) { let ic = thisClass.icn3d;
               ic.bAddLogs = false; // turn off log
               let code =(e.keyCode ? e.keyCode : e.which);
               if(code == 13) { //Enter keycode
                  e.preventDefault();
                  let dataStr = $(this).val();
                  ic.bRender = true;
                  let commandArray = dataStr.split('\n');

                  let prevLogLen = ic.logs.length;
                  for(let i = prevLogLen, il = commandArray.length; i < il; ++i) {
                      let lastCommand = (i == prevLogLen) ? commandArray[i].substr(2).trim() : commandArray[i].trim(); // skip "> "
                      if(lastCommand === '') continue;

                      ic.logs.push(lastCommand);
                      //$("#" + ic.pre + "logtext").val("> " + ic.logs.join("\n> ") + "\n> ").scrollTop($("#" + ic.pre + "logtext")[0].scrollHeight);
                      //if(lastCommand !== '') {
                        let transformation = {};
                        transformation.factor = ic._zoomFactor;
                        transformation.mouseChange = ic.mouseChange;
                        transformation.quaternion = ic.quaternion;
                        ic.commands.push(lastCommand + '|||' + ic.transformCls.getTransformationStr(transformation));
                        ic.optsHistory.push(me.hashUtilsCls.cloneHash(ic.opts));
                        ic.optsHistory[ic.optsHistory.length - 1].hlatomcount = Object.keys(ic.hAtoms).length;
                        if(me.utilsCls.isSessionStorageSupported()) ic.setStyleCls.saveCommandsToSession();
                        ic.STATENUMBER = ic.commands.length;
                        if(lastCommand.indexOf('load') !== -1) {
                            await thisClass.applyCommandLoad(lastCommand);
                        }
                        else if(lastCommand.indexOf('set map') !== -1 && lastCommand.indexOf('set map wireframe') === -1) {
                            await thisClass.applyCommandMap(lastCommand);
                        }
                        else if(lastCommand.indexOf('set emmap') !== -1 && lastCommand.indexOf('set emmap wireframe') === -1) {
                            await thisClass.applyCommandEmmap(lastCommand);
                        }
                        else if(lastCommand.indexOf('set phi') !== -1) {
                            await ic.delphiCls.applyCommandPhi(lastCommand);
                        }
                        else if(lastCommand.indexOf('set delphi') !== -1) {
                            await ic.delphiCls.applyCommandDelphi(lastCommand);
                        }
                        else if(lastCommand.indexOf('view annotations') == 0
                          //|| lastCommand.indexOf('set annotation cdd') == 0
                          //|| lastCommand.indexOf('set annotation site') == 0
                          ) {
                            await thisClass.applyCommandAnnotationsAndCddSite(lastCommand);
                        }
                        else if(lastCommand.indexOf('set annotation clinvar') == 0 ) {
                            await thisClass.applyCommandClinvar(lastCommand);
                        }
                        else if(lastCommand.indexOf('set annotation snp') == 0) {
                            await thisClass.applyCommandSnp(lastCommand);
                        }
                        else if(lastCommand.indexOf('set annotation ptm') == 0) {
                            await thisClass.applyCommandPTM(lastCommand);
                        }
                        else if(lastCommand.indexOf('ig refnum on') == 0) {
                            // await ic.refnumCls.showIgRefNum();
                            ic.bRunRefnumAgain = true;

                            if(!ic.bAnnoShown) await ic.showAnnoCls.showAnnotations();
                            await ic.annotationCls.setAnnoTabIg(true);

                            ic.bRunRefnumAgain = false;
                        }
                        else if(lastCommand.indexOf('set annotation 3ddomain') == 0) {
                            thisClass.applyCommand3ddomain(lastCommand);
                        }
                        else if(lastCommand.indexOf('set annotation all') == 0) {
                            await thisClass.applyCommandClinvar(lastCommand);
                            await thisClass.applyCommandSnp(lastCommand);
                            thisClass.applyCommand3ddomain(lastCommand);
                            await ic.annotationCls.setAnnoTabAll();
                        }
                        else if(lastCommand.indexOf('view interactions') == 0 && me.cfg.align !== undefined) {
                            await thisClass.applyCommandViewinteraction(lastCommand);
                        }
                        else if(lastCommand.indexOf('view 2d depiction') == 0) {
                          await ic.ligplotCls.drawLigplot(ic.atoms, true);
                        }
                        else if(lastCommand.indexOf('symmetry') == 0) {
                            let title = lastCommand.substr(lastCommand.indexOf(' ') + 1);
                            ic.symmetrytitle =(title === 'none') ? undefined : title;
                            if(title !== 'none') {
                                if(ic.symmetryHash === undefined) {
                                    await ic.symdCls.retrieveSymmetry(Object.keys(ic.structures)[0]);
                                }
                            }
                        }
                        else if(lastCommand.indexOf('symd symmetry') == 0) {
                            await ic.symdCls.applyCommandSymd(lastCommand);
                        }
                        else if(lastCommand.indexOf('scap ') == 0) {
                            await ic.scapCls.applyCommandScap(lastCommand);
                        }
                        else if(lastCommand.indexOf('realign on seq align') == 0) {
                            let paraArray = lastCommand.split(' | ');
                            if(paraArray.length == 2) {
                                let nameArray = paraArray[1].split(',');
                                ic.hAtoms = ic.definedSetsCls.getAtomsFromNameArray(nameArray);
                            }
                            await thisClass.applyCommandRealign(lastCommand);
                        }
                        else if(lastCommand.indexOf('realign on structure align') == 0) {
                            let paraArray = lastCommand.split(' | ');
                            if(paraArray.length == 2) {
                                let nameArray = paraArray[1].split(',');
                                ic.hAtoms = ic.definedSetsCls.getAtomsFromNameArray(nameArray);
                            }

                            me.cfg.aligntool = 'vast';

                            await thisClass.applyCommandRealignByStruct(lastCommand);
                        }
                        else if(lastCommand.indexOf('realign on tmalign') == 0) {
                            let paraArray = lastCommand.split(' | ');
                            if(paraArray.length == 2) {
                                let nameArray = paraArray[1].split(',');
                                ic.hAtoms = ic.definedSetsCls.getAtomsFromNameArray(nameArray);
                            }
                            
                            me.cfg.aligntool = 'tmalign';

                            await thisClass.applyCommandRealignByStruct(lastCommand);
                        }
                        else if(lastCommand.indexOf('realign on vastplus') == 0) {
                            let paraArray = lastCommand.split(' | ');
                            if(paraArray.length == 2) {
                                let nameArray = paraArray[1].split(',');
                                ic.hAtoms = ic.definedSetsCls.getAtomsFromNameArray(nameArray);
                            }
                            
                            await ic.vastplusCls.realignOnVastplus();
                        }
                        else if(lastCommand.indexOf('graph interaction pairs') == 0) {
                            await thisClass.applyCommandGraphinteraction(lastCommand);
                        }
                        else {
                            await ic.applyCommandCls.applyCommand(lastCommand + '|||' + ic.transformCls.getTransformationStr(transformation));
                        }
                        //ic.selectionCls.saveSelectionIfSelected();
                        //ic.drawCls.draw();
                      //} // if
                  } // for

                  ic.selectionCls.saveSelectionIfSelected();
                  ic.drawCls.draw();

                  $("#" + ic.pre + "logtext").val("> " + ic.logs.join("\n> ") + "\n> ").scrollTop($("#" + ic.pre + "logtext")[0].scrollHeight);
               }
               ic.bAddLogs = true;
            });
        }

        //Execute the command to load a structure. This step is different from the rest steps since
        //it has to finish before the rest steps start.
        async applyCommandLoad(commandStr) { let ic = this.icn3d, me = ic.icn3dui;

          // allow multiple load
          //if(ic.atoms !== undefined && Object.keys(ic.atoms).length > 0) return;

          // chain functions together
    ///      ic.deferred2 = $.Deferred(function() {
          ic.bAddCommands = false;
          let commandTransformation = commandStr.split('|||');

          let commandOri = commandTransformation[0].replace(/\s\s/g, ' ').trim();
          let command = commandOri; //.toLowerCase();

          if(command.indexOf('load') !== -1) { // 'load pdb [pdbid]'
            let load_parameters = command.split(' | ');
            let loadStr = load_parameters[0];

            // do not reset me.cfg.inpara from "command=..." part if it was not empty
            if(load_parameters.length > 1 && !me.cfg.inpara) {
                let firstSpacePos = load_parameters[load_parameters.length - 1].indexOf(' ');
                me.cfg.inpara = load_parameters[load_parameters.length - 1].substr(firstSpacePos + 1);
                if(me.cfg.inpara === 'undefined') {
                    me.cfg.inpara = '';
                }
            }

            // load pdb, mmcif, mmdb, cid
            let id = loadStr.substr(loadStr.lastIndexOf(' ') + 1);
            if(id.length == 4) id = id.toUpperCase();

            // skip loading the structure if 
            // 1. PDB was in the iCn3D PNG Image file
            // 2. it was loaded before
            let idArray = id.split(',');
            let idNew = '';
            for(let i = 0, il = idArray.length; i < il; ++i) {
              if(!(ic.structures && (ic.structures.hasOwnProperty(idArray[i]) 
                  || ic.structures.hasOwnProperty(idArray[i].toLowerCase()) 
                  || ic.structures.hasOwnProperty(idArray[i].toUpperCase())
                  ) )) {
                if(idNew) idNew += ',';
                idNew += idArray[i];
              }
            }
            id = idNew;
            if(ic.bInputPNGWithData || !id) return;

            ic.inputid = id;
            if(command.indexOf('load mmtf') !== -1) {
              me.cfg.mmtfid = id;
              
              await ic.bcifParserCls.downloadBcif(id);
            }
            else if(command.indexOf('load bcif') !== -1) {
              me.cfg.bcifid = id;
              
              await ic.bcifParserCls.downloadBcif(id);
            }
            else if(command.indexOf('load pdb') !== -1) {
              me.cfg.pdbid = id;

              await ic.pdbParserCls.downloadPdb(id);
            }
            else if(command.indexOf('load af') !== -1) {
              me.cfg.afid = id;  
              await ic.pdbParserCls.downloadPdb(id, true);
            }
            else if(command.indexOf('load opm') !== -1) {
              me.cfg.opmid = id;
              await ic.opmParserCls.downloadOpm(id);
            }
            else if(command.indexOf('load mmcif') !== -1) {
              me.cfg.mmcifid = id;
              await ic.mmcifParserCls.downloadMmcif(id);
            }
            else if(command.indexOf('load mmdb ') !== -1 || command.indexOf('load mmdb1 ') !== -1) {
              me.cfg.mmdbid = id;
              me.cfg.bu = 1;

              await ic.mmdbParserCls.downloadMmdb(id);
            }
            else if(command.indexOf('load mmdb0') !== -1) {
                me.cfg.mmdbid = id;
                me.cfg.bu = 0;
      
                await ic.mmdbParserCls.downloadMmdb(id);
            }
            else if(command.indexOf('load mmdbaf1') !== -1) {
                me.cfg.mmdbafid = id;
                me.cfg.bu = 1;
      
                await ic.chainalignParserCls.downloadMmdbAf(id);
            }
            else if(command.indexOf('load mmdbaf0') !== -1) {
                me.cfg.mmdbafid = id;
                me.cfg.bu = 0;

                await ic.chainalignParserCls.downloadMmdbAf(id);
            }
            else if(command.indexOf('load gi') !== -1) {
                me.cfg.gi = id;
                await ic.mmdbParserCls.downloadGi(id);
            }
            else if(command.indexOf('load refseq') !== -1) {
                me.cfg.refseqid = id;
                await ic.mmdbParserCls.downloadRefseq(id);
            }
            else if(command.indexOf('load protein') !== -1) {
                me.cfg.protein = id;
                await ic.mmdbParserCls.downloadProteinname(id);
            }
            else if(command.indexOf('load seq_struct_ids ') !== -1) {
              ic.bSmithwm = false;
              ic.bLocalSmithwm = false;
              await ic.mmdbParserCls.downloadBlast_rep_id(id);
            }
            else if(command.indexOf('load seq_struct_ids_smithwm ') !== -1) {
                ic.bSmithwm = true;
                await ic.mmdbParserCls.downloadBlast_rep_id(id);
            }
            else if(command.indexOf('load seq_struct_ids_local_smithwm ') !== -1) {
                ic.bLocalSmithwm = true;
                await ic.mmdbParserCls.downloadBlast_rep_id(id);
            }
            else if(command.indexOf('load cid') !== -1) {
              me.cfg.cid = id;
              await ic.sdfParserCls.downloadCid(id);
            }
            else if(command.indexOf('load smiles') !== -1) {
              me.cfg.smiles = id;
              await ic.sdfParserCls.downloadSmiles(id);
            }
            else if(command.indexOf('load alignment') !== -1) {
              me.cfg.align = id;

              if(me.cfg.inpara || me.cfg.inpara.indexOf('atype=2') == -1) {
                await ic.alignParserCls.downloadAlignment(me.cfg.align);
              }
              else {
                let vastplusAtype = 2; // Tm-align
                await ic.chainalignParserCls.downloadMmdbAf(me.cfg.align, undefined, vastplusAtype);
              }
            }
            else if(command.indexOf('load chainalignment') !== -1) {
              //load chainalignment [id] | resnum [resnum] | resdef [resdef] | aligntool [aligntool] | parameters [inpara] | resrange [resrange] 
              let urlArray = command.split(" | ");
              if(urlArray.length > 1 && urlArray[1].indexOf('resnum') != -1) {
                    me.cfg.resnum = urlArray[1].substr(urlArray[1].indexOf('resnum') + 7);
              }
              if(urlArray.length > 2 && urlArray[2].indexOf('resdef') != -1) {
                    me.cfg.resdef = urlArray[2].substr(urlArray[2].indexOf('resdef') + 7);
              }
              if(urlArray.length > 3 && urlArray[3].indexOf('aligntool') != -1) {
                    me.cfg.aligntool = urlArray[3].substr(urlArray[3].indexOf('aligntool') + 10);
              }
              if(urlArray.length > 5 && urlArray[5].indexOf('resrange') != -1) {
                me.cfg.resrange = urlArray[5].substr(urlArray[5].indexOf('resrange') + 9);
              }

              me.cfg.chainalign = id;
              await ic.chainalignParserCls.downloadChainalignment(id);
            }
            else if(command.indexOf('load url') !== -1) {
                let typeStr = load_parameters[1]; // type pdb
                let pos =(typeStr !== undefined) ? typeStr.indexOf('type ') : -1;
                let type = 'pdb';

                if(pos !== -1) {
                    type = typeStr.substr(pos + 5);
                }

                me.cfg.url = id;
                await ic.pdbParserCls.downloadUrl(id, type);
            }
          }

          ic.bAddCommands = true;
    ///      }); // end of me.deferred = $.Deferred(function() {

    ///      return ic.deferred2.promise();
        }

        //Apply the command to show electron density map.
        async applyCommandMap(command) { let ic = this.icn3d; ic.icn3dui;

          // chain functions together
        //   ic.deferredMap = $.Deferred(function() { let ic = thisClass.icn3d;
              //"set map 2fofc sigma 1.5"
              // or "set map 2fofc sigma 1.5 | [url]"

              // added more para later
              //"set map 2fofc sigma 1.5 file dsn6"
              // or "set map 2fofc sigma 1.5 file dsn6 | [url]"
              let urlArray = command.split(" | ");

              let str = urlArray[0].substr(8);
              let paraArray = str.split(" ");

              //if(paraArray.length == 3 && paraArray[1] == 'sigma') {
              if(paraArray[1] == 'sigma') {
                  let sigma = paraArray[2];
                  let type = paraArray[0];

                  let fileType = 'dsn6';
                  if(paraArray.length == 5) fileType = paraArray[4];

                  if(urlArray.length == 2) {
                    let bInputSigma = true;
                    if(fileType == 'dsn6') {
                      // await ic.dsn6ParserCls.dsn6ParserBase(urlArray[1], type, sigma, 'url', bInputSigma);
                      await ic.densityCifParserCls.densityCifParserBase(urlArray[1], type, sigma, 'url', bInputSigma);
                    }
                    else if(fileType == 'ccp4') {
                      await ic.ccp4ParserCls.ccp4ParserBase(urlArray[1], type, sigma, 'url', bInputSigma);
                    }
                    else if(fileType == 'mtz') {
                      await ic.mtzParserCls.mtzParserBase(urlArray[1], type, sigma, 'url', bInputSigma);
                    }
                    else if(fileType == 'rcsbmtz') {
                      await ic.mtzParserCls.mtzParserBase(urlArray[1], type, sigma, 'url', bInputSigma, true);
                    }
                  }
                  else {
                    // await ic.dsn6ParserCls.dsn6Parser(ic.inputid, type, sigma);
                    await ic.densityCifParserCls.densityCifParser(ic.inputid, type, sigma);
                  }
              }
        //   }); // end of me.deferred = $.Deferred(function() {

        //   return ic.deferredMap.promise();
        }

        //Apply the command to show EM density map.
        async applyCommandEmmap(command) { let ic = this.icn3d; ic.icn3dui;

          // chain functions together
        //   ic.deferredEmmap = $.Deferred(function() { let ic = thisClass.icn3d;
              let str = command.substr(10);
              let paraArray = str.split(" ");

              if(paraArray.length == 2 && paraArray[0] == 'percentage') {
                  let percentage = paraArray[1];
                  let type = 'em';

                  await ic.densityCifParserCls.densityCifParser(ic.inputid, type, percentage, ic.emd);
              }
        //   }); // end of me.deferred = $.Deferred(function() {

        //   return ic.deferredEmmap.promise();
        }

        async applyCommandRealign(command) { let ic = this.icn3d; ic.icn3dui;
            await ic.realignParserCls.realignOnSeqAlign();
        }

        async applyCommandRealignByStruct(command) { let ic = this.icn3d; ic.icn3dui;
          ic.drawCls.draw();
          await ic.realignParserCls.realignOnStructAlign();
        }

        async applyCommandAfmap(command, bFull) { let ic = this.icn3d; ic.icn3dui;
          let afid = command.substr(command.lastIndexOf(' ') + 1);
         
          await ic.contactMapCls.afErrorMap(afid, bFull);
        }

        async applyCommandGraphinteraction(command) { let ic = this.icn3d; ic.icn3dui;
          let paraArray = command.split(' | ');
          if(paraArray.length >= 3) {
              let setNameArray = paraArray[1].split(' ');
              let nameArray2 = setNameArray[0].split(',');
              let nameArray = setNameArray[1].split(',');

              let bHbond = paraArray[2].indexOf('hbonds') !== -1;
              let bSaltbridge = paraArray[2].indexOf('salt bridge') !== -1;
              let bInteraction = paraArray[2].indexOf('interactions') !== -1;

              let bHalogen = paraArray[2].indexOf('halogen') !== -1;
              let bPication = paraArray[2].indexOf('pi-cation') !== -1;
              let bPistacking = paraArray[2].indexOf('pi-stacking') !== -1;

              let bHbondCalc;
              if(paraArray.length >= 4) {
                  bHbondCalc =(paraArray[3] == 'true') ? true : false;
              }

              ic.applyCommandCls.setStrengthPara(paraArray);

              await ic.viewInterPairsCls.viewInteractionPairs(nameArray2, nameArray, bHbondCalc, 'graph',
                  bHbond, bSaltbridge, bInteraction, bHalogen, bPication, bPistacking);
          }
        }

        async applyCommandCartoon2d(command) { let ic = this.icn3d; ic.icn3dui;
            let type = command.substr(command.lastIndexOf(' ') + 1);
            await ic.cartoon2dCls.draw2Dcartoon(type);
        }

        //The annotation window calls many Ajax calls. Thus the command "view interactions"
        //(in Share Link or loading state file) is handled specially to wait for the Ajax calls
        //to finish before executing the next command.
        async applyCommandAnnotationsAndCddSite(command) { let ic = this.icn3d; ic.icn3dui;
            if(command == "view annotations") {
                //if(me.cfg.showanno === undefined || !me.cfg.showanno) {
                    await ic.showAnnoCls.showAnnotations();
                //}
            }
        }

        async applyCommandClinvar(command) { let ic = this.icn3d; ic.icn3dui;
            // chain functions together
            let pos = command.lastIndexOf(' '); // set annotation clinvar
            command.substr(pos + 1);
            
            await ic.annotationCls.setAnnoTabClinvar();
        }

        async applyCommandSnp(command) { let ic = this.icn3d; ic.icn3dui;
            // chain functions together
            let pos = command.lastIndexOf(' '); // set annotation clinvar
            command.substr(pos + 1);
            
            await ic.annotationCls.setAnnoTabSnp();
        }

        async applyCommandPTM(command) { let ic = this.icn3d; ic.icn3dui;
            // chain functions together
            let pos = command.lastIndexOf(' '); // set annotation clinvar
            command.substr(pos + 1);
      
            await ic.annotationCls.setAnnoTabPTM();
        }

        applyCommand3ddomain(command) { let ic = this.icn3d; ic.icn3dui;
            // chain functions together
            let pos = command.lastIndexOf(' ');
            let type = command.substr(pos + 1);
        
            if(type == '3ddomain' || type == 'all') {
                ic.annotationCls.setAnnoTab3ddomain();
            }
        }

        async applyCommandViewinteraction(command) { let ic = this.icn3d, me = ic.icn3dui;
            // chain functions together
            if(me.cfg.align !== undefined || me.cfg.chainalign !== undefined) {
                let structureArray = Object.keys(ic.structures);
                await ic.ParserUtilsCls.set2DDiagramsForAlign(structureArray[0].toUpperCase(), structureArray[1].toUpperCase());
            }
        }

        //When reading a list of commands, apply transformation at the last step.
        async renderFinalStep(steps) { let ic = this.icn3d, me = ic.icn3dui;
            // enable ic.ParserUtilsCls.hideLoading
            ic.bCommandLoad = false;

            // hide "loading ..."
            ic.ParserUtilsCls.hideLoading();

            //ic.bRender = true;

            // end of all commands
            if(steps + 1 === ic.commands.length) ic.bAddCommands = true;


            ic.bRender = true;

            let commandTransformation = (ic.commands[steps-1]) ? ic.commands[steps-1].split('|||') : [];

            if(commandTransformation.length == 2) {
                let transformation = JSON.parse(commandTransformation[1]);

                ic._zoomFactor = transformation.factor;

                ic.mouseChange.x = transformation.mouseChange.x;
                ic.mouseChange.y = transformation.mouseChange.y;

                ic.quaternion._x = transformation.quaternion._x;
                ic.quaternion._y = transformation.quaternion._y;
                ic.quaternion._z = transformation.quaternion._z;
                ic.quaternion._w = transformation.quaternion._w;
            }

            ic.selectionCls.oneStructurePerWindow();

            // simple if all atoms are modified
            //if( me.cfg.command === undefined &&(steps === 1 ||(Object.keys(ic.hAtoms).length === Object.keys(ic.atoms).length) ||(ic.optsHistory[steps - 1] !== undefined && ic.optsHistory[steps - 1].hasOwnProperty('hlatomcount') && ic.optsHistory[steps - 1].hlatomcount === Object.keys(ic.atoms).length) ) ) {
            if(steps === 1
              || (ic.hAtoms && ic.atoms && Object.keys(ic.hAtoms).length === Object.keys(ic.atoms).length)
              || (ic.optsHistory[steps - 1] !== undefined && ic.optsHistory[steps - 1].hasOwnProperty('hlatomcount') && ic.optsHistory[steps - 1].hlatomcount === Object.keys(ic.atoms).length) ) {
        // the following code caused problem for many links,e.g., https://www.ncbi.nlm.nih.gov/Structure/icn3d/share.html?17g3r1JDvZ7ZL39e6
        //        if(steps === 1) {
                    // assign styles and color using the options at that stage
        //            ic.setStyleCls.setAtomStyleByOptions(ic.optsHistory[steps - 1]);
        //            ic.setColorCls.setColorByOptions(ic.optsHistory[steps - 1], ic.hAtoms);
        //        }

                if(ic.optsHistory.length >= steps) {
                    let pkOption = ic.optsHistory[steps - 1].pk;
                    if(pkOption === 'no') {
                        ic.pk = 0;
                    }
                    else if(pkOption === 'atom') {
                        ic.pk = 1;
                    }
                    else if(pkOption === 'residue') {
                        ic.pk = 2;
                    }
                    else if(pkOption === 'strand') {
                        ic.pk = 3;
                    }

        // the following code caused problem for many links,e.g., https://www.ncbi.nlm.nih.gov/Structure/icn3d/share.html?17g3r1JDvZ7ZL39e6
        //            if(steps === 1) {
        //                ic.setColorCls.applyOriginalColor();
        //            }

                    ic.hlUpdateCls.updateHlAll();

                    // caused some problem with the following line
        //            $.extend(ic.opts, ic.optsHistory[steps - 1]);
                    ic.drawCls.draw();
                }
                else {
                    ic.hlUpdateCls.updateHlAll();

                    ic.drawCls.draw();
                }
            }
            else { // more complicated if partial atoms are modified
                ic.hlUpdateCls.updateHlAll();

                ic.drawCls.draw();
            }

            if(me.cfg.closepopup || me.cfg.imageonly) {
                setTimeout(function(){
                    ic.resizeCanvasCls.closeDialogs();
                }, 100);

                ic.resizeCanvasCls.resizeCanvas(me.htmlCls.WIDTH, me.htmlCls.HEIGHT, true);
            }

            // an extra render to remove artifacts in transparent surface
            if(ic.bTransparentSurface && ic.bRender) ic.drawCls.render();

            if(me.cfg.imageonly) ic.saveFileCls.saveFile(undefined, 'png', undefined, true);

            /// if(ic.deferred !== undefined) ic.deferred.resolve(); /// if(ic.deferred2 !== undefined) ic.deferred2.resolve();
            /// if(ic.deferredMmdbaf !== undefined) ic.deferredMmdbaf.resolve();
        }

        async replayFirstStep(currentNumber) { let ic = this.icn3d, me = ic.icn3dui;
              // fresh start
              ic.reinitAfterLoad();
              //ic.selectionCls.resetAll();

              //ic.opts = me.hashUtilsCls.cloneHash(ic.opts);
              await this.execCommandsBase(currentNumber, currentNumber, ic.STATENUMBER);

              let cmdStrOri = ic.commands[currentNumber];
              //var pos = ic.commands[currentNumber].indexOf(' | ');
              let pos = ic.commands[currentNumber].indexOf('|');
              if(pos != -1) cmdStrOri = ic.commands[currentNumber].substr(0, pos);

              let maxLen = 20;
              let cmdStr =(cmdStrOri.length > maxLen) ? cmdStrOri.substr(0, maxLen) + '...' : cmdStrOri;

              let menuStr = ic.applyCommandCls.getMenuFromCmd(cmdStrOri); // 'File > Retrieve by ID, Align';

              $("#" + ic.pre + "replay_cmd").html('Cmd: ' + cmdStr);
              $("#" + ic.pre + "replay_menu").html('Menu: ' + menuStr);

              me.htmlCls.clickMenuCls.setLogCmd(cmdStrOri, true);

              ic.bCommandLoad = false;

              // hide "loading ..."
              ic.ParserUtilsCls.hideLoading();

              ic.bRender = true;
              ic.drawCls.draw();
        }

        getHAtoms(fullcommand) { let ic = this.icn3d; ic.icn3dui;
            let strArray = fullcommand.split("|||");
            let command = strArray[0].trim();

            let paraArray = command.split(' | ');
            if(paraArray.length == 2) {
                let nameArray = paraArray[1].split(',');
                ic.hAtoms = ic.definedSetsCls.getAtomsFromNameArray(nameArray);
            }
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class SelectByCommand {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Set a custom selection with the "command", its name "commandname" and its description "commanddesc".
        async selectByCommand(select, commandname, commanddesc) { let ic = this.icn3d, me = ic.icn3dui;
               if(select.indexOf('saved atoms') === 0) {
                    let pos = 12; // 'saved atoms '
                    let strSets = select.substr(pos);

                    ic.definedSetsCls.selectCombinedSets(strSets, commandname);
               }
               else {
                   let selectTmp = select.replace(/ AND /g, ' and ').replace(/ OR /g, ' or ').replace(/ or and /g, ' and ').replace(/ and /g, ' or and ').replace(/ or not /g, ' not ').replace(/ not /g, ' or not ');

                   let commandStr =(selectTmp.trim().substr(0, 6) === 'select') ? selectTmp.trim().substr(7) : selectTmp.trim();

                   // each select command may have several commands separated by ' or '
                   let commandArray = commandStr.split(' or ');
                   let allHighlightAtoms = {};

                   for(let i = 0, il = commandArray.length; i < il; ++i) {
                       let command = commandArray[i].trim().replace(/\s+/g, ' ');
                       let pos = command.indexOf(' ');

                       ic.hAtoms = {};

                       if(command.substr(0, pos).toLowerCase() === 'and') { // intersection
                          await ic.applyCommandCls.applyCommand('select ' + command.substr(pos + 1));

                          allHighlightAtoms = me.hashUtilsCls.intHash(allHighlightAtoms, ic.hAtoms);
                       }
                       else if(command.substr(0, pos).toLowerCase() === 'not') { // negation
                          await ic.applyCommandCls.applyCommand('select ' + command.substr(pos + 1));

                          allHighlightAtoms = me.hashUtilsCls.exclHash(allHighlightAtoms, ic.hAtoms);
                       }
                       else { // union
                          await ic.applyCommandCls.applyCommand('select ' + command);
                          allHighlightAtoms = me.hashUtilsCls.unionHash(allHighlightAtoms, ic.hAtoms);
                       }
                   }

                   ic.hAtoms = me.hashUtilsCls.cloneHash(allHighlightAtoms);

                   let atomArray = Object.keys(ic.hAtoms);

                   if(commandname !== "") {
                       ic.selectionCls.addCustomSelection(atomArray, commandname, commanddesc, select, false);

                       let nameArray = [commandname];
                       //ic.changeCustomResidues(nameArray);

                       ic.definedSetsCls.changeCustomAtoms(nameArray);
                   }
               }
        }

        selectBySpec(select, commandname, commanddesc, bDisplay, bNoUpdateAll) { let ic = this.icn3d, me = ic.icn3dui;
           select =(select.trim().substr(0, 6) === 'select') ? select.trim().substr(7) : select.trim();
           ic.hAtoms = {};

           // selection definition is similar to Chimera: https://www.cgl.ucsf.edu/chimera/docs/UsersGuide/midas/frameatom_spec.html
           // There will be no ' or ' in the spec. It's already separated in selectByCommand()
           // There could be ' and ' in the spec.
           let commandArray = select.replace(/\s+/g, ' ').replace(/ AND /g, ' and ').split(' and ');
           let residueHash = {};
           let atomHash = {};

           let bSelectResidues = true;
           for(let i = 0, il=commandArray.length; i < il; ++i) {
               //$1,2,3.A,B,C:5-10,LYS,chemicals@CA,C
               // $1,2,3: Structure
               // .A,B,C: chain
               // :5-10,K,chemicals: residues, could be 'proteins', 'nucleotides', 'chemicals', 'ions', and 'water'
               // :ref_1250,ref_anchors,ref_strands,ref_loops: reference numbers 1250, anchor residues (e.g., 2250), residues in strands, residues in loops
               // @CA,C,C*: atoms
               // wild card * can be used to select all
               //var currHighlightAtoms = {}

               let dollarPos = commandArray[i].indexOf('$');
               let periodPos = commandArray[i].indexOf('.');
               let colonPos = commandArray[i].indexOf(':');
               let colonPos2 = commandArray[i].indexOf(':ref_'); // for reference numbers
               let atPos = commandArray[i].indexOf('@');

               let moleculeStr, chainStr, residueStr, refResStr, atomStrArray;
               let testStr = commandArray[i];

               if(atPos === -1) {
                 atomStrArray = ["*"];
               }
               else {
                 atomStrArray = testStr.substr(atPos + 1).split(',');
                 testStr = testStr.substr(0, atPos);
               }

               if(colonPos === -1 && colonPos2 === -1 ) {
                 residueStr = "*";
               }
               else if(colonPos2 != -1) {
                  refResStr = testStr.substr(colonPos2 + 5);
                  testStr = testStr.substr(0, colonPos2);

                  // somehow sometimes refResStr or residueStr is rmpty
                  if(!refResStr) continue;
               }
               else if(colonPos != -1) {
                  residueStr = testStr.substr(colonPos + 1);
                  testStr = testStr.substr(0, colonPos);

                  // somehow sometimes refResStr or residueStr is rmpty
                  if(!residueStr) continue;
               }

               if(periodPos === -1) {
                 chainStr = "*";
               }
               else {
                 chainStr = testStr.substr(periodPos + 1);

                 //replace "A_1" with "A"
                 chainStr = chainStr.replace(/_/g, '');

                 testStr = testStr.substr(0, periodPos);
               }

               if(dollarPos === -1) {
                 moleculeStr = "*";
               }
               else {
                 //moleculeStr = testStr.substr(dollarPos + 1).toUpperCase();
                 moleculeStr = testStr.substr(dollarPos + 1);
                 testStr = testStr.substr(0, dollarPos);
               }

               if(atomStrArray.length > 1 || (atomStrArray.length == 1 && atomStrArray[0] !== '*')) {
                 bSelectResidues = false; // selected atoms
               }

               let molecule, molecule_chain, moleculeArray=[], Molecule_ChainArray=[], start, end;

               if(moleculeStr === '*') {
                 moleculeArray = Object.keys(ic.structures);
               }
               else {
                 moleculeArray = moleculeStr.split(",");
               }

               if(chainStr === '*') {
                 let tmpArray = Object.keys(ic.chains);  // 1_A(molecule_chain)

                 for(let j = 0, jl = tmpArray.length; j < jl; ++j) {
                   molecule_chain = tmpArray[j];

                   molecule = molecule_chain.substr(0, molecule_chain.indexOf('_'));
                   //if(moleculeArray.toString().toLowerCase().indexOf(molecule.toLowerCase()) !== -1) {
                   let moleculeArrayLower = moleculeArray.map(function(x){ return x.toLowerCase(); });
                   if(moleculeArrayLower.indexOf(molecule.toLowerCase()) !== -1 ) {
                     Molecule_ChainArray.push(molecule_chain);
                   }
                 }
               }
               else {
                 for(let j = 0, jl = moleculeArray.length; j < jl; ++j) {
                   molecule = moleculeArray[j];

                   let chainArray = chainStr.split(",");
                   for(let k in chainArray) {
                     Molecule_ChainArray.push(molecule + '_' + chainArray[k]);
                   }
                 }
               }

               let bRefnum = (refResStr) ? true : false;
               let residueStrArray = (bRefnum) ? refResStr.split(',') : residueStr.split(',');

               for(let j = 0, jl = residueStrArray.length; j < jl; ++j) {
                   let bResidueId = false;

                   //var hyphenPos = residueStrArray[j].indexOf('-');
                   let hyphenPos = residueStrArray[j].lastIndexOf('-');

                   let oneLetterResidueStr = undefined, threeLetterResidueStr = undefined;
                   let bAllResidues = false;
                   let bResidueArray = false;
                   let bResidueArrayThree = false; // three letter residues

                   if(hyphenPos !== -1) {
                     start = residueStrArray[j].substr(0, hyphenPos);
                     end = residueStrArray[j].substr(hyphenPos+1);
                     bResidueId = true;
                   }
                   else {
                     //if(residueStrArray[j].length > 1 && residueStrArray[j][0] === '3' && (residueStrArray[j].length - 1) % 3 === 0) { // three letter residue string, such as :3LysArg
                     if(!bRefnum && residueStrArray[j].length > 1 && residueStrArray[j][0] === '3' 
                         && isNaN(residueStrArray[j][1]) && residueStrArray[j][0] !== '-') { // three letter residue string, such as :3LysArg or :3ZN, but not :30 neither :3-10
                       let tmpStr = residueStrArray[j].toUpperCase();
                       threeLetterResidueStr = tmpStr.substr(1);
                       bResidueArrayThree = true;
                     }
                     // some residue ID could be "35A"
                     //else if(residueStrArray[j] !== '' && !isNaN(residueStrArray[j])) { // residue id
                     else if(residueStrArray[j] !== '' && !isNaN(parseInt(residueStrArray[j]))) { // residue id
                       start = residueStrArray[j];
                       end = start;
                       bResidueId = true;
                     }
                     else if(residueStrArray[j] === '*') { // all resiues
                       bAllResidues = true;
                     }
                     else if(residueStrArray[j] !== 'proteins' && residueStrArray[j] !== 'nucleotides' 
                       && residueStrArray[j] !== 'chemicals' && residueStrArray[j] !== 'ions' && residueStrArray[j] !== 'water'
                       && residueStrArray[j] !== 'anchors' && residueStrArray[j] !== 'strands' && residueStrArray[j] !== 'loops') { // residue name
                       let tmpStr = residueStrArray[j].toUpperCase();
                       //oneLetterResidue =(residueStrArray[j].length === 1) ? tmpStr : me.utilsCls.residueName2Abbr(tmpStr);
                       oneLetterResidueStr = tmpStr;
                       bResidueArray = true;
                     }
                   }

                   for(let mc = 0, mcl = Molecule_ChainArray.length; mc < mcl; ++mc) {
                     molecule_chain = Molecule_ChainArray[mc];

                     if(bResidueId) {
                       // start and end could be a string such as 35A
                       //for(let k = parseInt(start); k <= parseInt(end); ++k) {
                       start = !isNaN(start) ? parseInt(start) : start;
                       end = !isNaN(end) ? parseInt(end) : end;
                       for(let k = start; k <= end; ++k) {
                         let residArray = [];

                         if(bRefnum) {
                          let residArrayTmp = (ic.refnum2residArray[k.toString()]) ? ic.refnum2residArray[k.toString()] : [];
                          for(let m = 0, ml = residArrayTmp.length; m < ml; ++m) {
                            let residueId = residArrayTmp[m];
                            if(residueId.substr(0, residueId.lastIndexOf('_')) == molecule_chain) {
                              residArray.push(residueId);
                            }
                          }
                         }
                         else {
                          let residueId = molecule_chain + '_' + k;
                          residArray = [residueId];
                         }

                         for(let l = 0, ll = residArray.length; l < ll; ++l) {
                            let residueId = residArray[l];
                            if(i === 0) {
                                  residueHash[residueId] = 1;
                            }
                            else {
                                // if not exit previously, "and" operation will remove this one
                                //if(!residueHash.hasOwnProperty(residueId)) residueHash[residueId] = undefined;
                                if(!residueHash.hasOwnProperty(residueId)) delete residueHash[residueId];
                            }

                            for(let m in ic.residues[residueId]) {
                              for(let n = 0, nl = atomStrArray.length; n < nl; ++n) {
                                  let atomStr = atomStrArray[n];
                                  atomHash = this.processAtomStr(atomStr, atomHash, i, m);
                                  
                                  // if(atomStr === '*' || atomStr === ic.atoms[m].name) {
                                  //   if(i === 0) {
                                  //       atomHash[m] = 1;
                                  //   }
                                  //   else {
                                  //       if(!atomHash.hasOwnProperty(m)) delete atomHash[m];
                                  //   }
                                  // }
                              }
                            }
                          } // end for(let l = 0, 
                       } // end for
                     }
                     else {
                       if(molecule_chain in ic.chains) {
                         let chainAtomHash = ic.chains[molecule_chain];
                         for(let m in chainAtomHash) {
                           // residue could also be 'proteins', 'nucleotides', 'chemicals', 'ions', and 'water'
                           ic.atoms[m].resn.substr(0,3).toUpperCase();
                           let resid = molecule_chain + '_' + ic.atoms[m].resi; 
                           let refnumLabel, refnumStr, refnum;
                           if(bRefnum) {
                             refnumLabel = ic.resid2refnum[resid];
                             if(refnumLabel) {
                              refnumStr = ic.refnumCls.rmStrandFromRefnumlabel(refnumLabel);
                              refnum = parseInt(refnumStr);
                             }
                           }

                           if(bAllResidues
                               //|| me.utilsCls.residueName2Abbr(tmpStr) === oneLetterResidue
                               ||(residueStrArray[j] === 'proteins' && m in ic.proteins)
                               ||(residueStrArray[j] === 'nucleotides' && m in ic.nucleotides)
                               ||(residueStrArray[j] === 'chemicals' && m in ic.chemicals)
                               ||(residueStrArray[j] === 'ions' && m in ic.ions)
                               ||(residueStrArray[j] === 'water' && m in ic.water)
                               ||(bRefnum && refnumLabel && residueStrArray[j] === 'anchors' && refnum % 100 == 50)
                               ||(bRefnum && refnumLabel && residueStrArray[j] === 'strands' && !ic.residIgLoop.hasOwnProperty(resid))
                               ||(bRefnum && refnumLabel && residueStrArray[j] === 'loops' && ic.residIgLoop.hasOwnProperty(resid))
                               ) {
                             // many duplicates
                             if(i === 0) {
                                 residueHash[resid] = 1;
                             }
                             else {
                                 if(!residueHash.hasOwnProperty(resid)) delete residueHash[resid];
                             }

                             for(let n = 0, nl = atomStrArray.length; n < nl; ++n) {
                                 let atomStr = atomStrArray[n];

                                 atomHash = this.processAtomStr(atomStr, atomHash, i, m);
                             }
                           }
                         } // end for(let m in atomHash) {

                         if(bResidueArray || bResidueArrayThree) {
                           let n =(bResidueArray) ? 1 : 3;
                           let residueStrTmp =(bResidueArray) ? oneLetterResidueStr : threeLetterResidueStr;

                           let chainSeq = '', resiArray = [];
                           for(let s = 0, sl = ic.chainsSeq[molecule_chain].length; s < sl;  ++s) {
                               if(bResidueArray) {
                                   chainSeq +=(ic.chainsSeq[molecule_chain][s].name.length == 1) ? ic.chainsSeq[molecule_chain][s].name : ' ';
                               }
                               else if(bResidueArrayThree) {
                                   let threeLetter = me.utilsCls.residueAbbr2Name(ic.chainsSeq[molecule_chain][s].name);

                                   chainSeq +=(threeLetter.length == 3) ? threeLetter : threeLetter.padEnd(3, '_');
                               }
                               resiArray.push(ic.chainsSeq[molecule_chain][s].resi);
                           }

                           chainSeq = chainSeq.toUpperCase();

                           let seqReg = residueStrTmp.replace(/x/gi, ".");
                           let posArray = [];

                           let searchReg = new RegExp(seqReg, 'i');

                           let targetStr = chainSeq;
                           let pos = targetStr.search(searchReg);
                           let sumPos = pos / n;
                           while(pos !== -1) {
                               posArray.push(sumPos);
                               targetStr = targetStr.substr(pos + n);
                               pos = targetStr.search(searchReg);
                               sumPos += pos / n + 1;
                           }

                           for(let s = 0, sl = posArray.length; s < sl; ++s) {
                               let pos = posArray[s];

                               for(let t = 0, tl = residueStrTmp.length / n; t < tl;  t += n) {
                                 let residueId = molecule_chain + '_' + resiArray[t/n + pos];
                                 if(i === 0) {
                                     residueHash[residueId] = 1;
                                 }
                                 else {
                                     //if(!residueHash.hasOwnProperty(residueId)) residueHash[residueId] = undefined;
                                     if(!residueHash.hasOwnProperty(residueId)) delete residueHash[residueId];
                                 }

                                 for(let m in ic.residues[residueId]) {
                                   for(let n = 0, nl = atomStrArray.length; n < nl; ++n) {
                                      let atomStr = atomStrArray[n];

                                      atomHash = this.processAtomStr(atomStr, atomHash, i, m);
                                   }
                                 }
                               } // for
                           } // end for(s = 0
                         } // end if

                       } // end if(molecule_chain
                     } // end else
                   } // end for(let mc = 0
               } // for(j
           }  // for(i

           ic.hAtoms = me.hashUtilsCls.cloneHash(atomHash);

           if(Object.keys(ic.hAtoms).length == 0) {
               console.log("No residues were selected. Please try another search.");
           }

           if(bDisplay === undefined || bDisplay) ic.hlUpdateCls.updateHlAll();

           let residueAtomArray;
           if(bSelectResidues) {
               residueAtomArray = Object.keys(residueHash);
           }
           else {
               residueAtomArray = Object.keys(atomHash);
           }

           if(commandname != "") {
               ic.selectionCls.addCustomSelection(residueAtomArray, commandname, commanddesc, select, bSelectResidues);

               let nameArray = [commandname];          
               if(!bNoUpdateAll) ic.definedSetsCls.changeCustomAtoms(nameArray);
           }
        }

        processAtomStr(atomStr, atomHash, i, m) {  let ic = this.icn3d; ic.icn3dui;                           
            let atomStrLen = atomStr.length;
            let lastChar = atomStr.substr(atomStrLen - 1, 1);

            if(lastChar == '*' && atomStrLen > 1) { // wildcard to replace anything with *
              if(atomStr.substr(0, atomStrLen - 1) === ic.atoms[m].name.substr(0, atomStrLen - 1)) {
                if(i === 0) {
                    atomHash[m] = 1;
                }
                else {
                    if(!atomHash.hasOwnProperty(m)) delete atomHash[m];
                }
              }
            }
            else {
              if(atomStr === '*' || atomStr === ic.atoms[m].name) {
                if(i === 0) {
                    atomHash[m] = 1;
                }
                else {
                    if(!atomHash.hasOwnProperty(m)) delete atomHash[m];
                }
              }
            } 

            return atomHash;
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Selection {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Select all atom in the structures.
        selectAll() { let ic = this.icn3d; ic.icn3dui;
            this.selectAll_base();

            ic.hlObjectsCls.removeHlObjects();
            ic.hlUpdateCls.removeHl2D();
            ic.hlUpdateCls.removeHlMenus();

            ic.bSelectResidue = false;
            ic.bSelectAlignResidue = false;

            ic.hlUpdateCls.removeSeqResidueBkgd();
            ic.hlUpdateCls.update2DdgmContent();

            // show annotations for all protein chains
            $("#" + ic.pre + "dl_annotations > .icn3d-annotation").show();

            ic.definedSetsCls.setMode('all');

            //let title =(ic.molTitle.length > 40) ? ic.molTitle.substr(0, 40) + "..." : ic.molTitle;
            //$("#" + ic.pre + "title").html(title);
            ic.saveFileCls.showTitle();
        }

        selectAll_base() { let ic = this.icn3d, me = ic.icn3dui;
            ic.hAtoms = {};
            ic.dAtoms = {};

            for(let structure in ic.structures) {
                let chainidArray = ic.structures[structure];
                for(let i = 0, il = chainidArray.length; i < il; ++i) {
                    ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.chains[chainidArray[i]]);
                }
            }

            ic.dAtoms = me.hashUtilsCls.cloneHash(ic.hAtoms);
            ic.viewSelectionAtoms = me.hashUtilsCls.cloneHash(ic.hAtoms);
            ic.ALTERNATE_STRUCTURE = -1;
        }

        //Select a chain with the chain id "chainid" in the sequence dialog and save it as a custom selection with the name "commandname".
        selectAChain(chainid, commandname, bAlign, bUnion) { let ic = this.icn3d, me = ic.icn3dui;
            commandname = commandname.replace(/\s/g, '');
            let command =(bAlign !== undefined || bAlign) ? 'select alignChain ' + chainid : 'select chain ' + chainid;

            //var residueHash = {}, chainHash = {}

            if(bUnion === undefined || !bUnion) {
                ic.hAtoms = {};
                ic.nameArray = [];
            }
            else {
                ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.chains[chainid]);

                if(ic.nameArray === undefined) ic.nameArray = [];
            }

            ic.nameArray.push(chainid);

            //chainHash[chainid] = 1;

            let chnsSeq =(bAlign) ? ic.alnChainsSeq[chainid] : ic.chainsSeq[chainid];
            let chnsSeqLen;
            if(chnsSeq === undefined) chnsSeqLen = 0;
            else chnsSeqLen = chnsSeq.length;

            let oriResidueHash = {};
            for(let i = 0, il = chnsSeqLen; i < il; ++i) { // get residue number
                let resObj = chnsSeq[i];
                let residueid = chainid + "_" + resObj.resi;

                let value = resObj.name;

                if(value !== '' && value !== '-') {
                  oriResidueHash[residueid] = 1;
                  for(let j in ic.residues[residueid]) {
                    ic.hAtoms[j] = 1;
                  }
                }
            }

            if((ic.defNames2Atoms === undefined || !ic.defNames2Atoms.hasOwnProperty(commandname)) &&(ic.defNames2Residues === undefined || !ic.defNames2Residues.hasOwnProperty(commandname)) ) {
                this.addCustomSelection(Object.keys(oriResidueHash), commandname, commandname, command, true);
            }

            let bForceHighlight = true;

            if(bAlign) {
                ic.hlUpdateCls.updateHlAll(undefined, undefined, bUnion, bForceHighlight);
            }
            else {
                ic.hlUpdateCls.updateHlAll(ic.nameArray, undefined, bUnion, bForceHighlight);
            }
        }

        selectResidueList(residueHash, commandname, commanddescr, bUnion, bUpdateHighlight, bAtom) { let ic = this.icn3d; ic.icn3dui;
          if(residueHash !== undefined && Object.keys(residueHash).length > 0) {
            if(bUnion === undefined || !bUnion) {
                ic.hAtoms = {};
                ic.nameArray = [];
            }
            else {
                if(ic.nameArray === undefined) ic.nameArray = [];
            }

            if(bAtom) {
                for(let i in residueHash) {
                    ic.hAtoms[i] = 1;
                }
            }
            else {
                for(let i in residueHash) {
                    for(let j in ic.residues[i]) {
                      ic.hAtoms[j] = 1;
                    }
                }
            }

            commandname = commandname.replace(/\s/g, '');

            ic.nameArray.push(commandname);

            let select, bSelectResidues;

            if(bAtom) {
                select = "select " + ic.resid2specCls.atoms2spec(ic.hAtoms);
                bSelectResidues = false;
            }
            else {
                select = "select " + ic.resid2specCls.residueids2spec(Object.keys(residueHash));
                bSelectResidues = true;
            }

            let residueAtomArray = Object.keys(residueHash);

            //if((ic.defNames2Atoms === undefined || !ic.defNames2Atoms.hasOwnProperty(commandname)) &&(ic.defNames2Residues === undefined || !ic.defNames2Residues.hasOwnProperty(commandname)) ) {
                this.addCustomSelection(residueAtomArray, commandname, commanddescr, select, bSelectResidues);
            //}

            if(bUpdateHighlight === undefined || bUpdateHighlight) ic.hlUpdateCls.updateHlAll(ic.nameArray, undefined, bUnion);
          }
        }

        selectMainChains() { let ic = this.icn3d, me = ic.icn3dui;
            let currHAtoms = me.hashUtilsCls.cloneHash(ic.hAtoms);

            ic.hAtoms = ic.applyDisplayCls.selectMainChainSubset(currHAtoms);

            ic.hlUpdateCls.showHighlight();
        }

        //Select only the side chain atoms of the current selection.
        selectSideChains() { let ic = this.icn3d, me = ic.icn3dui;
            let currHAtoms = me.hashUtilsCls.cloneHash(ic.hAtoms);

            ic.hAtoms = this.getSideAtoms(currHAtoms);
            ic.hlUpdateCls.showHighlight();
        }

        getSideAtoms(atoms) { let ic = this.icn3d, me = ic.icn3dui;
            let sideAtoms = {};
            for(let i in atoms) {
                if((ic.proteins.hasOwnProperty(i) && ic.atoms[i].name !== "N" && ic.atoms[i].name !== "H" 
                  && ic.atoms[i].name !== "C" && ic.atoms[i].name !== "O"
                  && !(ic.atoms[i].name === "CA" && ic.atoms[i].elem === "C") && ic.atoms[i].name !== "HA")
                  ||(ic.nucleotides.hasOwnProperty(i) && me.parasCls.nuclMainArray.indexOf(ic.atoms[i].name) === -1) ) {
                    sideAtoms[i] = 1;
                }
            }

            return sideAtoms;
        }

        selectMainSideChains() { let ic = this.icn3d, me = ic.icn3dui;
            let residHash = ic.firstAtomObjCls.getResiduesFromAtoms(ic.hAtoms);

            ic.hAtoms = {};
            for(let resid in residHash) {
                ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.residues[resid]);
                ic.dAtoms = me.hashUtilsCls.unionHash(ic.dAtoms, ic.residues[resid]);
            }

            ic.drawCls.draw();

            ic.hlUpdateCls.showHighlight();
        }

        clickShow_selected() { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;
            me.myEventCls.onIds(["#" + ic.pre + "show_selected", "#" + ic.pre + "mn2_show_selected"], "click", function(e) { thisClass.icn3d;
               //me.htmlCls.clickMenuCls.setLogCmd("show selection", true);

               thisClass.showSelection();
               me.htmlCls.clickMenuCls.setLogCmd("show selection", true);
            });
        }

        clickHide_selected() { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;
            me.myEventCls.onIds("#" + ic.pre + "mn2_hide_selected", "click", function(e) { thisClass.icn3d;
               thisClass.hideSelection();
               me.htmlCls.clickMenuCls.setLogCmd("hide selection", true);
            });
        }

        getGraphDataForDisplayed() { let ic = this.icn3d; ic.icn3dui;
              let graphJson = JSON.parse(ic.graphStr);

              let residHash = ic.firstAtomObjCls.getResiduesFromAtoms(ic.dAtoms);

              let nodeArray = [], linkArray = [];

              let nodeHash = {};
              for(let i = 0, il = graphJson.nodes.length; i < il; ++i) {
                  let node = graphJson.nodes[i];
                  let resid = node.r.substr(4); // 1_1_1KQ2_A_1

                  if(residHash.hasOwnProperty(resid)) {
                      nodeArray.push(node);
                      nodeHash[node.id] = 1;
                  }
              }

              for(let i = 0, il = graphJson.links.length; i < il; ++i) {
                  let link = graphJson.links[i];

                  if(nodeHash.hasOwnProperty(link.source) && nodeHash.hasOwnProperty(link.target)) {
                      linkArray.push(link);
                  }
              }

              graphJson.nodes = nodeArray;
              graphJson.links = linkArray;

              ic.graphStr = JSON.stringify(graphJson);

              return ic.graphStr;
        }

        updateSelectionNameDesc() { let ic = this.icn3d; ic.icn3dui;
            let numDef = Object.keys(ic.defNames2Residues).length + Object.keys(ic.defNames2Atoms).length;

            $("#" + ic.pre + "seq_command_name").val("seq_" + numDef);
            //$("#" + ic.pre + "seq_command_desc").val("seq_desc_" + numDef);

            $("#" + ic.pre + "seq_command_name2").val("seq_" + numDef);
            //$("#" + ic.pre + "seq_command_desc2").val("seq_desc_" + numDef);

            $("#" + ic.pre + "alignseq_command_name").val("alseq_" + numDef);
            //$("#" + ic.pre + "alignseq_command_desc").val("alseq_desc_" + numDef);
        }

        //Define a custom selection based on the array of residues or atoms. The custom selection is defined
        //by the "command" with the name "commandname" and the description "commanddesc". If "bResidue" is true,
        //the custom selection is based on residues. Otherwise, the custom selection is based on atoms.
        addCustomSelection(residueAtomArray, commandname, commanddesc, select, bSelectResidues) { let ic = this.icn3d; ic.icn3dui;
            if(bSelectResidues) {
                ic.defNames2Residues[commandname] = residueAtomArray;
            }
            else {
                ic.defNames2Atoms[commandname] = residueAtomArray;
            }

            ic.defNames2Command[commandname] = select;
            ic.defNames2Descr[commandname] = commanddesc;

            ic.hlUpdateCls.updateHlMenus([commandname]);
        }

        //Show the selection.
        showSelection() { let ic = this.icn3d, me = ic.icn3dui;
            //ic.dAtoms = {};

            if(Object.keys(ic.hAtoms).length == 0) {
                ic.hAtoms = me.hashUtilsCls.cloneHash(ic.dAtoms);
            }

            ic.dAtoms = me.hashUtilsCls.cloneHash(ic.hAtoms);
            ic.viewSelectionAtoms = me.hashUtilsCls.cloneHash(ic.hAtoms);
            ic.ALTERNATE_STRUCTURE = -1;

            let centerAtomsResults = ic.applyCenterCls.centerAtoms(me.hashUtilsCls.hash2Atoms(ic.dAtoms, ic.atoms));
            ic.maxD = centerAtomsResults.maxD;
            if(ic.maxD < 5) ic.maxD = 5;

            //show selected rotationcenter
            ic.opts['rotationcenter'] = 'display center';

            this.saveSelectionIfSelected();

            ic.drawCls.draw();

            ic.hlUpdateCls.update2DdgmContent();
            ic.hlUpdateCls.updateHl2D();

            // show selected chains in annotation window
            ic.annotationCls.showAnnoSelectedChains();

            // update 2d graph
            if(ic.graphStr !== undefined) {
              ic.graphStr = this.getGraphDataForDisplayed();
            }

            ic.saveFileCls.showTitle();

            // don not redraw graphs after the selection changes
            /*
            if(ic.bGraph) ic.drawGraphCls.drawGraph(ic.graphStr, ic.pre + 'dl_graph');
            if(ic.bLinegraph) ic.lineGraphCls.drawLineGraph(ic.graphStr);
            if(ic.bScatterplot) ic.lineGraphCls.drawLineGraph(ic.graphStr, true);
            */
        }

        hideSelection() { let ic = this.icn3d, me = ic.icn3dui;
            ic.hAtoms = me.hashUtilsCls.exclHash(ic.dAtoms, ic.hAtoms);
            if(Object.keys(ic.hAtoms).length == 0) {
                ic.hAtoms = me.hashUtilsCls.cloneHash(ic.dAtoms);
            }

            ic.dAtoms = me.hashUtilsCls.cloneHash(ic.hAtoms);

            let centerAtomsResults = ic.applyCenterCls.centerAtoms(me.hashUtilsCls.hash2Atoms(ic.dAtoms, ic.atoms));
            ic.maxD = centerAtomsResults.maxD;
            if(ic.maxD < 5) ic.maxD = 5;

            //show selected rotationcenter
            ic.opts['rotationcenter'] = 'display center';

            this.saveSelectionIfSelected();

            ic.drawCls.draw();

            ic.hlUpdateCls.update2DdgmContent();
            ic.hlUpdateCls.updateHl2D();

            // show selected chains in annotation window
            ic.annotationCls.showAnnoSelectedChains();
        }

        saveSelection(name, description, bDragSeq) { let ic = this.icn3d, me = ic.icn3dui;
            if(!bDragSeq) {
                ic.selectedResidues = {};

                ic.selectedResidues = ic.firstAtomObjCls.getResiduesFromCalphaAtoms(ic.hAtoms);
            }

            if(!name) {
                let index = Object.keys(ic.defNames2Atoms).length + Object.keys(ic.defNames2Residues).length + 1;
                name = 'seq_' + index;
                description = name;
            }

            if(Object.keys(ic.selectedResidues).length > 0) {
                if(ic.pk == 1) {
                    let bAtom = true;
                    this.selectResidueList(ic.hAtoms, name, description, undefined, undefined, bAtom);
                    //ic.hlUpdateCls.updateHlAll();

                    this.updateSelectionNameDesc();

                    if(!bDragSeq) {
                        me.htmlCls.clickMenuCls.setLogCmd('select ' + ic.resid2specCls.atoms2spec(ic.hAtoms) + ' | name ' + name, true);
                    }
                    else { // no names for temp selections
                        me.htmlCls.clickMenuCls.setLogCmd('select ' + ic.resid2specCls.atoms2spec(ic.hAtoms), true);
                    }
                }
                else {
                    this.selectResidueList(ic.selectedResidues, name, description, undefined, undefined, undefined);
                    //ic.hlUpdateCls.updateHlAll();

                    this.updateSelectionNameDesc();

                    if(!bDragSeq) {
                        me.htmlCls.clickMenuCls.setLogCmd('select ' + ic.resid2specCls.residueids2spec(Object.keys(ic.selectedResidues)) + ' | name ' + name, true);
                    }
                    else { // no names for temp selections
                        me.htmlCls.clickMenuCls.setLogCmd('select ' + ic.resid2specCls.residueids2spec(Object.keys(ic.selectedResidues)), true);
                    }
                }
            }
        }

        saveSelInCommand() { let ic = this.icn3d, me = ic.icn3dui;
            ic.selectedResidues = ic.firstAtomObjCls.getResiduesFromCalphaAtoms(ic.hAtoms);

            me.htmlCls.clickMenuCls.setLogCmd('select ' + ic.resid2specCls.residueids2spec(Object.keys(ic.selectedResidues)), true);
        }

        saveEachResiInSel() { let ic = this.icn3d; ic.icn3dui;
            ic.selectionCls.saveSelectionPrep();
            
            ic.selectedResidues = {};

            ic.selectedResidues = ic.firstAtomObjCls.getResiduesFromCalphaAtoms(ic.hAtoms);

            for(let resid in ic.selectedResidues) {
                let eachResidueHash = {};
                eachResidueHash[resid] = 1;
                let name = resid + '_' + ic.selectedResidues[resid];

                this.selectResidueList(eachResidueHash, name, name);
            }
        }

        removeSelection() { let ic = this.icn3d; ic.icn3dui;
            if(!ic.bAnnotations) {
                ic.hlUpdateCls.removeSeqChainBkgd();
            }

            if(!ic.bCtrl && !ic.bShift) {
                ic.hlUpdateCls.removeSeqResidueBkgd();

                ic.hlUpdateCls.removeSeqChainBkgd();
            }

              ic.selectedResidues = {};
              ic.bSelectResidue = false;

              ic.hAtoms = {};

              ic.hlObjectsCls.removeHlObjects();

              ic.hlUpdateCls.removeHl2D();
        }

        resetAll() { let ic = this.icn3d, me = ic.icn3dui;
            ic.maxD = ic.oriMaxD;
            ic.center = ic.oriCenter.clone();

            ic.opts = me.hashUtilsCls.cloneHash(ic.optsOri);

            //reset side chains
            ic.setOptionCls.setStyle('sidec', 'nothing');

            ic.reinitAfterLoad();

            //ic.loadScriptCls.renderFinalStep(1);
            ic.definedSetsCls.setMode('all');

            ic.selectionCls.selectAll();

            me.htmlCls.clickMenuCls.setLogCmd("reset", true);

            ic.hlUpdateCls.removeSeqChainBkgd();
            ic.hlUpdateCls.removeSeqResidueBkgd();
            ic.hlUpdateCls.removeHl2D();
            ic.hlUpdateCls.removeHlMenus();

            ic.loadScriptCls.renderFinalStep(1);
        }

        async loadSelection(dataStr) { let ic = this.icn3d, me = ic.icn3dui;
          let nameCommandArray = dataStr.trim().split('\n');

          for(let i = 0, il = nameCommandArray.length; i < il; ++i) {
              //let nameCommand = nameCommandArray[i].split('\t');
              //let name = nameCommand[0];
              //let command = nameCommand[1];

              let nameCommand = nameCommandArray[i].replace(/\t/g, ' ');
              let pos1 = nameCommand.indexOf(' ');
              
              let name = nameCommand.substr(0, pos1);
              let command = nameCommand.substr(pos1 + 1);

              let pos = command.indexOf(' '); // select ...

              await ic.selByCommCls.selectByCommand(command.substr(pos + 1), name, name);

              me.htmlCls.clickMenuCls.setLogCmd('select ' + command.substr(pos + 1) + ' | name ' + name, true);
          }
        }

        oneStructurePerWindow() { let ic = this.icn3d, me = ic.icn3dui;
            // only display one of the two aligned structures

            let structureArray = (ic.structures) ? Object.keys(ic.structures) : [];
            if(me.cfg.bSidebyside && structureArray.length == 2) {
                let dividArray = Object.keys(window.icn3duiHash);
                let pos = dividArray.indexOf(ic.divid);
                let structure = structureArray[pos];
                let chainArray = ic.structures[structure];
                
                let structAtoms = {};
                if(chainArray) {
                    for(let i = 0, il = chainArray.length; i < il; ++i) {
                        structAtoms = me.hashUtilsCls.unionHash(structAtoms, ic.chains[chainArray[i]]);
                    }

                    ic.dAtoms = me.hashUtilsCls.intHash(structAtoms, ic.dAtoms);
                    ic.hAtoms = me.hashUtilsCls.cloneHash(ic.dAtoms);
                }
            }
        }

        showAll() {var ic = this.icn3d, me = ic.icn3dui;
               ic.dAtoms = me.hashUtilsCls.cloneHash(ic.atoms);
               ic.maxD = ic.oriMaxD;
               ic.drawCls.draw();
        }

        saveSelectionIfSelected(id, value) {var ic = this.icn3d; ic.icn3dui;
          if(ic.bSelectResidue || ic.bSelectAlignResidue) {
              let name = $("#" + ic.pre + "seq_command_name2").val().replace(/\s+/g, '_');
              //var description = $("#" + ic.pre + "seq_command_desc2").val();
              if(name === "") {
                name = $("#" + ic.pre + "alignseq_command_name").val().replace(/\s+/g, '_');
                //description = $("#" + ic.pre + "alignseq_command_desc").val();
              }
              if(name !== "") this.saveSelection(name, name);
              ic.bSelectResidue = false;
              ic.bSelectAlignResidue = false;
          }
        }

        saveSelectionPrep(bDragSeq) {var ic = this.icn3d, me = ic.icn3dui;
               if(!me.cfg.notebook) {
                   if(!$('#' + ic.pre + 'dl_definedsets').hasClass('ui-dialog-content') || !$('#' + ic.pre + 'dl_definedsets').dialog( 'isOpen' )) {
                     me.htmlCls.dialogCls.openDlg('dl_definedsets', 'Select sets');
                     $("#" + ic.pre + "atomsCustom").resizable();
                   }
               }
               else {
                   $('#' + ic.pre + 'dl_definedsets').show();
                   $("#" + ic.pre + "atomsCustom").resizable();
               }

               if(!bDragSeq) {
                    ic.bSelectResidue = false;
                    ic.bSelectAlignResidue = false;
               }
        }
        selectOneResid(idStr, bUnchecked) {var ic = this.icn3d; ic.icn3dui;
          //var idStr = idArray[i]; // TYR $1KQ2.B:56@OH, $1KQ2.B:40 ASP
          //change to: let idStr = idArray[i]; // TYR $1KQ2.B:56@OH, or ASP $1KQ2.B:40
          //change to: let idStr = idArray[i]; // TYR $1KQ2.B:56@OH, or ASP $1KQ2.B:40, or $1KQ2.B:56@OH 130, or ASP $1KQ2.B:40 144
          let idArray = idStr.split(' ');
          idStr = idArray[1];

          let posStructure = idStr.indexOf('$');
          let posChain = idStr.indexOf('.');
          let posRes = idStr.indexOf(':');
          let posAtom = idStr.indexOf('@');
          if(posAtom == -1) posAtom = idStr.length; //idStr.indexOf(' ');
          let structure = idStr.substr(posStructure + 1, posChain - posStructure - 1);
          let chain = idStr.substr(posChain + 1, posRes - posChain - 1);
          let resi = idStr.substr(posRes + 1, posAtom - posRes - 1);
          let resid = structure + '_' + chain + '_' + resi;
          for(let j in ic.residues[resid]) {
              if(bUnchecked) {
                  delete ic.hAtoms[j];
              }
              else {
                  ic.hAtoms[j] = 1;
              }
          }
          if(bUnchecked) {
              delete ic.selectedResidues[resid];
          }
          else {
              ic.selectedResidues[resid] = 1;
          }
          let cmd = '$' + structure + '.' + chain + ':' + resi;
          return cmd;
        }

        //Toggle on and off the current selection.
        toggleSelection() {var ic = this.icn3d, me = ic.icn3dui;
            if(ic.bHideSelection) {
                for(let i in ic.dAtoms) {
                    if(ic.hAtoms.hasOwnProperty(i)) delete ic.dAtoms[i];
                }
                  ic.bHideSelection = false;
            }
            else {
                ic.dAtoms = me.hashUtilsCls.unionHash(ic.dAtoms, ic.hAtoms);
                  ic.bHideSelection = true;
            }
            ic.drawCls.draw();
        }

        toggleMembrane(bShowMembrane) {var ic = this.icn3d, me = ic.icn3dui;
            let structureArray = (ic.structures) ? Object.keys(ic.structures) : [];

            for(let i = 0, il = structureArray.length; i < il; ++i) {
                let structure = structureArray[i];
                let atomsHash = ic.residues[structure + '_MEM_1'];
                let firstAtom = ic.firstAtomObjCls.getFirstAtomObj(atomsHash);
                if(firstAtom === undefined) continue;

                let oriStyle = firstAtom.style;
                if(!ic.dAtoms.hasOwnProperty(firstAtom.serial)) {
                    // add membrane to displayed atoms if the membrane is not part of the display
                    ic.dAtoms = me.hashUtilsCls.unionHash(ic.dAtoms, atomsHash);
                    oriStyle = 'nothing';
                }

                for(let j in atomsHash) {
                    let atom = ic.atoms[j];
                    if(oriStyle !== 'nothing') {
                        atom.style = 'nothing';
                    }
                    else {
                        atom.style = 'stick';
                    }

                    if(bShowMembrane !== undefined) {
                        atom.style = (bShowMembrane) ? 'stick' : 'nothing';
                    }
                }
            }

            if(bShowMembrane === undefined) ic.drawCls.draw();
        }

        adjustMembrane(extra_mem_z, intra_mem_z) {var ic = this.icn3d; ic.icn3dui;
            for(let i in ic.chains[ic.inputid.toUpperCase() + '_MEM']) {
                let atom = ic.atoms[i];
                if(atom.name == 'O') {
                    atom.coord.z = extra_mem_z;
                }
                else if(atom.name == 'N') {
                    atom.coord.z = intra_mem_z;
                }
            }
            // reset transmembrane set
            let bReset = true;
            ic.definedSetsCls.setTransmemInMenu(extra_mem_z, intra_mem_z, bReset);
            ic.hlUpdateCls.updateHlMenus();
            ic.drawCls.draw();
        }
        selectBtwPlanes(large, small) {var ic = this.icn3d; ic.icn3dui;
            if(large < small) {
                let tmp = small;
                small = large;
                large = tmp;
            }
            let residueHash = {};
            for(let i in ic.atoms) {
                let atom = ic.atoms[i];
                if(atom.resn == 'DUM') continue;
                if(atom.coord.z >= small && atom.coord.z <= large) {
                    let resid = atom.structure + '_' + atom.chain + '_' + atom.resi;
                    residueHash[resid] = 1;
                }
            }
            let commandname = "z_planes_" + large + "_" + small;
            let commanddescr = commandname;
            this.selectResidueList(residueHash, commandname, commanddescr, false);
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Resid2spec {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        residueids2spec(residueArray) {var ic = this.icn3d; ic.icn3dui;
             let spec = "";

             if(residueArray !== undefined){
                 let residueArraySorted = residueArray.sort(function(a, b) {
                    if(a !== '' && !isNaN(a)) {
                        return parseInt(a) - parseInt(b);
                    }
                    else {
                        let lastPosA = a.lastIndexOf('_');
                        let lastPosB = b.lastIndexOf('_');
                        if(a.substr(0, lastPosA) < b.substr(0, lastPosB)) return -1;
                        else if(a.substr(0, lastPosA) > b.substr(0, lastPosB)) return 1;
                        else if(a.substr(0, lastPosA) == b.substr(0, lastPosB)) {
                            if(parseInt(a.substr(lastPosA + 1)) < parseInt(b.substr(lastPosB + 1)) ) return -1;
                            else if(parseInt(a.substr(lastPosA + 1)) > parseInt(b.substr(lastPosB + 1)) ) return 1;
                            else if(parseInt(a.substr(lastPosA + 1)) == parseInt(b.substr(lastPosB + 1)) ) return 0;
                        }
                    }
                 });
                 let prevChain = '', chain, prevResi = 0, resi, lastDashPos, firstDashPos, struturePart, chainPart;
                 let startResi;
                 let bMultipleStructures =(Object.keys(ic.structures).length == 1) ? false : true;
                 for(let j = 0, jl = residueArraySorted.length; j < jl; ++j) {
                     let residueid = residueArraySorted[j];
                     lastDashPos = residueid.lastIndexOf('_');
                     chain = residueid.substr(0, lastDashPos);
                     // allow resi such as 35A
                     //resi = parseInt(residueid.substr(lastDashPos+1));
                     resi = residueid.substr(lastDashPos+1);
                     firstDashPos = prevChain.indexOf('_');
                     struturePart = prevChain.substr(0, firstDashPos);
                     chainPart = prevChain.substr(firstDashPos + 1);

                     // create separate spec for resi such as 100a
                     if(isNaN(resi)) {
                        if(bMultipleStructures) {
                            spec += '$' + struturePart + '.' + chainPart + ':' + resi + ' or ';
                        }
                        else {
                            spec += '.' + chainPart + ':' + resi + ' or ';
                        }

                        continue;
                     }

                     if(prevChain !== chain) {
                         if(j > 0) {
                             if(prevResi === startResi) {
                                 if(bMultipleStructures) {
                                     spec += '$' + struturePart + '.' + chainPart + ':' + startResi + ' or ';
                                 }
                                 else {
                                     spec += '.' + chainPart + ':' + startResi + ' or ';
                                 }
                             }
                             else {
                                 if(bMultipleStructures) {
                                     spec += '$' + struturePart + '.' + chainPart + ':' + startResi + '-' + prevResi + ' or ';
                                 }
                                 else {
                                     spec += '.' + chainPart + ':' + startResi + '-' + prevResi + ' or ';
                                 }
                             }
                         }
                         startResi = resi;
                     }
                     else if(prevChain === chain) {
                         // some residue number could be "35A"
                         //let tmpPrevResi = !isNaN(prevResi) ? parseInt(prevResi) : prevResi;
                         let tmpPrevResi = ic.ParserUtilsCls.getResiNCBI(prevChain, prevResi);
                         //if(resi != parseInt(prevResi) + 1) {
                         //if(resi != tmpPrevResi + 1) {
                         if(ic.ParserUtilsCls.getResiNCBI(chain, resi) != tmpPrevResi + 1) {
                             if(prevResi === startResi) {
                                 if(bMultipleStructures) {
                                     spec += '$' + struturePart + '.' + chainPart + ':' + startResi + ' or ';
                                 }
                                 else {
                                     spec += '.' + chainPart + ':' + startResi + ' or ';
                                 }
                             }
                             else {
                                 if(bMultipleStructures) {
                                     spec += '$' + struturePart + '.' + chainPart + ':' + startResi + '-' + prevResi + ' or ';
                                 }
                                 else {
                                     spec += '.' + chainPart + ':' + startResi + '-' + prevResi + ' or ';
                                 }
                             }
                             startResi = resi;
                         }
                     }
                     prevChain = chain;
                     prevResi = resi;
                 }
                 // last residue
                 firstDashPos = prevChain.indexOf('_');
                 struturePart = prevChain.substr(0, firstDashPos);
                 chainPart = prevChain.substr(firstDashPos + 1);
                 if(prevResi === startResi) {
                     if(bMultipleStructures) {
                         spec += '$' + struturePart + '.' + chainPart + ':' + startResi;
                     }
                     else {
                         spec += '.' + chainPart + ':' + startResi;
                     }
                 }
                 else {
                     if(bMultipleStructures) {
                         spec += '$' + struturePart + '.' + chainPart + ':' + startResi + '-' + prevResi;
                     }
                     else {
                         spec += '.' + chainPart + ':' + startResi + '-' + prevResi;
                     }
                 }
             }

             return spec;
        }

        resi2range(resiArray, bString) {var ic = this.icn3d; ic.icn3dui;
            let range = [], rangeStr = '';
        
            // some chains such as 3SN6_R start with residues with high residue numbers, then end with residues with low residue numbers
            // let resiArraySorted = resiArray.sort(function(a, b) {
            //    return parseInt(a) - parseInt(b);
            // });

            let resiArraySorted = resiArray;
            
            let startResi = resiArraySorted[0];
            let prevResi, resi;
            for(let j = 0, jl = resiArraySorted.length; j < jl; ++j) {
                resi = resiArraySorted[j];
        
                if(j != 0 && parseInt(resi) != parseInt(prevResi) + 1) {
                    range.push(startResi);
                    range.push(prevResi);

                    if(rangeStr) rangeStr += ',';
                    if(startResi == prevResi) rangeStr += startResi;
                    else rangeStr += startResi + '-' + prevResi;

                    startResi = resi;
                }
        
                prevResi = resi;
            }
            
            // last residue
            range.push(startResi);
            range.push(prevResi);

            if(rangeStr) rangeStr += ',';
            if(startResi == prevResi) rangeStr += startResi;
            else rangeStr += startResi + '-' + prevResi;

            if(bString) return rangeStr;
            else return range;
        }

        atoms2spec(atomHash) {var ic = this.icn3d; ic.icn3dui;
            let spec = "";
            let i = 0;
            let structureHash = {}, chainHash = {}, resiHash = {};

            let atom;
            for(let serial in atomHash) {
                atom = ic.atoms[serial];
                if(i > 0) {
                    spec += ' or ';
                }
                spec += '$' + atom.structure + '.' + atom.chain + ':' + atom.resi + '@' + atom.name;

                structureHash[atom.structure] = 1;
                chainHash[atom.structure + '_' + atom.chain] = 1;
                resiHash[atom.structure + '_' + atom.chain + '_' + atom.resi] = 1;

                ++i;
            }

            if(Object.keys(resiHash).length == 1) {
                let tmpStr = '\\$' + atom.structure + '\\.' + atom.chain + ':' + atom.resi;
                spec = spec.replace(new RegExp(tmpStr,'g'), '');
            }
            else if(Object.keys(chainHash).length == 1) {
                let tmpStr = '\\$' + atom.structure + '\\.' + atom.chain;
                spec = spec.replace(new RegExp(tmpStr,'g'), '');
            }
            else if(Object.keys(structureHash).length == 1) {
                let tmpStr = '\\$' + atom.structure;
                spec = spec.replace(new RegExp(tmpStr,'g'), '');
            }

            return spec;
        }

        atoms2residues(atomArray) {var ic = this.icn3d; ic.icn3dui;
             let atoms = {};
             for(let j = 0, jl = atomArray.length; j < jl; ++j) {
                 atoms[atomArray[j]] = 1;
             }
             //var residueHash = ic.firstAtomObjCls.getResiduesFromCalphaAtoms(atoms);
             let residueHash = ic.firstAtomObjCls.getResiduesFromAtoms(atoms);
             return Object.keys(residueHash);
        }

        atoms2structureArray(atoms) {var ic = this.icn3d; ic.icn3dui;
             let structures = {};
             for(let i in atoms) {
                 let atom = ic.atoms[i];
                 structures[atom.structure] = 1;
             }
             return Object.keys(structures);
        }

        selectProperty(property, from, to) {var ic = this.icn3d, me = ic.icn3dui;
            let prevHAtoms = me.hashUtilsCls.cloneHash(ic.hAtoms);
            if(property == 'positive') {
                let select = ':r,k,h';
                ic.hAtoms = {};
                ic.selByCommCls.selectBySpec(select, select, select);
            }
            else if(property == 'negative') {
                let select = ':d,e';
                ic.hAtoms = {};
                ic.selByCommCls.selectBySpec(select, select, select);
                // add nucleotides
                ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.nucleotides);
            }
            else if(property == 'hydrophobic') {
                let select = ':w,f,y,l,i,c,m';
                ic.hAtoms = {};
                ic.selByCommCls.selectBySpec(select, select, select);
                // only proteins
                ic.hAtoms = me.hashUtilsCls.intHash(ic.hAtoms, ic.proteins);
            }
            else if(property == 'polar') {
                let select = ':g,v,s,t,a,n,p,q';
                ic.hAtoms = {};
                ic.selByCommCls.selectBySpec(select, select, select);
                // only proteins
                ic.hAtoms = me.hashUtilsCls.intHash(ic.hAtoms, ic.proteins);
            }
            else if(property == 'b factor') {
                let atoms = me.hashUtilsCls.cloneHash(ic.calphas);
                atoms = me.hashUtilsCls.unionHash(atoms, ic.nucleotidesO3);
                atoms = me.hashUtilsCls.unionHash(atoms, ic.chemicals);
                atoms = me.hashUtilsCls.unionHash(atoms, ic.ions);
                atoms = me.hashUtilsCls.unionHash(atoms, ic.water);
                ic.hAtoms = {};
                for(let i in atoms) {
                    let atom = ic.atoms[i];
                    if(atom.b >= parseInt(from) && atom.b <= parseInt(to)) {
                        ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.residues[atom.structure + '_' + atom.chain + '_' + atom.resi]);
                    }
                }
            }
            else if(property == 'percent out') {
               ic.bCalcArea = true;
               ic.opts.surface = 'solvent accessible surface';
               ic.applyMapCls.applySurfaceOptions();
               ic.bCalcArea = false;
               ic.hAtoms = {};

               for(let resid in ic.resid2area) { // resid: structure_chain_resi_resn
                    let pos = resid.lastIndexOf('_');
                    let resn = resid.substr(pos + 1);

                    if(me.parasCls.residueArea.hasOwnProperty(resn)) {
                        let percent = parseInt(ic.resid2area[resid] / me.parasCls.residueArea[resn] * 100);
                        if(percent >= from && percent <= to) {
                            let residReal = resid.substr(0, pos);
                            ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.residues[residReal]);
                        }
                    }
               }
            }
            ic.hAtoms = me.hashUtilsCls.intHash(ic.hAtoms, prevHAtoms);
            ic.drawCls.draw();
            ic.hlUpdateCls.updateHlAll();
        }

        //Select the complement of the current selection.
        selectComplement() { let ic = this.icn3d, me = ic.icn3dui;
           let complement = {};
           for(let i in ic.atoms) {
               if(!ic.hAtoms.hasOwnProperty(i)) {
                   complement[i] = 1;
               }
           }
           ic.hAtoms = me.hashUtilsCls.cloneHash(complement);
           //ic.highlightResidues(Object.keys(residueHash), Object.keys(chainHash));
           ic.hlUpdateCls.updateHlAll();
        }

        switchHighlightLevel() {var ic = this.icn3d, me = ic.icn3dui;
          if(me.bNode) return;

          let thisClass = this;

          //$(document).bind('keydown', function(e) { let ic = thisClass.icn3d;
          document.addEventListener('keydown', function(e) { let ic = thisClass.icn3d;
            if(e.keyCode === 38) { // arrow up, select upper level of atoms
              e.preventDefault();
              if(Object.keys(ic.pickedAtomList).length == 0 || !ic.hAtoms.hasOwnProperty(ic.firstAtomObjCls.getFirstAtomObj(ic.pickedAtomList).serial)) {
                  ic.pickedAtomList = me.hashUtilsCls.cloneHash(ic.hAtoms);
                  //ic.pk = 2;
              }
              thisClass.switchHighlightLevelUp();
              me.htmlCls.clickMenuCls.setLogCmd("highlight level up", true);
            }
            else if(e.keyCode === 40) { // arrow down, select down level of atoms
              e.preventDefault();
              if(Object.keys(ic.pickedAtomList).length == 0 || !ic.hAtoms.hasOwnProperty(ic.firstAtomObjCls.getFirstAtomObj(ic.pickedAtomList).serial)) {
                  ic.pickedAtomList = me.hashUtilsCls.cloneHash(ic.hAtoms);
                  //ic.pk = 2;
              }
              thisClass.switchHighlightLevelDown();
              me.htmlCls.clickMenuCls.setLogCmd("highlight level down", true);
            }
          });
        }

        //When users pick an atom, a residue, a strand/helix, a chain, or a structure, they can use upper arrow
        //to increase the highlight level by one, or use down arrow to decrease the highlight level by one. This
        //function switchHighlightLevelUp() increases the highlight level by one.
        switchHighlightLevelUp() {var ic = this.icn3d, me = ic.icn3dui;
          if(me.bNode) return;

          if(!ic.bShift && !ic.bCtrl) ic.hlObjectsCls.removeHlObjects();
          if(ic.pickedAtomList === undefined || Object.keys(ic.pickedAtomList).length === 0) {
              ic.pickedAtomList = me.hashUtilsCls.cloneHash(ic.hAtoms);
          }
          if(Object.keys(ic.pickedAtomList).length === 0) {
              ic.pickedAtomList = ic.dAtoms;
          }
          if(ic.highlightlevel === 1) { // atom -> residue
              ic.highlightlevel = 2;
              let firstAtom = ic.firstAtomObjCls.getFirstAtomObj(ic.pickedAtomList);
              if(!ic.bShift && !ic.bCtrl) {
                  ic.hAtoms = me.hashUtilsCls.cloneHash(ic.residues[firstAtom.structure + '_' + firstAtom.chain + '_' + firstAtom.resi]);
            }
            else {
                ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.residues[firstAtom.structure + '_' + firstAtom.chain + '_' + firstAtom.resi]);
            }
          }
          else if(ic.highlightlevel === 2) { // residue -> strand
              ic.highlightlevel = 3;
              let firstAtom = ic.firstAtomObjCls.getFirstAtomObj(ic.pickedAtomList);
              if(!ic.bShift && !ic.bCtrl) {
                  ic.hAtoms = me.hashUtilsCls.cloneHash(ic.pickingCls.selectStrandHelixFromAtom(firstAtom));
            }
            else {
                ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.pickingCls.selectStrandHelixFromAtom(firstAtom));
            }
          }
          else if(ic.highlightlevel === 3) {
              let atomLevel4;
              if(me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined) { // strand -> domain
                  ic.highlightlevel = 4;
                  let firstAtom = ic.firstAtomObjCls.getFirstAtomObj(ic.pickedAtomList);
                  atomLevel4 = ic.pickingCls.select3ddomainFromAtom(firstAtom);
                  if(!ic.bShift && !ic.bCtrl) {
                      ic.hAtoms = me.hashUtilsCls.cloneHash(atomLevel4);
                  }
                  else {
                    ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, atomLevel4);
                  }
              }
              if((me.cfg.mmdbid === undefined && me.cfg.gi === undefined) || Object.keys(atomLevel4).length == 0) { // strand -> chain
                  ic.highlightlevel = 5;
                  let firstAtom = ic.firstAtomObjCls.getFirstAtomObj(ic.pickedAtomList);
                  if(!ic.bShift && !ic.bCtrl) {
                      ic.hAtoms = me.hashUtilsCls.cloneHash(ic.chains[firstAtom.structure + '_' + firstAtom.chain]);
                  }
                  else {
                    ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.chains[firstAtom.structure + '_' + firstAtom.chain]);
                  }
              }
          }
          else if(ic.highlightlevel === 4) { // domain -> chain
              ic.highlightlevel = 5;
              let firstAtom = ic.firstAtomObjCls.getFirstAtomObj(ic.pickedAtomList);
              if(!ic.bShift && !ic.bCtrl) {
                  ic.hAtoms = me.hashUtilsCls.cloneHash(ic.chains[firstAtom.structure + '_' + firstAtom.chain]);
              }
              else {
                ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.chains[firstAtom.structure + '_' + firstAtom.chain]);
              }
          }
          else if(ic.highlightlevel === 5 || ic.highlightlevel === 6) { // chain -> structure
              ic.highlightlevel = 6;
              let firstAtom = ic.firstAtomObjCls.getFirstAtomObj(ic.pickedAtomList);
              if(!ic.bShift && !ic.bCtrl) ic.hAtoms = {};
              let chainArray = ic.structures[firstAtom.structure];
              for(let i = 0, il = chainArray.length; i < il; ++i) {
                  ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.chains[chainArray[i]]);
            }
          }
          ic.hlObjectsCls.addHlObjects();
          ic.hlUpdateCls.updateHlAll();
        }

        //When users pick an atom, a residue, a strand/helix, a chain, or a structure, they can use upper
        //arrow to increase the highlight level by one, or use down arrow to decrease the highlight level
        //by one. This function switchHighlightLevelDown() decreases the highlight level by one.
        switchHighlightLevelDown() {var ic = this.icn3d, me = ic.icn3dui;
          if(me.bNode) return;

          ic.hlObjectsCls.removeHlObjects();
          if(ic.pickedAtomList === undefined || Object.keys(ic.pickedAtomList).length === 0) {
              ic.pickedAtomList = me.hashUtilsCls.cloneHash(ic.hAtoms);
          }
          if((ic.highlightlevel === 2 || ic.highlightlevel === 1) && Object.keys(ic.pickedAtomList).length === 1) { // residue -> atom
              ic.highlightlevel = 1;
              ic.hAtoms = me.hashUtilsCls.cloneHash(ic.pickedAtomList);
              if(!ic.bShift && !ic.bCtrl) {
                  ic.hAtoms = me.hashUtilsCls.cloneHash(ic.pickedAtomList);
            }
            else {
                ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.pickedAtomList);
            }
          }
          else if(ic.highlightlevel === 3) { // strand -> residue
            let residueHash = {};
            for(let i in ic.pickedAtomList) {
                residueid = ic.atoms[i].structure + '_' + ic.atoms[i].chain + '_' + ic.atoms[i].resi;
                residueHash[residueid] = 1;
            }
            if(Object.keys(residueHash).length === 1) {
                ic.highlightlevel = 2;
                let firstAtom = ic.firstAtomObjCls.getFirstAtomObj(ic.pickedAtomList);
                if(!ic.bShift && !ic.bCtrl) {
                    ic.hAtoms = me.hashUtilsCls.cloneHash(ic.residues[firstAtom.structure + '_' + firstAtom.chain + '_' + firstAtom.resi]);
                }
                else {
                    ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.residues[firstAtom.structure + '_' + firstAtom.chain + '_' + firstAtom.resi]);
                }
            }
          }
          else if(ic.highlightlevel === 4) { // domain -> strand
              ic.highlightlevel = 3;
              let firstAtom = ic.firstAtomObjCls.getFirstAtomObj(ic.pickedAtomList);
              if(!ic.bShift && !ic.bCtrl) {
                  ic.hAtoms = me.hashUtilsCls.cloneHash(ic.pickingCls.selectStrandHelixFromAtom(firstAtom));
              }
              else {
                  ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.pickingCls.selectStrandHelixFromAtom(firstAtom));
              }
          }
          else if(ic.highlightlevel === 5) {
              let atomLevel4;
              if(me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined) { // chain -> domain
                  ic.highlightlevel = 4;
                  let firstAtom = ic.firstAtomObjCls.getFirstAtomObj(ic.pickedAtomList);
                  atomLevel4 = ic.pickingCls.select3ddomainFromAtom(firstAtom);
                  if(!ic.bShift && !ic.bCtrl) {
                      ic.hAtoms = me.hashUtilsCls.cloneHash(atomLevel4);
                  }
                  else {
                      ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, atomLevel4);
                  }
              }
              if((me.cfg.mmdbid === undefined && me.cfg.gi === undefined) || Object.keys(atomLevel4).length == 0) { // chain -> strand
                  ic.highlightlevel = 3;
                  let firstAtom = ic.firstAtomObjCls.getFirstAtomObj(ic.pickedAtomList);
                  if(!ic.bShift && !ic.bCtrl) {
                      ic.hAtoms = me.hashUtilsCls.cloneHash(ic.pickingCls.selectStrandHelixFromAtom(firstAtom));
                  }
                  else {
                      ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.pickingCls.selectStrandHelixFromAtom(firstAtom));
                  }
              }
          }
          else if(ic.highlightlevel === 6) { // structure -> chain
              ic.highlightlevel = 5;
              let firstAtom = ic.firstAtomObjCls.getFirstAtomObj(ic.pickedAtomList);
              if(!ic.bShift && !ic.bCtrl) {
                  ic.hAtoms = me.hashUtilsCls.cloneHash(ic.chains[firstAtom.structure + '_' + firstAtom.chain]);
            }
            else {
                ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.chains[firstAtom.structure + '_' + firstAtom.chain]);
            }
          }
          ic.hlObjectsCls.addHlObjects();
          ic.hlUpdateCls.updateHlAll();
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Delphi {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        async CalcPhiUrl(gsize, salt, contour, bSurface, url) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            let data = await me.getXMLHttpRqstPromise(url, 'GET', 'text', 'PQR');

            await thisClass.CalcPhi(gsize, salt, contour, bSurface, data);
        }

        getPdbStr(bNode) { let ic = this.icn3d, me = ic.icn3dui;
           let ionHash = {};
           let atomHash = {};

           let atoms = me.hashUtilsCls.intHash(ic.dAtoms, ic.hAtoms);
           for(let i in atoms) {
               ic.atoms[i];

               if(ic.ions.hasOwnProperty(i)) {
                 ionHash[i] = 1;
               }
               else {
                 atomHash[i] = 1;
               }
           }

           let atomCnt = Object.keys(atomHash).length;
           let bCalphaOnly = me.utilsCls.isCalphaPhosOnly(me.hashUtilsCls.hash2Atoms(atomHash, ic.atoms));
           if(bCalphaOnly) {
               if(!bNode) {
                   alert("The potential will not be shown because the side chains are missing in the structure...");
               }
               else {
                   console.log("The potential will not be shown because the side chains are missing in the structure...");
               }

               return;
           }

           if(atomCnt > 30000) {
               if(!bNode) {
                   alert("The maximum number of allowed atoms is 30,000. Please try it again with selected chains...");
               }
               else {
                   console.log("The maximum number of allowed atoms is 30,000. Please try it again with selected chains...");
               }

               return;
           }

           let pdbstr = '';
    ///       pdbstr += ic.saveFileCls.getPDBHeader();

           let bMergeIntoOne = true, bOneLetterChain = true;
           pdbstr +=(me.cfg.cid) ? ic.saveFileCls.getAtomPDB(atomHash, true, undefined, undefined, undefined, undefined, bMergeIntoOne, bOneLetterChain) : ic.saveFileCls.getAtomPDB(atomHash, undefined, undefined, undefined, undefined, undefined, bMergeIntoOne, bOneLetterChain);
           pdbstr += ic.saveFileCls.getAtomPDB(ionHash, true, undefined, true, undefined, undefined, bMergeIntoOne, bOneLetterChain);

           return pdbstr;
        }

        async CalcPhi(gsize, salt, contour, bSurface, data) { let ic = this.icn3d; ic.icn3dui;
            let phidata = await this.CalcPhiPrms(gsize, salt, contour, bSurface, data);

            this.loadPhiData(phidata, contour, bSurface);

            ic.bAjaxPhi = true;

            if(bSurface) {
                ic.setOptionCls.setOption('phisurface', 'phi');
            }
            else {
                ic.setOptionCls.setOption('phimap', 'phi');
            }

            /// if(ic.deferredDelphi !== undefined) ic.deferredDelphi.resolve();
            /// if(ic.deferredPhi !== undefined) ic.deferredPhi.resolve();
        }

        CalcPhiPrms(gsize, salt, contour, bSurface, data) { let ic = this.icn3d, me = ic.icn3dui;
            ic.loadPhiFrom = 'delphi';
     
            let url = me.htmlCls.baseUrl + "delphi/delphi.cgi";
            let pdbid =(me.cfg.cid) ? me.cfg.cid : Object.keys(ic.structures).toString();
            let dataObj = {};
     
            if(data) {
                dataObj = {'pqr2phi': data, 'gsize': gsize, 'salt': salt, 'pdbid': pdbid};
            }
            else {
                let pdbstr = this.getPdbStr();
     
                dataObj = {'pdb2phi': pdbstr, 'gsize': gsize, 'salt': salt, 'pdbid': pdbid};
            }

            return new Promise(function(resolve, reject) {
                // see icn3dui.js for ajaxTransport
                $.ajax({
                    url: url,
                    type: 'POST',
                    data : dataObj,
                    dataType: 'binary',
                    responseType: 'arraybuffer',
                    cache: true,
                    beforeSend: function() {
                        ic.ParserUtilsCls.showLoading();
                    },
                    complete: function() {
                        ic.ParserUtilsCls.hideLoading();
                    },
                    success: function(phidata) {
                        resolve(phidata);
                    },
                    error : function(xhr, textStatus, errorThrown ) {
                        return;
                    }
                });
            });
        }

        async PhiParser(url, type, contour, bSurface) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;
            //var dataType;

            //var bCid = undefined;

            //https://stackoverflow.com/questions/33902299/using-jquery-ajax-to-download-a-binary-file
        /*
            if(type == '2fofc' && ic.bAjax2fofc) {
                ic.mapData.contour2 = contour;
                ic.setOptionCls.setOption('map', type);
            }
            else if(type == 'fofc' && ic.bAjaxfofc) {
                ic.mapData.contour = contour;
                ic.setOptionCls.setOption('map', type);
            }
            else {
        */

                let responseType;
                if(type == 'phiurl' || type == 'phiurl2') {
                    responseType = "arraybuffer";
                }
                else {
                    responseType = "text";
                }

                let data = await me.getXMLHttpRqstPromise(url, 'GET', responseType, 'potential');

                if(type == 'phiurl' || type == 'phiurl2') {
                    thisClass.loadPhiData(data, contour, bSurface);
                }
                else {
                    thisClass.loadCubeData(data, contour, bSurface);
                }

                ic.bAjaxPhi = true;

                if(bSurface) {
                  ic.setOptionCls.setOption('phisurface', 'phi');
                }
                else {
                  ic.setOptionCls.setOption('phimap', 'phi');
                }
        //    }
        }

        loadPhiData(data, contour, bSurface) { let ic = this.icn3d; ic.icn3dui;
            // http://compbio.clemson.edu/downloadDir/delphi/delphi_manual8.pdf
            // Delphi phi map is almost the same as GRASP potential map except the last line in Delphi phi map
            //   has five float values and the last value is the grid size.

            let header = {};
            header.filetype = 'phi';

            let bin =(data.buffer && data.buffer instanceof ArrayBuffer) ? data.buffer : data;
        //var byteView = new Uint8Array(bin);

            // skip 4 bytes before and after each line
            //http://compbio.clemson.edu/downloadDir/delphi/delphi_manual8.pdf
            //character*20 uplbl
            //character*10 nxtlbl,character*60 toplbl
            //real*4 phi(65,65,65)
            //character*16 botlbl
            //real*4 scale,oldmid(3)

        //var headStr = String.fromCharCode.apply(null, byteView.subarray(0, 106));
        //var uplbl = headStr.substr(4, 20); // 20 chars, 0-28, skip 4 bytes at both ends
        //var nxtlbl = headStr.substr(32, 70); // 70 chars, 28-106, skip 4 bytes at both ends

            // 16 chars, bin.byteLength-52 : bin.byteLength-28, skip 4 bytes at both ends
        //var botlbl = String.fromCharCode.apply(null, byteView.subarray(byteView.length - 48, byteView.length - 32));

            // 20 chars, bin.byteLength-28 : bin.byteLength, skip 4 bytes at both ends
            let scale_center = new Float32Array(bin.slice(bin.byteLength-24, bin.byteLength-8) ); // 4 values
            header.scale = scale_center[0];
            let cx = scale_center[1], cy = scale_center[2], cz = scale_center[3];

            // gridSize
            header.n = new Int32Array(bin.slice(bin.byteLength-8, bin.byteLength-4) ); // 1 value, skip the last 4 bytes

            header.xExtent = header.yExtent = header.zExtent = header.n;

            let step = 1.0/header.scale;
            let half_size = step *((header.n - 1) / 2);
            header.ori = new THREE.Vector3(cx - half_size, cy - half_size, cz - half_size);

            // matrix: n*n*n*4 chars, 106 : bin.byteLength-52, skip 4 bytes at both ends
            // In .phi file, correctly loop x, then y, then z
            let floatView = new Float32Array(bin.slice(110, bin.byteLength-56) ); // 4 values

            header.bSurface = bSurface;

            ic.mapData.headerPhi = header;
            ic.mapData.dataPhi = floatView;
            ic.mapData.contourPhi = contour;

            let matrix = new THREE.Matrix4();
            matrix.identity();
            matrix.multiply(new THREE.Matrix4().makeTranslation(
              header.ori.x, header.ori.y, header.ori.z
            ));
            ic.mapData.matrixPhi = matrix;
        }

        loadCubeData(data, contour, bSurface) { let ic = this.icn3d; ic.icn3dui;
            // http://compbio.clemson.edu/downloadDir/delphi/delphi_manual8.pdf
        //  2.000000   117 22.724000 42.148000  8.968000 // scale, grid size, center x, y, z
        //Gaussian cube format phimap
        //    1    -11.859921     24.846119    -37.854994
        //  117      0.944863      0.000000      0.000000
        //  117      0.000000      0.944863      0.000000
        //  117      0.000000      0.000000      0.944863
        //    1      0.000000      0.000000      0.000000      0.000000
        // -2.89368e+00 -2.91154e+00 -2.92951e+00 -2.94753e+00 -2.96562e+00 -2.98375e+00 // each section contains 117 values, loops z, then y, then x

            let header = {};
            header.filetype = 'cube';

            let lines = data.split('\n');

            let paraArray = [];

        /*
            let tmpArray = lines[0].split(/\s+/);
            for(let i = 0; i < tmpArray.length; ++i) {
                let value = parseFloat(tmpArray[i]);
                if(!isNaN(value)) paraArray.push(value);
            }
        */
            paraArray.push(parseFloat( lines[0].substr(0, 10) ) );
            paraArray.push(parseFloat( lines[0].substr(10, 6) ) );
            paraArray.push(parseFloat( lines[0].substr(16, 10) ) );
            paraArray.push(parseFloat( lines[0].substr(26, 10) ) );
            paraArray.push(parseFloat( lines[0].substr(36, 10) ) );

            header.scale = paraArray[0];
            let cx = paraArray[2], cy = paraArray[3], cz = paraArray[4];

            // gridSize
            header.n = paraArray[1];

            header.xExtent = header.yExtent = header.zExtent = header.n;

            let step = 1.0/header.scale;
            let half_size = step *((header.n - 1) / 2);
            header.ori = new THREE.Vector3(cx - half_size, cy - half_size, cz - half_size);

            let dataPhi = [];
            for(let i = 7, il = lines.length; i < il; ++i) {
                let valueArray = lines[i].split(/\s+/);
                for(let j = 0, jl = valueArray.length; j < jl; ++j) {
                    let value = parseFloat(valueArray[j]);
                    if(!isNaN(value)) dataPhi.push(value);
                }
            }

            if(dataPhi.length != header.n * header.n * header.n) {
                console.log("the data array size " + dataPhi.length + " didn't match the grid size " + header.n * header.n * header.n + "...");
            }

            header.bSurface = bSurface;

            ic.mapData.headerPhi = header;
            ic.mapData.dataPhi = dataPhi;
            ic.mapData.contourPhi = contour;

            let matrix = new THREE.Matrix4();
            matrix.identity();
            matrix.multiply(new THREE.Matrix4().makeTranslation(
              header.ori.x, header.ori.y, header.ori.z
            ));
            ic.mapData.matrixPhi = matrix;
        }

        async applyCommandPhi(command) { let ic = this.icn3d; ic.icn3dui;
          let thisClass = this;
          // chain functions together
        //   ic.deferredPhi = $.Deferred(function() { let ic = thisClass.icn3d;
              //me.htmlCls.clickMenuCls.setLogCmd('set phi phiurl2/cubeurl2 | contour ' + contour + ' | url ' + encodeURIComponent(url)
              //       + ' | gsize ' + gsize + ' | salt ' + salt
              //       + ' | surface ' + ic.phisurftype + ' | opacity ' + ic.phisurfop + ' | wireframe ' + ic.phisurfwf, true);
              //me.htmlCls.clickMenuCls.setLogCmd('set phi phiurl/cubeurl | contour ' + contour + ' | url ' + encodeURIComponent(url)
              //       + ' | gsize ' + gsize + ' | salt ' + salt, true);
              let paraArray = command.split(" | ");

              let typeArray = paraArray[0].split(" ");
              let contourArray = paraArray[1].split(" ");
              let urlArray = paraArray[2].split(" ");
              let gsizeArray = paraArray[3].split(" ");
              let saltArray = paraArray[4].split(" ");

              let type = typeArray[2];
              let contour = parseFloat(contourArray[1]);
              let url = urlArray[1];
              let gsize = gsizeArray[1];
              let salt = saltArray[1];

              //var pdbid = Object.keys(ic.structures)[0];
              //url = url.replace(/!/g, pdbid + '_');

              if(paraArray.length == 8) {
                  let surfaceArray = paraArray[5].split(" ");
                  let opacityArray = paraArray[6].split(" ");
                  let wireframeArray = paraArray[7].split(" ");

                  ic.phisurftype = surfaceArray[1];
                  ic.phisurfop = parseFloat(opacityArray[1]);
                  ic.phisurfwf = wireframeArray[1];

                  $("#" + ic.pre + "delphi" + "surftype").val(ic.phisurftype);
                  $("#" + ic.pre + "delphi" + "surfop").val(ic.phisurfop);
                  $("#" + ic.pre + "delphi" + "surfwf").val(ic.phisurfwf);
              }

              let bSurface =(type == 'pqrurl2' || type == 'phiurl2' || type == 'cubeurl2') ? true : false;

              if(type == 'pqrurl' || type == 'pqrurl2') {
                  await thisClass.CalcPhiUrl(gsize, salt, contour, bSurface, url);
              }
              else {
                  await thisClass.PhiParser(url, type, contour, bSurface);
              }
        //   }); // end of me.deferred = $.Deferred(function() {

        //   return ic.deferredPhi.promise();
        }

        async applyCommandDelphi(command) { let ic = this.icn3d; ic.icn3dui;
          let thisClass = this;

          // chain functions together
        //   ic.deferredDelphi = $.Deferred(function() { let ic = thisClass.icn3d;
               //me.htmlCls.clickMenuCls.setLogCmd('set delphi surface | contour ' + contour + ' | gsize ' + gsize + ' | salt ' + salt
               //  + ' | surface ' + ic.phisurftype + ' | opacity ' + ic.phisurfop + ' | wireframe ' + ic.phisurfwf, true);

               //me.htmlCls.clickMenuCls.setLogCmd('set delphi map | contour ' + contour + ' | gsize ' + gsize + ' | salt ' + salt, true);

              let paraArray = command.split(" | ");

              let typeArray = paraArray[0].split(" ");
              let contourArray = paraArray[1].split(" ");
              let gsizeArray = paraArray[2].split(" ");
              let saltArray = paraArray[3].split(" ");

              let type = typeArray[2];
              let contour = contourArray[1]; //parseFloat(contourArray[1]);
              let gsize = gsizeArray[1]; //parseInt(gsizeArray[1]);
              let salt = saltArray[1]; //parseFloat(saltArray[1]);

              // The values should be string
              $("#" + ic.pre + "delphi1gsize").val(gsize);
              $("#" + ic.pre + "delphi1salt").val(salt);

              $("#" + ic.pre + "delphi2gsize").val(gsize);
              $("#" + ic.pre + "delphi2salt").val(salt);

              if(paraArray.length == 7) {
                  let surfaceArray = paraArray[4].split(" ");
                  let opacityArray = paraArray[5].split(" ");
                  let wireframeArray = paraArray[6].split(" ");

                  ic.phisurftype = surfaceArray[1];
                  ic.phisurfop = opacityArray[1]; //parseFloat(opacityArray[1]);
                  ic.phisurfwf = wireframeArray[1];

                  $("#" + ic.pre + "delphi" + "surftype").val(ic.phisurftype);
                  $("#" + ic.pre + "delphi" + "surfop").val(ic.phisurfop);
                  $("#" + ic.pre + "delphi" + "surfwf").val(ic.phisurfwf);
              }

              let bSurface =(type == 'surface') ? true : false;

              await thisClass.CalcPhi(gsize, salt, contour, bSurface);
        //   }); // end of me.deferred = $.Deferred(function() {

        //   return ic.deferredDelphi.promise();
        }

        async loadDelphiFile(type) { let ic = this.icn3d, me = ic.icn3dui;
           let gsize = (type == 'delphi2') ? $("#" + ic.pre + "delphi2gsize").val() : $("#" + ic.pre + "delphi1gsize").val();
           let salt = (type == 'delphi2') ? $("#" + ic.pre + "delphi2salt").val() : $("#" + ic.pre + "delphi1gsize").val();
           let contour = (type == 'delphi2') ? $("#" + ic.pre + "delphicontour2").val() : $("#" + ic.pre + "delphicontour").val();

           let bSurface = (type == 'delphi2') ? true: false;

           await this.CalcPhi(gsize, salt, contour, bSurface);

           let displayType =(type == 'delphi2') ? 'surface' : 'map';

           if(bSurface) {
               me.htmlCls.clickMenuCls.setLogCmd('set delphi ' + displayType + ' | contour ' + contour + ' | gsize ' + gsize + ' | salt ' + salt
                 + ' | surface ' + ic.phisurftype + ' | opacity ' + ic.phisurfop + ' | wireframe ' + ic.phisurfwf, true);
           }
           else {
               me.htmlCls.clickMenuCls.setLogCmd('set delphi ' + displayType + ' | contour ' + contour + ' | gsize ' + gsize + ' | salt ' + salt, true);
           }
        }

        loadPhiFile(type) { let ic = this.icn3d, me = ic.icn3dui;
           let thisClass = this;

           let file;
           if(type == 'pqr' || type == 'phi' || type == 'cube') {
               file = $("#" + ic.pre + type + "file")[0].files[0];
           }
           else if(type == 'pqr2') {
               file = $("#" + ic.pre + "pqrfile2")[0].files[0];
           }
           else if(type == 'phi2') {
               file = $("#" + ic.pre + "phifile2")[0].files[0];
           }
           else if(type == 'cube2') {
               file = $("#" + ic.pre + "cubefile2")[0].files[0];
           }

           let contour =(type == 'pqr' || type == 'phi' || type == 'cube') ? $("#" + ic.pre + "phicontour").val() : $("#" + ic.pre + "phicontour2").val();
           if(!file) {
             alert("Please select a file before clicking 'Load'");
           }
           else {
             me.utilsCls.checkFileAPI();
             let reader = new FileReader();
             reader.onload = async function(e) { let ic = thisClass.icn3d;
               let data = e.target.result; // or = reader.result;

               let gsize = 0, salt = 0;
               if(type == 'pqr' || type == 'pqr2') {
                 let bSurface =(type == 'pqr2') ? true: false;

                 gsize = $("#" + ic.pre + type + "gsize").val();
                 salt = $("#" + ic.pre + type + "salt").val();
                 await thisClass.CalcPhi(gsize, salt, contour, bSurface, data);
               }
               else if(type == 'phi' || type == 'phi2') {
                 let bSurface =(type == 'phi2') ? true: false;
                 thisClass.loadPhiData(data, contour, bSurface);
               }
               else if(type == 'cube' || type == 'cube2') {
                 let bSurface =(type == 'cube2') ? true: false;
                 thisClass.loadCubeData(data, contour, bSurface);
               }

               ic.bAjaxPhi = true;

               if(bSurface) {
                 ic.setOptionCls.setOption('phisurface', 'phi');
               }
               else {
                 ic.setOptionCls.setOption('phimap', 'phi');
               }

               if(bSurface) {
                   me.htmlCls.clickMenuCls.setLogCmd('load phi ' + type + ' | contour ' + contour + ' | file ' + $("#" + ic.pre + type + "file").val()
                     + ' | gsize ' + gsize + ' | salt ' + salt
                     + ' | surface ' + ic.phisurftype + ' | opacity ' + ic.phisurfop + ' | wireframe ' + ic.phisurfwf, false);
               }
               else {
                   me.htmlCls.clickMenuCls.setLogCmd('load phi ' + type + ' | contour ' + contour + ' | file ' + $("#" + ic.pre + type + "file").val()
                     + ' | gsize ' + gsize + ' | salt ' + salt, false);
               }
             };
             if(type == 'phi' || type == 'phi2') {
                 reader.readAsArrayBuffer(file);
             }
             else {
                 reader.readAsText(file);
             }
           }
        }
        async loadPhiFileUrl(type) { let ic = this.icn3d, me = ic.icn3dui;
           let url;
           if(type == 'pqrurl' || type == 'phiurl' || type == 'cubeurl') {
               url = $("#" + ic.pre + type + "file").val();
           }
           else if(type == 'pqrurl2') {
               url = $("#" + ic.pre + "pqrurlfile2").val();
           }
           else if(type == 'phiurl2') {
               url = $("#" + ic.pre + "phiurlfile2").val();
           }
           else if(type == 'cubeurl2') {
               url = $("#" + ic.pre + "cubeurlfile2").val();
           }

           let contour =(type == 'pqrurl' || type == 'phiurl' || type == 'cubeurl') ? $("#" + ic.pre + "phiurlcontour").val() :  $("#" + ic.pre + "phiurlcontour2").val();
           if(!url) {
                alert("Please input the file URL before clicking 'Load'");
           }
           else {
               let bSurface =(type == 'pqrurl2' || type == 'phiurl2' || type == 'cubeurl2') ? true: false;

               let gsize = 0, salt = 0;

               if(type == 'pqrurl' || type == 'pqrurl2') {
                   gsize = $("#" + ic.pre + type + "gsize").val();
                   salt = $("#" + ic.pre + type + "salt").val();
                   await this.CalcPhiUrl(gsize, salt, contour, bSurface, url);
               }
               else {
                   await this.PhiParser(url, type, contour, bSurface);
               }

               if(bSurface) {
                   me.htmlCls.clickMenuCls.setLogCmd('set phi ' + type + ' | contour ' + contour + ' | url ' + encodeURIComponent(url)
                     + ' | gsize ' + gsize + ' | salt ' + salt
                     + ' | surface ' + ic.phisurftype + ' | opacity ' + ic.phisurfop + ' | wireframe ' + ic.phisurfwf, true);
               }
               else {
                   me.htmlCls.clickMenuCls.setLogCmd('set phi ' + type + ' | contour ' + contour + ' | url ' + encodeURIComponent(url)
                     + ' | gsize ' + gsize + ' | salt ' + salt, true);
               }
           }
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Dssp {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        async applyDssp(bCalphaOnly, bAppend) { let ic = this.icn3d, me = ic.icn3dui;
          let thisClass = this;

          let calphaonly =(bCalphaOnly) ? '1' : '0';

          // make it work for concatenated multiple PDB files
          let struArray = Object.keys(ic.structures);

          let ajaxArray = [];

          let url = (window && window.location && window.location.hostname.indexOf('ncbi.nlm.nih.gov') != -1) ? "/Structure/mmcifparser/mmcifparser.cgi" :
            me.htmlCls.baseUrl + "mmcifparser/mmcifparser.cgi";
            
          for(let i = 0, il = struArray.length; i < il; ++i) {
               let pdbStr = '';

               let atomHash = {};
               let chainidArray = ic.structures[struArray[i]];

               for(let j = 0, jl = chainidArray.length; j < jl; ++j) {
                 atomHash = me.hashUtilsCls.unionHash(atomHash, ic.chains[chainidArray[j]]);
               }

               pdbStr += ic.saveFileCls.getAtomPDB(atomHash, undefined, true);

               let dataObj = {'dssp':'t', 'calphaonly': calphaonly, 'pdbfile': pdbStr};
               let dssp = me.getAjaxPostPromise(url, dataObj);

               ajaxArray.push(dssp);
          }

            let allPromise = Promise.allSettled(ajaxArray);
            try {
                let dataArray = await allPromise;

                await thisClass.parseDsspData(dataArray, struArray, bAppend);

                if(!me.bNode) await ic.ParserUtilsCls.checkMemProteinAndRotate();
            }
            catch(err) {
                console.log("DSSP calculation had a problem with this structure " + struArray[0] + "...");

                await ic.pdbParserCls.loadPdbDataRender(bAppend);
            }
        }

        async parseDsspData(dataArray, struArray, bAppend) { let ic = this.icn3d; ic.icn3dui;
            //var dataArray =(struArray.length == 1) ? [data] : data;

            // Each argument is an array with the following structure: [ data, statusText, jqXHR ]
            //var data2 = v2[0];
            for(let index = 0, indexl = dataArray.length; index < indexl; ++index) {
                //let ssHash = dataArray[index][0];
                //let ssHash = (me.bNode) ? dataArray[index] : dataArray[index].value;
                let ssHash = dataArray[index].value;

                if(ssHash !== undefined && JSON.stringify(ssHash).indexOf('Oops there was a problem') === -1) {
                  for(let chainNum in ic.chainsSeq) {
                      let pos = chainNum.indexOf('_');
                      // one structure at a time
                      if(chainNum.substr(0, pos) != struArray[index]) continue;

                      let chain = chainNum.substr(pos + 1);

                      let residueObjectArray = ic.chainsSeq[chainNum];
                      let prevSS = 'coil', prevResi;

                      for(let i = 0, il = residueObjectArray.length; i < il; ++i) {
                        let resi = residueObjectArray[i].resi;
                        let chain_resi = chain + '_' + resi;

                        let ssOneLetter = 'c';
                        if(ssHash.hasOwnProperty(chain_resi)) {
                            ssOneLetter = ssHash[chain_resi];
                        }
                        else if(ssHash.hasOwnProperty(' _' + resi)) {
                            ssOneLetter = ssHash[' _' + resi];
                        }
                        else if(ssHash.hasOwnProperty('_' + resi)) {
                            ssOneLetter = ssHash['_' + resi];
                        }

                        let ss;
                        if(ssOneLetter === 'H') {
                            ss = 'helix';
                        }
                        else if(ssOneLetter === 'E') {
                            ss = 'sheet';
                        }
                        else {
                            ss = 'coil';
                        }

                        // update ss in sequence window
                        //ic.chainsAn[chainNum][1][i] = ssOneLetter;

                        // assign atom ss, ssbegin, and ssend
                        let resid = chainNum + '_' + resi;

                        ic.secondaries[resid] = ssOneLetter;

                        // no residue can be both ssbegin and ssend in DSSP calculated secondary structures
                        let bSetPrevResidue = 0; // 0: no need to reset, 1: reset previous residue to "ssbegin = true", 2: reset previous residue to "ssend = true"

                        let ssbegin, ssend;
                        if(ss !== prevSS) {
                            if(prevSS === 'coil') {
                                ssbegin = true;
                                ssend = false;
                            }
                            else if(ss === 'coil') {
                                bSetPrevResidue = 2;
                                ssbegin = false;
                                ssend = false;
                            }
                            else if((prevSS === 'sheet' && ss === 'helix') ||(prevSS === 'helix' && ss === 'sheet')) {
                                //bSetPrevResidue = 1;
                                bSetPrevResidue = 2;
                                ssbegin = true;
                                ssend = false;
                            }
                        }
                        else {
                                ssbegin = false;
                                ssend = false;
                        }

                        if(bSetPrevResidue == 1) { //1: reset previous residue to "ssbegin = true"
                            let prevResid = chainNum + '_' + prevResi; //(resi - 1).toString();
                            for(let j in ic.residues[prevResid]) {
                                ic.atoms[j].ssbegin = true;
                                ic.atoms[j].ssend = false;
                            }
                        }
                        else if(bSetPrevResidue == 2) { //2: reset previous residue to "ssend = true"
                            let prevResid = chainNum + '_' + prevResi; //(resi - 1).toString();
                            for(let j in ic.residues[prevResid]) {
                                ic.atoms[j].ssbegin = false;
                                ic.atoms[j].ssend = true;
                            }
                        }

                        // set the current residue
                        for(let j in ic.residues[resid]) {
                            ic.atoms[j].ss = ss;
                            ic.atoms[j].ssbegin = ssbegin;
                            ic.atoms[j].ssend = ssend;
                        }

                        prevSS = ss;
                        prevResi = resi;
                      } // for each residue
                  } // for each chain
                } // if no error
                else {
                    console.log("DSSP calculation had a problem with this structure " + struArray[index] + "...");
                }
            }

            await ic.pdbParserCls.loadPdbDataRender(bAppend);

            ///// if(ic.deferredMmdbaf !== undefined) ic.deferredMmdbaf.resolve();
            /// if(ic.deferredSecondary !== undefined) ic.deferredSecondary.resolve();
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

     class Refnum {
        constructor(icn3d) {
            this.icn3d = icn3d;
            this.TMThresholdIgType = 0.85;
            this.TMThresholdTemplate = 0.4;
            this.topClusters = 5;
        }

        async hideIgRefNum() { let ic = this.icn3d; ic.icn3dui;
            ic.bShowRefnum = false;
            // ic.bRunRefnum = false;

            // redo all ref numbers
            ic.resid2refnum = {};

            ic.annotationCls.hideAnnoTabIg();

            ic.selectionCls.selectAll_base();
            ic.opts.color = 'chain';
            ic.setColorCls.setColorByOptions(ic.opts, ic.atoms);

            ic.hlUpdateCls.updateHlAll();
            ic.drawCls.draw();

            ic.bResetAnno = true;
            // await ic.showAnnoCls.showAnnotations();
            if(ic.bAnnoShown) {
            //     for(let chain in ic.protein_chainid) {
            //         let chainidBase = ic.protein_chainid[chain];
            //         ic.showSeqCls.showSeq(chain, chainidBase, 'protein');
            //     }
            // }
            // else {
                // await ic.showAnnoCls.showAnnotations();
                await ic.annotationCls.resetAnnoTabAll();
            }
        }

        setRefPdbs() { let ic = this.icn3d; ic.icn3dui;
            // round 1, 16 templates
            ic.refpdbArray = ['1InsulinR_8guyE_human_FN3-n1', '1Endo-1,4-BetaXylanase10A_1i8aA_bacteria_n4', '1CoAtomerGamma1_1r4xA_human', '1C3_2qkiD_human_n1', '1CuZnSuperoxideDismutase_1hl5C_human', '1ASF1A_2iijA_human', '1FAB-LIGHT_5esv_C1-n2', '1CD2_1hnfA_human_C2-n2', '1NaCaExchanger_2fwuA_dog_n2', '1NaKATPaseTransporterBeta_2zxeB_spurdogshark', '1FAB-HEAVY_5esv_V-n1', '1PDL1_4z18B_human_V-n1', '1BTLA_2aw2A_human_Iset', '1LaminAC_1ifrA_human', '1CD3g_6jxrg_human_C2', '1CD28_1yjdC_human_V', '1CD19_6al5A_human-n1'];

            // round 2
            ic.refpdbHash = {};
            ic.refpdbHash['1InsulinR_8guyE_human_FN3-n1'] = ['InsulinR_8guyE_human_FN3-n1', 'IL6Rb_1bquB_human_FN3-n3', 'Sidekick2_1wf5A_human_FN3-n7', 'InsulinR_8guyE_human_FN3-n2', 'Contactin1_2ee2A_human_FN3-n9', 'IL6Rb_1bquB_human_FN3-n2'];
            ic.refpdbHash['1Endo-1,4-BetaXylanase10A_1i8aA_bacteria_n4'] = ['Endo-1,4-BetaXylanase10A_1i8aA_bacteria_n4', 'ICOS_6x4gA_human_V'];
            ic.refpdbHash['1CoAtomerGamma1_1r4xA_human'] = ['CoAtomerGamma1_1r4xA_human', 'TP34_2o6cA_bacteria'];
            ic.refpdbHash['1C3_2qkiD_human_n1'] = ['C3_2qkiD_human_n1', 'BArrestin1_4jqiA_rat_n1', 'RBPJ_6py8C_human_Unk-n1'];
            ic.refpdbHash['1CuZnSuperoxideDismutase_1hl5C_human'] = ['CuZnSuperoxideDismutase_1hl5C_human', 'TEAD1_3kysC_human'];
            ic.refpdbHash['1ASF1A_2iijA_human'] = ['ASF1A_2iijA_human', 'RBPJ_6py8C_human_Unk-n2', 'TP47_1o75A_bacteria'];
            ic.refpdbHash['1FAB-LIGHT_5esv_C1-n2'] = ['FAB-LIGHT_5esv_C1-n2', 'GHR_1axiB_human_C1-n1', 'VTCN1_Q7Z7D3_human_C1-n2', 'B2Microglobulin_7phrL_human_C1', 'FAB-HEAVY_5esv_C1-n2', 'MHCIa_7phrH_human_C1'];
            ic.refpdbHash['1CD2_1hnfA_human_C2-n2'] = ['CD2_1hnfA_human_C2-n2', 'Siglec3_5j0bB_human_C1-n2'];
            ic.refpdbHash['1NaCaExchanger_2fwuA_dog_n2'] = ['NaCaExchanger_2fwuA_dog_n2', 'ORF7a_1xakA_virus', 'ECadherin_4zt1A_human_n2'];
            ic.refpdbHash['1NaKATPaseTransporterBeta_2zxeB_spurdogshark'] = ['NaKATPaseTransporterBeta_2zxeB_spurdogshark'];
            ic.refpdbHash['1FAB-HEAVY_5esv_V-n1'] = ['FAB-HEAVY_5esv_V-n1', 'FAB-LIGHT_5esv_V-n1', 'VNAR_1t6vN_shark_V', 'TCRa_6jxrm_human_V-n1', 'VISTA_6oilA_human_V', 'CD8a_1cd8A_human_V', 'PD1_4zqkB_human_V'];
            ic.refpdbHash['1PDL1_4z18B_human_V-n1'] = ['PDL1_4z18B_human_V-n1', 'CD2_1hnfA_human_V-n1', 'LAG3_7tzgD_human_V-n1'];
            ic.refpdbHash['1BTLA_2aw2A_human_Iset'] = ['BTLA_2aw2A_human_Iset', 'Palladin_2dm3A_human_Iset-n1', 'Titin_4uowM_human_Iset-n152', 'LAG3_7tzgD_human_C1-n2', 'JAM1_1nbqA_human_Iset-n2', 'Contactin1_3s97C_human_Iset-n2'];
            ic.refpdbHash['1LaminAC_1ifrA_human'] = ['LaminAC_1ifrA_human', 'CD3d_6jxrd_human_C1'];
            ic.refpdbHash['1CD3g_6jxrg_human_C2'] = ['CD3g_6jxrg_human_C2', 'TCRa_6jxrm_human_C1-n2', 'IsdA_2iteA_bacteria'];
            ic.refpdbHash['1CD28_1yjdC_human_V'] = ['CD28_1yjdC_human_V', 'MPT63_1lmiA_bacteria', 'CD3e_6jxrf_human_C1'];
            ic.refpdbHash['1CD19_6al5A_human-n1'] = ['CD19_6al5A_human-n1'];

            ic.refpdbHash['all_templates'] = ['ASF1A_2iijA_human', 'B2Microglobulin_7phrL_human_C1', 'BArrestin1_4jqiA_rat_n1', 'BTLA_2aw2A_human_Iset', 'C3_2qkiD_human_n1', 'CD19_6al5A_human-n1', 'CD28_1yjdC_human_V', 'CD2_1hnfA_human_C2-n2', 'CD2_1hnfA_human_V-n1', 'CD3d_6jxrd_human_C1', 'CD3e_6jxrf_human_C1', 'CD3g_6jxrg_human_C2', 'CD8a_1cd8A_human_V', 'CoAtomerGamma1_1r4xA_human', 'Contactin1_2ee2A_human_FN3-n9', 'Contactin1_3s97C_human_Iset-n2', 'CuZnSuperoxideDismutase_1hl5C_human', 'ECadherin_4zt1A_human_n2', 'Endo-1,4-BetaXylanase10A_1i8aA_bacteria_n4', 'FAB-HEAVY_5esv_C1-n2', 'FAB-HEAVY_5esv_V-n1', 'FAB-LIGHT_5esv_C1-n2', 'FAB-LIGHT_5esv_V-n1', 'GHR_1axiB_human_C1-n1', 'ICOS_6x4gA_human_V', 'IL6Rb_1bquB_human_FN3-n2', 'IL6Rb_1bquB_human_FN3-n3', 'InsulinR_8guyE_human_FN3-n1', 'InsulinR_8guyE_human_FN3-n2', 'IsdA_2iteA_bacteria', 'JAM1_1nbqA_human_Iset-n2', 'LAG3_7tzgD_human_C1-n2', 'LAG3_7tzgD_human_V-n1', 'LaminAC_1ifrA_human', 'MHCIa_7phrH_human_C1', 'MPT63_1lmiA_bacteria', 'NaCaExchanger_2fwuA_dog_n2', 'NaKATPaseTransporterBeta_2zxeB_spurdogshark', 'ORF7a_1xakA_virus', 'PD1_4zqkB_human_V', 'PDL1_4z18B_human_V-n1', 'Palladin_2dm3A_human_Iset-n1', 'RBPJ_6py8C_human_Unk-n1', 'RBPJ_6py8C_human_Unk-n2', 'Sidekick2_1wf5A_human_FN3-n7', 'Siglec3_5j0bB_human_C1-n2', 'TCRa_6jxrm_human_C1-n2', 'TCRa_6jxrm_human_V-n1', 'TEAD1_3kysC_human', 'TP34_2o6cA_bacteria', 'TP47_1o75A_bacteria', 'Titin_4uowM_human_Iset-n152', 'VISTA_6oilA_human_V', 'VNAR_1t6vN_shark_V', 'VTCN1_Q7Z7D3_human_C1-n2'];

            // use known ref structure
            ic.refpdbHash['5ESV_C'] = ['FAB-HEAVY_5esv_V-n1', 'FAB-HEAVY_5esv_C1-n2'];
            ic.refpdbHash['5ESV_D'] = ['FAB-LIGHT_5esv_V-n1', 'FAB-LIGHT_5esv_C1-n2'];
            ic.refpdbHash['8GUY_E'] = ['InsulinR_8guyE_human_FN3-n1', 'InsulinR_8guyE_human_FN3-n2'];
            ic.refpdbHash['6JXR_m'] = ['TCRa_6jxrm_human_V-n1', 'TCRa_6jxrm_human_C1-n2'];
            ic.refpdbHash['1HNF_A'] = ['CD2_1hnfA_human_V-n1', 'CD2_1hnfA_human_C2-n2'];
            ic.refpdbHash['7TZG_D'] = ['LAG3_7tzgD_human_V-n1', 'LAG3_7tzgD_human_C1-n2'];
            ic.refpdbHash['6PY8_C'] = ['RBPJ_6py8C_human_Unk-n1', 'RBPJ_6py8C_human_Unk-n2'];
            ic.refpdbHash['1BQU_B'] = ['IL6Rb_1bquB_human_FN3-n2', 'IL6Rb_1bquB_human_FN3-n3'];

            ic.refpdbHash['1R4X_A'] = ['CoAtomerGamma1_1r4xA_human'];
            ic.refpdbHash['6OIL_A'] = ['VISTA_6oilA_human_V'];
            ic.refpdbHash['2ZXE_B'] = ['NaKATPaseTransporterBeta_2zxeB_spurdogshark'];
            ic.refpdbHash['1I8A_A'] = ['Endo-1,4-BetaXylanase10A_1i8aA_bacteria_n4'];
            ic.refpdbHash['2FWU_A'] = ['NaCaExchanger_2fwuA_dog_n2'];
            ic.refpdbHash['4JQI_A'] = ['BArrestin1_4jqiA_rat_n1'];
            ic.refpdbHash['1NBQ_A'] = ['JAM1_1nbqA_human_Iset-n2'];
            ic.refpdbHash['1O75_A'] = ['TP47_1o75A_bacteria'];
            ic.refpdbHash['7PHR_H'] = ['MHCIa_7phrH_human_C1'];
            ic.refpdbHash['2IIJ_A'] = ['ASF1A_2iijA_human'];
            ic.refpdbHash['4Z18_B'] = ['PDL1_4z18B_human_V-n1'];
            ic.refpdbHash['1T6V_N'] = ['VNAR_1t6vN_shark_V'];
            ic.refpdbHash['2O6C_A'] = ['TP34_2o6cA_bacteria'];
            ic.refpdbHash['3KYS_C'] = ['TEAD1_3kysC_human'];
            ic.refpdbHash['7PHR_L'] = ['B2Microglobulin_7phrL_human_C1'];
            ic.refpdbHash['2AW2_A'] = ['BTLA_2aw2A_human_Iset'];
            ic.refpdbHash['1HL5_C'] = ['CuZnSuperoxideDismutase_1hl5C_human'];
            ic.refpdbHash['1WF5_A'] = ['Sidekick2_1wf5A_human_FN3-n7'];
            ic.refpdbHash['5J0B_B'] = ['Siglec3_5j0bB_human_C1-n2'];
            ic.refpdbHash['1IFR_A'] = ['LaminAC_1ifrA_human'];
            ic.refpdbHash['Q7Z7D3_A'] = ['VTCN1_Q7Z7D3_human_C1-n2'];
            ic.refpdbHash['4ZQK_B'] = ['PD1_4zqkB_human_V'];
            ic.refpdbHash['2DM3_A'] = ['Palladin_2dm3A_human_Iset-n1'];
            ic.refpdbHash['2ITE_A'] = ['IsdA_2iteA_bacteria'];
            ic.refpdbHash['1XAK_A'] = ['ORF7a_1xakA_virus'];
            ic.refpdbHash['4ZT1_A'] = ['ECadherin_4zt1A_human_n2'];
            ic.refpdbHash['1LMI_A'] = ['MPT63_1lmiA_bacteria'];
            ic.refpdbHash['1CD8_A'] = ['CD8a_1cd8A_human_V'];
            ic.refpdbHash['3S97_C'] = ['Contactin1_3s97C_human_Iset-n2'];
            ic.refpdbHash['1AXI_B'] = ['GHR_1axiB_human_C1-n1'];
            ic.refpdbHash['6X4G_A'] = ['ICOS_6x4gA_human_V'];
            ic.refpdbHash['2EE2_A'] = ['Contactin1_2ee2A_human_FN3-n9'];
            ic.refpdbHash['4UOW_M'] = ['Titin_4uowM_human_Iset-n152'];
            ic.refpdbHash['6A15_A'] = ['CD19_6al5A_human-n1'];
            ic.refpdbHash['2QKI_D'] = ['C3_2qkiD_human_n1'];
            ic.refpdbHash['1YJD_C'] = ['CD28_1yjdC_human_V'];
            ic.refpdbHash['6JXR_d'] = ['CD3d_6jxrd_human_C1'];
            ic.refpdbHash['6JXR_f'] = ['CD3e_6jxrf_human_C1'];
            ic.refpdbHash['6JXR_g'] = ['CD3g_6jxrg_human_C2'];

            // assign Ig types
            ic.ref2igtype = {};

            ic.ref2igtype['ASF1A_2iijA_human'] = 'IgFN3-like';
            ic.ref2igtype['B2Microglobulin_7phrL_human_C1'] = 'IgC1';
            ic.ref2igtype['BArrestin1_4jqiA_rat_n1'] = 'IgFN3-like';
            ic.ref2igtype['BTLA_2aw2A_human_Iset'] = 'IgI';
            ic.ref2igtype['C3_2qkiD_human_n1'] = 'IgFN3-like';
            ic.ref2igtype['CD19_6al5A_human-n1'] = 'CD19';
            ic.ref2igtype['CD28_1yjdC_human_V'] = 'IgV';
            ic.ref2igtype['CD2_1hnfA_human_C2-n2'] = 'IgC2';
            ic.ref2igtype['CD2_1hnfA_human_V-n1'] = 'IgV';
            ic.ref2igtype['CD3d_6jxrd_human_C1'] = 'IgC1';
            ic.ref2igtype['CD3e_6jxrf_human_C1'] = 'IgC1';
            ic.ref2igtype['CD3g_6jxrg_human_C2'] = 'IgC2';
            ic.ref2igtype['CD8a_1cd8A_human_V'] = 'IgV';
            ic.ref2igtype['CoAtomerGamma1_1r4xA_human'] = 'IgE';
            ic.ref2igtype['Contactin1_2ee2A_human_FN3-n9'] = 'IgFN3';
            ic.ref2igtype['Contactin1_3s97C_human_Iset-n2'] = 'IgI';
            ic.ref2igtype['CuZnSuperoxideDismutase_1hl5C_human'] = 'SOD';
            ic.ref2igtype['ECadherin_4zt1A_human_n2'] = 'Cadherin';
            ic.ref2igtype['Endo-1,4-BetaXylanase10A_1i8aA_bacteria_n4'] = 'IgE';
            ic.ref2igtype['FAB-HEAVY_5esv_C1-n2'] = 'IgC1';
            ic.ref2igtype['FAB-HEAVY_5esv_V-n1'] = 'IgV';
            ic.ref2igtype['FAB-LIGHT_5esv_C1-n2'] = 'IgC1';
            ic.ref2igtype['FAB-LIGHT_5esv_V-n1'] = 'IgV';
            ic.ref2igtype['GHR_1axiB_human_C1-n1'] = 'IgC1';
            ic.ref2igtype['ICOS_6x4gA_human_V'] = 'IgV';
            ic.ref2igtype['IL6Rb_1bquB_human_FN3-n2'] = 'IgFN3';
            ic.ref2igtype['IL6Rb_1bquB_human_FN3-n3'] = 'IgFN3';
            ic.ref2igtype['InsulinR_8guyE_human_FN3-n1'] = 'IgFN3';
            ic.ref2igtype['InsulinR_8guyE_human_FN3-n2'] = 'IgFN3';
            ic.ref2igtype['IsdA_2iteA_bacteria'] = 'IgE';
            ic.ref2igtype['JAM1_1nbqA_human_Iset-n2'] = 'IgI';
            ic.ref2igtype['LAG3_7tzgD_human_C1-n2'] = 'IgC1';
            ic.ref2igtype['LAG3_7tzgD_human_V-n1'] = 'IgV';
            ic.ref2igtype['LaminAC_1ifrA_human'] = 'Lamin';
            ic.ref2igtype['MHCIa_7phrH_human_C1'] = 'IgC1';
            ic.ref2igtype['MPT63_1lmiA_bacteria'] = 'IgFN3-like';
            ic.ref2igtype['NaCaExchanger_2fwuA_dog_n2'] = 'IgFN3-like';
            ic.ref2igtype['NaKATPaseTransporterBeta_2zxeB_spurdogshark'] = 'IgE';
            ic.ref2igtype['ORF7a_1xakA_virus'] = 'ORF';
            ic.ref2igtype['PD1_4zqkB_human_V'] = 'IgV';
            ic.ref2igtype['PDL1_4z18B_human_V-n1'] = 'IgV';
            ic.ref2igtype['Palladin_2dm3A_human_Iset-n1'] = 'IgI';
            ic.ref2igtype['RBPJ_6py8C_human_Unk-n1'] = 'IgFN3-like';
            ic.ref2igtype['RBPJ_6py8C_human_Unk-n2'] = 'IgFN3-like';
            ic.ref2igtype['Sidekick2_1wf5A_human_FN3-n7'] = 'IgFN3';
            ic.ref2igtype['Siglec3_5j0bB_human_C1-n2'] = 'IgC1';
            ic.ref2igtype['TCRa_6jxrm_human_C1-n2'] = 'IgC1';
            ic.ref2igtype['TCRa_6jxrm_human_V-n1'] = 'IgV';
            ic.ref2igtype['TEAD1_3kysC_human'] = 'IgFN3-like';
            ic.ref2igtype['TP34_2o6cA_bacteria'] = 'IgE';
            ic.ref2igtype['TP47_1o75A_bacteria'] = 'IgE';
            ic.ref2igtype['Titin_4uowM_human_Iset-n152'] = 'IgI';
            ic.ref2igtype['VISTA_6oilA_human_V'] = 'IgV';
            ic.ref2igtype['VNAR_1t6vN_shark_V'] = 'IgV';
            ic.ref2igtype['VTCN1_Q7Z7D3_human_C1-n2'] = 'IgC1';
        }

        getPdbAjaxArray() {  let ic = this.icn3d, me = ic.icn3dui;
            let pdbAjaxArray = [];
            for(let k = 0, kl = ic.refpdbArray.length; k < kl; ++k) {
                let urlpdb = me.htmlCls.baseUrl + "mmcifparser/mmcifparser.cgi?refpdbid=" + ic.refpdbArray[k];
                //let urlpdb = me.htmlCls.baseUrl + "mmcifparser/mmcifparser.cgi?refjsonid=" + ic.refpdbArray[k];

                let pdbAjax = me.getAjaxPromise(urlpdb, 'text');

                pdbAjaxArray.push(pdbAjax);
            }

            return pdbAjaxArray;
        }

        async showIgRefNum(template) { let ic = this.icn3d; ic.icn3dui;
            let thisClass = this;

            this.setRefPdbs();

            let pdbAjaxArray = this.getPdbAjaxArray();

            // try {
                if(!template) {
                    //let allPromise = Promise.allSettled(pdbAjaxArray);
                    //ic.pdbDataArray = await allPromise;

                    ic.pdbDataArray = await this.promiseWithFixedJobs(pdbAjaxArray);

                    let numRound = 0;
                    let bNoMoreIg = await thisClass.parseRefPdbData(ic.pdbDataArray, template, undefined, numRound);
                     ++numRound;

                    //while(!bNoMoreIg) {
                    while(!bNoMoreIg && numRound < 15) {
                        let bRerun = true;
                        bNoMoreIg = await thisClass.parseRefPdbData(ic.pdbDataArray, template, bRerun, numRound);
                        ++numRound;
                    }
                }
                else {
                    await thisClass.parseRefPdbData(undefined, template, undefined, numRound);
                }

                // refnum should be adjusted after all Ig are detected since sometimes the sheet extension may affect another Ig domain
                if(!ic.chainid2igtrack) ic.chainid2igtrack = {};
                for(let chainid in ic.chains) {
                    let atom = ic.firstAtomObjCls.getFirstAtomObj(ic.chains[chainid]);
                    if(ic.proteins.hasOwnProperty(atom.serial)) {
                        let giSeq = ic.showSeqCls.getSeq(chainid);
                        ic.chainid2igtrack[chainid] = this.ajdustRefnum(giSeq, chainid);
                    }
                }
            // }
            // catch(err) {
            //     if(!me.bNode) alert("Error in retrieveing reference PDB data...");
            //     return;
            // }
        }

        async parseRefPdbData(dataArray, template, bRerun, numRound) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            let struArray = Object.keys(ic.structures);

            let ajaxArray = [];
            let domainidpairArray = [];

            let urltmalign = me.htmlCls.tmalignUrl;
            // let urlalign = me.htmlCls.baseUrl + "vastdyn/vastdyn.cgi";

            if(!ic.resid2domainid) ic.resid2domainid = {};
            //ic.resid2domainid = {};
            ic.domainid2pdb = {};

            let bNoMoreIg = true;
            let bFoundDomain = false;
            for(let i = 0, il = struArray.length; i < il; ++i) {
                let struct = struArray[i];
                let chainidArray = ic.structures[struct];

                for(let j = 0, jl = chainidArray.length; j < jl; ++j) {
                    let chainid = chainidArray[j];

                    // for selected atoms only
                    let domainAtomsArray = this.getDomainAtomsArray(chainid, bRerun);

                    if(!ic.domainid2refpdbname) ic.domainid2refpdbname = {};
                    if(!ic.domainid2score) ic.domainid2score = {};

                    if(domainAtomsArray.length == 0) {
                        continue;
                    }

                    bFoundDomain = true;

                    for(let k = 0, kl = domainAtomsArray.length; k < kl; ++k) {
                        bNoMoreIg = false;

                        let pdb_target = ic.saveFileCls.getAtomPDB(domainAtomsArray[k], undefined, undefined, undefined, undefined, struct);

                        // ig strand for any subset will have the same k, use the number of residue to separate them
                        let atomFirst = ic.firstAtomObjCls.getFirstAtomObj(domainAtomsArray[k]);
                        let atomLast = ic.firstAtomObjCls.getLastAtomObj(domainAtomsArray[k]);
                        let resiSum = atomFirst.resi + ':' + atomLast.resi + ':' + Object.keys(domainAtomsArray[k]).length;
                        //let domainid = chainid + '-' + k + '_' + Object.keys(domainAtomsArray[k]).length;
                        let domainid = chainid + ',' + k + '_' + resiSum;

                        // clear score
                        delete ic.domainid2score[domainid];

                        ic.domainid2pdb[domainid] = pdb_target;

                        if(!template) {
                            for(let index = 0, indexl = dataArray.length; index < indexl; ++index) {
                                let struct2 = ic.defaultPdbId + index;
                                let pdb_query = dataArray[index].value; //[0];
                                let header = 'HEADER                                                        ' + struct2 + '\n';
                                pdb_query = header + pdb_query;
                                //let jsonStr_q = dataArray[index].value; //[0];

                                let dataObj = {'pdb_query': pdb_query, 'pdb_target': pdb_target, "queryid": ic.refpdbArray[index]};
                                let alignAjax = me.getAjaxPostPromise(urltmalign, dataObj);

                                // let dataObj = {'domains1': jsonStr_q, 'domains2': jsonStr_t};
                                // let alignAjax = me.getAjaxPostPromise(urlalign, dataObj);

                                ajaxArray.push(alignAjax);

                                domainidpairArray.push(domainid + "|" + ic.refpdbArray[index]);
                            }
                        }
                        else {
                            ic.domainid2refpdbname[domainid] = [template];
                            domainidpairArray.push(domainid + "|1" + template); // "1" was added for the first round strand-only template
                        }
                    }
                }
            }

            if(!bFoundDomain) {
                return bNoMoreIg;
            }

            //try {
                if(!template) {
                    let dataArray2 = [];

                    // let allPromise = Promise.allSettled(ajaxArray);
                    // dataArray2 = await allPromise;

                    dataArray2 = await this.promiseWithFixedJobs(ajaxArray);

                    let bRound1 = true;
                    bNoMoreIg = await thisClass.parseAlignData(dataArray2, domainidpairArray, bRound1, numRound);

                    /// if(ic.deferredRefnum !== undefined) ic.deferredRefnum.resolve();
                }
                else {
                    if(!me.bNode) console.log("Start alignment with the reference culsters " + JSON.stringify(ic.domainid2refpdbname));

                    // start round2
                    let ajaxArray = [];
                    let domainidpairArray3 = [];
                    let urltmalign = me.htmlCls.tmalignUrl;

                    let urlpdb = me.htmlCls.baseUrl + "mmcifparser/mmcifparser.cgi?refpdbid=" + template;
                    let pdbAjax = me.getAjaxPromise(urlpdb, 'text');
                    let pdbAjaxArray = [];
                    pdbAjaxArray.push(pdbAjax);

                    //let allPromise2 = Promise.allSettled(pdbAjaxArray);
                    //ic.pdbDataArray = await allPromise2;

                    let pdbDataArray = await this.promiseWithFixedJobs(pdbAjaxArray);

                    for(let domainid in ic.domainid2refpdbname) {
                        let pdb_target = ic.domainid2pdb[domainid];
                        for(let index = 0, indexl = pdbDataArray.length; index < indexl; ++index) {
                            let struct2 = ic.defaultPdbId + index;
                            let pdb_query = pdbDataArray[index].value; //[0];

                            let header = 'HEADER                                                        ' + struct2 + '\n';
                            pdb_query = header + pdb_query;

                            let dataObj = {'pdb_query': pdb_query, 'pdb_target': pdb_target, "queryid": template};
                            let alignAjax = me.getAjaxPostPromise(urltmalign, dataObj);
                            ajaxArray.push(alignAjax);

                            //domainidpairArray3.push(domainid + "," + refpdbname);
                            domainidpairArray3.push(domainid + "|" + template);
                        }
                    }

                    let dataArray3 = [];
                    //let allPromise = Promise.allSettled(ajaxArray);
                    //dataArray3 = await allPromise;

                    dataArray3 = await this.promiseWithFixedJobs(ajaxArray);

                    bNoMoreIg = await thisClass.parseAlignData(dataArray3, domainidpairArray3, undefined, numRound);
                }

                return bNoMoreIg;
                /*
            }
            catch(err) {
                let mess = "Some of " + ajaxArray.length + " TM-align alignments failed. Please select a chain or a subset to assing reference numbers to avoid overloading the server...";
                if(!me.bNode) {
                    alert(mess);
                }
                else {
                    console.log(mess);
                }
                //console.log("Error in aligning with TM-align...");
                return;
            }
            */
        }

        getDomainAtomsArray(chainid, bRerunDomain) { let ic = this.icn3d, me = ic.icn3dui;
            let domainAtomsArray = [];

            let minResidues = 20, minAtoms = 200;

            if(!ic.chainid2atomsLeft) ic.chainid2atomsLeft = {};

            if(!ic.proteins.hasOwnProperty(ic.firstAtomObjCls.getFirstAtomObj(ic.chains[chainid]).serial)
            && !ic.proteins.hasOwnProperty(ic.firstAtomObjCls.getMiddleAtomObj(ic.chains[chainid]).serial)) return domainAtomsArray;
            if(ic.chainsSeq[chainid].length < minResidues) return domainAtomsArray; // peptide

            // only consider selected atoms
            let currAtoms = me.hashUtilsCls.intHash(ic.chains[chainid], ic.hAtoms);
            if(Object.keys(currAtoms).length == 0) return domainAtomsArray;

            if(bRerunDomain) {
                let atomsAssigned = {};
                // for(let resid in ic.resid2refnum_ori) {
                for(let resid in ic.resid2domainid) {
                    if(ic.resid2domainid[resid]) atomsAssigned = me.hashUtilsCls.unionHash(atomsAssigned, ic.residues[resid]);
                }

                currAtoms = me.hashUtilsCls.exclHash(currAtoms, atomsAssigned);

                // no need to rerun the rest residues any more
                if(ic.chainid2atomsLeft[chainid] == Object.keys(currAtoms).length) {
                    return domainAtomsArray;
                }

                ic.chainid2atomsLeft[chainid] = Object.keys(currAtoms).length;

                if(Object.keys(currAtoms).length < minAtoms) return domainAtomsArray;
            }

            // align each 3D domain with reference structure
            //let result = ic.domain3dCls.c2b_NewSplitChain(ic.chains[chainid]);
            // assign ref numbers to selected residues
            let result = ic.domain3dCls.c2b_NewSplitChain(currAtoms, undefined);
            let subdomains = result.subdomains;
            // let pos2resi = result.pos2resi;

            if(subdomains.length >= 1) {
                for(let k = 0, kl = subdomains.length; k < kl; ++k) {
                    let domainAtoms = {};
                    let segArray = subdomains[k];

                    let resCnt = 0; // minResi = 999, maxResi = -999;
                    for(let m = 0, ml = segArray.length; m < ml; m += 2) {
                        let startResi = parseInt(segArray[m]);
                        let endResi = parseInt(segArray[m+1]);

                        // if(startResi < minResi) minResi = startResi;
                        // if(endResi > maxResi) maxResi = endResi;

                        for(let n = startResi; n <= endResi; ++n) {
                            // let resid = chainid + '_' + pos2resi[n - 1];
                            let resid = ic.ncbi2resid[chainid + '_' + n];
                            ++resCnt;
                            domainAtoms = me.hashUtilsCls.unionHash(domainAtoms, ic.residues[resid]);

                            // clear previous refnum assignment if any
                            // delete ic.resid2refnum[resid];
                            delete ic.residIgLoop[resid];
                            delete ic.resid2domainid[resid];
                        }
                    }

                    if(resCnt < minResidues) continue;

                    domainAtomsArray.push(domainAtoms);
                }
            }
            // else { // no domain
            //     domainAtomsArray = [currAtoms];
            // }

            return domainAtomsArray;
        }

        getTemplateList(domainid) { let ic = this.icn3d; ic.icn3dui;
            let refpdbname = '', score = '', seqid = '', nresAlign = '';

            refpdbname = ic.domainid2refpdbname[domainid][0]; // one template in round 2

            if(ic.domainid2score[domainid]) {
                let itemArray = ic.domainid2score[domainid].split('_');

                score = itemArray[0];
                seqid = itemArray[1];
                nresAlign = itemArray[2];
            }

            return {'refpdbname': refpdbname, 'score': score, 'seqid': seqid, 'nresAlign': nresAlign};
        }

        parseAlignData_part1(dataArray, domainidpairArray, bRound1) { let ic = this.icn3d, me = ic.icn3dui;
        // async parseAlignData(dataArray, domainidpairArray, bRound1) { let ic = this.icn3d, me = ic.icn3dui;
            // find the best alignment for each chain
            let domainid2segs = {};
            let domainid2refpdbnamelist = {};

            if(!ic.chainid2refpdbname) ic.chainid2refpdbname = {};
            // if(!ic.chainid2score) ic.chainid2score = {};
            if(!ic.domainid2refpdbname) ic.domainid2refpdbname = {};
            if(!ic.domainid2score) ic.domainid2score = {};
            if(!ic.domainid2ig2kabat) ic.domainid2ig2kabat = {};
            if(!ic.domainid2ig2imgt) ic.domainid2ig2imgt = {};

            let minResidues = 20;

            for(let i = 0, il = domainidpairArray.length; i < il; ++i) {
                //let queryData = (me.bNode) ? dataArray[i] : dataArray[i].value; //[0];
                let queryData = (dataArray[i]) ? dataArray[i].value : undefined; //[0];

                if(!queryData || queryData.length == 0) {
                    if(!me.bNode) console.log("The alignment data for " + domainidpairArray[i] + " is unavailable...");
                    continue;
                }

                if(queryData[0].score === undefined) continue;
                let score = parseFloat(queryData[0].score);

                //let domainid_index = domainidpairArray[i].split(',');
                //let domainid = domainid_index[0];
                let domainid = domainidpairArray[i].substr(0, domainidpairArray[i].indexOf('|'));
                let refpdbname = domainidpairArray[i].substr(domainidpairArray[i].indexOf('|') + 1);
                //let chainid = domainid.split('-')[0];

                if(!bRound1) {
                    if(queryData[0].score < this.TMThresholdTemplate || queryData[0].num_res < minResidues) {
                        if(!me.bNode) console.log("bRound1: " + bRound1 + ": domainid " + domainid + " and refpdbname " + refpdbname + " were skipped due to a TM-score less than " + this.TMThresholdTemplate);
                        continue;
                    }
                }
                else {
                    if(queryData[0].score < this.TMThresholdTemplate || queryData[0].num_res < minResidues / 2) {
                        continue;
                    }
                }

                if(!bRound1) {
                    if(!me.bNode) console.log("refpdbname " + refpdbname + " TM-score: " + queryData[0].score);
                }
                else {
                    // if(!me.bNode) console.log("domainid: " + domainid + " refpdbname " + refpdbname + " RMSD: " + queryData[0].super_rmsd + ", num_seg: " + queryData[0].num_seg + ",  10/RMSD + num_seg/5: " + (10 / queryData[0].super_rmsd + queryData[0].num_seg / 5).toFixed(1));
                    if(!me.bNode) console.log("domainid: " + domainid + " refpdbname " + refpdbname + " TM-score: " + queryData[0].score);

                    if(!domainid2refpdbnamelist[domainid]) domainid2refpdbnamelist[domainid] = {};
                    domainid2refpdbnamelist[domainid][refpdbname] = score;
                }

                // Ig-like domains: B (2150, 2150a, 2150b), C (3150, 3250), E (7150, 7250), F (8150, 8250) strands
                // Ig domain may require G (7050). But we'll leave that out for now.
                if(!bRound1 && queryData[0].segs) {
                    let bBstrand = false, bCstrand = false, bEstrand = false, bFstrand = false;
                    let bBSheet = true, bCSheet = true, bESheet = true, bFSheet = true;
                    let chainid = domainid.split(',')[0];

                    for(let j = 0, jl = queryData[0].segs.length; j < jl; ++j) {
                        let seg = queryData[0].segs[j];
                        let resi = seg.t_start;
                        let resid = chainid + '_' + resi;
                        let q_start = parseInt(seg.q_start);

                        if(q_start > 2540 && q_start < 2560) {
                            bBstrand = true;
                        }
                        else if(q_start > 3540 && q_start < 3560) {
                            bCstrand = true;
                        }
                        else if(q_start > 7540 && q_start < 7560) {
                            bEstrand = true;
                        }
                        else if(q_start > 8540 && q_start < 8560) {
                            bFstrand = true;
                        }

                        if(q_start == 2550) {
                            let atom = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid]);
                            if(atom.ss == 'helix') bBSheet = false;
                        }
                        else if(q_start == 3550) {
                            let atom = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid]);
                            if(atom.ss == 'helix') bCSheet = false;
                        }
                        else if(q_start == 7550) {
                            let atom = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid]);
                            if(atom.ss == 'helix') bESheet = false; 
                        }
                        else if(q_start == 8550) {
                            let atom = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid]);
                            if(atom.ss == 'helix') bFSheet = false;
                        }

                        //if(bBstrand && bCstrand && bEstrand && bFstrand && bGstrand) break;
                        if(bBstrand && bCstrand && bEstrand && bFstrand) break;
                    }

                    // if(refpdbname != 'CD19_6al5A_human-n1') { // relax for CD19
                        if(!(bBstrand && bCstrand && bEstrand && bFstrand) || !(bBSheet && bCSheet && bESheet && bFSheet)) {
                        // if(!(bBstrand && bCstrand && bEstrand && bFstrand)) {
                            if(!me.bNode && !(bBstrand && bCstrand && bEstrand && bFstrand)) console.log("Some of the Ig strands B, C, E, F are missing in the domain " + domainid + "...");
                            if(!me.bNode && !(bBSheet && bCSheet && bESheet && bFSheet)) console.log("Some of the Ig strands B, C, E, F are not beta sheets...");

                            if(ic.domainid2refpdbname[domainid][0] == refpdbname) {
                                delete ic.domainid2refpdbname[domainid];
                                delete ic.domainid2score[domainid];
                            }
                            continue;                          
                      }
                    // }
                }

                if(!bRound1) {
                    if(!me.bNode) console.log("domainid: " + domainid);
                }

                // count the number of matched strands
                // let strandHash = {};
                // for(let j = 0, jl = queryData[0].segs.length; j < jl; ++j) {
                //     let seg = queryData[0].segs[j];
                //     let q_start = parseInt(seg.q_start)

                //     let strand = this.getStrandFromRefnum(q_start);
                //     strandHash[strand] = 1;
                // }

                // let tmAdjust = 0.1; 

                // if the TM score difference is within 0.1 and more strands are found, use the template with more strands
                // if(!domainid2segs.hasOwnProperty(domainid) || 
                //     (score >= parseFloat(ic.domainid2score[domainid].split('_')[0]) + tmAdjust)
                //     || (score >= parseFloat(ic.domainid2score[domainid].split('_')[0]) - tmAdjust && score < parseFloat(ic.domainid2score[domainid].split('_')[0]) + tmAdjust && Object.keys(strandHash).length > domainid2strandcnt[domainid])
                //     ) {

                // use TM-score alone
                if(!domainid2segs.hasOwnProperty(domainid) || score >= parseFloat(ic.domainid2score[domainid].split('_')[0])) {      
                    ic.domainid2score[domainid] = queryData[0].score + '_' + queryData[0].frac_identical + '_' + queryData[0].num_res ;

                    if(bRound1) {
                        ic.domainid2refpdbname[domainid] = score >= this.TMThresholdIgType ? [refpdbname] : ['all_templates'];
                    }
                    else {
                        ic.domainid2refpdbname[domainid] = [refpdbname];
                    }

                    domainid2segs[domainid] = queryData[0].segs;
                    // domainid2strandcnt[domainid] = Object.keys(strandHash).length;

                    ic.domainid2ig2kabat[domainid] = queryData[0].ig2kabat;
                    ic.domainid2ig2imgt[domainid] = queryData[0].ig2imgt;
                }
            }

            // combine the top  clusters for the 2nd round alignment
            if(bRound1) {
                for(let domainid in domainid2refpdbnamelist) {
                    if(!me.bNode && ic.domainid2refpdbname[domainid][0] == 'all_templates') {
                        let refpdbname2score = domainid2refpdbnamelist[domainid];
                        let refpdbnameList = Object.keys(refpdbname2score);
                        refpdbnameList.sort(function(a, b) {
                            return refpdbname2score[b] - refpdbname2score[a]
                        });
                        // top templates
                        ic.domainid2refpdbname[domainid] = refpdbnameList.slice(0, this.topClusters);
                    }
                }
            }

            return domainid2segs; // only used in round 2
        }

        async parseAlignData(dataArray, domainidpairArray, bRound1, numRound) { let ic = this.icn3d, me = ic.icn3dui;
            let bNoMoreIg = false;

            let domainid2segs = this.parseAlignData_part1(dataArray, domainidpairArray, bRound1);

            // no more Igs to detect
            // no need to rerun the rest residues any more
            if(Object.keys(domainid2segs).length == 0) {
                bNoMoreIg = true;
                return bNoMoreIg;
            }

            if(bRound1) {
                if(!me.bNode) console.log("Start round 2 alignment with the reference culsters " + JSON.stringify(ic.domainid2refpdbname));

                // start round2
                let ajaxArray = [];
                let domainidpairArray3 = [];
                let urltmalign = me.htmlCls.tmalignUrl;
                for(let domainid in ic.domainid2refpdbname) {
                    let pdbAjaxArray = [];
                    let refpdbnameList = ic.domainid2refpdbname[domainid];
                    //let pdbid = domainid.substr(0, domainid.indexOf('_'));
                    let chainid = domainid.substr(0, domainid.indexOf(','));

                    // Adjusted refpdbname in the first try
                    if(ic.refpdbHash.hasOwnProperty(chainid) && numRound == 0) {
                        refpdbnameList = [chainid];

                        if(!me.bNode) console.log("Adjusted refpdbname for domainid " + domainid + ": " + chainid);
                    }

                    let templates = [];
                    for(let i = 0, il = refpdbnameList.length; i < il; ++i) {
                        let refpdbname = refpdbnameList[i];
                        if(!ic.refpdbHash[refpdbname]) continue;
                        templates = templates.concat(ic.refpdbHash[refpdbname]);
                    }
        
                    // if(!ic.refpdbHash[refpdbname]) {
                    if(templates.length == 0) {
                        continue;
                    }

                    for(let k = 0, kl = templates.length; k < kl; ++k) {
                        let urlpdb = me.htmlCls.baseUrl + "mmcifparser/mmcifparser.cgi?refpdbid=" + templates[k];

                        let pdbAjax = me.getAjaxPromise(urlpdb, 'text');

                        pdbAjaxArray.push(pdbAjax);
                    }

                    //let allPromise2 = Promise.allSettled(pdbAjaxArray);
                    //ic.pdbDataArray = await allPromise2;

                    let pdbDataArray = await this.promiseWithFixedJobs(pdbAjaxArray);

                    let pdb_target = ic.domainid2pdb[domainid];
                    for(let index = 0, indexl = pdbDataArray.length; index < indexl; ++index) {
                        let struct2 = ic.defaultPdbId + index;
                        //let pdb_query = (me.bNode) ? pdbDataArray[index] : pdbDataArray[index].value; //[0];
                        let pdb_query = pdbDataArray[index].value; //[0];
                        let header = 'HEADER                                                        ' + struct2 + '\n';
                        pdb_query = header + pdb_query;

                        let dataObj = {'pdb_query': pdb_query, 'pdb_target': pdb_target, "queryid": templates[index]};
                        let alignAjax = me.getAjaxPostPromise(urltmalign, dataObj);
                        ajaxArray.push(alignAjax);

                        domainidpairArray3.push(domainid + "|" + templates[index]);
                    }
                }

                let dataArray3 = [];
                //let allPromise = Promise.allSettled(ajaxArray);
                //dataArray3 = await allPromise;

                dataArray3 = await this.promiseWithFixedJobs(ajaxArray);

                bNoMoreIg = await this.parseAlignData(dataArray3, domainidpairArray3, false, numRound);

                // end of round 2
                return bNoMoreIg;
            }

            this.parseAlignData_part3(domainid2segs);

            return bNoMoreIg;
        }

        parseAlignData_part3(domainid2segs) { let ic = this.icn3d, me = ic.icn3dui;

            // combine domainid into chainid
            let processedChainid = {};

            for(let domainid in ic.domainid2refpdbname) {
                // remove the first round template
                if(ic.domainid2refpdbname[domainid][0].substr(0,1) == '1') {
                    delete ic.domainid2refpdbname[domainid];
                    delete ic.domainid2score[domainid];
                    continue;
                }

                let chainid = domainid.split(',')[0];

                if(!processedChainid.hasOwnProperty(chainid)) {
                    ic.chainid2refpdbname[chainid] = [];
                    // ic.chainid2score[chainid] = [];
                }
                processedChainid[chainid] = 1;

                if(!ic.chainid2refpdbname.hasOwnProperty(chainid)) ic.chainid2refpdbname[chainid] = [];
                ic.chainid2refpdbname[chainid].push(ic.domainid2refpdbname[domainid][0] + '|' + domainid);

                // if(!ic.chainid2score.hasOwnProperty(chainid)) ic.chainid2score[chainid] = [];
                // ic.chainid2score[chainid].push(ic.domainid2score[domainid] + '|' + domainid);
            }

    /*
            // combine domainid into chainid
            for(let domainid in domainid2segs) {
                let chainid = domainid.split(',')[0];
                if(!chainid2segs[chainid]) chainid2segs[chainid] = [];
                chainid2segs[chainid] = chainid2segs[chainid].concat(domainid2segs[domainid]);
            }
    */

            // assign ic.resid2refnum, ic.refnum2residArray, ic.chainsMapping
            if(!ic.resid2refnum) ic.resid2refnum = {};
            // if(!ic.resid2refnum_ori) ic.resid2refnum_ori = {};
            if(!ic.refnum2residArray) ic.refnum2residArray = {};
            if(!ic.chainsMapping) ic.chainsMapping = {};

            // if(!ic.refPdbList) ic.refPdbList = [];
            if(!ic.domainid2info) ic.domainid2info = {};

            //for(let chainid in chainid2segs) {
                // let segArray = chainid2segs[chainid];
            for(let domainid in domainid2segs) {
                let segArray = domainid2segs[domainid];
                let chainid = domainid.split(',')[0];

                let result = this.getTemplateList(domainid);
                let refpdbname = result.refpdbname;
                let score = result.score;
                let seqid = result.seqid;
                let nresAlign = result.nresAlign;

                if(refpdbname) {
                    let message = "The reference PDB for domain " + domainid + " is " + refpdbname + ". The TM-score is " + score  + ". The sequence identity is " + seqid  + ". The number of aligned residues is " + nresAlign + ".";

                    if(!me.bNode) {
                        console.log(message);
                        me.htmlCls.clickMenuCls.setLogCmd(message, false, true);
                    }

                    // ic.refPdbList.push(message);
                    ic.domainid2info[domainid] = {'refpdbname': refpdbname, 'score': score, 'seqid': seqid, 'nresAlign': nresAlign};
                }

                // adjust C' and D strands ======start
                let bCstrand = false, bCpstrand = false, bCppstrand = false, bDstrand = false, bEstrand = false;
                let CAtom, CpAtom, DAtom, EAtom;
                let CAtomArray = [], EAtomArray = [];

                //let chainid = domainid.split(',')[0];

                let cntBtwCE;
                let CpToDResi = [], DToCpResi = [];
                for(let i = 0, il = segArray.length; i < il; ++i) {
                    let seg = segArray[i];
                    if(!seg) continue;

                    let resi = seg.t_start;
                    let resid = chainid + '_' + resi;

                    if(seg.q_start.indexOf('3550') != -1) {
                        bCstrand = true;
                        CAtom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[resid]);

                        // a chain could have multiple Ig domains
                        cntBtwCE = 0;
                    }
                    else if(seg.q_start.indexOf('4550') != -1) {
                        bCpstrand = true;
                        CpAtom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[resid]);
                        ++cntBtwCE;
                    }
                    // else if(seg.q_start.indexOf('5550') != -1) {
                    //     bCppstrand = true;
                    //     CppAtom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[resid]);
                    //     ++cntBtwCE;
                    // }
                    else if(seg.q_start.indexOf('6550') != -1) {
                        bDstrand = true;
                        DAtom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[resid]);
                        ++cntBtwCE;
                    }
                    else if(seg.q_start.indexOf('7550') != -1) {
                        bEstrand = true;
                        EAtom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[resid]);
                    }

                    if(seg.q_start >= 3545 && seg.q_start <= 3555) {
                        let atomTmp = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[resid]);
                        if(atomTmp) CAtomArray.push(atomTmp);
                    }
                    else if(seg.q_start >= 7545 && seg.q_start <= 7555) {
                        let atomTmp = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[resid]);
                        if(atomTmp) EAtomArray.push(atomTmp);
                    }

                    if(seg.q_start.indexOf('8550') != -1) {
                        // check C' and D strands
                        if(cntBtwCE == 1 && CAtom && EAtom && (CpAtom || DAtom)) {
                            let distToC = 999, distToE = 999;
                            for(let j = 0, jl = CAtomArray.length; j < jl; ++j) {
                                let dist = (bCpstrand) ? CpAtom.coord.distanceTo(CAtomArray[j].coord) : DAtom.coord.distanceTo(CAtomArray[j].coord);
                                if(dist < distToC) distToC = dist;
                            }
                            for(let j = 0, jl = EAtomArray.length; j < jl; ++j) {
                                let dist = (bCpstrand) ? CpAtom.coord.distanceTo(EAtomArray[j].coord) : DAtom.coord.distanceTo(EAtomArray[j].coord);
                                if(dist < distToE) distToE = dist;
                            }

                            distToC = parseInt(distToC);
                            distToE = parseInt(distToE);

                            let resiDistToC = (bCpstrand) ? parseInt(CpAtom.resi) - parseInt(CAtom.resi) : parseInt(DAtom.resi) - parseInt(CAtom.resi);
                            let resiDistToE = (bCpstrand) ? parseInt(EAtom.resi) - parseInt(CpAtom.resi) : parseInt(EAtom.resi) - parseInt(DAtom.resi);

                            let adjust = 1;

                            if(bCpstrand) {
                                if(distToC > distToE + adjust || (distToC == distToE + adjust && resiDistToC > resiDistToE + adjust)) { // rename C' to D
                                    CpToDResi.push(CpAtom.resi);
                                    if(!me.bNode) console.log("Rename strand C' to D: distToC " + distToC + " distToE " + distToE + " resiDistToC " + resiDistToC + " resiDistToE " + resiDistToE);
                                }
                            }
                            else if(bDstrand) {
                                if(distToC + adjust < distToE || (distToC + adjust == distToE && resiDistToC + adjust < resiDistToE)) { // rename D to C'
                                    DToCpResi.push(DAtom.resi);
                                    if(!me.bNode) console.log("Rename strand D to C': distToC " + distToC + " distToE " + distToE + " resiDistToC " + resiDistToC + " resiDistToE " + resiDistToE);
                                }
                            }
                        }
                    }

                    if(bCstrand && bCpstrand && bCppstrand && bDstrand && bEstrand) break;
                }

                let currStrand;

                // let bCd19 = refpdbnameArray.length == 1 && refpdbnameArray[0] == 'CD19_6al5A_human-n1';
                for(let i = 0, il = segArray.length; i < il; ++i) {
                    let seg = segArray[i];
                    if(!seg) continue;

                    seg.q_start;
                    let qStartInt = parseInt(seg.q_start);
                    let postfix = '';
                    if(isNaN(seg.q_start)) postfix = seg.q_start.substr(seg.q_start.length - 1, 1);

                    // one item in "seq"
                    // q_start and q_end are numbers, but saved in string
                    // t_start and t_end are strings such as 100a
                    //for(let j = 0; j <= parseInt(seg.t_end) - parseInt(seg.t_start); ++j) {
                        // let resid = chainid + '_' + (j + parseInt(seg.t_start)).toString();
                        // let refnum = (j + qStartInt).toString() + postfix;

                        let resid = chainid + '_' + seg.t_start;
                        //let refnum = qStartInt.toString() + postfix;
                        //let refnum = qStart + postfix;
                        //let refnum = qStart;
                        let refnum = qStartInt;

                        let refnumLabel = this.getLabelFromRefnum(refnum, postfix);
                        currStrand = (refnumLabel) ? refnumLabel.replace(new RegExp(refnum,'g'), '') : undefined;

                        let currStrandFinal = currStrand;
                        if(currStrand == "C'" && CpToDResi.length > 0) {
                            for(let j = 0, jl = CpToDResi.length; j < jl; ++j) {
                                if(parseInt(seg.t_start) < parseInt(CpToDResi[j]) + 10 && parseInt(seg.t_start) > parseInt(CpToDResi[j]) - 10 ) {
                                    currStrandFinal = "D";
                                    break;
                                }
                            }
                        }
                        else if(currStrand == "D" && DToCpResi.length > 0) {
                            for(let j = 0, jl = DToCpResi.length; j < jl; ++j) {
                                if(parseInt(seg.t_start) < parseInt(DToCpResi[j]) + 10 && parseInt(seg.t_start) > parseInt(DToCpResi[j]) - 10 ) {
                                    currStrandFinal = "C'";
                                    break;
                                }
                            }
                        }

                        if(currStrand != currStrandFinal) {
                            refnumLabel = this.getLabelFromRefnum(refnum, postfix, currStrandFinal);
                        }

                        let atom = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid]);
                        // only sheet or loop will be aligned
                        if(atom.ss != 'helix') {
                            ic.resid2refnum[resid] = refnumLabel;
                            // ic.resid2refnum_ori[resid] = refnumLabel;
                            ic.resid2domainid[resid] = domainid;
                        }
                    //}
                }
            }

            if(Object.keys(ic.resid2refnum).length > 0) {
                ic.bShowRefnum = true;
                //ic.annotationCls.setAnnoViewAndDisplay('detailed view');
            }
            else if(!me.bNode) {
                if(!ic.bNoIg) {
                    // alert("No Ig reference numbers are assigned based on the reference structures in iCn3D...");
                    console.log("No Ig reference numbers are assigned based on the reference structures in iCn3D...");
                    ic.bNoIg = true;
                }
            }

            // refnum should be adjusted after all Ig are detected since sometimes the sheet extension may affect another Ig domain
            /*
            if(!ic.chainid2igtrack) ic.chainid2igtrack = {};
            for(let chainid in ic.chains) {
                let atom = ic.firstAtomObjCls.getFirstAtomObj(ic.chains[chainid]);
                if(ic.proteins.hasOwnProperty(atom.serial)) {
                    let giSeq = ic.showSeqCls.getSeq(chainid);
                    ic.chainid2igtrack[chainid] = this.ajdustRefnum(giSeq, chainid);
                }
            }
            */
        }

        getStrandFromRefnum(oriRefnum, finalStrand) { let ic = this.icn3d; ic.icn3dui;
            let refnum = parseInt(oriRefnum);

            //N-terminus = 0999-0001
            //A--- = 12xx
            //A-- = 13xx
            //A- = 14xx
            //A = 15xx (anchor 1550)
            //A+ = 16xx
            //A' = 18xx (anchor 1850)
            //B = 25xx (anchor 2550)
            //C-- = 33xx
            //C- = 34xx
            //C = 35xx (anchor 3550)
            //C' = 45xx (anchor 4550)
            //C'' = 55xx (anchor 5550)
            //D = 65xx (anchor 3550)
            //E = 75xx (anchor 7550)
            //E+ = 76xx
            //F = 85xx (anchor 8550)
            //G = 95xx (anchor 9550)
            //G+ = 96xx
            //G++ = 97xx
            //C-terminus = 9901-9999 (no anchor, numbering going forward)

            // loops may have numbers such as 1310, 1410

            let strand;
    /*
            if(refnum < 1000) strand = undefined;
            else if(refnum >= 1200 && refnum < 1290) strand = "A---";
            else if(refnum >= 1320 && refnum < 1390) strand = "A--";
            else if(refnum >= 1420 && refnum < 1490) strand = "A-";
            else if(refnum >= 1520 && refnum < 1590) strand = "A";
            else if(refnum >= 1620 && refnum < 1690) strand = "A+";
            else if(refnum >= 1820 && refnum < 1890) strand = "A'";
            else if(refnum >= 2000 && refnum < 2900) strand = "B";
            else if(refnum >= 3300 && refnum < 3390) strand = "C--";
            else if(refnum >= 3420 && refnum < 3490) strand = "C-";
            else if(refnum >= 3520 && refnum < 3590) strand = "C";
            else if(refnum >= 4000 && refnum < 4900) strand = "C'";
            else if(refnum >= 5000 && refnum < 5900) strand = "C''";
            else if(refnum >= 6000 && refnum < 6900) strand = "D";
            else if(refnum >= 7500 && refnum < 7590) strand = "E";
            else if(refnum >= 7620 && refnum < 7900) strand = "E+";
            else if(refnum >= 8000 && refnum < 8900) strand = "F";
            else if(refnum >= 9500 && refnum < 9590) strand = "G";
            else if(refnum >= 9620 && refnum < 9690) strand = "G+";
            else if(refnum >= 9720 && refnum < 9790) strand = "G++";
            else if(refnum > 9900) strand = undefined;
            else strand = " ";
    */

            // cover all ranges
            if(refnum < 1000) strand = undefined;
            else if(refnum >= 1200 && refnum < 1320) strand = "A---";
            else if(refnum >= 1320 && refnum < 1420) strand = "A--";
            else if(refnum >= 1420 && refnum < 1520) strand = "A-";
            else if(refnum >= 1520 && refnum < 1620) strand = "A";
            else if(refnum >= 1620 && refnum < 1720) strand = "A+";
            else if(refnum >= 1720 && refnum < 1820) strand = "A++";
            else if(refnum >= 1820 && refnum < 2000) strand = "A'";
            else if(refnum >= 2000 && refnum < 3000) strand = "B";
            else if(refnum >= 3000 && refnum < 3420) strand = "C--";
            else if(refnum >= 3420 && refnum < 3520) strand = "C-";
            else if(refnum >= 3520 && refnum < 4000) strand = "C";
            else if(refnum >= 4000 && refnum < 5000) strand = "C'";
            else if(refnum >= 5000 && refnum < 6000) strand = "C''";
            else if(refnum >= 6000 && refnum < 7000) strand = "D";
            else if(refnum >= 7000 && refnum < 7620) strand = "E";
            else if(refnum >= 7620 && refnum < 8000) strand = "E+";
            else if(refnum >= 8000 && refnum < 9000) strand = "F";
            else if(refnum >= 9000 && refnum < 9620) strand = "G";
            else if(refnum >= 9620 && refnum < 9720) strand = "G+";
            else if(refnum >= 9720 && refnum < 9820) strand = "G++";
            else if(refnum >= 9820 && refnum < 9900) strand = "G+++";
            else if(refnum > 9900) strand = undefined;
            else strand = " ";

            if(finalStrand) strand = finalStrand;

            return strand
        }

        getLabelFromRefnum(oriRefnum, postfix, finalStrand) { let ic = this.icn3d; ic.icn3dui;
            let strand = this.getStrandFromRefnum(oriRefnum, finalStrand);

            // rename C' to D or D to C'
            let refnum = oriRefnum.toString();
            if(finalStrand == "C'" && refnum.substr(0, 1) == '6') { // previous D
                refnum = '4' + refnum.substr(1);
            }
            else if(finalStrand == "D" && refnum.substr(0, 1) == '4') { // previous C'
                refnum = '6' + refnum.substr(1);
            }

            if(strand) {
                return strand + refnum + postfix;
            }
            else {
                return undefined;
            }
        }

        async parseCustomRefFile(data) { let ic = this.icn3d; ic.icn3dui;
            ic.bShowCustomRefnum = true;

            //refnum,11,12,,21,22
            //1TUP_A,100,101,,,132
            //1TUP_B,110,111,,141,142

            let lineArray = data.split('\n');

            if(!ic.resid2refnum) ic.resid2refnum = {};
            if(!ic.refnum2residArray) ic.refnum2residArray = {};
            if(!ic.chainsMapping) ic.chainsMapping = {};

            let refAA = [];
            for(let i = 0, il = lineArray.length; i < il; ++i) {
                let numArray = lineArray[i].split(',');
                refAA.push(numArray);
            }

            // assign ic.refnum2residArray
            let refI = 0;
            for(let j = 1, jl = refAA[refI].length; j < jl; ++j) {
                if(!refAA[refI][j]) continue;

                let refnum = refAA[refI][j].trim();
                if(refnum) {
                    for(let i = 1, il = refAA.length; i < il; ++i) {
                        if(!refAA[i][j]) continue;
                        let chainid = refAA[i][0].trim();
                        let resid = chainid + '_' + refAA[i][j].trim();
                        if(!ic.refnum2residArray[refnum]) {
                            ic.refnum2residArray[refnum] = [resid];
                        }
                        else {
                            ic.refnum2residArray[refnum].push(resid);
                        }
                    }
                }
            }

            // assign ic.resid2refnum and ic.chainsMapping
            for(let i = 1, il = refAA.length; i < il; ++i) {
                let chainid = refAA[i][0].trim();

                for(let j = 1, jl = refAA[i].length; j < jl; ++j) {
                    if(!refAA[i][j] || !refAA[refI][j]) continue;

                    let resi = refAA[i][j].trim();
                    let refnum = refAA[refI][j].trim();

                    if(!ic.chainsMapping.hasOwnProperty(chainid)) {
                        ic.chainsMapping[chainid] = {};
                    }

                    let resid = chainid + '_' + resi;

                    if(resi && refnum) {
                        ic.resid2refnum[resid] = refnum;

                        ic.chainsMapping[chainid][resid] = refnum;
                    }
                    else {
                        ic.chainsMapping[chainid][resid] = resi;
                    }
                }
            }

            // open sequence view
            await ic.showAnnoCls.showAnnotations();
            ic.annotationCls.setAnnoViewAndDisplay('detailed view');
        }

        rmStrandFromRefnumlabel(refnumLabel) { let ic = this.icn3d; ic.icn3dui;
            if(refnumLabel && isNaN(refnumLabel.substr(0,1))) {
                return (!refnumLabel) ? refnumLabel : refnumLabel.replace(/'/g, '').replace(/\*/g, '').replace(/\^/g, '').replace(/\+/g, '').replace(/\-/g, '').substr(1); // C', C''
            }
            else { // custom ref numbers
                return refnumLabel;
            }
        }

        exportRefnum(type, bNoArraySymbol) { let ic = this.icn3d, me = ic.icn3dui;
            let refData = '';

            // 1. show IgStrand ref numbers
            if(type == 'igstrand' || type == 'IgStrand') {
                // iGStrand reference numbers were adjusted when showing in sequences
                // if(me.bNode) {        
                if(ic.bShowRefnum) {
                    for(let chnid in ic.chains) {
                        let atom = ic.firstAtomObjCls.getFirstAtomObj(ic.chains[chnid]);
                        if(ic.proteins.hasOwnProperty(atom.serial)) {
                            let giSeq = [];
                            for(let i = 0; i < ic.chainsSeq[chnid].length; ++i) {
                                giSeq.push(ic.chainsSeq[chnid][i].name);
                            }
                            ic.annoIgCls.showRefNum(giSeq, chnid);
                        }
                    }
                }

                let resid2refnum = {};
                for(let resid in ic.resid2refnum) {
                    let atom = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid]);
                    if(!atom) continue;

                    let resn = me.utilsCls.residueName2Abbr(atom.resn.substr(0, 3));

                    let domainid = ic.resid2domainid[resid];
                    let refnumLabel = ic.resid2refnum[resid];

                    if(refnumLabel) {
                        let refnumStr_ori = ic.refnumCls.rmStrandFromRefnumlabel(refnumLabel);
                        (ic.domainid2ig2kabat[domainid]) ? ic.domainid2ig2kabat[domainid][refnumStr_ori] : undefined;
                    }

                    if(ic.resid2refnum[resid]) {
                        if(ic.residIgLoop.hasOwnProperty(resid)) { // loop
                        resid2refnum[resid + '_' + resn] = ic.resid2refnum[resid] + '_loop';
                        }
                        else {
                        resid2refnum[resid + '_' + resn] = ic.resid2refnum[resid];
                        }
                    }
                }

            // if(bIgDomain) {
                for(let structure in ic.structures) {
                    let bIgDomain = 0;
                    let refDataTmp = '';
                    for(let m = 0, ml = ic.structures[structure].length; ic.bShowRefnum && m < ml; ++m) {
                        let chnid = ic.structures[structure][m]; 
                        let igArray = ic.chain2igArray[chnid];

                        if(igArray && igArray.length > 0) {
                            refDataTmp += '{"' + chnid + '": {\n';

                            for(let i = 0, il = igArray.length; i < il; ++i) {
                                let startPosArray = igArray[i].startPosArray;
                                let endPosArray = igArray[i].endPosArray;
                                let domainid = igArray[i].domainid;
                                let info = ic.domainid2info[domainid];
                                if(!info) continue;

                                refDataTmp += '"' + domainid + '": {\n';

                                refDataTmp += '"refpdbname":"' + info.refpdbname + '", "score":' + info.score + ', "seqid":' + info.seqid + ', "nresAlign":' + info.nresAlign + ', "data": [';
                                for(let j = 0, jl = startPosArray.length; j < jl; ++j) {
                                    let startPos = startPosArray[j];
                                    let endPos = endPosArray[j];
                                    for(let k = startPos; k <= endPos; ++k) {
                                        const resid = chnid + '_' + ic.chainsSeq[chnid][k].resi + '_' + ic.chainsSeq[chnid][k].name;
                                        refDataTmp += '{"' + resid + '": "' + resid2refnum[resid] + '"},\n';
                                    }
                                }
                                refDataTmp += '],\n';

                                refDataTmp += '},\n';

                                bIgDomain = 1;
                            }

                            refDataTmp += '}},\n';
                        }
                    }

                    refData += '{"' + structure + '": {"Ig domain" : ' + bIgDomain + ', "igs": [\n';

                    if(bIgDomain) refData += refDataTmp;

                    refData += ']}},\n';
                }
            // }
            }
            // 2. show Kabat ref numbers
            else if(type == 'kabat' || type == 'Kabat') {
                let resid2kabat = {};
                for(let resid in ic.resid2refnum) {
                    let domainid = ic.resid2domainid[resid];
                    let refnumStr, refnumLabel = ic.resid2refnum[resid];

                    let atom = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid]);
                    if(!atom) continue;
                    let resn = me.utilsCls.residueName2Abbr(atom.resn.substr(0, 3));

                    if(refnumLabel) {
                        let refnumStr_ori = ic.refnumCls.rmStrandFromRefnumlabel(refnumLabel);
                        refnumStr = (ic.domainid2ig2kabat[domainid]) ? ic.domainid2ig2kabat[domainid][refnumStr_ori] : undefined;
                    }

                    resid2kabat[resid + '_' + resn] = refnumStr;
                }

                refData += '{"Kabat": ';
                refData += JSON.stringify(resid2kabat);
                refData += ',\n';
            }
            // 3. show IMGT ref numbers
            else if(type == 'imgt'|| type == 'IMGT') {
                let resid2imgt = {};
                for(let resid in ic.resid2refnum) {
                    let domainid = ic.resid2domainid[resid];
                    let refnumStr, refnumLabel = ic.resid2refnum[resid];

                    let atom = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid]);
                    if(!atom) continue;
                    let resn = me.utilsCls.residueName2Abbr(atom.resn.substr(0, 3));

                    if(refnumLabel) {
                        let refnumStr_ori = ic.refnumCls.rmStrandFromRefnumlabel(refnumLabel);
                        refnumStr = (ic.domainid2ig2imgt[domainid]) ? ic.domainid2ig2imgt[domainid][refnumStr_ori] : undefined;
                    }

                    resid2imgt[resid + '_' + resn] = refnumStr;
                }

                refData += '{"Kabat": ';
                refData += JSON.stringify(resid2imgt);
                refData += ',\n';
            }


            if(!bNoArraySymbol) {
                refData = '[' + refData + ']';
            }

            if(!me.bNode) {
                let file_pref = Object.keys(me.utilsCls.getHlStructures()).join(',');

                ic.saveFileCls.saveFile(file_pref + '_refnum_' + type + '.txt', 'text', [refData]);
            }
            else {
                return refData;
            }
        }

        async promiseWithFixedJobs(ajaxArray) { let ic = this.icn3d, me = ic.icn3dui;
            if(!me.bNode) me.icn3d.ParserUtilsCls.showLoading();

            let dataArray3 = [];
            //let allPromise = Promise.allSettled(ajaxArray);
            //dataArray3 = await allPromise;

            //split arrays into chunks of 48 jobs or me.cfg.maxajax jobs
            let n = (me.cfg.maxajax) ? me.cfg.maxajax : ic.refpdbArray.length * 6;

            for(let i = 0, il = parseInt((ajaxArray.length - 1) / n + 1); i < il; ++i) {
                let currAjaxArray = [];
                if(i == il - 1) { // last one
                    currAjaxArray = ajaxArray.slice(i * n, ajaxArray.length);
                }
                else {
                    currAjaxArray = ajaxArray.slice(i * n, (i + 1) * n);
                }

                let currPromise = Promise.allSettled(currAjaxArray);
                let currDataArray = await currPromise;

                dataArray3 = dataArray3.concat(currDataArray);
            }

            if(!me.bNode) me.icn3d.ParserUtilsCls.hideLoading();

            return dataArray3;
        }

        ajdustRefnum(giSeq, chnid) {  let ic = this.icn3d, me = ic.icn3dui;
            if(!ic.chainid2refpdbname[chnid]) return false;

            // auto-generate ref numbers for loops 
            let currStrand = '', prevStrand = '', prevValidStrand = '';
            let refnumLabel, refnumStr_ori, refnumStr, postfix, strandPostfix, refnum, refnum3c, refnum2c;
            let bExtendedStrand = false, bSecThird9 = false;

            // sometimes one chain may have several Ig domains,set an index for each IgDomain
            let index = 1, bStart = false;

            if(!me.bNode) { // do not overwrite loops in node  
                // reset ic.residIgLoop for the current selection, which could be the second round of ref num assignment
                // just current chain
                let atomHash = me.hashUtilsCls.intHash(ic.chains[chnid], ic.hAtoms);
                ic.firstAtomObjCls.getResiduesFromAtoms(atomHash);
            }

            // 1. get the range of each strand excluding loops
            let strandArray = [], strandHash = {}, strandCnt = 0, resCnt = 0, resCntBfAnchor = 0, resCntAtAnchor = 0;
            let bFoundAnchor = false;

            for(let i = 0, il = giSeq.length; i < il; ++i, ++resCnt, ++resCntBfAnchor, ++resCntAtAnchor) {
                let currResi = ic.ParserUtilsCls.getResi(chnid, i);
                let residueid = chnid + '_' + currResi;
                let domainid;

                refnumLabel = ic.resid2refnum[residueid];

                let firstChar = (refnumLabel) ? refnumLabel.substr(0,1) : '';
                if(!bStart && refnumLabel && (firstChar == 'A' || firstChar == 'B')) { // start of a new IG domain
                    bStart = true;
                    resCnt = 1; // the first one is included
                    bFoundAnchor = false;
                }

                //if((prevStrand.substr(0,1) == 'F' || prevStrand.substr(0,1) == 'G') && !refnumLabel) { // indicate the end of an IG domain
                if((prevStrand.substr(0,1) == 'G') && !refnumLabel) { // indicate the end of an IG domain
                        bStart = false;
                }

                if(refnumLabel) {    
                    domainid = ic.resid2domainid[residueid];

                    refnumStr_ori = ic.refnumCls.rmStrandFromRefnumlabel(refnumLabel);
                    currStrand = refnumLabel.replace(new RegExp(refnumStr_ori,'g'), '');
                    refnumStr_ori.substr(0, 1);

                    refnumStr = refnumStr_ori;
                    refnum = parseInt(refnumStr);
                    refnum3c = (refnum - parseInt(refnum/1000) * 1000).toString();
                    refnum2c = (refnum - parseInt(refnum/100) * 100).toString();

                    // for extended strands, since A is 1550 and A+ is 1650, then the AA+ loop will be 1591, 1592, ... 1618, 1619, etc
                    bSecThird9 = refnum3c.substr(0,1) == '9' || refnum2c.substr(0,1) == '9' || refnum2c.substr(0,1) == '0' || refnum2c.substr(0,1) == '1';
                    if(bSecThird9) ic.residIgLoop[residueid] = 1;

                    strandPostfix = refnumStr.replace(refnum.toString(), '');

                    postfix = strandPostfix + '_' + index;

                    let firstTwo = parseInt(refnum.toString().substr(0, 2)); // check extended strands
                    bExtendedStrand = refnum3c.substr(0,1) != '5' && firstTwo != '18'; // all strands and A' (18##)

                    if(currStrand && currStrand != ' ') {
                        if(!bSecThird9 || (bExtendedStrand && !bSecThird9)) {
                            let lastTwo = parseInt(refnum.toString().substr(refnum.toString().length - 2, 2));
                            
                            // reset currCnt
                            if(currStrand != prevStrand && currStrand != prevValidStrand) { // sometimes the same resid appear several times, e.g, 7M7B_H_135
                                bFoundAnchor = false;

                                if(strandHash[currStrand + postfix]) {
                                    ++index;
                                    postfix = refnumStr.replace(refnum.toString(), '') + '_' + index;
                                }

                                strandHash[currStrand + postfix] = 1;

                                strandArray[strandCnt] = {};    
                                
                                strandArray[strandCnt].startResi = currResi;
                                strandArray[strandCnt].startRefnum = refnum; // 1250 in A1250a

                                resCntBfAnchor = 0;
                                
                                strandArray[strandCnt].domainid = domainid;

                                strandArray[strandCnt].endResi = currResi;
                                strandArray[strandCnt].endRefnum = refnum; // 1250a

                                if(lastTwo == 50) {
                                    strandArray[strandCnt].anchorRefnum = refnum;
                                    strandArray[strandCnt].resCntBfAnchor = resCntBfAnchor;

                                    resCntAtAnchor = 0;

                                    bFoundAnchor = true;
                                }
                                
                                // in case A1550 is not found, but A1551 is found
                                if(!bFoundAnchor && (lastTwo >= 46 && lastTwo <= 54) ) {
                                    let offset = lastTwo - 50;
                                    strandArray[strandCnt].anchorRefnum = refnum - offset;
                                    strandArray[strandCnt].resCntBfAnchor = resCntBfAnchor - offset;

                                    resCntAtAnchor = offset;

                                    bFoundAnchor = true;
                                }

                                if(bExtendedStrand) {
                                    strandArray[strandCnt].anchorRefnum = 0;
                                }

                                strandArray[strandCnt].strandPostfix = strandPostfix; // a in A1250a
                                strandArray[strandCnt].strand = currStrand; // A in A1250a

                                strandArray[strandCnt].postfix = postfix; // Aa_1

                                strandArray[strandCnt].loopResCnt = resCnt - 1;

                                ++strandCnt;
                                resCnt = 0;
                            }
                            else {
                                if(strandHash[currStrand + postfix]) {
                                    if(lastTwo == 50) {
                                        strandArray[strandCnt - 1].anchorRefnum = refnum;
                                        strandArray[strandCnt - 1].resCntBfAnchor = resCntBfAnchor;

                                        // update
                                        strandArray[strandCnt - 1].startRefnum = strandArray[strandCnt - 1].anchorRefnum - strandArray[strandCnt - 1].resCntBfAnchor;

                                        resCntAtAnchor = 0;

                                        bFoundAnchor = true;
                                    }
                                    
                                    // in case A1550 is not found, but A1551 is found
                                    if(!bFoundAnchor && (lastTwo == 51 || lastTwo == 52 || lastTwo == 53 || lastTwo == 54) ) {
                                        let offset = lastTwo - 50;
                                        strandArray[strandCnt - 1].anchorRefnum = refnum - offset;
                                        strandArray[strandCnt - 1].resCntBfAnchor = resCntBfAnchor - offset;

                                        // update
                                        strandArray[strandCnt - 1].startRefnum = strandArray[strandCnt - 1].anchorRefnum - strandArray[strandCnt - 1].resCntBfAnchor;

                                        resCntAtAnchor = offset;

                                        bFoundAnchor = true;
                                    }

                                    if(bExtendedStrand) {
                                        strandArray[strandCnt - 1].anchorRefnum = 0;
                                    }

                                    strandArray[strandCnt - 1].domainid = domainid;

                                    strandArray[strandCnt - 1].endResi = currResi;
                                    strandArray[strandCnt - 1].endRefnum = refnum; // 1250a
                                    strandArray[strandCnt - 1].resCntAtAnchor = resCntAtAnchor;

                                    if(strandArray[strandCnt - 1].anchorRefnum) {
                                        strandArray[strandCnt - 1].endRefnum = strandArray[strandCnt - 1].anchorRefnum + strandArray[strandCnt - 1].resCntAtAnchor;
                                    }

                                    resCnt = 0;
                                }
                            }
                        }

                        prevValidStrand = currStrand;
                    }
                }

                prevStrand = currStrand;
            }

            // 2. extend the strand to end of sheet
            let maxExtend = 8;
            for(let i = 0, il = strandArray.length; i < il; ++i) {
                let startAtom = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[chnid + '_' + strandArray[i].startResi]);
                let endAtom = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[chnid + '_' + strandArray[i].endResi]);

                let startPos = ic.setSeqAlignCls.getPosFromResi(chnid, strandArray[i].startResi);
                let endPos = ic.setSeqAlignCls.getPosFromResi(chnid, strandArray[i].endResi);

                if(startAtom.ss == 'sheet' && !startAtom.ssbegin) {
                    for(let j = 1; j <= maxExtend; ++j) {
                        let currPos = startPos - j;
                        let currResi = ic.ParserUtilsCls.getResi(chnid, currPos);
                        if(i > 0 && parseInt(currResi) <= parseInt(strandArray[i-1].endResi)) break;

                        let currResid = chnid + '_' + currResi;
                        let currAtom = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[currResid]);
                        let domainid = ic.resid2domainid[currResid];
                        if(currAtom.ssbegin) { // find the start of the sheet
                            // update the following: startResi,startRefnum,endResi,endRefnum,loopResCnt,resCntBfAnchor,resCntAtAnchor
                            let oriStartRefnum = strandArray[i].startRefnum;
                            strandArray[i].startResi = currResi;
                            strandArray[i].startRefnum -= j;
                            strandArray[i].loopResCnt -= j;
                            if(strandArray[i].loopResCnt < 0) strandArray[i].loopResCnt = 0;
                            strandArray[i].resCntBfAnchor += j;

                            // update ic.resid2refnum
                            for(let k = 1; k <= j; ++k) {
                                currPos = startPos - k;
                                currResi = ic.ParserUtilsCls.getResi(chnid, currPos);
                                let currResid = chnid + '_' + currResi;
                                delete ic.residIgLoop[currResid];
                                ic.resid2refnum[currResid] = strandArray[i].strand + (oriStartRefnum - k).toString();

                                ic.resid2domainid[currResid] = domainid;
                                // ic.resid2refnum_ori[currResid] = 1; // a hash to check which residues were assigned
                            }

                            break;
                        }
                    }
                }

                if(endAtom.ss == 'sheet' && !endAtom.ssend) {
                    for(let j = 1; j <= maxExtend; ++j) {
                        let currPos = endPos + j;
                        let currResi = ic.ParserUtilsCls.getResi(chnid, currPos);
                        if(i < il - 1 && parseInt(currResi) >= parseInt(strandArray[i+1].startResi)) break; 

                        let currResid = chnid + '_' + currResi;
                        let currAtom = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[currResid]);
                        let domainid = ic.resid2domainid[currResid];
                        if(currAtom.ssend) { // find the end of the sheet
                            // update the following: startResi,startRefnum,endResi,endRefnum,loopResCnt,resCntBfAnchor,resCntAtAnchor
                            let oriEndRefnum = strandArray[i].endRefnum;
                            strandArray[i].endResi = currResi;
                            strandArray[i].endRefnum += j;
                            if(i < il - 1) {
                                strandArray[i + 1].loopResCnt -= j;
                                if(strandArray[i + 1].loopResCnt < 0) strandArray[i + 1].loopResCnt = 0;
                            }
                            strandArray[i].resCntAtAnchor += j;

                            // update ic.residIgLoop[resid];
                            for(let k = 1; k <= j; ++k) {
                                currPos = endPos + k;
                                currResi = ic.ParserUtilsCls.getResi(chnid, currPos);
                                let currResid = chnid + '_' + currResi;
                                delete ic.residIgLoop[currResid];
                                ic.resid2refnum[currResid] = strandArray[i].strand + (oriEndRefnum + k).toString();

                                ic.resid2domainid[currResid] = domainid;
                                // ic.resid2refnum_ori[currResid] = 1; // a hash to check which residues were assigned
                            }

                            break;
                        }
                    }
                }
            }

            // 2b. remove strands with less than 3 residues except G strand
            let removeDomainidHash = {};
            for(let il = strandArray.length, i = il - 1; i >= 0; --i) {
                // let strandTmp = strandArray[i].strand.substr(0, 1);
                let strandTmp = strandArray[i].strand;

                if(strandTmp != 'G' && strandArray[i].endRefnum - strandArray[i].startRefnum + 1 < 3) { // remove the strand
                    if(strandArray[i + 1]) { // modify 
                        strandArray[i + 1].loopResCnt += strandArray[i].loopResCnt + parseInt(strandArray[i].endResi) - parseInt(strandArray[i].startResi) + 1;
                    }
                    
                    // assign before removing
                    chnid + '_' + strandArray[i].startResi;

                    strandArray.splice(i, 1);

                    // do not remove BCEF strands even though they are short
                    // if(strandTmp == 'B' || strandTmp == 'C' || strandTmp == 'E' || strandTmp == 'F') {
                    //     if(!me.bNode) console.log("Ig strand " + strandTmp + " is removed since it is too short...");
                        
                    //     let domainid = ic.resid2domainid[resid];
                    //     removeDomainidHash[domainid] = 1;
                    //     continue;
                    // }   
                }
            }

            // 3. assign refnumLabel for each resid
            strandCnt = 0;
            let loopCnt = 0;

            let bBeforeAstrand = true, bAfterGstrand = true, refnumLabelNoPostfix, prevStrandCnt = 0, currRefnum;
            bStart = false;
            let refnumInStrand = 0;
            if(strandArray.length > 0) {
                for(let i = 0, il = giSeq.length; i < il; ++i, ++loopCnt, ++refnumInStrand) {
                    let currResi = ic.ParserUtilsCls.getResi(chnid, i);
                    let residueid = chnid + '_' + currResi;
                    refnumLabel = ic.resid2refnum[residueid];

                    currStrand = strandArray[strandCnt].strand;

                    let domainid;

                    if(refnumLabel) {
                        domainid = ic.resid2domainid[residueid];

                        refnumStr = ic.refnumCls.rmStrandFromRefnumlabel(refnumLabel);
                        currRefnum = parseInt(refnumStr);
                        refnumLabelNoPostfix = currStrand + currRefnum;

                        currStrand = refnumLabel.replace(new RegExp(refnumStr,'g'), '');
                        
                        let firstChar = refnumLabel.substr(0,1);
                        if(!bStart && (firstChar == 'A' || firstChar == 'B')) { // start of a new IG domain
                            bStart = true;
                            bBeforeAstrand = true;
                            loopCnt = 0;
                        }
                    }

                    let atom = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[residueid]);

                    // skip non-protein residues
                    if(!atom || !ic.proteins.hasOwnProperty(atom.serial)) {
                        refnumLabel = undefined;
                    }
                    else {
                        let bBefore = false, bInRange= false, bAfter = false;
                        // 100, 100A
                        if(parseInt(currResi) == parseInt(strandArray[strandCnt].startResi) && currResi != strandArray[strandCnt].startResi) {
                            bBefore = currResi < strandArray[strandCnt].startResi;
                        }
                        else {
                            bBefore = parseInt(currResi) < parseInt(strandArray[strandCnt].startResi);
                        }

                        // 100, 100A
                        if(parseInt(currResi) == parseInt(strandArray[strandCnt].endResi) && currResi != strandArray[strandCnt].endResi) {
                            bAfter = currResi > strandArray[strandCnt].endResi;
                        }
                        else {
                            bAfter = parseInt(currResi) > parseInt(strandArray[strandCnt].endResi);
                        }

                        bInRange = (!bBefore && !bAfter) ? true : false;

                        if(bBefore) {
                            ic.residIgLoop[residueid] = 1;

                            if(bBeforeAstrand) { // make it continuous to the 1st strand
                                if(bStart) {
                                    currRefnum = strandArray[strandCnt].startRefnum - strandArray[strandCnt].loopResCnt + loopCnt;
                                    refnumLabelNoPostfix = strandArray[strandCnt].strand + currRefnum;
                                    refnumLabel = refnumLabelNoPostfix  + strandArray[strandCnt].strandPostfix;
                                    domainid = strandArray[strandCnt].domainid;
                                }    
                                else {
                                    refnumLabelNoPostfix = undefined;
                                    refnumLabel = undefined;
                                }                        
                            }
                            else {
                                // if(prevStrandCnt >= 0 && (strandArray[prevStrandCnt].strand.substr(0, 1) == 'G')) {
                                if(prevStrandCnt >= 0 && (strandArray[prevStrandCnt].strand.substr(0, 1) == 'G' || (strandArray[prevStrandCnt].strand.substr(0, 1) == 'F' && strandArray[strandCnt].strand.substr(0, 1) != 'G') )) {
                                    if(!bAfterGstrand) {
                                        //loopCnt = 0;
                                        refnumLabelNoPostfix = undefined;
                                        refnumLabel = undefined;
                                    }
                                    else {
                                        if(bStart && ic.resid2refnum[residueid]) {
                                            bAfterGstrand = true;

                                            currRefnum = strandArray[prevStrandCnt].endRefnum + loopCnt;
                                            refnumLabelNoPostfix = strandArray[prevStrandCnt].strand + currRefnum;
                                            refnumLabel = refnumLabelNoPostfix  + strandArray[prevStrandCnt].strandPostfix; 
                                            domainid = strandArray[prevStrandCnt].domainid;
                                        }
                                        else {
                                            bStart = false;
                                            bBeforeAstrand = true;
                                            //loopCnt = 0;

                                            bAfterGstrand = false;
        
                                            refnumLabelNoPostfix = undefined;
                                            refnumLabel = undefined;
                                        }
                                    }
                                }
                                else {
                                    bAfterGstrand = true; // reset

                                    let len = strandArray[strandCnt].loopResCnt;
                                    let halfLen = parseInt(len / 2.0 + 0.5);
                        
                                    if(loopCnt <= halfLen) {
                                        if(strandArray[prevStrandCnt]) {
                                            currRefnum = strandArray[prevStrandCnt].endRefnum + loopCnt;
                                            refnumLabelNoPostfix = strandArray[prevStrandCnt].strand + currRefnum;
                                            refnumLabel = refnumLabelNoPostfix  + strandArray[prevStrandCnt].strandPostfix; 
                                            domainid = strandArray[prevStrandCnt].domainid;
                                        }
                                    }
                                    else {
                                        currRefnum = strandArray[strandCnt].startRefnum - len + loopCnt - 1;
                                        refnumLabelNoPostfix = strandArray[strandCnt].strand + currRefnum;
                                        refnumLabel = refnumLabelNoPostfix  + strandArray[strandCnt].strandPostfix; 
                                        domainid = strandArray[strandCnt].domainid;
                                    }
                                }
                            }
                        }
                        else if(bInRange) {
                            // not in loop any more if you assign ref numbers multiple times
                            //delete ic.residIgLoop[residueid];

                            bBeforeAstrand = false;

                            if(strandArray[strandCnt].anchorRefnum) { // use anchor to name refnum
                                if(currResi == strandArray[strandCnt].startResi) {
                                    refnumInStrand = strandArray[strandCnt].anchorRefnum - strandArray[strandCnt].resCntBfAnchor;
                                    strandArray[strandCnt].startRefnum = refnumInStrand;
                                }
                                else if(currResi == strandArray[strandCnt].endResi) {
                                    strandArray[strandCnt].endRefnum = refnumInStrand;
                                }

                                refnumLabelNoPostfix = strandArray[strandCnt].strand + refnumInStrand;
                                refnumLabel = refnumLabelNoPostfix  + strandArray[strandCnt].strandPostfix; 
                                domainid = strandArray[strandCnt].domainid;
                            }

                            if(currResi == strandArray[strandCnt].endResi) {
                                ++strandCnt; // next strand
                                loopCnt = 0;

                                if(!strandArray[strandCnt]) { // last strand
                                    --strandCnt;
                                }
                            }
                        }
                        else if(bAfter) {     
                            ic.residIgLoop[residueid] = 1;    

                            if(!bAfterGstrand) {
                                refnumLabelNoPostfix = undefined;
                                refnumLabel = undefined;
                            }
                            else {
                                // C-terminal
                                if(!ic.resid2refnum[residueid]) {
                                    bAfterGstrand = false;

                                    refnumLabelNoPostfix = undefined;
                                    refnumLabel = undefined;
                                }
                                else {
                                    bAfterGstrand = true;

                                    currRefnum = strandArray[strandCnt].endRefnum + loopCnt;
                                    refnumLabelNoPostfix = strandArray[strandCnt].strand + currRefnum;
                                    refnumLabel = refnumLabelNoPostfix  + strandArray[strandCnt].strandPostfix; 
                                    domainid = strandArray[strandCnt].domainid;
                                }
                            }
                        }
                    }

                    prevStrand = currStrand;
                    prevStrandCnt = strandCnt - 1;

                    // remove domians without B,C,E,F strands
                    if(removeDomainidHash.hasOwnProperty(domainid)) {
                        delete ic.resid2refnum[residueid];
                        delete ic.residIgLoop[residueid];
                        delete ic.resid2domainid[residueid];

                        continue;
                    }

                    // assign the adjusted reference numbers
                    ic.resid2refnum[residueid] = refnumLabel;
                    ic.resid2domainid[residueid] = domainid;

                    refnumStr = ic.refnumCls.rmStrandFromRefnumlabel(refnumLabel);

                    if(!ic.refnum2residArray.hasOwnProperty(refnumStr)) {
                        ic.refnum2residArray[refnumStr] = [residueid];
                    }
                    else {
                        ic.refnum2residArray[refnumStr].push(residueid);
                    }

                    if(!ic.chainsMapping.hasOwnProperty(chnid)) {
                        ic.chainsMapping[chnid] = {};
                    }

                    // remove the postfix when comparing interactions
                    //ic.chainsMapping[chnid][residueid] = refnumLabel;
                    ic.chainsMapping[chnid][residueid] = (refnumLabelNoPostfix) ? refnumLabelNoPostfix : currResi;
                }
            }

            return true;
        }
     }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Scap {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        async applyCommandScap(command) { let ic = this.icn3d; ic.icn3dui;
            let snp = command.substr(command.lastIndexOf(' ') + 1);

            if(command.indexOf('scap 3d') == 0) {
              await this.retrieveScap(snp);
            }
            else if(command.indexOf('scap interaction') == 0) {
              await this.retrieveScap(snp, true);
            }
            else if(command.indexOf('scap pdb') == 0) {
              await this.retrieveScap(snp, undefined, true);
            }
        }

        adjust2DWidth(id) { let ic = this.icn3d; ic.icn3dui;
            id = ic.pre + id;
    /*
            let height =($("#" + ic.pre + 'dl_selectannotations').hasClass("ui-dialog-content")) ? $("#" + ic.pre + 'dl_selectannotations').dialog( "option", "height") : me.htmlCls.HEIGHT;
            let width =($("#" + ic.pre + 'dl_selectannotations').hasClass("ui-dialog-content")) ? halfWidth * 2 : me.htmlCls.WIDTH * 0.5;

            $("#" + id).dialog( "option", "width", width );
            $("#" + id).dialog( "option", "height", height);
            let position = { my: "left-" + halfWidth + " top+" + me.htmlCls.MENU_HEIGHT, at: "right top", of: "#" + ic.pre + "viewer", collision: "none" }

            $("#" + id).dialog( "option", "position", position );
    */

            let width, height, top;
            
            if($("#" + ic.pre + 'dl_selectannotations').hasClass("ui-dialog-content")) {
              width = $("#" + ic.pre + 'dl_selectannotations').dialog( "option", "width");
              height = $("#" + ic.pre + 'dl_selectannotations').dialog( "option", "height") * 0.5;
              top = height;

              $("#" + ic.pre + "dl_selectannotations").dialog( "option", "height", height);

              $("#" + id).dialog( "option", "width", width );
              $("#" + id).dialog( "option", "height", height);
              
              let position = { my: "left top", at: "right top+" + top, of: "#" + ic.pre + "viewer", collision: "none" };
      
              $("#" + id).dialog( "option", "position", position );
            }
        }

        async retrieveScap(snp, bInteraction, bPdb) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            ic.bScap = true;

            //snp: 6M0J_E_484_K,6M0J_E_501_Y,6M0J_E_417_N
            let snpStr = '';
            let snpArray = snp.split(','); //stru_chain_resi_snp
            let atomHash = {}, snpResidArray = [], chainResi2pdb = {};
            for(let i = 0, il = snpArray.length; i < il; ++i) {
                let idArray = snpArray[i].split('_'); //stru_chain_resi_snp

                let resid = idArray[0] + '_' + idArray[1] + '_' + idArray[2];
                atomHash = me.hashUtilsCls.unionHash(atomHash, ic.residues[resid]);
                snpResidArray.push(resid);
                chainResi2pdb[idArray[1] + '_' + idArray[2]] = '';

                snpStr += idArray[1] + '_' + idArray[2] + '_' + idArray[3];
                if(i != il -1) snpStr += ',';
            }

            let selectSpec = ic.resid2specCls.residueids2spec(snpResidArray);
            let select = "select " + selectSpec;

            let bGetPairs = false;
            let radius = 10; //4;
            // find neighboring residues
            let result = ic.showInterCls.pickCustomSphere_base(radius, atomHash, ic.atoms, false, false, undefined, select, bGetPairs);


            let residArray = Object.keys(result.residues);
            ic.hAtoms = {};
            for(let index = 0, indexl = residArray.length; index < indexl; ++index) {
              let residueid = residArray[index];
              for(let i in ic.residues[residueid]) {
                ic.hAtoms[i] = 1;
              }
            }

        //    ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.residues[resid]);
            ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, atomHash);
            ic.hAtoms = me.hashUtilsCls.exclHash(ic.hAtoms, ic.chemicals);

            // the displayed atoms are for each SNP only
            //var atomHash = me.hashUtilsCls.intHash(ic.dAtoms, ic.hAtoms);

    ///        let pdbStr = ic.saveFileCls.getPDBHeader() + ic.saveFileCls.getAtomPDB(ic.hAtoms);
            let pdbStr = ic.saveFileCls.getAtomPDB(ic.hAtoms);

            let url = me.htmlCls.baseUrl + "scap/scap.cgi";

            let pdbid = Object.keys(ic.structures)[0]; //Object.keys(ic.structures).toString();
            let dataObj = {'pdb': pdbStr, 'snp': snpStr, 'pdbid': pdbid, 'v': '2'};

            let data;
             
            // try {
              data = await me.getAjaxPostPromise(url, dataObj, true, undefined, undefined, undefined, 'text');

              let pos = data.indexOf('\n');
              let energy = data.substr(0, pos);
              let pdbData = data.substr(pos + 1);
    console.log("free energy: " + energy + " kcal/mol");

              let bAddition = true;
              let hAtom1 = me.hashUtilsCls.cloneHash(ic.hAtoms);

              // the wild type is the reference
              for(let serial in hAtom1) {
                  let atom = ic.atoms[serial];
                  let chainid = atom.structure + '_' + atom.chain;
                  let resid = chainid + '_' + atom.resi;

                  if(!ic.chainsMapping.hasOwnProperty(chainid)) {
                    ic.chainsMapping[chainid] = {};
                  }
                  ic.chainsMapping[chainid][resid] = me.utilsCls.residueName2Abbr(atom.resn) + atom.resi;
              }

              //ic.hAtoms = {};
              //ic.loadPDBCls.loadPDB(pdbData, pdbid, false, false, bAddition);
              //let hAtom2 = me.hashUtilsCls.cloneHash(ic.hAtoms);

              // get the mutant pdb
              let lines = pdbData.split('\n');
              let allChainResiHash = {};
              for (let i in lines) {
                  let line = lines[i];
                  let record = line.substr(0, 6);
                  
                  if (record === 'ATOM  ' || record === 'HETATM') {
                      let chain = line.substr(20, 2).trim();
                      if(chain === '') chain = 'A';
      
                      let resi = line.substr(22, 5).trim();
                      let chainResi = chain + '_' + resi;
                      
                      if(chainResi2pdb.hasOwnProperty(chainResi)) {
                          chainResi2pdb[chainResi] += line + '\n';
                      }  

                      allChainResiHash[chainResi] = 1;
                  }
              }

              // get the full mutant PDB
              let pdbDataMutant = ic.saveFileCls.getAtomPDB(ic.atoms, false, false, false, chainResi2pdb);

              ic.hAtoms = {};
              let bMutation = true;
              ic.loadPDBCls.loadPDB(pdbDataMutant, pdbid, false, false, bMutation, bAddition);
              //let allAtoms2 = me.hashUtilsCls.cloneHash(ic.hAtoms);

              // copy the secondary structures from wild type to mutatnt
              for(let resid in ic.residues) {
                let struct = resid.substr(0, resid.indexOf('_'));
                
                if(struct == pdbid + '2') { // mutant
                  let residWt = pdbid + resid.substr(resid.indexOf('_'));       
                  let atomWt = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[residWt]);
                  if(atomWt) {
                    for(let i in ic.residues[resid]) {
                      ic.atoms[i].ss = atomWt.ss;
                      ic.atoms[i].ssbegin = atomWt.ssbegin;
                      ic.atoms[i].ssend = atomWt.ssend;           
                    }
                  }
                }
              }
              for(let resid in ic.secondaries) {
                let struct = resid.substr(0, resid.indexOf('_'));
                
                if(struct == pdbid + '2') { // mutant
                  let residWt = pdbid + resid.substr(resid.indexOf('_'));       
                  ic.secondaries[resid] = ic.secondaries[residWt];
                }
              }
              

              ic.setStyleCls.setAtomStyleByOptions(ic.opts);
              ic.setColorCls.setColorByOptions(ic.opts, ic.hAtoms);

              // get the mutant residues in the sphere
              let hAtom2 = {};
              for(let serial in ic.hAtoms) {
                let atom = ic.atoms[serial];
                let chainResi = atom.chain + '_' + atom.resi;
                if(allChainResiHash.hasOwnProperty(chainResi)) {
                  hAtom2[serial] = 1;
                }
              }

              ic.hAtoms = me.hashUtilsCls.unionHash(hAtom1, hAtom2);
              //ic.hAtoms = me.hashUtilsCls.unionHash(hAtom1, allAtoms2);
              ic.dAtoms = me.hashUtilsCls.cloneHash(ic.hAtoms);
              //ic.dAtoms = ic.hAtoms;

              ic.transformCls.zoominSelection();
              ic.setOptionCls.setStyle('proteins', 'stick');

              //ic.opts['color'] = 'chain';
              //ic.setColorCls.setColorByOptions(ic.opts, ic.dAtoms);
              for(let serial in hAtom2) {
              //for(let serial in allAtoms2) {
                  let atom = ic.atoms[serial];

                  if(!atom.het) {
                      // use the same color as the wild type
                      let resid = atom.structure.substr(0, atom.structure.length - 1) + '_' + atom.chain + '_' + atom.resi;

                      let atomWT = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid]);

                      if(atomWT) {
                        ic.atoms[serial].color = atomWT.color;
                        ic.atomPrevColors[serial] = atomWT.color;
                      }
                  }

                  let chainid = atom.structure + '_' + atom.chain;
                  let resid = chainid + '_' + atom.resi;
                  let residWT = atom.structure.substr(0, atom.structure.length - 1) + '_' + atom.chain + '_' + atom.resi;

                  if(!ic.chainsMapping.hasOwnProperty(chainid)) {
                    ic.chainsMapping[chainid] = {};
                  }
                  ic.chainsMapping[chainid][resid] = me.utilsCls.residueName2Abbr(atom.resn) + atom.resi;
                  // use the wild type as reference

                  if(snpResidArray.indexOf(residWT) != -1) {
                      let atomWT = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[residWT]);
                      ic.chainsMapping[chainid][resid] = me.utilsCls.residueName2Abbr(atomWT.resn) + atomWT.resi;
                  }
              }

              if(bPdb) {
                  // let file_pref = Object.keys(me.utilsCls.getHlStructures()).join(',');
                  // ic.saveFileCls.saveFile(file_pref + '_' + snpStr + '.pdb', 'text', [pdbDataMutant]);

                  await thisClass.exportPdbProfix(false, pdbDataMutant, snpStr); 

                  ic.drawCls.draw();
              }
              else {
                  //var select = '.' + idArray[1] + ':' + idArray[2];
                  //var name = 'snp_' + idArray[1] + '_' + idArray[2];
                  let select = selectSpec;

                  let name = 'snp_' + snpStr;
                  await ic.selByCommCls.selectByCommand(select, name, name);
                  ic.opts['color'] = 'atom';
                  ic.setColorCls.setColorByOptions(ic.opts, ic.hAtoms);

                  ic.viewInterPairsCls.clearInteractions();

                  if(bInteraction) {
                    //me.htmlCls.clickMenuCls.setLogCmd("select " + select + " | name " + name, true);

                    let type = 'linegraph';
                    await ic.viewInterPairsCls.viewInteractionPairs(['selected'], ['non-selected'], false, type, true, true, true, true, true, true);
                    //me.htmlCls.clickMenuCls.setLogCmd("line graph interaction pairs | selected non-selected | hbonds,salt bridge,interactions,halogen,pi-cation,pi-stacking | false | threshold 3.8 6 4 3.8 6 5.5", true);

                    thisClass.adjust2DWidth('dl_linegraph');
                  }

                  ic.hAtoms = ic.dAtoms;
                  //me.htmlCls.clickMenuCls.setLogCmd("select displayed set", true);

                  ic.drawCls.draw();

                  if(!me.alertAlt) {
                    me.alertAlt = true;

                    //if(ic.bRender) alert('Please press the letter "a" to alternate between wild type and mutant.');
                    alert('Please press the letter "a" to alternate between wild type and mutant.');
                  }
              }

              $("#" + ic.pre + "mn2_alternateWrap").show();
              // expand the toolbar
              let id = ic.pre + 'selection';
              $("#" + id).show();
    /*
            }
            catch(err) {
                alert("There are some problems in predicting the side chain of the mutant...");

                ic.ParserUtilsCls.hideLoading();

                /// if(ic.deferredScap !== undefined) ic.deferredScap.resolve();
                return;
            }
            */
        }

        async exportPdbProfix(bHydrogen, pdb, snpStr) { let ic = this.icn3d, me = ic.icn3dui;
          let pdbStr;

          if(pdb) {
            pdbStr = pdb;
          }
          else {
            let atoms = me.hashUtilsCls.intHash(ic.dAtoms, ic.hAtoms);
            let bMergeIntoOne = true;
            pdbStr = ic.saveFileCls.getAtomPDB(atoms, undefined, undefined, undefined, undefined, undefined, bMergeIntoOne);
          }

          let url = me.htmlCls.baseUrl + "scap/scap.cgi";
          let hydrogenStr = (bHydrogen) ? '1' : '0';
          let dataObj = {'pdb': pdbStr, 'profix': '1', 'hydrogen': hydrogenStr};

          let data;
           
          try {
            data = await me.getAjaxPostPromise(url, dataObj, undefined, undefined, undefined, undefined, 'text');
          }
          catch(err) {
            alert("There are some problems in adding missing atoms or hydrogens...");
            return;
          }

          if(!me.bNode) {
            let file_pref = Object.keys(me.utilsCls.getHlStructures()).join(',');
            let postfix = (bHydrogen) ? "add_hydrogen" : "add_missing_atoms";
            if(snpStr) postfix = snpStr;

            ic.saveFileCls.saveFile(file_pref + '_icn3d_' + postfix + '.pdb', 'text', [data]);
          }
          else {
            return data;
          }
       }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Symd {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        async applyCommandSymd(command) { let ic = this.icn3d; ic.icn3dui;
            await this.retrieveSymd();
        }

        async retrieveSymd() { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            //var url = "https://data.rcsb.org/rest/v1/core/assembly/" + pdbid + "/1";
            let url = me.htmlCls.baseUrl + "symd/symd.cgi";

            let atomHash = me.hashUtilsCls.intHash(ic.dAtoms, ic.hAtoms);

            // just output C-alpha atoms
            // the number of residues matters
            //   atomHash = me.hashUtilsCls.intHash(atomHash, ic.calphas);
            // just output proteins
            atomHash = me.hashUtilsCls.intHash(atomHash, ic.proteins);

            let atomCnt = Object.keys(atomHash).length;

            let residHash = {};
            for(let serial in atomHash) {
                let atom = ic.atoms[serial];
                let resid = atom.structure + '_' + atom.chain + '_' + atom.resi;
                residHash[resid] = 1;
            }

            // the cgi took too long for structures with more than 10000 atoms
            if(atomCnt > 10000) {
                alert("The maximum number of allowed atoms is 10,000. Please try it again with smaller sets...");
                return;
            }

            let pdbstr = '';
            pdbstr += ic.saveFileCls.getAtomPDB(atomHash);

            let dataObj = {'pdb': pdbstr, 'pdbid': Object.keys(ic.structures).toString()};
            let data;
            try {
                data = await me.getAjaxPostPromise(url, dataObj, true);

                let symmetryArray = data.rcsb_struct_symmetry;
                let rot, centerFrom, centerTo;

                let title = 'none';

                if(symmetryArray !== undefined) {
                    if(ic.rmsd_supr !== undefined && ic.rmsd_supr.rot !== undefined) {
                        rot = ic.rmsd_supr.rot;
                        centerFrom = ic.rmsd_supr.trans1;
                        centerTo = ic.rmsd_supr.trans2;
                    }

                    //ic.symdHash = {}
                    if(ic.symdArray === undefined) ic.symdArray = [];
                    let order;
                    for(let i = 0, il = symmetryArray.length; i < il; ++i) {
                        if(symmetryArray[i].symbol == 'C1') continue;
                        title = symmetryArray[i].symbol + " ";
                        if(symmetryArray[i].kind == "Pseudo Symmetry") {
                            title = symmetryArray[i].symbol + ' (pseudo)';
                        }
                        else if(symmetryArray[i].kind == "Global Symmetry") {
                            title = symmetryArray[i].symbol + ' (global)';
                        }
                        else if(symmetryArray[i].kind == "Local Symmetry") {
                            title = symmetryArray[i].symbol + ' (local)';
                        }

                        let rotation_axes = symmetryArray[i].rotation_axes;
                        let axesArray = [];
                        for(let j = 0, jl = rotation_axes.length; j < jl; ++j) {
                            let tmpArray = [];
                            let start = new THREE.Vector3(rotation_axes[j].start[0], rotation_axes[j].start[1], rotation_axes[j].start[2]);
                            let end = new THREE.Vector3(rotation_axes[j].end[0], rotation_axes[j].end[1], rotation_axes[j].end[2]);

                            order = rotation_axes[j].order;

                            // apply matrix for each atom
                            //if(ic.rmsd_supr !== undefined && ic.rmsd_supr.rot !== undefined) {
                            //    start = ic.surfaceCls.transformMemPro(start, rot, centerFrom, centerTo);
                            //    end = ic.surfaceCls.transformMemPro(end, rot, centerFrom, centerTo);
                            //}

                            tmpArray.push(start);
                            tmpArray.push(end);

                            // https://www.rcsb.org/pages/help/viewers/jmol_symmetry_view
                            let colorAxis = thisClass.getAxisColor(symmetryArray[i].symbol, rotation_axes[j].order);
                            let colorPolygon = thisClass.getPolygonColor(symmetryArray[i].symbol);
                            tmpArray.push(colorAxis);
                            tmpArray.push(colorPolygon);

                            tmpArray.push(rotation_axes[j].order);

                            // selected chain
                            tmpArray.push('selection');

                            axesArray.push(tmpArray);
                        }
                        let symdHash = {};
                        symdHash[title] = axesArray;
                        ic.symdArray.push(symdHash);
                    }

                    if(ic.symdArray.length == 0) {
                        $("#" + ic.pre + "dl_symd").html("<br>The selected residues have no detected symmetry with a Z score of " + data.zscore + " from the program <a href='https://symd.nci.nih.gov/' target='_blank'>SymD</a>.");
                        me.htmlCls.dialogCls.openDlg('dl_symd', 'Dynamically Calculated Symmetry Using SymD');
                    }
                    else {
                        let ori_permSeq = data.seqalign.replace(/ /g, '').split(','); //oriSeq,permSeq
                        let nres = data.nres;
                        let shift = data.shift;
                        let rmsd = data.rmsd;

                        let oriResidArray = Object.keys(residHash);
                        let residArrayHash1 = {}, residArrayHash2 = {};
                        let residArray1 = [], residArray2 = [];
                        let index1 = 0, index2 = 0;
                        let chainCntHash = {};
                        for(let i = 0, il = ori_permSeq[0].length; i < il; ++i) {
                            let resn1 = ori_permSeq[0][i];
                            let resn2 = ori_permSeq[1][i];

                            if(resn1 != '-') {
                                if(resn1 == resn1.toUpperCase()) { // aligned
                                    residArrayHash1[oriResidArray[index1]] = 1;

                                    let idArray1 = me.utilsCls.getIdArray(oriResidArray[index1]);
                                    residArray1.push(resn1 + ' $' + idArray1[0] + '.' + idArray1[1] + ':' + idArray1[2]);

                                    let chainid = idArray1[0] + '_' + idArray1[1];
                                    if(!chainCntHash.hasOwnProperty(chainid)) {
                                        chainCntHash[chainid] = [];
                                    }

                                    chainCntHash[chainid].push(residArray1.length - 1); // the position in the array
                                }
                                ++index1;
                            }

                            if(resn2 != '-') {
                                if(resn2 == resn2.toUpperCase()) { // aligned
                                    let oriIndex =(index2 + shift + nres) % nres;
                                    residArrayHash2[oriResidArray[oriIndex]] = 1;

                                    let idArray2 = me.utilsCls.getIdArray(oriResidArray[oriIndex]);
                                    residArray2.push(resn2 + ' $' + idArray2[0] + '.' + idArray2[1] + ':' + idArray2[2]);
                                }
                                ++index2;
                            }
                        }

                        let residArrayHashFinal1 = {}, residArrayHashFinal2 = {};
                        let residArrayFinal1 = [], residArrayFinal2 = [];

                        let bOnechain = false;
                        if(Object.keys(chainCntHash).length == 1) {
                            bOnechain = true;
                            let nResUnit = parseInt(residArray1.length / order + 0.5);
                            let residArrayFromHash1 = Object.keys(residArrayHash1), residArrayFromHash2 = Object.keys(residArrayHash2);
                            for(let i = 0; i < nResUnit; ++i) {
                            if(!residArrayHashFinal1.hasOwnProperty(residArrayFromHash2[i])) { // do not appear in both original and permuted
                                residArrayFinal1.push(residArray1[i]);
                                residArrayFinal2.push(residArray2[i]);
                                residArrayHashFinal1[residArrayFromHash1[i]] = 1;
                                residArrayHashFinal2[residArrayFromHash2[i]] = 1;
                            }
                            }
                        }
                        else {
                            let selChainid, selCnt = 0;
                            for(let chainid in chainCntHash) {
                                if(chainCntHash[chainid].length > selCnt) {
                                    selCnt = chainCntHash[chainid].length;
                                    selChainid = chainid;
                                }
                            }

                            let residArrayFromHash1 = Object.keys(residArrayHash1), residArrayFromHash2 = Object.keys(residArrayHash2);
                            for(let i = 0, il = chainCntHash[selChainid].length; i < il; ++i) {
                            let pos = chainCntHash[selChainid][i];
                            if(!residArrayHashFinal1.hasOwnProperty(residArrayFromHash2[pos])) { // do not appear in both original and permuted
                                residArrayFinal1.push(residArray1[pos]);
                                residArrayFinal2.push(residArray2[pos]);
                                residArrayHashFinal1[residArrayFromHash1[pos]] = 1;
                                residArrayHashFinal2[residArrayFromHash2[pos]] = 1;
                            }
                            }
                        }

                        let html = '<br>';
                        html += "The symmetry " + symmetryArray[0].symbol + " was calculated dynamically using the program <a href='https://symd.nci.nih.gov/' target='_blank'>SymD</a>. The Z score " + data.zscore + " is greater than the threshold Z score 8. The RMSD is " + rmsd + " angstrom. <br><br>The following sequence alignment shows the residue mapping of the best aligned sets: \"symOri\" and \"symPerm\", which are also available in the menu \"Analysis > Defined Sets\".<br>";

                        $("#" + ic.pre + "symd_info").html(html);

                        thisClass.setSeqAlignForSymmetry(residArrayFinal1, residArrayFinal2, bOnechain);

                        let bShowHighlight = false;
                        let seqObj = me.htmlCls.alignSeqCls.getAlignSequencesAnnotations(Object.keys(ic.alnChains), undefined, undefined, bShowHighlight, bOnechain);

                        html = $("#" + ic.pre + "dl_sequence2").html() + seqObj.sequencesHtml;

                        $("#" + ic.pre + "dl_sequence2").html(html);
                        $("#" + ic.pre + "dl_sequence2").width(me.htmlCls.RESIDUE_WIDTH * seqObj.maxSeqCnt + 200);

                        me.htmlCls.dialogCls.openDlg('dl_alignment', 'Select residues in aligned sequences from SymD');

                        let numDef = Object.keys(ic.defNames2Residues).length + Object.keys(ic.defNames2Atoms).length;

                        let name = 'symOri' + numDef;
                        ic.selectionCls.selectResidueList(residArrayHashFinal1, name, name);
                        ic.selectionCls.updateSelectionNameDesc();
                        me.htmlCls.clickMenuCls.setLogCmd('select ' + ic.resid2specCls.residueids2spec(Object.keys(residArrayHashFinal1)) + ' | name ' + name, false);

                        name = 'symPerm' + numDef;
                        ic.selectionCls.selectResidueList(residArrayHashFinal2, name, name);
                        ic.selectionCls.updateSelectionNameDesc();
                        me.htmlCls.clickMenuCls.setLogCmd('select ' + ic.resid2specCls.residueids2spec(Object.keys(residArrayHashFinal2)) + ' | name ' + name, false);

                        name = 'symBoth' + numDef;
                        residArrayHashFinal1 = me.hashUtilsCls.unionHash(residArrayHashFinal1, residArrayHashFinal2);
                        ic.selectionCls.selectResidueList(residArrayHashFinal1, name, name);
                        ic.selectionCls.updateSelectionNameDesc();
                        me.htmlCls.clickMenuCls.setLogCmd('select ' + ic.resid2specCls.residueids2spec(Object.keys(residArrayHashFinal1)) + ' | name ' + name, false);

                        //ic.hlUpdateCls.toggleHighlight();
                    }
                }
                else {
                    $("#" + ic.pre + "dl_symd").html("<br>The selected residues have no detected symmetry with a Z score of " + data.zscore + " from the program <a href='https://symd.nci.nih.gov/' target='_blank'>SymD</a>.");
                    me.htmlCls.dialogCls.openDlg('dl_symd', 'Dynamically Calculated Symmetry Using SymD');
                }

                //var title = $("#" + ic.pre + "selectSymd" ).val();
                ic.symdtitle =(title === 'none') ? undefined : title;
                ic.drawCls.draw();

                /// if(ic.deferredSymd !== undefined) ic.deferredSymd.resolve();
            }
            catch(err) {
                $("#" + ic.pre + "dl_symd").html("<br>The web service can not determine the symmetry of the input set.");

                me.htmlCls.dialogCls.openDlg('dl_symd', 'Dynamically Calculated Symmetry Using SymD');

                ic.ParserUtilsCls.hideLoading();

                /// if(ic.deferredSymd !== undefined) ic.deferredSymd.resolve();
                return;
            }
        }

        getResObj(resn_resid) { let ic = this.icn3d; ic.icn3dui;
            // K $1KQ2.A:2

            let resn = resn_resid.substr(0, resn_resid.indexOf(' '));
            let pos1 = resn_resid.indexOf('$');
            let pos2 = resn_resid.indexOf('.');
            let pos3 = resn_resid.indexOf(':');

            let structure = resn_resid.substr(pos1 + 1, pos2 - pos1 - 1);
            let chain = resn_resid.substr(pos2 + 1, pos3 - pos2 - 1);
            let resi = resn_resid.substr(pos3 + 1);
            let resid = structure + '_' + chain + '_' + resi;

            let resObject = {'resn': resn, 'resid': resid, 'resi': resi, 'aligned': true};

            return resObject;
        }

        setSeqAlignForSymmetry(residArray1, residArray2, bOnechain) { let ic = this.icn3d, me = ic.icn3dui;
              //var structureArray = Object.keys(ic.structures);
              //var structure1 = structureArray[0];
              //var structure2 = structureArray[1];

              ic.conservedName1 = 'symOri_cons'; //structure1 + '_cons';
              ic.conservedName2 = 'symPerm_cons'; //structure2 + '_cons';

              ic.consHash1 = {};
              ic.consHash2 = {};

              ic.alnChainsAnTtl = {};
              ic.alnChainsAnno = {};

              ic.alnChainsSeq = {};
              ic.alnChains = {};

              ic.alnChainsSeq = {};

              let residuesHash = {};

              for(let i = 0, il = residArray1.length; i < il; ++i) { // K $1KQ2.A:2
                  let resObject1 = this.getResObj(residArray1[i]);
                  let resObject2 = this.getResObj(residArray2[i]);

                  let chainid1 = resObject1.resid.substr(0, resObject1.resid.lastIndexOf('_'));
                  let chainid2Ori = resObject2.resid.substr(0, resObject2.resid.lastIndexOf('_'));
                  let chainid2 = chainid2Ori;
                  // if one chain, separate it into two chains to show seq alignment
                  if(bOnechain) {
                      let structure = chainid2Ori.substr(0, chainid2Ori.indexOf('_'));
                      chainid2 = structure + '2' + chainid2Ori.substr(chainid2Ori.indexOf('_'));
                  }

                  residuesHash[resObject1.resid] = 1;
                  residuesHash[resObject2.resid] = 1;

                  let color;
                  if(resObject1.resn == resObject2.resn) {
                      color = "#FF0000";
                  }
                  else {
                      color = "#0000FF";
                  }
                  let color2 = '#' + ic.showAnnoCls.getColorhexFromBlosum62(resObject1.resn, resObject2.resn);

                  resObject1.color = color;
                  resObject2.color = color;

                  resObject1.color2 = color2;
                  resObject2.color2 = color2;

                  for(let j in ic.residues[resObject1.resid]) {
                      ic.atoms[j].color = me.parasCls.thr(color);
                      ic.atomPrevColors[j] = me.parasCls.thr(color);
                  }
                  for(let j in ic.residues[resObject2.resid]) {
                      ic.atoms[j].color = me.parasCls.thr(color);
                      ic.atomPrevColors[j] = me.parasCls.thr(color);
                  }

                  // annotation title for the master seq only
                  if(ic.alnChainsAnTtl[chainid1] === undefined ) ic.alnChainsAnTtl[chainid1] = [];

                  for(let j = 0; j < 3; ++j) {
                      if(ic.alnChainsAnTtl[chainid1][j] === undefined ) ic.alnChainsAnTtl[chainid1][j] = [];
                  }

                  // two annotations without titles
                  for(let j = 0; j < 3; ++j) {
                      ic.alnChainsAnTtl[chainid1][j].push("");
                  }

                  if(ic.alnChainsSeq[chainid1] === undefined) ic.alnChainsSeq[chainid1] = [];
                  if(ic.alnChainsSeq[chainid2] === undefined) ic.alnChainsSeq[chainid2] = [];

                  ic.alnChainsSeq[chainid1].push(resObject1);
                  ic.alnChainsSeq[chainid2].push(resObject2);

                  if(ic.alnChains[chainid1] === undefined) ic.alnChains[chainid1] = {};
                  if(ic.alnChains[chainid2] === undefined) ic.alnChains[chainid2] = {};
                  $.extend(ic.alnChains[chainid1], ic.residues[chainid1 + '_' + resObject1.resi] );
                  $.extend(ic.alnChains[chainid2], ic.residues[chainid2 + '_' + resObject2.resi] );

                  ic.consHash1[chainid1 + '_' + resObject1.resi] = 1;
                  ic.consHash2[chainid2 + '_' + resObject2.resi] = 1;

                  // annotation is for the master seq only
                  if(ic.alnChainsAnno[chainid1] === undefined ) ic.alnChainsAnno[chainid1] = [];
                  //if(ic.alnChainsAnno[chainid2] === undefined ) ic.alnChainsAnno[chainid2] = [];

                  for(let j = 0; j < 3; ++j) {
                      if(ic.alnChainsAnno[chainid1][j] === undefined ) ic.alnChainsAnno[chainid1][j] = [];
                  }

                  let symbol = '.';
                  if(i % 5 === 0) symbol = '*';
                  if(i % 10 === 0) symbol = '|';
                  ic.alnChainsAnno[chainid1][0].push(symbol); // symbol: | for 10th, * for 5th, . for rest

                  let numberStr = '';
                  if(i % 10 === 0) numberStr = i.toString();
                  ic.alnChainsAnno[chainid1][1].push(numberStr); // symbol: 10, 20, etc, empty for rest
              }

        /*
                let commandname = 'symBoth_aligned'; //'protein_aligned';
                let commanddescr = 'symBoth aligned'; //'protein aligned';
                let select = "select " + ic.resid2specCls.residueids2spec(Object.keys(residuesHash));

                ic.selectionCls.addCustomSelection(Object.keys(residuesHash), commandname, commanddescr, select, true);
        */
        }

        async retrieveSymmetry(pdbid) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass =this;
            
            let data;
            let url = "https://data.rcsb.org/rest/v1/core/assembly/" + pdbid + "/1";
            try {
                data = await me.getAjaxPromise(url, 'json', false);
            }
            catch(err) {
                $("#" + ic.pre + "dl_symmetry").html("<br>This structure has no symmetry.");

                me.htmlCls.dialogCls.openDlg('dl_symmetry', 'Symmetry');

                /// if(ic.deferredSymmetry !== undefined) ic.deferredSymmetry.resolve();
                return;
            }

            let symmetryArray = data.rcsb_struct_symmetry;
            let rot, centerFrom, centerTo;

            if(symmetryArray !== undefined) {
                if(ic.rmsd_supr !== undefined && ic.rmsd_supr.rot !== undefined) {
                    rot = ic.rmsd_supr.rot;
                    centerFrom = ic.rmsd_supr.trans1;
                    centerTo = ic.rmsd_supr.trans2;
                }

                ic.symmetryHash = {};
                for(let i = 0, il = symmetryArray.length; i < il; ++i) {
                    if(symmetryArray[i].symbol == 'C1') continue;
                    let title = 'no title';
                    if(symmetryArray[i].kind == "Pseudo Symmetry") {
                        title = symmetryArray[i].symbol + ' (pseudo)';
                    }
                    else if(symmetryArray[i].kind == "Global Symmetry") {
                        title = symmetryArray[i].symbol + ' (global)';
                    }
                    else if(symmetryArray[i].kind == "Local Symmetry") {
                        title = symmetryArray[i].symbol + ' (local)';
                    }

                    let rotation_axes = symmetryArray[i].rotation_axes;
                    let axesArray = [];
                    for(let j = 0, jl = rotation_axes.length; j < jl; ++j) {
                        let tmpArray = [];
                        let start = new THREE.Vector3(rotation_axes[j].start[0], rotation_axes[j].start[1], rotation_axes[j].start[2]);
                        let end = new THREE.Vector3(rotation_axes[j].end[0], rotation_axes[j].end[1], rotation_axes[j].end[2]);

                        // apply matrix for each atom
                        if(ic.rmsd_supr !== undefined && ic.rmsd_supr.rot !== undefined) {
                            start = ic.surfaceCls.transformMemPro(start, rot, centerFrom, centerTo);
                            end = ic.surfaceCls.transformMemPro(end, rot, centerFrom, centerTo);
                        }

                        tmpArray.push(start);
                        tmpArray.push(end);

                        // https://www.rcsb.org/pages/help/viewers/jmol_symmetry_view
                        let colorAxis = thisClass.getAxisColor(symmetryArray[i].symbol, rotation_axes[j].order);
                        let colorPolygon = thisClass.getPolygonColor(symmetryArray[i].symbol);
                        tmpArray.push(colorAxis);
                        tmpArray.push(colorPolygon);

                        tmpArray.push(rotation_axes[j].order);

                        // selected chain
                        tmpArray.push(symmetryArray[i].clusters[0].members[0].asym_id);

                        axesArray.push(tmpArray);
                    }

                    ic.symmetryHash[title] = axesArray;
                }

                if(Object.keys(ic.symmetryHash).length == 0) {
                    $("#" + ic.pre + "dl_symmetry").html("<br>This structure has no symmetry.");
                }
                else {
                    let html = "<option value='none'>None</option>", index = 0;
                    for(let title in ic.symmetryHash) {
                        let selected =(index == 0) ? 'selected' : '';
                        html += "<option value=" + "'" + title + "' " + selected + ">" + title + "</option>";
                        ++index;
                    }

                    $("#" + ic.pre + "selectSymmetry").html(html);
                }
            }
            else {
                $("#" + ic.pre + "dl_symmetry").html("<br>This structure has no symmetry.");
            }

            me.htmlCls.dialogCls.openDlg('dl_symmetry', 'Symmetry');

            /// if(ic.deferredSymmetry !== undefined) ic.deferredSymmetry.resolve();
        }

        getPolygonColor(symbol) { let ic = this.icn3d, me = ic.icn3dui;
            let type = symbol.substr(0, 1);

            //https://www.rcsb.org/pages/help/viewers/jmol_symmetry_view
            if(type == 'C') { // Cyclic Cn
                return me.parasCls.thr(0xFF8C00); // dark orange
            }
            else if(type == 'D') { // Dihedral Dn
                return me.parasCls.thr(0x00FFFF); // cyan
            }
            else if(type == 'T') { // Tetrahedral T
                return me.parasCls.thr(0xEE82EE); //0x800080); // purple
            }
            else if(type == 'O') { // Octahedral O
                return me.parasCls.thr(0xFFA500); // orange
            }
            else if(type == 'I') { // Icosahedral I
                return me.parasCls.thr(0x00FF00); // green
            }
            else { // Helical H, etc
                return me.parasCls.thr(0xA9A9A9); // dark grey
            }
        }

        getAxisColor(symbol, order) { let ic = this.icn3d, me = ic.icn3dui;
            let type = symbol.substr(0, 1);

            //https://www.rcsb.org/pages/help/viewers/jmol_symmetry_view
            if(type == 'C') { // Cyclic Cn
                return me.parasCls.thr(0xFF0000); // red
            }
            else if(type == 'D') { // Dihedral Dn
                if(order == 2) {
                    return me.parasCls.thr(0x00FFFF); // cyan
                }
                else {
                    return me.parasCls.thr(0xFF0000); // red
                }
            }
            else if(type == 'T') { // Tetrahedral T
                if(order == 2) {
                    return me.parasCls.thr(0x00FFFF); // cyan
                }
                else {
                    return me.parasCls.thr(0x00FF00); // green
                }
            }
            else if(type == 'O') { // Octahedral O
                if(order == 2) {
                    return me.parasCls.thr(0x00FFFF); // cyan
                }
                else if(order == 3) {
                    return me.parasCls.thr(0x00FF00); // green
                }
                else {
                    return me.parasCls.thr(0xFF0000); // red
                }
            }
            else if(type == 'I') { // Icosahedral I
                if(order == 2) {
                    return me.parasCls.thr(0x00FFFF); // cyan
                }
                else if(order == 3) {
                    return me.parasCls.thr(0x00FF00); // green
                }
                else {
                    return me.parasCls.thr(0xFF0000); // red
                }
            }
            else { // Helical H, etc
                return me.parasCls.thr(0xFF0000); // red
            }
        }
    }

    /**
     * @author Jack Lin, modified from https://github.com/lh3/bioseq-js/blob/master/bioseq.js
     */

    class AlignSW {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        alignSW(target, query, match_score, mismatch, gap, extension, is_local) { let ic = this.icn3d; ic.icn3dui;
            //let time_start = new Date().getTime();

            let rst = this.bsa_align(is_local, target, query, [match_score, mismatch], [gap, extension]);
            let str = 'score: ' + rst[0] + '\n';
            str += 'start: ' + rst[1] + '\n';
            str += 'cigar: ' + this.bsa_cigar2str(rst[2]) + '\n\n';
            str += 'alignment:\n\n';
            let fmt = this.bsa_cigar2gaps(target, query, rst[1], rst[2]);

            let algn = {};
            algn.score = rst[0];
            algn.start = rst[1];
            algn.cigar = this.bsa_cigar2str(rst[2]);
            algn.target = fmt[0];
            algn.query = fmt[1];

            return algn;
        }

        /**
         * Encode a sequence string with table
         *
         * @param seq    sequence
         * @param table  encoding table; must be of size 256
         *
         * @return an integer array
         */

        bsg_enc_seq(seq, table) { let ic = this.icn3d; ic.icn3dui;
            if (table == null) return null;
            let s = [];
            s.length = seq.length;
            for (let i = 0; i < seq.length; ++i)
                s[i] = table[seq.charCodeAt(i)];
            return s;
        }

        /**************************
         *** Pairwise alignment ***
            **************************/

        /*
            * The following implements local and global pairwise alignment with affine gap
            * penalties. There are two formulations: the Durbin formulation as is
            * described in his book and the Green formulation as is implemented in phrap.
            * The Durbin formulation is easier to understand, while the Green formulation
            * is simpler to code and probably faster in practice.
            *
            * The Durbin formulation is:
            *
            *   M(i,j) = max{M(i-1,j-1)+S(i,j), E(i-1,j-1), F(i-1,j-1)}
            *   E(i,j) = max{M(i-1,j)-q-r, F(i-1,j)-q-r, E(i-1,j)-r}
            *   F(i,j) = max{M(i,j-1)-q-r, F(i,j-1)-r, E(i,j-1)-q-r}
            *
            * where q is the gap open penalty, r the gap extension penalty and S(i,j) is
            * the score between the i-th residue in the row sequence and the j-th residue
            * in the column sequence. Note that the original Durbin formulation disallows
            * transitions between between E and F states, but we allow them here.
            *
            * In the Green formulation, we introduce:
            *
            *   H(i,j) = max{M(i,j), E(i,j), F(i,j)}
            *
            * The recursion becomes:
            *
            *   H(i,j) = max{H(i-1,j-1)+S(i,j), E(i,j), F(i,j)}
            *   E(i,j) = max{H(i-1,j)-q, E(i-1,j)} - r
            *   F(i,j) = max{H(i,j-1)-q, F(i,j-1)} - r
            *
            * It is in fact equivalent to the Durbin formulation. In implementation, we
            * calculate the scores in a different order:
            *
            *   H(i,j)   = max{H(i-1,j-1)+S(i,j), E(i,j), F(i,j)}
            *   E(i+1,j) = max{H(i,j)-q, E(i,j)} - r
            *   F(i,j+1) = max{H(i,j)-q, F(i,j)} - r
            *
            * i.e. at cell (i,j), we compute E for the next row and F for the next column.
            * Please see inline comments below for details.
            *
            *
            * The following implementation is ported from klib/ksw.c. The original C
            * implementation has a few bugs which have been fixed here. Like the C
            * version, this implementation should be very efficient. It could be made more
            * efficient if we use typed integer arrays such as Uint8Array. In addition,
            * I mixed the local and global alignments together. For performance,
            * it would be preferred to separate them out.
            */

        /**
         * Generate scoring matrix from match/mismatch score
         *
         * @param n     size of the alphabet
         * @param a     match score, positive
         * @param b     mismatch score, negative
         *
         * @return square scoring matrix. The last row and column are zero, for
         * matching an ambiguous residue.
         */
        bsa_gen_score_matrix(n, a, b) { let ic = this.icn3d; ic.icn3dui;
            let m = [];
            if (b > 0) b = -b; // mismatch score b should be non-positive
            let i, j;
            for (i = 0; i < n - 1; ++i) {
                m[i] = [];
                for (j = 0; j < n - 1; ++j)
                    m[i][j] = i == j ? a : b;
                m[i][j] = 0;
            }
            m[n - 1] = [];
            for (let j = 0; j < n; ++j) m[n - 1][j] = 0;
            return m;
        }

        /**
         * Generate query profile (a preprocessing step)
         *
         * @param _s      sequence in string or post bsg_enc_seq()
         * @param _m      score matrix or [match,mismatch] array
         * @param table   encoding table; must be consistent with _s and _m
         *
         * @return query profile. It is a two-dimensional integer matrix.
         */
        bsa_gen_query_profile(_s, _m, table) { let ic = this.icn3d; ic.icn3dui;
            let s = typeof _s == 'string' ? this.bsg_enc_seq(_s, table) : _s;
            let qp = [],
                matrix;
            if (_m.length >= 2 && typeof _m[0] == 'number' && typeof _m[1] == 'number') { // match/mismatch score
                if (table == null) return null;
                let n = typeof table == 'number' ? table : table[table.length - 1] + 1;
                matrix = this.bsa_gen_score_matrix(n, _m[0], _m[1]);
            } else matrix = _m; // _m is already a matrix; FIXME: check if it is really a square matrix!
            for (let j = 0; j < matrix.length; ++j) {
                let qpj, mj = matrix[j];
                qpj = qp[j] = [];
                for (let i = 0; i < s.length; ++i)
                    qpj[i] = mj[s[i]];
            }
            return qp;
        }

        /**
         * Local or global pairwise alignment
         *
         * @param is_local  perform local alignment
         * @param target    target string
         * @param query     query string or query profile
         * @param matrix    square score matrix or [match,mismatch] array
         * @param gapsc     [gap_open,gap_ext] array; k-length gap costs gap_open+gap_ext*k
         * @param w         bandwidth, disabled by default
         * @param table     encoding table. It defaults to bst_nt5.
         *
         * @return [score,target_start,cigar]. cigar is encoded in the BAM way, where
         * higher 28 bits keeps the length and lower 4 bits the operation in order of
         * "MIDNSH". See bsa_cigar2str() for converting cigar to string.
         */
        bsa_align(is_local, target, query, matrix, gapsc, w, table) { let ic = this.icn3d; ic.icn3dui;
            let bst_nt5 = [
                4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                4, 0, 4, 1, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4,
                4, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                4, 0, 4, 1, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4,
                4, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,

                4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
            ];

            // convert bases to integers
            if (table == null) table = bst_nt5;
            let t = this.bsg_enc_seq(target, table);
            let qp = this.bsa_gen_query_profile(query, matrix, table);
            let qlen = qp[0].length;

            // adjust band width
            let max_len = qlen > t.length ? qlen : t.length;
            w = w == null || w < 0 ? max_len : w;
            let len_diff = t.target > qlen ? t.target - qlen : qlen - t.target;
            w = w > len_diff ? w : len_diff;

            // set gap score
            let gapo, gape; // these are penalties which should be non-negative
            if (typeof gapsc == 'number') gapo = 0, gape = gapsc > 0 ? gapsc : -gapsc;
            else gapo = gapsc[0] > 0 ? gapsc[0] : -gapsc[0], gape = gapsc[1] > 0 ? gapsc[1] : -gapsc[1];
            let gapoe = gapo + gape; // penalty for opening the first gap

            // initial values
            let NEG_INF = -0x40000000;
            let H = [],
                E = [],
                z = [],
                score, max = 0,
                end_i = -1,
                end_j = -1;
            if (is_local) {
                for (let j = 0; j <= qlen; ++j) H[j] = E[j] = 0;
            } else {
                H[0] = 0;
                E[0] = -gapoe - gapoe;
                for (let j = 1; j <= qlen; ++j) {
                    if (j >= w) H[j] = E[j] = NEG_INF; // everything is -inf outside the band
                    else H[j] = -(gapoe + gape * (j - 1)), E[j] = -(gapoe + gapoe + gape * j);
                }
            }

            // the DP loop
            for (let i = 0; i < t.length; ++i) {
                let h1 = 0,
                    f = 0,
                    m = 0,
                    mj = -1;
                let zi, qpi = qp[t[i]];
                zi = z[i] = [];
                let beg = i > w ? i - w : 0;
                let end = i + w + 1 < qlen ? i + w + 1 : qlen; // only loop through [beg,end) of the query sequence
                if (!is_local) {
                    h1 = beg > 0 ? NEG_INF : -(gapoe + gape * i);
                    f = beg > 0 ? NEG_INF : -(gapoe + gapoe + gape * i);
                }
                for (let j = beg; j < end; ++j) {
                    // At the beginning of the loop: h=H[j]=H(i-1,j-1), e=E[j]=E(i,j), f=F(i,j) and h1=H(i,j-1)
                    // If we only want to compute the max score, delete all lines involving direction "d".
                    let e = E[j],
                        h = H[j],
                        d;
                    H[j] = h1; // set H(i,j-1) for the next row
                    h += qpi[j]; // h = H(i-1,j-1) + S(i,j)
                    d = h >= e ? 0 : 1;
                    h = h >= e ? h : e;
                    d = h >= f ? d : 2;
                    h = h >= f ? h : f; // h = H(i,j) = max{H(i-1,j-1)+S(i,j), E(i,j), F(i,j)}
                    d = !is_local || h > 0 ? d : 1 << 6;
                    h1 = h; // save H(i,j) to h1 for the next column
                    mj = m > h ? mj : j;
                    m = m > h ? m : h; // update the max score in this row
                    h -= gapoe;
                    h = !is_local || h > 0 ? h : 0;
                    e -= gape;
                    d |= e > h ? 1 << 2 : 0;
                    e = e > h ? e : h; // e = E(i+1,j)
                    E[j] = e; // save E(i+1,j) for the next row
                    f -= gape;
                    d |= f > h ? 2 << 4 : 0;
                    f = f > h ? f : h; // f = F(i,j+1)
                    zi[j] = d; // z[i,j] keeps h for the current cell and e/f for the next cell
                }
                H[end] = h1, E[end] = is_local ? 0 : NEG_INF;
                if (m > max) max = m, end_i = i, end_j = mj;
            }
            if (is_local && max == 0) return null;
            score = is_local ? max : H[qlen];

            let cigar = [],
                tmp, which = 0,
                i, k, start_i = 0;
            if (is_local) {
                i = end_i, k = end_j;
                if (end_j != qlen - 1) // then add soft clipping
                    this.push_cigar(cigar, 4, qlen - 1 - end_j);
            } else i = t.length - 1, k = (i + w + 1 < qlen ? i + w + 1 : qlen) - 1; // (i,k) points to the last cell
            while (i >= 0 && k >= 0) {
                tmp = z[i][k - (i > w ? i - w : 0)];
                which = tmp >> (which << 1) & 3;
                if (which == 0 && tmp >> 6) break;
                if (which == 0) which = tmp & 3;
                if (which == 0) { this.push_cigar(cigar, 0, 1);--i, --k; } // match
                else if (which == 1) { this.push_cigar(cigar, 2, 1);--i; } // deletion
                else { this.push_cigar(cigar, 1, 1), --k; } // insertion
            }
            if (is_local) {
                if (k >= 0) this.push_cigar(cigar, 4, k + 1); // add soft clipping
                start_i = i + 1;
            } else { // add the first insertion or deletion
                if (i >= 0) this.push_cigar(cigar, 2, i + 1);
                if (k >= 0) this.push_cigar(cigar, 1, k + 1);
            }
            for (let i = 0; i < cigar.length >> 1; ++i) // reverse CIGAR
                tmp = cigar[i], cigar[i] = cigar[cigar.length - 1 - i], cigar[cigar.length - 1 - i] = tmp;
            return [score, start_i, cigar];
        }

        // backtrack to recover the alignment/cigar
        push_cigar(ci, op, len) { let ic = this.icn3d; ic.icn3dui;
            if (ci.length == 0 || op != (ci[ci.length - 1] & 0xf))
                ci.push(len << 4 | op);
            else ci[ci.length - 1] += len << 4;
        }

        bsa_cigar2gaps(target, query, start, cigar) { let ic = this.icn3d; ic.icn3dui;
            let oq = '',
                ot = '',
                mid = '',
                lq = 0,
                lt = start;
            for (let k = 0; k < cigar.length; ++k) {
                let op = cigar[k] & 0xf,
                    len = cigar[k] >> 4;
                if (op == 0) { // match
                    oq += query.substr(lq, len);
                    ot += target.substr(lt, len);
                    lq += len, lt += len;
                } else if (op == 1) { // insertion
                    oq += query.substr(lq, len);
                    ot += Array(len + 1).join("-");
                    lq += len;
                } else if (op == 2) { // deletion
                    oq += Array(len + 1).join("-");
                    ot += target.substr(lt, len);
                    lt += len;
                } else if (op == 4) { // soft clip
                    lq += len;
                }
            }
            let ut = ot.toUpperCase();
            let uq = oq.toUpperCase();
            for (let k = 0; k < ut.length; ++k)
                mid += ut.charAt(k) == uq.charAt(k) ? '|' : ' ';
            return [ot, oq, mid];
        }

        bsa_cigar2str(cigar) { let ic = this.icn3d; ic.icn3dui;
            let s = [];
            for (let k = 0; k < cigar.length; ++k)
                s.push((cigar[k] >> 4).toString() + "MIDNSHP=XB".charAt(cigar[k] & 0xf));
            return s.join("");
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Analysis {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        calculateArea() {var ic = this.icn3d, me = ic.icn3dui;
           ic.bCalcArea = true;
           ic.opts.surface = 'solvent accessible surface';
           ic.applyMapCls.applySurfaceOptions();
           $("#" + ic.pre + "areavalue").val(ic.areavalue);
           $("#" + ic.pre + "areatable").html(ic.areahtml);
           me.htmlCls.dialogCls.openDlg('dl_area', 'Surface area calculation');
           ic.bCalcArea = false;
        }

        calcBuriedSurface(nameArray2, nameArray) {var ic = this.icn3d, me = ic.icn3dui;
           if(nameArray2.length == 0) {
               alert("Please select the first set");
           }
           else {
               let prevHAtoms = me.hashUtilsCls.cloneHash(ic.hAtoms);
               let atomSet2 = ic.definedSetsCls.getAtomsFromNameArray(nameArray2);
               let atomSet1 = ic.definedSetsCls.getAtomsFromNameArray(nameArray);
               ic.bCalcArea = true;
               ic.opts.surface = 'solvent accessible surface';
               ic.hAtoms = me.hashUtilsCls.cloneHash(atomSet2);
               ic.applyMapCls.applySurfaceOptions();
               let area2 = ic.areavalue;
               let resid2area2 = me.hashUtilsCls.cloneHash(ic.resid2area);
               ic.hAtoms = me.hashUtilsCls.cloneHash(atomSet1);
               ic.applyMapCls.applySurfaceOptions();
               let area1 = ic.areavalue;
               let resid2area1 = me.hashUtilsCls.cloneHash(ic.resid2area);

               ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, atomSet2);
               ic.applyMapCls.applySurfaceOptions();
               let areaTotal = ic.areavalue;
               let resid2areaTotal = me.hashUtilsCls.cloneHash(ic.resid2area);

               let buriedArea1 = 0, buriedArea2 = 0;
               let areaSum1 = 0, areaSum2 = 0;
               // set 1 buried
               for(let resid in resid2area2) {
                   if(resid2areaTotal.hasOwnProperty(resid)) {
                       areaSum2 += parseFloat(resid2areaTotal[resid]);
                   }
               }
               buriedArea2 = (area2 - areaSum2).toFixed(2);

               // set 2 buried
               for(let resid in resid2area1) {
                   if(resid2areaTotal.hasOwnProperty(resid)) {
                       areaSum1 += parseFloat(resid2areaTotal[resid]);
                   }
               }
               buriedArea1 = (area1 - areaSum1).toFixed(2);

               ic.bCalcArea = false;
               ic.hAtoms = me.hashUtilsCls.cloneHash(prevHAtoms);
               let buriedArea =(parseFloat(area1) + parseFloat(area2) - parseFloat(areaTotal)).toFixed(2);
               let html = '<br>Calculate solvent accessible surface area in the interface:<br><br>';
               html += 'Set 1: ' + nameArray2 + ', Surface: ' +  area2 + ' &#8491;<sup>2</sup><br>';
               html += 'Set 2: ' + nameArray + ', Surface: ' +  area1 + ' &#8491;<sup>2</sup><br>';
               html += 'Total Surface: ' +  areaTotal + ' &#8491;<sup>2</sup><br>';
               //html += '<b>Buried Surface for both Sets</b>: ' +  buriedArea + ' &#8491;<sup>2</sup><br>';
               html += '<b>Buried Surface for Set 1</b>: ' +  buriedArea2 + ' &#8491;<sup>2</sup><br>';
               html += '<b>Buried Surface for Set 2</b>: ' +  buriedArea1 + ' &#8491;<sup>2</sup><br><br>';
               $("#" + ic.pre + "dl_buriedarea_html").html(html);
               me.htmlCls.dialogCls.openDlg('dl_buriedarea', 'Buried solvent accessible surface area in the interface');
               me.htmlCls.clickMenuCls.setLogCmd('buried surface ' + buriedArea, false);
           }
        }

        measureDistTwoSets(nameArray, nameArray2) {var ic = this.icn3d, me = ic.icn3dui;
           if(nameArray.length == 0 || nameArray2.length == 0) {
               alert("Please select two sets");
           }
           else {
               let prevHAtoms = me.hashUtilsCls.cloneHash(ic.hAtoms);
               let atomSet1 = ic.definedSetsCls.getAtomsFromNameArray(nameArray);
               let atomSet2 = ic.definedSetsCls.getAtomsFromNameArray(nameArray2);

               let posArray1 = ic.contactCls.getExtent(atomSet1);
               let posArray2 = ic.contactCls.getExtent(atomSet2);

               let pos1 = new THREE.Vector3(posArray1[2][0], posArray1[2][1], posArray1[2][2]);
               let pos2 = new THREE.Vector3(posArray2[2][0], posArray2[2][1], posArray2[2][2]);

               ic.hAtoms = me.hashUtilsCls.cloneHash(prevHAtoms);

               if(ic.distPnts === undefined) ic.distPnts = [];
               ic.distPnts.push(pos1);
               ic.distPnts.push(pos2);

               let color = $("#" + ic.pre + "distancecolor2" ).val();

               this.addLine(pos1.x, pos1.y, pos1.z, pos2.x, pos2.y, pos2.z, color, true, 'distance');

               let size = 0, background = 0;
               let labelPos = pos1.clone().add(pos2).multiplyScalar(0.5);
               let distance = parseInt(pos1.distanceTo(pos2) * 10) / 10;
               let text = distance.toString() + " A";
               this.addLabel(text, labelPos.x, labelPos.y, labelPos.z, size, color, background, 'distance');
               ic.drawCls.draw();
           }
        }

        measureDistManySets(nameArray, nameArray2) {var ic = this.icn3d, me = ic.icn3dui;
            if(nameArray.length == 0 || nameArray2.length == 0) {
                alert("Please select sets for distance calculation...");
            }
            else {

                let prevHAtoms = me.hashUtilsCls.cloneHash(ic.hAtoms);

                let distHash = {};

                for(let i = 0, il = nameArray.length; i < il; ++i) {
                    let set1 = nameArray[i];
                    let array1 = [set1];
                    distHash[set1] = {};

                    for(let j = 0, jl = nameArray2.length; j < jl; ++j) {
                        let set2 = nameArray2[j];
                        let array2 = [set2];

                        if(set1 == set2) continue;

                        let atomSet1 = ic.definedSetsCls.getAtomsFromNameArray(array1);
                        let atomSet2 = ic.definedSetsCls.getAtomsFromNameArray(array2);

                        let posArray1 = ic.contactCls.getExtent(atomSet1);
                        let posArray2 = ic.contactCls.getExtent(atomSet2);
            
                        let pos1 = new THREE.Vector3(posArray1[2][0], posArray1[2][1], posArray1[2][2]);
                        let pos2 = new THREE.Vector3(posArray2[2][0], posArray2[2][1], posArray2[2][2]);
            
                        let distance = pos1.distanceTo(pos2);

                        distHash[set1][set2] = distance.toFixed(2);
                    }
                }

                ic.hAtoms = me.hashUtilsCls.cloneHash(prevHAtoms);

                let tableHtml = 'Note: Click on the distance to show a dashed line in 3D view.<br><br>';
                tableHtml += '<table align=center border=1 cellpadding=10 cellspacing=0><tr><th></th>';
                for(let j = 0, jl = nameArray2.length; j < jl; ++j) {
                    let set2 = nameArray2[j];
                    tableHtml += '<th><b>' + set2 + '</b> (&#8491;)</th>';
                }
                tableHtml += '</tr>';

                for(let i = 0, il = nameArray.length; i < il; ++i) {
                    let set1 = nameArray[i];
                    tableHtml += '<tr><th><b>' + set1 + '</b> (&#8491;)</th>';

                    for(let j = 0, jl = nameArray2.length; j < jl; ++j) {
                        let set2 = nameArray2[j];

                        if(distHash[set1] && distHash[set1][set2]) {
                            tableHtml += '<td><span class="icn3d-distance" sets="' + set1 + '|' + set2 + '">' + distHash[set1][set2] + '</span></td>';
                        }
                        else {
                            tableHtml += '<td>0</td>';
                        }
                    }

                    tableHtml += '</tr>';
                }

                tableHtml += '</table><br><br>';

                $("#" + me.pre + "dl_disttable_html").html(tableHtml);
            }
        }

        measureAngleManySets(nameArray, nameArray2) {var ic = this.icn3d, me = ic.icn3dui;
            if(nameArray.length == 0 || nameArray2.length == 0) {
                alert("Please select sets for angleance calculation...");
            }
            else {
                let angleHash = {};

                for(let i = 0, il = nameArray.length; i < il; ++i) {
                    let set1 = nameArray[i];
                    let array1 = [set1];
                    angleHash[set1] = {};

                    ic.hAtoms = ic.definedSetsCls.getAtomsFromNameArray(array1);
                    let axis1 = ic.axesCls.setPc1Axes(true);

                    for(let j = 0, jl = nameArray2.length; j < jl; ++j) {
                        let set2 = nameArray2[j];
                        let array2 = [set2];

                        if(set1 == set2) continue;

                        ic.hAtoms = ic.definedSetsCls.getAtomsFromNameArray(array2);
                        let axis2 = ic.axesCls.setPc1Axes(true);

                        let angleRad = new THREE.Vector3(parseFloat(axis1.x), parseFloat(axis1.y), parseFloat(axis1.z)).angleTo(new THREE.Vector3(parseFloat(axis2.x), parseFloat(axis2.y), parseFloat(axis2.z)));
                        
                        let angle = angleRad / 3.1416 * 180;
                        angle = Math.abs(angle).toFixed(0);
                        if(angle > 180) angle -= 180;
                        if(angle > 90) angle = 180 - angle;

                        angleHash[set1][set2] = angle;
                    }
                }

                let tableHtml = '<table align=center border=1 cellpadding=10 cellspacing=0><tr><th></th>';
                for(let j = 0, jl = nameArray2.length; j < jl; ++j) {
                    let set2 = nameArray2[j];
                    tableHtml += '<th><b>' + set2 + '</b> (&deg;)</th>';
                }
                tableHtml += '</tr>';

                for(let i = 0, il = nameArray.length; i < il; ++i) {
                    let set1 = nameArray[i];
                    tableHtml += '<tr><th><b>' + set1 + '</b> (&deg;)</th>';

                    for(let j = 0, jl = nameArray2.length; j < jl; ++j) {
                        let set2 = nameArray2[j];

                        if(angleHash[set1] && angleHash[set1][set2]) {
                            tableHtml += '<td><span>' + angleHash[set1][set2] + '</span></td>';
                        }
                        else {
                            tableHtml += '<td>0</td>';
                        }
                    }

                    tableHtml += '</tr>';
                }

                tableHtml += '</table><br><br>';

                $("#" + me.pre + "dl_angletable_html").html(tableHtml);
            }
        }

        //Add a line between the position (x1, y1, z1) and the position (x2, y2, z2) with the input "color".
        //The line can be dashed if "dashed" is set true.
        addLine(x1, y1, z1, x2, y2, z2, color, dashed, type, radius, opacity) {var ic = this.icn3d; ic.icn3dui;
            let line = {}; // Each line contains 'position1', 'position2', 'color', and a boolean of 'dashed'
            line.position1 = new THREE.Vector3(x1, y1, z1);
            line.position2 = new THREE.Vector3(x2, y2, z2);
            line.color = color;
            line.dashed = dashed;
            line.radius = radius;
            line.opacity = opacity;
            if(ic.lines[type] === undefined) ic.lines[type] = [];
            if(type !== undefined) {
                ic.lines[type].push(line);
            }
            else {
                if(ic.lines['custom'] === undefined) ic.lines['custom'] = [];
                ic.lines['custom'].push(line);
            }
            ic.hlObjectsCls.removeHlObjects();
            //ic.drawCls.draw();
        }

        addLineFromPicking(type) {var ic = this.icn3d, me = ic.icn3dui;
            let color = $("#" + ic.pre + type + "color" ).val();
            (ic.pAtom.coord.x + ic.pAtom2.coord.x) / 2;
            (ic.pAtom.coord.y + ic.pAtom2.coord.y) / 2;
            (ic.pAtom.coord.z + ic.pAtom2.coord.z) / 2;
            let dashed =(type == 'stabilizer') ? false : true;
            me.htmlCls.clickMenuCls.setLogCmd('add line | x1 ' + ic.pAtom.coord.x.toPrecision(4)  + ' y1 ' + ic.pAtom.coord.y.toPrecision(4) + ' z1 ' + ic.pAtom.coord.z.toPrecision(4) + ' | x2 ' + ic.pAtom2.coord.x.toPrecision(4)  + ' y2 ' + ic.pAtom2.coord.y.toPrecision(4) + ' z2 ' + ic.pAtom2.coord.z.toPrecision(4) + ' | color ' + color + ' | dashed ' + dashed + ' | type ' + type, true);
            this.addLine(ic.pAtom.coord.x, ic.pAtom.coord.y, ic.pAtom.coord.z, ic.pAtom2.coord.x, ic.pAtom2.coord.y, ic.pAtom2.coord.z, color, dashed, type);
            ic.pickpair = false;
        }

        //Add a "text" at the position (x, y, z) with the input "size", "color", and "background".
        addLabel(text, x, y, z, size, color, background, type) {var ic = this.icn3d; ic.icn3dui;
            let label = {}; // Each label contains 'position', 'text', 'color', 'background'

            if(size === '0' || size === '' || size === 'undefined') size = undefined;
            if(color === '0' || color === '' || color === 'undefined') color = undefined;
            if(background === '0' || background === '' || background === 'undefined') background = undefined;

            let position = new THREE.Vector3();
            position.x = x;
            position.y = y;
            position.z = z;

            label.position = position;

            label.text = text;
            label.size = size;
            label.color = color;
            label.background = background;

            if(ic.labels[type] === undefined) ic.labels[type] = [];

            if(type !== undefined) {
                ic.labels[type].push(label);
            }
            else {
                if(ic.labels['custom'] === undefined) ic.labels['custom'] = [];
                ic.labels['custom'].push(label);
            }

            ic.hlObjectsCls.removeHlObjects();

            //ic.drawCls.draw();
        }

        //Display chain name in the 3D structure display for the chains intersecting with the atoms in "atomHash".
        addChainLabels(atoms) {var ic = this.icn3d, me = ic.icn3dui;
            let size = 18;
            let background = "#FFFFFF"; //"#CCCCCC";
            let atomsHash = me.hashUtilsCls.intHash(ic.hAtoms, atoms);
            if(ic.labels['chain'] === undefined) ic.labels['chain'] = [];
            let chainHash = ic.firstAtomObjCls.getChainsFromAtoms(atomsHash);
            for(let chainid in chainHash) {
                let label = {};
                label.position = ic.applyCenterCls.centerAtoms(ic.chains[chainid]).center;
                let pos = chainid.indexOf('_');
                let chainName = chainid.substr(pos + 1);
                let proteinName = ic.showSeqCls.getProteinName(chainid);
                if(proteinName.length > 20) proteinName = proteinName.substr(0, 20) + '...';
                label.text = 'Chain ' + chainName + ': ' + proteinName;
                label.size = size;
                ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.chains[chainid]).color.getHexString().toUpperCase();
                label.color = (ic.opts.background != 'black') ? ic.colorWhitebkgd : ic.colorBlackbkgd; //(atomColorStr === "CCCCCC" || atomColorStr === "C8C8C8") ? "#888888" : "#" + atomColorStr;
                label.background = background;
                ic.labels['chain'].push(label);
            }
            ic.hlObjectsCls.removeHlObjects();
        }
        //Display the terminal labels for the atoms in "atomHash". The termini of proteins are labelled
        //as "N-" and "C-". The termini of nucleotides are labeled as "5'" and "3'".
        addTerminiLabels(atoms) {var ic = this.icn3d, me = ic.icn3dui;
            let size = 18;
            let background = "#FFFFFF"; //"#CCCCCC";
            let protNucl;
            protNucl = me.hashUtilsCls.unionHash(protNucl, ic.proteins);
            protNucl = me.hashUtilsCls.unionHash(protNucl, ic.nucleotides);
            let hlProtNucl = me.hashUtilsCls.intHash(ic.dAtoms, protNucl);
            let atomsHash = me.hashUtilsCls.intHash(hlProtNucl, atoms);
            if(ic.labels['chain'] === undefined) ic.labels['chain'] = [];
            let chainHash = ic.firstAtomObjCls.getChainsFromAtoms(atomsHash);
            for(let chainid in chainHash) {
                let chainAtomsHash = me.hashUtilsCls.intHash(hlProtNucl, ic.chains[chainid]);
                let serialArray = Object.keys(chainAtomsHash);
                let firstAtom = ic.atoms[serialArray[0]];
                let lastAtom = ic.atoms[serialArray[serialArray.length - 1]];
                let labelN = {}, labelC = {};
                labelN.position = firstAtom.coord;
                labelC.position = lastAtom.coord;
                labelN.text = 'N-';
                labelC.text = 'C-';
                if(ic.nucleotides.hasOwnProperty(firstAtom.serial)) {
                    labelN.text = "5'";
                    labelC.text = "3'";
                }
                labelN.size = size;
                labelC.size = size;
                firstAtom.color.getHexString().toUpperCase();
                lastAtom.color.getHexString().toUpperCase();
                labelN.color = (ic.opts.background != 'black') ? ic.colorWhitebkgd : ic.colorBlackbkgd; //(atomNColorStr === "CCCCCC" || atomNColorStr === "C8C8C8") ? "#888888" : "#" + atomNColorStr;
                labelC.color = (ic.opts.background != 'black') ? ic.colorWhitebkgd : ic.colorBlackbkgd; //(atomCColorStr === "CCCCCC" || atomCColorStr === "C8C8C8") ? "#888888" : "#" + atomCColorStr;
                labelN.background = background;
                labelC.background = background;
                ic.labels['chain'].push(labelN);
                ic.labels['chain'].push(labelC);
            }
            ic.hlObjectsCls.removeHlObjects();
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Diagram2d {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        // draw 2D dgm for MMDB ID
        // Used as a reference the work at 2016 ISMB hackathon: https://github.com/NCBI-Hackathons/3D_2D_Rep_Structure
        // bUpdate: redraw 2Ddiagramfor the displayed structure
        draw2Ddgm(data, mmdbid, structureIndex, bUpdate) { let ic = this.icn3d, me = ic.icn3dui;
            // only show the 2D diagrams for displayed structures

    ///        mmdbid = mmdbid.substr(0, 4);

            // reduce the size from 300 to 200 (150)
            let factor = 0.667;

            // set molid2chain
            let molid2chain = {}, molid2color = {}, molid2name = {}, chainid2molid = {};
            let chainNameHash = {};

            if(data === undefined) return '';

            for(let molid in data.moleculeInfor) {
                  let color = '#' +( '000000' + data.moleculeInfor[molid].color.toString( 16 ) ).slice( - 6 );
                  let chainName = data.moleculeInfor[molid].chain.trim();
                  if(chainNameHash[chainName] === undefined) {
                      chainNameHash[chainName] = 1;
                  }
                  else {
                      ++chainNameHash[chainName];
                  }

                  let chainNameFinal =(chainNameHash[chainName] === 1) ? chainName : chainName + chainNameHash[chainName].toString();
                  let chainid = mmdbid + '_' + chainNameFinal;
                  if(ic.mmdbid_q !== undefined && ic.mmdbid_q === ic.mmdbid_t && structureIndex === 0) ;

                  molid2chain[molid] = chainid;
                  molid2color[molid] = color;
                  molid2name[molid] = data.moleculeInfor[molid].name;

                  chainid2molid[chainid] = molid;
            }

            // save the interacting residues
            if(bUpdate === undefined || !bUpdate) {
                for(let i = 0, il = data['intracResidues'].length; i < il; ++i) {
                    let pair = data['intracResidues'][i];

                    let index = 0;
                    let chainid1, chainid2;

                    for(let molid in pair) {
                        //molid = parseInt(molid);

                        let chainid;

                        chainid = molid2chain[molid];
                        if(index === 0) {
                            chainid1 = chainid;
                        }
                        else {
                            chainid2 = chainid;
                        }

                        ++index;
                    }

                    if(chainid1 === undefined || chainid2 === undefined) continue;

                    index = 0;
                    for(let molid in pair) {
                        let resArray = pair[molid];

                        let fisrtChainid, secondChainid;
                        if(index === 0) {
                            fisrtChainid = chainid1;
                            secondChainid = chainid2;
                        }
                        else {
                            fisrtChainid = chainid2;
                            secondChainid = chainid1;
                        }

                        if(ic.chainids2resids[fisrtChainid] === undefined) {
                            ic.chainids2resids[fisrtChainid] = {};
                        }

                        if(ic.chainids2resids[fisrtChainid][secondChainid] === undefined) {
                            ic.chainids2resids[fisrtChainid][secondChainid] = [];
                        }

                        for(let j = 0, jl = resArray.length; j < jl; ++j) {
                            let res = resArray[j];
                            let resid = ic.mmdbMolidResid2mmdbChainResi[mmdbid.toUpperCase() + '_' + molid + '_' + res];

                            ic.chainids2resids[fisrtChainid][secondChainid].push(resid);
                        }

                        // update ic.chainname2residues
                        if(ic.chainname2residues === undefined) ic.chainname2residues = {};

                        chainid2 = secondChainid;

                        if(!ic.chains.hasOwnProperty(chainid2)) continue;

                        let atom2 = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.chains[chainid2]);
                        //if(ic.chainname2residues[chainid2] === undefined) ic.chainname2residues[chainid2] = {}

                        let type2;
                        if(ic.chemicals.hasOwnProperty(atom2.serial)) { // 1. chemical interacting with proteins
                            type2 = 'chemical';
                        }
                        else if(ic.nucleotides.hasOwnProperty(atom2.serial)) { // 2. DNA interacting with proteins
                            type2 = 'nucleotide';
                        }
                        else if(ic.ions.hasOwnProperty(atom2.serial)) { // 3. ions interacting with proteins
                            type2 = 'ion';
                        }
                        else if(ic.proteins.hasOwnProperty(atom2.serial)) { // 4. protein interacting with proteins
                            type2 = 'protein';
                        }
                        else if(ic.water.hasOwnProperty(atom2.serial)) { // 5. water interacting with proteins
                            type2 = 'water';
                        }

                        let name = chainid2.substr(chainid2.indexOf('_') + 1) + "(" + type2 + ")";

                        if(ic.chainname2residues[fisrtChainid] === undefined) ic.chainname2residues[fisrtChainid] = {};

                        ic.chainname2residues[fisrtChainid][name] = ic.chainids2resids[fisrtChainid][secondChainid];


                        ++index;
                    }
                }
            }

            let html = "<div id='#" + ic.pre + mmdbid + "'>";

            html += "<b>" + mmdbid.toUpperCase() + "</b><br/>";

            html += "<svg viewBox='0,0," + me.htmlCls.width2d + "," + me.htmlCls.width2d + "'>";
            let strokecolor = '#000000';
            let linestrokewidth = '2';

            let posHash = {};
            let lines = [];

            let nodeHtml = "", chemNodeHtml = "";

            let displayedMolids = {};
            if(bUpdate) {
                // get all displayed chains
                for(let i in ic.dAtoms) {
                    let atom = ic.atoms[i];
                    let chainid = atom.structure + '_' + atom.chain;
                    let molid = chainid2molid[chainid];

                    displayedMolids[molid] = 1;
                }
            }

            let allMolidArray = Object.keys(data.moleculeInfor);
            let intracMolidArray = Object.keys(data.intrac);

            let missingMolidArray = [];
            for(let i = 0, il = allMolidArray.length; i < il; ++i) {
                if(intracMolidArray.indexOf(allMolidArray[i]) === -1) missingMolidArray.push(allMolidArray[i]);
            }

            let missingMolid2intrac = {}; // biopolymer

            if(missingMolidArray.length > 0) {
                for(let molid in data.intrac) {
                    let dgm = data.intrac[molid];
                    for(let i = 0, il = dgm.intrac.length; i < il; ++i) {
                        let intracMolid = dgm.intrac[i].toString();
                        if(missingMolidArray.indexOf(intracMolid) !== -1) {
                            if(missingMolid2intrac[intracMolid] === undefined) missingMolid2intrac[intracMolid] = [];
                            missingMolid2intrac[intracMolid].push(molid);
                            lines.push([intracMolid, molid]);
                        }
                    }

                    if(dgm.shape === 'rect') {
                        let x = dgm.coords[0] * factor;
                        let y = dgm.coords[1] * factor;
                        let width = dgm.coords[2] * factor - x;
                        let height = dgm.coords[3] * factor - y;

                        posHash[molid] = [x + width/2, y + height/2];
                    }
                    else if(dgm.shape === 'circle') {
                        let x = dgm.coords[0] * factor;
                        let y = dgm.coords[1] * factor;
                        dgm.coords[2] * factor;

                        posHash[molid] = [x, y];
                    }
                    else if(dgm.shape === 'poly') {
                        let x0 = dgm.coords[0] * factor;
                        dgm.coords[1] * factor;
                        dgm.coords[2] * factor;
                        let y1 = dgm.coords[3] * factor;
                        dgm.coords[4] * factor;
                        dgm.coords[5] * factor;
                        dgm.coords[6] * factor;
                        dgm.coords[7] * factor;

                        posHash[molid] = [x0, y1];
                    }
                }
            }

            let cntNointeraction = 0;
            //for(let molid in data.intrac) {
            for(let index = 0, indexl = allMolidArray.length; index < indexl; ++index) {
                let molid = allMolidArray[index];

                let chainid = molid2chain[molid];

                // if redraw2d diagram and the molid is not displayed, skip
                if(bUpdate && !displayedMolids.hasOwnProperty(molid)) continue;

                let dgm = data.intrac[molid];
                let color = "#FFFFFF";
                let oricolor = molid2color[molid];
                if(chainid !== undefined && ic.chains[chainid] !== undefined) {
                    let atomArray = Object.keys(ic.chains[chainid]);
                    if(atomArray.length > 0) {
                        oricolor = "#" + ic.atoms[atomArray[0]].color.getHexString().toUpperCase();
                    }
                }

                let alignNum = "";
                if(ic.bInitial && structureIndex !== undefined) {
                    if(ic.alignmolid2color !== undefined && ic.alignmolid2color[structureIndex].hasOwnProperty(molid)) {
                        alignNum = ic.alignmolid2color[structureIndex][molid];
                        oricolor = "#FF0000";
                    }
                    else {
                        oricolor = "#FFFFFF";
                    }
                }

                let chainname = molid2name[molid];

                let chain = ' ', oriChain = ' ';
                if(chainid !== undefined) {
                    let pos = chainid.indexOf('_');
                    oriChain = chainid.substr(pos + 1);

                    if(oriChain.length > 1) {
                        chain = oriChain.substr(0, 1) + '..';
                    }
                    else {
                        chain = oriChain;
                    }
                }
                else {
                    chainid = 'Misc';
                }

                if(oricolor === undefined) {
                    oricolor = '#FFFFFF';
                }

                let ratio = 1.0;
                if(ic.bInitial && ic.alnChains[chainid] !== undefined) {
                    //ratio = 1.0 * Object.keys(ic.alnChains[chainid]).length / Object.keys(ic.chains[chainid]).length;
                    let alignedAtomCnt = 0;
                    for(let i in ic.alnChains[chainid]) {
                        let colorStr = ic.atoms[i].color.getHexString().toUpperCase();
                        if(colorStr === 'FF0000' || colorStr === '00FF00') {
                            ++alignedAtomCnt;
                        }
                    }
                    ratio = 1.0 * alignedAtomCnt / Object.keys(ic.chains[chainid]).length;
                }
                if(ratio < 0.2) ratio = 0.2;

                if(missingMolidArray.indexOf(molid) === -1) {
                    for(let i = 0, il = dgm.intrac.length; i < il; ++i) {
                        // show the interactin line once
                        if(parseInt(molid) < parseInt(dgm.intrac[i])) lines.push([molid, dgm.intrac[i] ]);
                    }

                    if(dgm.shape === 'rect') {
                        let x = dgm.coords[0] * factor;
                        let y = dgm.coords[1] * factor;
                        let width = dgm.coords[2] * factor - x;
                        let height = dgm.coords[3] * factor - y;

                        nodeHtml += this.draw2DNucleotide(x + 0.5 * width, y + 0.5 * height, chainid, oriChain, chain, chainname, alignNum, color, oricolor, factor, ratio);

                        posHash[molid] = [x + width/2, y + height/2];
                    }
                    else if(dgm.shape === 'circle') {
                        let x = dgm.coords[0] * factor;
                        let y = dgm.coords[1] * factor;

                        nodeHtml += this.draw2DProtein(x, y, chainid, oriChain, chain, chainname, alignNum, color, oricolor, factor, ratio);

                        posHash[molid] = [x, y];
                    }
                    else if(dgm.shape === 'poly') {
                      let x0 = dgm.coords[0] * factor;
                      dgm.coords[1] * factor;
                      dgm.coords[2] * factor;
                      let y1 = dgm.coords[3] * factor;
                      dgm.coords[4] * factor;
                      dgm.coords[5] * factor;
                      dgm.coords[6] * factor;
                      dgm.coords[7] * factor;

                      let x = x0, y = y1;

                      ic.firstAtomObjCls.getFirstAtomObj(ic.chains[chainid]);

                      chemNodeHtml += this.draw2DChemical(x, y, chainid, oriChain, chain, chainname, alignNum, color, oricolor, factor, ratio);

                      posHash[molid] = [x0, y1];
                    }
                }
                else { // missing biopolymer
                    // max x and y value: 300
                    let maxSize = 300;
                    let step = 50;

                    let xCenter, yCenter;
                    if(missingMolid2intrac[molid] !== undefined && missingMolid2intrac[molid].length > 1) { // has interactions
                        // find its position
                        let xSum = 0, ySum = 0;

                        for(let j = 0, jl = missingMolid2intrac[molid].length; j < jl; ++j) {
                            let intracMolid = missingMolid2intrac[molid][j];
                            if(posHash.hasOwnProperty(intracMolid)) {
                                let node = posHash[intracMolid];
                                xSum += node[0];
                                ySum += node[1];
                            }
                        }

                        xCenter = xSum / missingMolid2intrac[molid].length;
                        yCenter = ySum / missingMolid2intrac[molid].length;
                    }
                    else { // has NO interactions or just one interaction
                        let nSteps = maxSize / step;

                        if(cntNointeraction < nSteps - 1) {
                            xCenter =(cntNointeraction + 1) * step * factor;
                            yCenter = 0.1 * maxSize * factor;
                        }
                        else if(cntNointeraction -(nSteps - 1) < nSteps - 1) {
                            xCenter = 0.1 * maxSize * factor;
                            yCenter =(cntNointeraction -(nSteps - 1) + 1) * step * factor;
                        }
                        else {
                            xCenter = 0.25 * maxSize * factor;
                            yCenter = xCenter;
                        }

                        ++cntNointeraction;

                    }

                    let x = xCenter, y = yCenter;

                    ic.firstAtomObjCls.getFirstAtomObj(ic.chains[chainid]);

                    let bBiopolymer = true;
                    chemNodeHtml += this.draw2DChemical(x, y, chainid, oriChain, chain, chainname, alignNum, color, oricolor, factor, ratio, bBiopolymer);

                    posHash[molid] = [x, y];
                }
            }

            for(let i = 0, il = lines.length; i < il; ++i) {
                let pair = lines[i];

                // if redraw2d diagram and the molid is not displayed, skip
                if(bUpdate &&(!displayedMolids.hasOwnProperty(pair[0]) || !displayedMolids.hasOwnProperty(pair[1])) ) continue;

                let node1 = posHash[parseInt(pair[0])];
                let node2 = posHash[parseInt(pair[1])];

                if(node1 === undefined || node2 === undefined) continue;

                let chainid1, chainid2;

                chainid1 = molid2chain[pair[0]];
                chainid2 = molid2chain[pair[1]];

                let pos1 = chainid1.indexOf('_');
                let pos2 = chainid2.indexOf('_');

                let chain1 = chainid1.substr(pos1 + 1);
                let chain2 = chainid2.substr(pos2 + 1);

                let x1 = node1[0], y1 = node1[1], x2 = node2[0], y2 = node2[1], xMiddle =(x1 + x2) * 0.5, yMiddle =(y1 + y2) * 0.5;

                html += "<g class='icn3d-interaction' chainid1='" + chainid1 + "' chainid2='" + chainid2 + "' >";
                html += "<title>Interaction of chain " + chain1 + " with chain " + chain2 + "</title>";
                html += "<line x1='" + x1 + "' y1='" + y1 + "' x2='" + xMiddle + "' y2='" + yMiddle + "' stroke='" + strokecolor + "' stroke-width='" + linestrokewidth + "' /></g>";

                html += "<g class='icn3d-interaction' chainid1='" + chainid2 + "' chainid2='" + chainid1 + "' >";
                html += "<title>Interaction of chain " + chain2 + " with chain " + chain1 + "</title>";
                html += "<line x1='" + xMiddle + "' y1='" + yMiddle + "' x2='" + x2 + "' y2='" + y2 + "' stroke='" + strokecolor + "' stroke-width='" + linestrokewidth + "' /></g>";
            }

            html += chemNodeHtml + nodeHtml; // draw chemicals at the bottom layer

            html += "</svg>";
            html += "</div>";

            ic.html2ddgm += html;

            $("#" + ic.pre + "dl_2ddgm_html").html(ic.html2ddgm);

            return html;
        }

        set2DdgmNote(bAlign) { let ic = this.icn3d, me = ic.icn3dui;
            let html = "<div style='width:150px'><b>Nodes</b>:<br>";

            if(me.utilsCls.isMac()) {
                html += "<span style='margin-right:18px;'>&#9711;</span>Protein<br>";
                html += "<span style='margin-right:18px;'>&#9634;</span>Nucleotide<br>";
                html += "<span style='margin-right:18px;'>&#9826;</span>Chemical<br>";
                html += "<span style='margin-right:18px;display: inline-block;transform: skew(-25deg);'>&#9634;</span>Biopolymer<br>";
            }
            else {
                html += "<span style='margin-right:18px;'>O</span>Protein<br>";
                html += "<span style='margin-right:18px;'>&#9634;</span>Nucleotide<br>";
                html += "<span style='margin-right:18px;'>&#9671;</span>Chemical<br>";
                html += "<span style='margin-right:18px;display: inline-block;transform: skew(-25deg);'>&#9634;</span>Biopolymer<br>";
            }

            html += "<br><b>Lines</b>:<br> Interactions at 4 &#197;<br>";
            if(bAlign) html += "<b>Numbers in red</b>:<br> Aligned chains";
            html += "</div><br/>";

            return html;
        }

        highlightNode(type, highlight, base, ratio) { let ic = this.icn3d, me = ic.icn3dui;
            if(ratio < 0.2) ratio = 0.2;
            let strokeWidth = 3; // default 1

            if(type === 'rect') {
                $(highlight).attr('stroke', me.htmlCls.ORANGE);
                $(highlight).attr('stroke-width', strokeWidth);

                let x = Number($(base).attr('x'));
                let y = Number($(base).attr('y'));
                let width = Number($(base).attr('width'));
                let height = Number($(base).attr('height'));
                $(highlight).attr('x', x + width / 2.0 *(1 - ratio));
                $(highlight).attr('y', y + height / 2.0 *(1 - ratio));
                $(highlight).attr('width', width * ratio);
                $(highlight).attr('height', height * ratio);
            }
            else if(type === 'circle') {
                $(highlight).attr('stroke', me.htmlCls.ORANGE);
                $(highlight).attr('stroke-width', strokeWidth);

                $(highlight).attr('r', Number($(base).attr('r')) * ratio);
            }
            else if(type === 'polygon') {
                $(highlight).attr('stroke', me.htmlCls.ORANGE);
                $(highlight).attr('stroke-width', strokeWidth);

                let x = Number($(base).attr('x'));
                let y = Number($(base).attr('y'));

                let x0diff = Number($(base).attr('x0d'));
                let y0diff = Number($(base).attr('y0d'));
                let x1diff = Number($(base).attr('x1d'));
                let y1diff = Number($(base).attr('y1d'));
                let x2diff = Number($(base).attr('x2d'));
                let y2diff = Number($(base).attr('y2d'));
                let x3diff = Number($(base).attr('x3d'));
                let y3diff = Number($(base).attr('y3d'));

                $(highlight).attr('points',(x+x0diff*ratio).toString() + ", " +(y+y0diff*ratio).toString() + ", " +(x+x1diff*ratio).toString() + ", " +(y+y1diff*ratio).toString() + ", " +(x+x2diff*ratio).toString() + ", " +(y+y2diff*ratio).toString() + ", " +(x+x3diff*ratio).toString() + ", " +(y+y3diff*ratio).toString());
            }
        }

        removeLineGraphSelection() { let ic = this.icn3d; ic.icn3dui;
              $("#" + ic.pre + "dl_linegraph circle").attr('stroke', '#000000');
              $("#" + ic.pre + "dl_linegraph circle").attr('stroke-width', 1);

              $("#" + ic.pre + "dl_linegraph svg line.icn3d-hlline").attr('stroke', '#FFF');
              //$("#" + ic.pre + "dl_linegraph svg line .icn3d-hlline").attr('stroke-width', 1);
        }

        removeScatterplotSelection() { let ic = this.icn3d; ic.icn3dui;
              $("#" + ic.pre + "dl_scatterplot circle").attr('stroke', '#000000');
              $("#" + ic.pre + "dl_scatterplot circle").attr('stroke-width', 1);

              $("#" + ic.pre + "dl_scatterplot rect").attr('stroke', '#000000');
              $("#" + ic.pre + "dl_scatterplot rect").attr('stroke-width', 1);
        }

        click2Ddgm() { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            //$("#" + ic.pre + "dl_2ddgm .icn3d-node", "click", function(e) { let ic = this.icn3d, me = ic.icn3dui;
            $(document).on("click", "#" + ic.pre + "dl_2ddgm .icn3d-node", function(e) { let ic = thisClass.icn3d;
                e.stopImmediatePropagation();
                if(Object.keys(ic.hAtoms).length < Object.keys(ic.atoms).length) ic.definedSetsCls.setMode('selection');

                //ic.bClickInteraction = false;

                let chainid = $(this).attr('chainid');

                // clear all nodes
                if(!ic.bCtrl && !ic.bShift) {
                    ic.selectionCls.removeSelection();

                    // ic.lineArray2d is used to highlight lines in 2D diagram
                    ic.lineArray2d = [];
                }

                let ratio = 1.0;
                if(ic.alnChains[chainid] !== undefined) ratio = 1.0 * Object.keys(ic.alnChains[chainid]).length / Object.keys(ic.chains[chainid]).length;

                let target = $(this).find("rect[class='icn3d-hlnode']");
                let base = $(this).find("rect[class='icn3d-basenode']");
                thisClass.highlightNode('rect', target, base, ratio);

                target = $(this).find("circle[class='icn3d-hlnode']");
                base = $(this).find("circle[class='icn3d-basenode']");
                thisClass.highlightNode('circle', target, base, ratio);

                target = $(this).find("polygon[class='icn3d-hlnode']");
                base = $(this).find("polygon[class='icn3d-basenode']");
                thisClass.highlightNode('polygon', target, base, ratio);

                if(!ic.bCtrl && !ic.bShift) {
                    ic.hAtoms = me.hashUtilsCls.cloneHash(ic.chains[chainid]);
                }
                else {
                    ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.chains[chainid]);
                }

                // get the name array
                if(!ic.bCtrl && !ic.bShift) {
                    ic.chainArray2d = [chainid];
                }
                else {
                    if(ic.chainArray2d === undefined) ic.chainArray2d = [];
                    ic.chainArray2d.push(chainid);
                }

                ic.hlUpdateCls.updateHlAll(ic.chainArray2d);

                // show selected chains in annotation window
                ic.annotationCls.showAnnoSelectedChains();

                let select = "select chain " + chainid;
                me.htmlCls.clickMenuCls.setLogCmd(select, true);

                ic.bSelectResidue = false;
            });

            //$("#" + ic.pre + "dl_2ddgm .icn3d-interaction", "click", function(e) { let ic = thisClass.icn3d;
            $(document).on("click", "#" + ic.pre + "dl_2ddgm .icn3d-interaction", function(e) { let ic = thisClass.icn3d;
                e.stopImmediatePropagation();
                if(Object.keys(ic.hAtoms).length < Object.keys(ic.atoms).length) ic.definedSetsCls.setMode('selection');

                ic.bClickInteraction = true;

                let chainid1 = $(this).attr('chainid1');
                let chainid2 = $(this).attr('chainid2');

                $(this).find('line').attr('stroke', me.htmlCls.ORANGE);

                // interaction of chain1 with chain2, only show the part of chain1 interacting with chain2
                thisClass.selectInteraction(chainid1, chainid2);

                // show selected chains in annotation window
                ic.annotationCls.showAnnoSelectedChains();

                let select = "select interaction " + chainid1 + "," + chainid2;
                me.htmlCls.clickMenuCls.setLogCmd(select, true);

                ic.bClickInteraction = false;
            });

            //$("#" + ic.pre + "dl_linegraph .icn3d-node", "click", function(e) { let ic = this.icn3d, me = ic.icn3dui;
            $(document).on("click", "#" + ic.pre + "dl_linegraph .icn3d-node", function(e) { let ic = thisClass.icn3d;
                e.stopImmediatePropagation();
                if(Object.keys(ic.hAtoms).length < Object.keys(ic.atoms).length) ic.definedSetsCls.setMode('selection');

                let resid = $(this).attr('resid');

                if(!ic.bCtrl && !ic.bShift) {
                  ic.hAtoms = {};

                  thisClass.removeLineGraphSelection();
                }

                let strokeWidth = 2;
                $(this).find('circle').attr('stroke', me.htmlCls.ORANGE);
                $(this).find('circle').attr('stroke-width', strokeWidth);

                ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.residues[resid]);

                let select = 'select ' + ic.resid2specCls.residueids2spec([resid]);

                ic.hlUpdateCls.updateHlAll();

                me.htmlCls.clickMenuCls.setLogCmd(select, true);

                ic.bSelectResidue = false;
            });

            //$("#" + ic.pre + "dl_scatterplot .icn3d-node", "click", function(e) { let ic = this.icn3d, me = ic.icn3dui;
            $(document).on("click", "#" + ic.pre + "dl_scatterplot .icn3d-node", function(e) { thisClass.icn3d;
                e.stopImmediatePropagation();

                thisClass.clickNode(this);
            });

            $(document).on("click", "#" + ic.pre + "dl_ligplot .icn3d-node", function(e) { thisClass.icn3d;
                e.stopImmediatePropagation();

                thisClass.clickNode(this);
            });

            //$("#" + ic.pre + "dl_linegraph .icn3d-interaction", "click", function(e) { let ic = this.icn3d, me = ic.icn3dui;
            $(document).on("click", "#" + ic.pre + "dl_linegraph .icn3d-interaction", function(e) { let ic = thisClass.icn3d;
                  e.stopImmediatePropagation();
                if(Object.keys(ic.hAtoms).length < Object.keys(ic.atoms).length) ic.definedSetsCls.setMode('selection');

                let resid1 = $(this).attr('resid1');
                let resid2 = $(this).attr('resid2');

                if(!ic.bCtrl && !ic.bShift) {
                  ic.hAtoms = {};

                  thisClass.removeLineGraphSelection();
                }

                $(this).find('line.icn3d-hlline').attr('stroke', me.htmlCls.ORANGE);

                let strokeWidth = 2;
                $("[resid=" + resid1 + "]").find('circle').attr('stroke', me.htmlCls.ORANGE);
                $("[resid=" + resid1 + "]").find('circle').attr('stroke-width', strokeWidth);

                $("[resid=" + resid2 + "]").find('circle').attr('stroke', me.htmlCls.ORANGE);
                $("[resid=" + resid2 + "]").find('circle').attr('stroke-width', strokeWidth);

                ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.residues[resid1]);
                ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.residues[resid2]);

                let select = 'select ' + ic.resid2specCls.residueids2spec([resid1, resid2]);

                ic.hlUpdateCls.updateHlAll();

                ic.transformCls.zoominSelection();

                me.htmlCls.clickMenuCls.setLogCmd(select, true);
            });

            //$("#" + ic.pre + "dl_scatterplot .icn3d-interaction", "click", function(e) { let ic = this.icn3d, me = ic.icn3dui;
            $(document).on("click", "#" + ic.pre + "dl_scatterplot .icn3d-interaction", function(e) { let ic = thisClass.icn3d;
                e.stopImmediatePropagation();

                thisClass.clickInteraction(this);
                ic.transformCls.zoominSelection();
            });

            $(document).on("click", "#" + ic.pre + "dl_contactmap .icn3d-interaction", function(e) { thisClass.icn3d;
                e.stopImmediatePropagation();

                thisClass.clickInteraction(this);
            });

            $(document).on("click", "#" + ic.pre + "dl_contactmap .icn3d-node", function(e) { thisClass.icn3d;
                e.stopImmediatePropagation();

                thisClass.clickNode(this);
            });

            $(document).on("click", "#" + ic.pre + "dl_alignerrormap .icn3d-interaction", function(e) { thisClass.icn3d;
                e.stopImmediatePropagation();

                thisClass.clickInteraction(this);
            });

            $(document).on("click", "#" + ic.pre + "dl_ligplot .icn3d-interaction", function(e) { thisClass.icn3d;
                e.stopImmediatePropagation();

                thisClass.clickInteraction(this);
            });

            $(document).on("click", "#" + ic.pre + "dl_alignerrormap .icn3d-node", function(e) { thisClass.icn3d;
                e.stopImmediatePropagation();

                thisClass.clickNode(this);
            });
        }

        clickNode(node) {  let ic = this.icn3d, me = ic.icn3dui;
            if(Object.keys(ic.hAtoms).length < Object.keys(ic.atoms).length) ic.definedSetsCls.setMode('selection');

            let resid = $(node).attr('resid');

            if(!ic.bCtrl && !ic.bShift) {
              ic.hAtoms = {};

              this.removeScatterplotSelection();
            }

            let strokeWidth = 2;
            $(node).find('circle').attr('stroke', me.htmlCls.ORANGE);
            $(node).find('circle').attr('stroke-width', strokeWidth);
            $(node).find('rect').attr('stroke', me.htmlCls.ORANGE);
            $(node).find('rect').attr('stroke-width', strokeWidth);

            ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.residues[resid]);

            let select = 'select ' + ic.resid2specCls.residueids2spec([resid]);

            ic.hlUpdateCls.updateHlAll();

            me.htmlCls.clickMenuCls.setLogCmd(select, true);

            ic.bSelectResidue = false;
        }

        clickInteraction(node) {  let ic = this.icn3d, me = ic.icn3dui;
            if(Object.keys(ic.hAtoms).length < Object.keys(ic.atoms).length) ic.definedSetsCls.setMode('selection');

            let resid1 = $(node).attr('resid1');
            let resid2 = $(node).attr('resid2');

            if(!ic.bCtrl && !ic.bShift) {
              ic.hAtoms = {};

              this.removeScatterplotSelection();
            }

            let strokeWidth = 2;
            $(node).find('rect').attr('stroke', me.htmlCls.ORANGE);
            $(node).find('rect').attr('stroke-width', strokeWidth);

            ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.residues[resid1]);
            ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.residues[resid2]);

            let select = 'select ' + ic.resid2specCls.residueids2spec([resid1, resid2]);

            ic.hlUpdateCls.updateHlAll();

            me.htmlCls.clickMenuCls.setLogCmd(select, true);
        }

        selectInteraction(chainid1, chainid2) {  let ic = this.icn3d; ic.icn3dui;
                ic.hlUpdateCls.removeHl2D();
                ic.hlObjectsCls.removeHlObjects();

                if(!ic.bCtrl && !ic.bShift) {
                    // ic.lineArray2d is used to highlight lines in 2D diagram
                    ic.lineArray2d = [chainid1, chainid2];
                }
                else {
                    if(ic.lineArray2d === undefined) ic.lineArray2d = [];
                    ic.lineArray2d.push(chainid1);
                    ic.lineArray2d.push(chainid2);
                }

                this.selectInteractionAtoms(chainid1, chainid2);

                ic.hlObjectsCls.addHlObjects();

                ic.hlUpdateCls.updateHlAll();
        }

        selectInteractionAtoms(chainid1, chainid2) {  let ic = this.icn3d, me = ic.icn3dui;  // ic.pAtom is set already
            let radius = 4;

            // method 2. Retrieved from the cgi(This previously had problems in sharelink where the data from ajax is async. Now the data is from the same cgi as the atom data and there is no problem.)
            let residueArray = ic.chainids2resids[chainid1][chainid2];

            if(!ic.bCtrl && !ic.bShift) ic.hAtoms = {};

            for(let i = 0, il = residueArray.length; i < il; ++i) {
                ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.residues[residueArray[i]]);
            }

            let commandname, commanddesc;
            if(Object.keys(ic.structures).length > 1) {
                commandname = "inter_" + chainid1 + "_" + chainid2;
            }
            else {
                let pos1 = chainid1.indexOf('_');
                let pos2 = chainid2.indexOf('_');

                commandname = "inter_" + chainid1.substr(pos1 + 1) + "_" + chainid2.substr(pos2 + 1);
            }

            commanddesc = "select the atoms in chain " + chainid1 + " interacting with chain " + chainid2 + " in a distance of " + radius + " angstrom";

            let select = "select interaction " + chainid1 + "," + chainid2;

            ic.selectionCls.addCustomSelection(residueArray, commandname, commanddesc, select, true);
        }

        draw2DProtein(x, y, chainid, oriChain, chain, chainname, alignNum, color, oricolor, factor, ratio) { let ic = this.icn3d; ic.icn3dui;
            let strokecolor = '#000000';
            let strokewidth = '1';
            let textcolor = '#000000';
            let fontsize = '10';
            let smallfontsize = '8';
            let adjustx = 0, adjusty = 4, halfLetHigh = 6;

            let r = 20 * factor;

            let html = "<g class='icn3d-node' chainid='" + chainid + "' >";
            html += "<title>Chain " + oriChain + ": " + chainname + "</title>";
            html += "<circle class='icn3d-basenode' cx='" + x + "' cy='" + y + "' r='" + r + "' fill='" + color + "' stroke-width='" + strokewidth + "' stroke='" + strokecolor + "' class='icn3d-node' chainid='" + chainid + "' />";

            html += "<circle class='icn3d-hlnode' cx='" + x + "' cy='" + y + "' r='" +(r * ratio).toString() + "' fill='" + oricolor + "' stroke-width='" + strokewidth + "' stroke='" + strokecolor + "' />";

            html += "<text x='" +(x - adjustx).toString() + "' y='" +(y + adjusty).toString() + "' style='fill:" + textcolor + "; font-size:" + fontsize + "; text-anchor:middle' >" + chain + "</text>";

            if(alignNum !== "") html += "<text x='" +(x - adjustx).toString() + "' y='" +(y + r + adjusty + halfLetHigh).toString() + "' style='fill:" + oricolor + "; font-size:" + smallfontsize + "; font-weight:bold; text-anchor:middle' >" + alignNum + "</text>";

            html += "</g>";

            return html;
        }

        draw2DNucleotide(x, y, chainid, oriChain, chain, chainname, alignNum, color, oricolor, factor, ratio) { let ic = this.icn3d; ic.icn3dui;
            let strokecolor = '#000000';
            let strokewidth = '1';
            let textcolor = '#000000';
            let fontsize = '10';
            let smallfontsize = '8';
            let adjustx = 0, adjusty = 4, halfLetHigh = 6;

            let width = 30 * factor;
            let height = 30 * factor;

            x -= 0.5 * width;
            y -= 0.5 * height;

            let html = "<g class='icn3d-node' chainid='" + chainid + "' >";
            html += "<title>Chain " + oriChain + ": " + chainname + "</title>";
            // place holder
            html += "<rect class='icn3d-basenode' x='" + x + "' y='" + y + "' width='" + width + "' height='" + height + "' fill='" + color + "' stroke-width='" + strokewidth + "' stroke='" + strokecolor + "' />";
            // highlight
            html += "<rect class='icn3d-hlnode' x='" +(x + width / 2.0 *(1 - ratio)).toString() + "' y='" +(y + height / 2.0 *(1 - ratio)).toString() + "' width='" +(width * ratio).toString() + "' height='" +(height * ratio).toString() + "' fill='" + oricolor + "' stroke-width='" + strokewidth + "' stroke='" + strokecolor + "' />";

            html += "<text x='" +(x + width / 2 - adjustx).toString() + "' y='" +(y + height / 2 + adjusty).toString() + "' style='fill:" + textcolor + "; font-size:" + fontsize + "; text-anchor:middle' >" + chain + "</text>";

            if(alignNum !== "") html += "<text x='" +(x + width / 2 - adjustx).toString() + "' y='" +(y + height + adjusty + halfLetHigh).toString() + "' style='fill:" + oricolor + "; font-size:" + smallfontsize + "; font-weight:bold; text-anchor:middle' >" + alignNum + "</text>";

            html += "</g>";

            return html;
        }

        draw2DChemical(x, y, chainid, oriChain, chain, chainname, alignNum, color, oricolor, factor, ratio, bBiopolymer) { let ic = this.icn3d; ic.icn3dui;
            let strokecolor = '#000000';
            let strokewidth = '1';
            let textcolor = '#000000';
            let smallfontsize = '8';
            let smalladjustx = 1, smalladjusty = 2, halfLetHigh = 6;

            let bpsize = 30 * factor;

            let x0, y0, x1, y1, x2, y2, x3, y3;
            if(bBiopolymer) {
                // biopolymer
                let xOffset = 0.5 * bpsize / Math.sqrt(3);
                let yOffset = 0.5 * bpsize;

                x0 = x - xOffset;
                y0 = y - yOffset;
                x1 = x + 3 * xOffset;
                y1 = y - yOffset;
                x2 = x + xOffset;
                y2 = y + yOffset;
                x3 = x - 3 * xOffset;
                y3 = y + yOffset;
            }
            else {
                // diamond
                let xOffset = 0.5 * bpsize;
                let yOffset = 0.5 * bpsize;

                x0 = x - xOffset;
                y0 = y;
                x1 = x;
                y1 = y + yOffset;
                x2 = x + xOffset;
                y2 = y;
                x3 = x;
                y3 = y - yOffset;
            }

            let x0diff = x0 - x;
            let y0diff = y0 - y;
            let x1diff = x1 - x;
            let y1diff = y1 - y;
            let x2diff = x2 - x;
            let y2diff = y2 - y;
            let x3diff = x3 - x;
            let y3diff = y3 - y;

            let html = "<g class='icn3d-node' chainid='" + chainid + "' >";
            html += "<title>Chain " + oriChain + ": " + chainname + "</title>";
            html += "<polygon class='icn3d-basenode' points='" + x0 + ", " + y0 + "," + x1 + ", " + y1 + "," + x2 + ", " + y2 + "," + x3 + ", " + y3 + "' x='" + x + "' y='" + y + "' x0d='" + x0diff + "' y0d='" + y0diff + "' x1d='" + x1diff + "' y1d='" + y1diff + "' x2d='" + x2diff + "' y2d='" + y2diff + "' x3d='" + x3diff + "' y3d='" + y3diff + "' fill='" + color + "' stroke-width='" + strokewidth + "' stroke='" + strokecolor + "' />";

            html += "<polygon class='icn3d-hlnode' points='" +(x+x0diff*ratio).toString() + ", " +(y+y0diff*ratio).toString() + "," +(x+x1diff*ratio).toString() + ", " +(y+y1diff*ratio).toString() + "," +(x+x2diff*ratio).toString() + ", " +(y+y2diff*ratio).toString() + "," +(x+x3diff*ratio).toString() + ", " +(y+y3diff*ratio).toString() + "' fill='" + oricolor + "' stroke-width='" + strokewidth + "' stroke='" + strokecolor + "' />";

            html += "<text x='" +(x + smalladjustx).toString() + "' y='" +(y + smalladjusty).toString() + "' style='fill:" + textcolor + "; font-size:" + smallfontsize + "; text-anchor:middle' >" + chain + "</text>";

            if(alignNum !== "") html += "<text x='" +(x + smalladjustx).toString() + "' y='" +(y + smalladjusty + halfLetHigh).toString() + "' style='fill:" + oricolor + "; font-size:" + smallfontsize + "; font-weight:bold; text-anchor:middle' >" + alignNum + "</text>";

            html += "</g>";

            return html;
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Cartoon2d {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        async draw2Dcartoon(type, bResize) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            me.htmlCls.clickMenuCls.setLogCmd("cartoon 2d " + type, true);

            ic.cartoon2dType = type;

            //ic.bGraph = false; // differentiate from force-directed graph for interactions

            if(bResize) {
                let html = thisClass.getCartoonSvg(type, ic.graphStr);
                $("#" + me.svgid_ct).html(html);
            }
            else {
    /*            
                if(type == 'domain' && !ic.chainid2pssmid) {
                    //$.when(thisClass.getNodesLinksForSetCartoon(type)).then(function() {
                        await thisClass.getNodesLinksForSetCartoon(type);

                        ic.graphStr = thisClass.getCartoonData(type, ic.node_link);
                        //ic.viewInterPairsCls.drawGraphWrapper(ic.graphStr, ic.deferredCartoon2d, true);
                        let html = thisClass.getCartoonSvg(type, ic.graphStr);
                        $("#" + me.svgid_ct).html(html);
                        thisClass.setEventsForCartoon2d();

                        me.htmlCls.dialogCls.openDlg('dl_2dctn', '2D Cartoon');

                        /// if(ic.deferredCartoon2d !== undefined) ic.deferredCartoon2d.resolve();
                    //});
                }
                else {
    */               
                    //await this.getNodesLinksForSetCartoonBase(type);
                    await this.getNodesLinksForSetCartoon(type);

                    ic.graphStr = thisClass.getCartoonData(type, ic.node_link);

                    //ic.viewInterPairsCls.drawGraphWrapper(ic.graphStr, ic.deferredCartoon2d, true);
                    let html = thisClass.getCartoonSvg(type, ic.graphStr);

                    $("#" + me.svgid_ct).html(html);
                    thisClass.setEventsForCartoon2d();

                    me.htmlCls.dialogCls.openDlg('dl_2dctn', '2D Cartoon');
    //            }
            }
        }

        getCartoonSvg(type, graphStr) { let ic = this.icn3d, me = ic.icn3dui;
            //let html = "<svg id='" + me.svgid_ct + "' viewBox='" + "0,0," + me.htmlCls.width2d + "," + me.htmlCls.width2d + "'>";
            let html = "";

            let strokecolor = '#bbbbbb';
            let linestrokewidth = '1';

            let nodeHtml = "";

            let graph = JSON.parse(graphStr);
            ic.ctnNodeHash = {};
            for(let i = 0, il = graph.nodes.length; i < il; ++i) {
                let node = graph.nodes[i];
                ic.ctnNodeHash[node.id] = node;

                if(type == 'secondary') {
                    nodeHtml += this.drawHelix(type, node.id, node.ss, node.x, node.y, node.x1, node.y1, node.x2, node.y2, node.len, node.ang, node.c);
                }
                else {
                    nodeHtml += this.drawOval(type, node.id, node.x, node.y, node.rx, node.ry, node.ang, node.c, node.from, node.to);
                }
            }

            ic.nodeid2lineid = {};
            for(let i = 0, il = graph.links.length; i < il; ++i) {
                let id1 = graph.links[i].source;
                let id2 = graph.links[i].target;

                let x1 = ic.ctnNodeHash[id1].x, y1 = me.htmlCls.width2d - ic.ctnNodeHash[id1].y, x2 = ic.ctnNodeHash[id2].x, y2 = me.htmlCls.width2d - ic.ctnNodeHash[id2].y;

                if(type == 'chain') {
                    html += "<g class='icn3d-ctinteraction' chainid1='" + ic.ctnNodeHash[id1].id + "' chainid2='" + ic.ctnNodeHash[id2].id + "' >";
                }
                else if(type == 'domain') {
                    html += "<g class='icn3d-ctinteraction' from1='" + ic.ctnNodeHash[id1].from + "' to1='" + ic.ctnNodeHash[id1].to
                        + "' from2='" + ic.ctnNodeHash[id2].from + "' to2='" + ic.ctnNodeHash[id2].to + "' >";
                }
                else if(type == 'secondary') {
                    x1 = ic.ctnNodeHash[id1].x2, y1 = me.htmlCls.width2d - ic.ctnNodeHash[id1].y2, x2 = ic.ctnNodeHash[id2].x1, y2 = me.htmlCls.width2d - ic.ctnNodeHash[id2].y1;

                    html += "<g class='icn3d-ctinteraction' range1='" + ic.ctnNodeHash[id1].range + "' range2='" + ic.ctnNodeHash[id2].range + "' >";
                }

                let idStr1 = this.getLabelFromId(id1, type);
                let idStr2 = this.getLabelFromId(id2, type);
                let idpair = id1 + "--" + id2;

                html += "<title>Interaction of " + type + " " + idStr1 + " with " + type + " " + idStr2 + "</title>";
                html += "<line class='icn3d-edge' id='" + idpair + "' x1='" + x1 + "' y1='" + y1 + "' x2='" + x2 + "' y2='" + y2 + "' stroke='" + strokecolor + "' stroke-width='" + linestrokewidth + "' /></g>";

                if(!ic.nodeid2lineid.hasOwnProperty(id1)) {
                    ic.nodeid2lineid[id1] = [];
                }
                if(!ic.nodeid2lineid.hasOwnProperty(id2)) {
                    ic.nodeid2lineid[id2] = [];
                }
                ic.nodeid2lineid[id1].push(idpair);
                ic.nodeid2lineid[id2].push(idpair);
            }

            html += nodeHtml; // draw chemicals at the bottom layer

            //html += "</svg>";

            return html;
        }

        setEventsForCartoon2d() {  let ic = this.icn3d, me = ic.icn3dui;
            //https://stackoverflow.com/questions/1108480/svg-draggable-using-jquery-and-jquery-svg
            $("#" + me.svgid_ct + " .icn3d-ctnode")
            .draggable({
                start: function( e, ui ) {
                    let oriCx = parseFloat(e.target.getAttribute('cx'));
                    let oriCy = parseFloat(e.target.getAttribute('cy'));

                    e.target.setAttribute('cx', oriCx);
                    e.target.setAttribute('cy', oriCy);

                    let angle = e.target.getAttribute('ang');

                    if(angle) {
                        // update coordinates manually, since top/left style props don't work on SVG
                        e.target.setAttribute('transform', "rotate(" + angle + "," + oriCx + "," + oriCy + ")");
                    }
                    else {
                        let x1 = parseFloat(e.target.getAttribute('x1'));
                        let y1 = parseFloat(e.target.getAttribute('y1'));

                        let x2 = parseFloat(e.target.getAttribute('x2'));
                        let y2 = parseFloat(e.target.getAttribute('y2'));

                        e.target.setAttribute('x1', x1);
                        e.target.setAttribute('y1', y1);
                        e.target.setAttribute('x2', x2);
                        e.target.setAttribute('y2', y2);
                    }
                },
                drag: function( e, ui ) {
                    let offsetX = $("#" + me.svgid_ct).offset().left;
                    let offsetY = $("#" + me.svgid_ct).offset().top;

                    let id = e.target.getAttribute('id');
                    let angle = e.target.getAttribute('ang');

                    //let cx = ui.position.left - offsetX;
                    //let cy = ui.position.top - offsetY;
                    let cx = (e.clientX - offsetX);
                    let cy = (e.clientY - offsetY);

                    let oriCx = parseFloat(e.target.getAttribute('cx'));
                    let oriCy = parseFloat(e.target.getAttribute('cy'));

                    // change for each step
                    let dx = (cx - oriCx) / ic.resizeRatioX;
                    let dy = (cy - oriCy) / ic.resizeRatioY;

                    // move the text label
                    let oriX = parseFloat($("#" + id + "_text").attr('x'));
                    let oriY = parseFloat($("#" + id + "_text").attr('y'));

                    $("#" + id + "_text").attr('x', oriX + dx);
                    $("#" + id + "_text").attr('y', oriY + dy);

                    // update the center
                    e.target.setAttribute('cx', cx);
                    e.target.setAttribute('cy', cy);

                    if(angle) {
                        // update coordinates manually, since top/left style props don't work on SVG
                        e.target.setAttribute('transform', "rotate(" + angle + "," + cx + "," + cy + ")");
                    }
                    else {
                        let x1 = parseFloat(e.target.getAttribute('x1'));
                        let y1 = parseFloat(e.target.getAttribute('y1'));

                        let x2 = parseFloat(e.target.getAttribute('x2'));
                        let y2 = parseFloat(e.target.getAttribute('y2'));

                        e.target.setAttribute('x1', x1 + dx);
                        e.target.setAttribute('y1', y1 + dy);
                        e.target.setAttribute('x2', x2 + dx);
                        e.target.setAttribute('y2', y2 + dy);

                        // move the outer box for sheets
                        if(id.substr(0, 1) == 'S') {
                            let oriX1 = parseFloat($("#" + id + "_box").attr('x1'));
                            let oriY1 = parseFloat($("#" + id + "_box").attr('y1'));
                            let oriX2 = parseFloat($("#" + id + "_box").attr('x2'));
                            let oriY2 = parseFloat($("#" + id + "_box").attr('y2'));

                            $("#" + id + "_box").attr('x1', oriX1 + dx);
                            $("#" + id + "_box").attr('y1', oriY1 + dy);
                            $("#" + id + "_box").attr('x2', oriX2 + dx);
                            $("#" + id + "_box").attr('y2', oriY2 + dy);
                        }
                    }

                    // update the edges
                    if(ic.nodeid2lineid[id]) {
                        for(let i = 0, il = ic.nodeid2lineid[id].length; i < il; ++i) {
                            let idpair = ic.nodeid2lineid[id][i];

                            updateEdges(idpair, id, angle);
                        }
                    }

                    function updateEdges(idpair, id, angle) {
                        if(idpair && idpair.indexOf(id) != -1) {
                            let idArray = idpair.split('--');
                            if(idArray.length == 2) {
                                let id1, id2;

                                id1 = idArray[1];
                                id2 = idArray[0];

                                let posX1 = (angle) ? 'cx' : 'x1';
                                let posY1 = (angle) ? 'cy' : 'y1';

                                let x1 = $("#" + id1).attr(posX1);
                                let y1 = $("#" + id1).attr(posY1);

                                $("#" + idpair).attr('x1', x1);
                                $("#" + idpair).attr('y1', y1);

                                let posX2 = (angle) ? 'cx' : 'x2';
                                let posY2 = (angle) ? 'cy' : 'y2';

                                let x2 = $("#" + id2).attr(posX2);
                                let y2 = $("#" + id2).attr(posY2);

                                $("#" + idpair).attr('x2', x2);
                                $("#" + idpair).attr('y2', y2);
                            }
                        } // if
                    } // function
                }
            });
        }

        getLabelFromId(id, type) {
            let idStr = id;
            let pos = idStr.indexOf('__');
            if (pos !== -1) idStr = idStr.substr(0, pos);
            if(type == 'secondary') {
                idStr = idStr.substr(0, idStr.indexOf('-'));
            }
            else {
                idStr = idStr; //idStr.substr(idStr.lastIndexOf('_') + 1);
            }

            return idStr;
        }

        drawHelix(type, id, ss, x, y, x1, y1, x2, y2, length, angle, color) { let ic = this.icn3d, me = ic.icn3dui;
            let helixstrokewidth = '3';
            let helixstrokewidth2 = '1';
            let textcolor = '#000000';
            let adjustx = 0, adjusty = 4;

            let idStr = this.getLabelFromId(id, type);
            y = me.htmlCls.width2d - y; // flip
            y1 = me.htmlCls.width2d - y1; // flip
            y2 = me.htmlCls.width2d - y2; // flip

            let range = idStr.substr(1);
            //let html = "<g class='icn3d-node' range='" + range + "' >";
            let html = "<g range='" + range + "' >";
            html += "<title>" + type + " " + idStr + "</title>";

            if(id.substr(0,1) == 'H') {
                html += "<line id='" + id + "' class='icn3d-ctnode' x1='" + x1 + "' y1='" + y1 + "' x2='" + x2 + "' y2='" + y2 + "' cx='" + 0.5*(x1+x2).toFixed(1) + "' cy='" + 0.5*(y1+y2).toFixed(1) + "' stroke='#" + color + "' stroke-width='" + helixstrokewidth + "' stroke-linecap='round' />";
            }
            else {
                html += "<line id='" + id + "_box' x1='" + x1 + "' y1='" + y1 + "' x2='" + x2 + "' y2='" + y2 + "' stroke='#" + color + "' stroke-width='" + helixstrokewidth + "' stroke-linecap='square' />";
                html += "<line id='" + id + "' class='icn3d-ctnode' x1='" + x1 + "' y1='" + y1 + "' x2='" + x2 + "' y2='" + y2 + "' cx='" + 0.5*(x1+x2).toFixed(1) + "' cy='" + 0.5*(y1+y2).toFixed(1) + "' stroke='#FFF' stroke-width='" + helixstrokewidth2 + "' stroke-linecap='square' />";
            }

            html += "<text id='" + id + "_text' x='" +(x - adjustx).toString() + "' y='" +(y + adjusty).toString() + "' style='fill:" + textcolor + "; text-anchor:middle' class='icn3d-node-text8' >" + idStr + "</text>";

            html += "</g>";

            return html;
        }

        drawOval(type, id, x, y, rx, ry, angle, color, from, to) { let ic = this.icn3d, me = ic.icn3dui;
            let strokecolor = 'none';
            let strokewidth = '1';
            let textcolor = '#000000';
            let adjustx = 0, adjusty = 4;

            let idStr = this.getLabelFromId(id, type);
            y = me.htmlCls.width2d - y; // flip
            angle = 180 - angle; // flip

            let html = (type == 'chain') ? "<g chainid='" + id + "' >"
                : "<g from='" + from + "' to='" + to + "' >";
            html += "<title>" + type + " " + idStr + "</title>";

            html += "<defs>";
            html += "<linearGradient id='" + id + "_g_obj' x1='0%' y1='0%' x2='100%' y2='0%'>";
            html += "  <stop offset='0%' style='stop-color:rgb(255,255,255);stop-opacity:1' />";
            html += "  <stop offset='100%' style='stop-color:#" + color + ";stop-opacity:1' />";
            html += "</linearGradient>";
            html += "</defs>";

            html += "<ellipse id='" + id + "' class='icn3d-ctnode' cx='" + x.toFixed(0) + "' cy='" + y.toFixed(0) + "' rx='" + rx.toFixed(0) + "' ry='" + ry.toFixed(0) + "' fill='url(#" + id + "_g_obj)' stroke-width='" + strokewidth + "' stroke='" + strokecolor + "' ";
            html += " ang='" + angle + "' transform='rotate(" + angle + "," + x.toFixed(0) + "," + y.toFixed(0) + ")'";
            html += (type == 'chain') ? " chainid='" + id + "' />" : " from='" + from + "' to='" + to + "' />";

            html += "<text id='" + id + "_text' x='" +(x - adjustx).toString() + "' y='" +(y + adjusty).toString() + "' style='fill:" + textcolor + "; text-anchor:middle' class='icn3d-node-text12' >" + idStr + "</text>";

            html += "</g>";

            return html;
        }

        getCartoonData(type, node_link) { let ic = this.icn3d; ic.icn3dui;
           // get the nodes and links data
           let nodeArray = [], linkArray = [];
           let nodeStr, linkStr;

           nodeArray = node_link.node;

           // removed duplicated nodes
           let nodeJsonArray = [];
           let checkedNodeidHash = {};
           let cnt = 0;
           for(let i = 0, il = nodeArray.length; i < il; ++i) {
               let node = nodeArray[i];
               let nodeJson = JSON.parse(node);
               if(!checkedNodeidHash.hasOwnProperty(nodeJson.id)) {
                   nodeJsonArray.push(nodeJson);
                   checkedNodeidHash[nodeJson.id] = cnt;
                   ++cnt;
               }
           }
           let nodeStrArray = [];
           for(let i = 0, il = nodeJsonArray.length; i < il; ++i) {
               let nodeJson = nodeJsonArray[i];
               nodeStrArray.push(JSON.stringify(nodeJson));
           }
           nodeStr = nodeStrArray.join(', ');
           // linkStr
           linkArray = node_link.link;
           linkStr = linkArray.join(', ');

           ic.hAtoms;
           let chemicalNodeStr = '';
           let hBondLinkStr = '', ionicLinkStr = '', halogenpiLinkStr = '', contactLinkStr = '',
             disulfideLinkStr = '', crossLinkStr = '';

    //       contactLinkStr += ic.getGraphCls.getContactLinksForSet(ic.hAtoms, 'chain', true);

           let resStr = '{"nodes": [' + nodeStr + chemicalNodeStr + '], "links": [';
           resStr += linkStr + disulfideLinkStr + crossLinkStr + contactLinkStr + hBondLinkStr + ionicLinkStr + halogenpiLinkStr;

           let level = (node_link.level) ? node_link.level : '';
           resStr += '], "level": "' + level + '"}';
           return resStr;
        }

        // async getNodesLinksForSetCartoon(type) { let ic = this.icn3d, me = ic.icn3dui;
        //   await this.getNodesLinksForSetCartoonBase(type);
        // }

        projectTo2d(v3) { let ic = this.icn3d, me = ic.icn3dui;
            let v2 = v3.project( ic.cam );

            var realV3 = new THREE.Vector3();
            realV3.x = Math.round((v2.x + 1) * me.htmlCls.width2d * 0.5);
            realV3.y = Math.round((-v2.y) * me.htmlCls.width2d * 0.5);
            realV3.z = 0;

            if(realV3.y > 0) {
                realV3.y = me.htmlCls.width2d - realV3.y;
            }
            else {
                realV3.y = -realV3.y;
            }

            return realV3;
        }

        //async getNodesLinksForSetCartoonBase(type) { let ic = this.icn3d, me = ic.icn3dui;
        async getNodesLinksForSetCartoon(type) { let ic = this.icn3d, me = ic.icn3dui;
           let thisClass = this;

           let nodeArray = [], linkArray = [];
           let cnt = 0;
           let thickness = me.htmlCls.defaultValue; // 1

           let prevChain = '', prevResName = '', prevAtom, lastChain = '';
           let x, y;
           let bBegin = false, bEnd = true;
           let resName, residLabel;

           if(type == 'chain') {
               let chainidHash = {};
               for(let i in ic.hAtoms) {
                   let atom = ic.atoms[i];
                   if(atom.chain == 'DUM') continue;

                   let chainid = atom.structure + '_' + atom.chain;

                   if(ic.proteins.hasOwnProperty(i) || ic.nucleotides.hasOwnProperty(i)) {
                       if(!chainidHash.hasOwnProperty(chainid)) {
                           chainidHash[chainid] = {};
                       }
                       chainidHash[chainid][atom.serial] = atom;
                   }
               }

               let min_max_center = ic.contactCls.getExtent(ic.atoms);

               let minX=9999, minY=9999, maxX=-9999, maxY=-9999, maxR = -9999;
               let itemArray = [];
               for(let chainid in chainidHash) {
                   ic.hAtom = {};
                   ic.hAtoms = me.hashUtilsCls.cloneHash(ic.chains[chainid]);

                   let center_x_y_z = ic.axesCls.setPc1Axes();
                   let center = center_x_y_z[0];
                   let rx = center_x_y_z[1].distanceTo(center_x_y_z[0]);
                   let ry = center_x_y_z[2].distanceTo(center_x_y_z[0]);
                   let angle = new THREE.Vector2(center_x_y_z[1].x - center_x_y_z[0].x, center_x_y_z[1].y - center_x_y_z[0].y).angle() * 180 / Math.PI;
                   if(angle > 180) angle -= 180;

                   let serial = Object.keys(ic.hAtoms)[0];
                   let atom = ic.atoms[serial];

                   residLabel = chainid; //.substr(chainid.lastIndexOf('_') + 1); //chainid;
                   //let shapeid = 0;

                   center = this.projectTo2d(center);
                   let x = center.x;
                   let y = center.y;

                   if(x < minX) minX = x;
                   if(x > maxX) maxX = x;
                   if(y < minY) minY = y;
                   if(y > maxY) maxY = y;

                   //let x = me.htmlCls.width2d * (center.x - min_max_center[0][0]) / (min_max_center[1][0] - min_max_center[0][0]);
                   //let y = me.htmlCls.width2d * (center.y - min_max_center[0][1]) / (min_max_center[1][1] - min_max_center[0][1]);

                   let factor = 0.5;
                   rx = factor * me.htmlCls.width2d * rx / (min_max_center[1][0] - min_max_center[0][0]);
                   ry = factor * me.htmlCls.width2d * ry / (min_max_center[1][1] - min_max_center[0][1]);

                   if(rx > maxR) maxR = rx;
                   if(ry > maxR) maxR = ry;

                   itemArray.push({"id":chainid, "r":residLabel, "x":x, "y":y, "rx":rx, "ry":ry,
                     "ang":angle, "c":atom.color.getHexString()});
               }

               let offset = maxR + 2;
               let rangeX = maxX - minX, rangeY = maxY - minY;

               for(let i = 0, il = itemArray.length; i < il; ++i) {
                   let item = itemArray[i];
                   let x = (rangeX < 1) ? 0.5 * me.htmlCls.width2d : (item.x - minX) / rangeX * (me.htmlCls.width2d - 2 * offset) + offset;
                   let y = (rangeY < 1) ? 0.5 * me.htmlCls.width2d : (item.y - minY) / rangeY * (me.htmlCls.width2d - 2 * offset) + offset;

                   nodeArray.push('{"id": "' + item.id + '", "r": "' + item.r //+ '", "s": "' + setName
                       + '", "x": ' + x.toFixed(0) + ', "y": ' + y.toFixed(0)
                       + ', "rx": ' + item.rx.toFixed(0) + ', "ry": ' + item.ry.toFixed(0)
                       + ', "ang": ' + item.ang.toFixed(0) //+ ', "shape": ' + shapeid
                       + ', "c": "' + item.c.toUpperCase() + '"}');
               }

               ic.hAtoms = me.hashUtilsCls.cloneHash(ic.dAtoms);

               ic.node_link = {"node": nodeArray, "link":linkArray, "level": "chain"};
           }
           else if(type == 'domain') {
    /*
               if(!ic.chainid2pssmid) { // mmtf data do NOT have the missing residues
                    //$.when(ic.loadScriptCls.applyCommandAnnotationsAndCddSite('view annotations')).then(function() {
                        await ic.loadScriptCls.applyCommandAnnotationsAndCddSite('view annotations');
                        thisClass.getNodesLinksForDomains(ic.chainid2pssmid);
                        /// if(ic.deferredCartoonData !== undefined) ic.deferredCartoonData.resolve();
                        //return;
                    //});
               }
               else {
                   thisClass.getNodesLinksForDomains(ic.chainid2pssmid);
                   /// if(ic.deferredCartoonData !== undefined) ic.deferredCartoonData.resolve();
                   //return;
               }
    */

                if(!ic.chainid2pssmid) { // mmtf data do NOT have the missing residues
                    await ic.loadScriptCls.applyCommandAnnotationsAndCddSite('view annotations');
                }

                thisClass.getNodesLinksForDomains(ic.chainid2pssmid);
           }
           else if(type == 'secondary') {
               ic.resi2resirange = {};
               let resiArray = [], tmpResName;

               ic.contactCls.getExtent(ic.atoms);

               let ss = '';

               let minX=9999, minY=9999, maxX=-9999, maxY=-9999, maxR = 2;
               let itemArray = [];
               for(let i in ic.hAtoms) {
                   let atom = ic.atoms[i];
                   if(atom.chain == 'DUM') continue;

                   if((atom.ssbegin || atom.ssend) && atom.name == "CA" && atom.elem == "C") {
                       let resid = atom.structure + '_' + atom.chain + '_' + atom.resi;

                       //if((prevChain === '' || prevChain == atom.chain) && bEnd && atom.ssbegin) {
                       if(bEnd && atom.ssbegin) {
                           bBegin = true;
                           bEnd = false;

                           prevAtom = atom;

                           ss = (atom.ss == 'helix') ? 'H' : 'S';

                           resName = ss + atom.resi;
                           // add 1_1_ to match other conventionssuch as seq_div0_1KQ2_A_50
                           residLabel = '1_1_' + resid;

                           lastChain = atom.chain;
                       }

                       if(bBegin) {
                           tmpResName = me.utilsCls.residueName2Abbr(atom.resn) + atom.resi;
                           tmpResName += '__' + atom.chain;
                           if(Object.keys(ic.structures).length > 1) tmpResName += '__' + atom.structure;

                           resiArray.push(tmpResName);
                       }

                       if(lastChain == atom.chain && bBegin && atom.ssend) {
                           let v2a = this.projectTo2d(prevAtom.coord.clone());
                           let x1 = v2a.x;
                           let y1 = v2a.y;

                           let v2b = this.projectTo2d(atom.coord.clone());
                           let x2 = v2b.x;
                           let y2 = v2b.y;

                           x = 0.5 * (x1 + x2);
                           y = 0.5 * (y1 + y2);

                           // use half length of the helix or sheet to make the display clear
                           x1 = 0.5 * (x + x1);
                           y1 = 0.5 * (y + y1);
                           x2 = 0.5 * (x + x2);
                           y2 = 0.5 * (y + y2);

                           if(x1 < minX) minX = x1;
                           if(x1 > maxX) maxX = x1;
                           if(y1 < minY) minY = y1;
                           if(y1 > maxY) maxY = y1;

                           if(x2 < minX) minX = x2;
                           if(x2 > maxX) maxX = x2;
                           if(y2 < minY) minY = y2;
                           if(y2 > maxY) maxY = y2;

                           bBegin = false;
                           bEnd = true;

                           resName += '-' + atom.resi;
                           residLabel += '-' + atom.resi;

                           resName += '__' + atom.chain;
                           if(Object.keys(ic.structures).length > 1) resName += '__' + atom.structure;

                           for(let j = 0, jl = resiArray.length; j < jl; ++j) {
                               tmpResName = resiArray[j];
                               ic.resi2resirange[tmpResName] = resName;
                           }
                           resiArray = [];

                           if(cnt > 0 && prevChain == atom.chain) {
                               linkArray.push('{"source": "' + prevResName + '", "target": "' + resName
                                   + '", "v": ' + thickness + ', "c": "' + prevAtom.color.getHexString().toUpperCase() + '"}');
                           }

                           itemArray.push({"id":resName, "r":residLabel, "ss":ss, "x":x, "y":y,
                             "x1":x1, "y1":y1, "x2":x2, "y2":y2, "c":atom.color.getHexString()});

                           prevChain = atom.chain;
                           prevResName = resName;
                           ++cnt;
                       }
                   }
               } //end for

               let offset = maxR + 2;
               let rangeX = maxX - minX, rangeY = maxY - minY;

               for(let i = 0, il = itemArray.length; i < il; ++i) {
                   let item = itemArray[i];
                   let x = (rangeX < 1) ? 0.5 * me.htmlCls.width2d : (item.x - minX) / rangeX * (me.htmlCls.width2d - 2 * offset) + offset;
                   let y = (rangeY < 1) ? 0.5 * me.htmlCls.width2d : (item.y - minY) / rangeY * (me.htmlCls.width2d - 2 * offset) + offset;
                   let x1 = (rangeX < 1) ? 0.5 * me.htmlCls.width2d : (item.x1 - minX) / rangeX * (me.htmlCls.width2d - 2 * offset) + offset;
                   let y1 = (rangeY < 1) ? 0.5 * me.htmlCls.width2d : (item.y1 - minY) / rangeY * (me.htmlCls.width2d - 2 * offset) + offset;
                   let x2 = (rangeX < 1) ? 0.5 * me.htmlCls.width2d : (item.x2 - minX) / rangeX * (me.htmlCls.width2d - 2 * offset) + offset;
                   let y2 = (rangeY < 1) ? 0.5 * me.htmlCls.width2d : (item.y2 - minY) / rangeY * (me.htmlCls.width2d - 2 * offset) + offset;

                   nodeArray.push('{"id": "' + item.id + '", "r": "' + item.r
                       + '", "x": ' + x.toFixed(0) + ', "y": ' + y.toFixed(0)
                       + ', "x1": ' + x1.toFixed(0) + ', "y1": ' + y1.toFixed(0)
                       + ', "x2": ' + x2.toFixed(0) + ', "y2": ' + y2.toFixed(0)
                       + ', "c": "' + item.c.toUpperCase() + '"}');
               }

               ic.node_link = {"node": nodeArray, "link":linkArray, "level": "secondary"};
           }

           /// if(ic.deferredCartoonData !== undefined) ic.deferredCartoonData.resolve();
        }

        getNodesLinksForDomains(chainid2pssmid) { let ic = this.icn3d, me = ic.icn3dui;
           let nodeArray = [], linkArray = [];
           let thickness = me.htmlCls.defaultValue; // 1

           ic.resi2resirange = {};

           // find the chainids
           let chainidHash = {};
           for(let i in ic.hAtoms) {
               let atom = ic.atoms[i];
               if(atom.chain == 'DUM') continue;

               chainidHash[atom.structure + '_' + atom.chain] = 1;
           }

           let min_max_center = ic.contactCls.getExtent(ic.atoms);

           let minX=9999, minY=9999, maxX=-9999, maxY=-9999, maxR = -9999;
           let itemArray = [];

           // show domains for each chain
           for(let chainid in chainidHash) {
               if(!chainid2pssmid.hasOwnProperty(chainid)) continue;

               let pssmid2name = chainid2pssmid[chainid].pssmid2name;
               let pssmid2fromArray = chainid2pssmid[chainid].pssmid2fromArray;
               let pssmid2toArray = chainid2pssmid[chainid].pssmid2toArray;

               // sort the domains according to the starting residue number
               let pssmid2start = {};
               for(let pssmid in pssmid2name) {
                   let fromArray = pssmid2fromArray[pssmid];
                   pssmid2start[pssmid] = fromArray[0];
               }

               var pssmidArray = Object.keys(pssmid2start);
               pssmidArray.sort(function(a, b) {
                   return pssmid2start[a] - pssmid2start[b]
               });
               let prevDomainName, prevAtom;
               //for(let pssmid in pssmid2name) {
               for(let i = 0, il = pssmidArray.length; i < il; ++i) {
                   let pssmid = pssmidArray[i];

                   let domainName = pssmid2name[pssmid];
                   domainName += '__' + chainid.substr(chainid.indexOf('_') + 1);
                   if(Object.keys(ic.structures).length > 1) domainName += '__' + chainid.substr(0, chainid.indexOf('_'));

                   let fromArray = pssmid2fromArray[pssmid];
                   let toArray = pssmid2toArray[pssmid];

                   ic.hAtoms = {};
                   for(let j = 0, jl = fromArray.length; j < jl; ++j) {
                       let resiStart = parseInt(fromArray[j]) + 1;
                       let resiEnd = parseInt(toArray[j]) + 1;

                       for(let k = resiStart; k <= resiEnd; ++k) {
                           ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.residues[chainid + '_' + k]);
                       }
                   }

                   if(Object.keys(ic.hAtoms).length == 0) continue;

                   //let extent = ic.contactCls.getExtent(atomSet);

                   //let radiusSq = (extent[1][0] - extent[0][0]) * (extent[1][0] - extent[0][0]) + (extent[1][1] - extent[0][1]) * (extent[1][1] - extent[0][1]) + (extent[1][2] - extent[0][2]) * (extent[1][2] - extent[0][2]);
                   //let radius = Math.sqrt(radiusSq);

                   let center_x_y_z = ic.axesCls.setPc1Axes();
                   let center = center_x_y_z[0];
                   let rx = center_x_y_z[1].distanceTo(center_x_y_z[0]);
                   let ry = center_x_y_z[2].distanceTo(center_x_y_z[0]);
                   let angle = new THREE.Vector2(center_x_y_z[1].x - center_x_y_z[0].x, center_x_y_z[1].y - center_x_y_z[0].y).angle() * 180 / Math.PI;
                   if(angle > 180) angle -= 180;

                   let serial = Object.keys(ic.hAtoms)[0];
                   let atom = ic.atoms[serial];
                   //let shapeid = 0;

                   //let x = me.htmlCls.width2d * (center.x - min_max_center[0][0]) / (min_max_center[1][0] - min_max_center[0][0]);
                   //let y = me.htmlCls.width2d * (center.y - min_max_center[0][1]) / (min_max_center[1][1] - min_max_center[0][1]);
                   center = this.projectTo2d(center);
                   let x = center.x;
                   let y = center.y;

                   if(x < minX) minX = x;
                   if(x > maxX) maxX = x;
                   if(y < minY) minY = y;
                   if(y > maxY) maxY = y;

                   let factor = 0.5;
                   rx = factor * me.htmlCls.width2d * rx / (min_max_center[1][0] - min_max_center[0][0]);
                   ry = factor * me.htmlCls.width2d * ry / (min_max_center[1][1] - min_max_center[0][1]);

                   if(rx > maxR) maxR = rx;
                   if(ry > maxR) maxR = ry;

                   if(prevDomainName !== undefined) {
                       linkArray.push('{"source": "' + prevDomainName + '", "target": "' + domainName
                           + '", "v": ' + thickness + ', "c": "' + prevAtom.color.getHexString().toUpperCase() + '"}');
                   }

                   itemArray.push({"id":domainName, "from":fromArray + '', "to":toArray + '', "x":x, "y":y, "rx":rx, "ry":ry,
                     "ang":angle, "c":atom.color.getHexString()});

                   prevDomainName = domainName;
                   prevAtom = atom;
               }
           }

           let offset = maxR + 2;
           let rangeX = maxX - minX, rangeY = maxY - minY;

           for(let i = 0, il = itemArray.length; i < il; ++i) {
               let item = itemArray[i];
               let x = (rangeX < 1) ? 0.5 * me.htmlCls.width2d : (item.x - minX) / rangeX * (me.htmlCls.width2d - 2 * offset) + offset;
               let y = (rangeY < 1) ? 0.5 * me.htmlCls.width2d : (item.y - minY) / rangeY * (me.htmlCls.width2d - 2 * offset) + offset;

               nodeArray.push('{"id": "' + item.id
                   + '", "from": "' + item.from + '", "to": "' + item.to
                   + '", "x": ' + x.toFixed(0) + ', "y": ' + y.toFixed(0)
                   + ', "rx": ' + item.rx.toFixed(0) + ', "ry": ' + item.ry.toFixed(0)
                   + ', "ang": ' + item.ang.toFixed(0)
                   + ', "c": "' + item.c.toUpperCase() + '"}');
           }

           ic.hAtoms = me.hashUtilsCls.cloneHash(ic.dAtoms);

           ic.node_link = {"node": nodeArray, "link":linkArray, "level": "domain"};

           //return {"node": nodeArray, "link":linkArray};
        }

        getSelection(idArray, from, to) { let ic = this.icn3d, me = ic.icn3dui;
            let atomSet = {};
            let residArray = [];

            let fromArray = from.toString().split(',');
            let toArray = to.toString().split(',');

            let structure = (idArray.length == 3) ? idArray[2] : Object.keys(ic.structures)[0];
            let chainidTmp = (idArray.length >= 2) ? structure + '_' + idArray[1] : Object.keys(ic.chains)[0];

            for(let i = 0, il = fromArray.length; i < il; ++i) {
                let from = parseInt(fromArray[i]) + 1;
                let to = parseInt(toArray[i]) + 1;
                for(let j = from; j <= to; ++j) {
                    let resid = chainidTmp + '_' + j;
                    atomSet = me.hashUtilsCls.unionHash(atomSet, ic.residues[resid]);
                    residArray.push(resid);
                }
            }

            return {"atomSet": atomSet, "residArray": residArray};
        }

        click2Dcartoon() { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            me.myEventCls.onIds("#" + me.pre + "2dctn_chain", "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();
               thisClass.initCartoonSvg();

               //if(!me.cfg.notebook) dialog.dialog( "close" );
               await ic.cartoon2dCls.draw2Dcartoon('chain');
            });

            me.myEventCls.onIds("#" + me.pre + "2dctn_domain", "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();
               thisClass.initCartoonSvg();

               //if(!me.cfg.notebook) dialog.dialog( "close" );
               await ic.cartoon2dCls.draw2Dcartoon('domain');
            });

            me.myEventCls.onIds("#" + me.pre + "2dctn_secondary", "click", async function(e) { let ic = me.icn3d;
               e.preventDefault();
               thisClass.initCartoonSvg();

               //if(!me.cfg.notebook) dialog.dialog( "close" );
               await ic.cartoon2dCls.draw2Dcartoon('secondary');
            });

            $(document).on("click", "#" + ic.pre + "dl_2dctn .icn3d-ctnode", function(e) { let ic = thisClass.icn3d;
                e.stopImmediatePropagation();
                if(Object.keys(ic.hAtoms).length < Object.keys(ic.atoms).length) ic.definedSetsCls.setMode('selection');

                //ic.bClickInteraction = false;

                let atomSet = {}, residArray = [], type;

                let id = $(this).attr('id');
                let chainid = $(this).attr('chainid');
                let from = $(this).attr('from');
                let to = $(this).attr('to');
                let x1 = $(this).attr('x1');

                if(chainid !== undefined) {
                    type = 'chain';
                    atomSet = ic.chains[chainid];
                }
                else if(from !== undefined) {
                    type = 'domain';

                    let idArray = id.split('__');
                    let result = thisClass.getSelection(idArray, from, to);
                    atomSet = result.atomSet;
                    residArray = result.residArray;
                }
                else if(x1 !== undefined) {
                    type = 'secondary';

                    let idArray = id.split('__');
                    let from_to = idArray[0].substr(1).split('-');
                    let from = parseInt(from_to[0]) - 1; // 0-based
                    let to = parseInt(from_to[1]) - 1;
                    let result = thisClass.getSelection(idArray, from, to);
                    atomSet = result.atomSet;
                    residArray = result.residArray;
                }

                // clear all nodes
                if(!ic.bCtrl && !ic.bShift) {
                    ic.selectionCls.removeSelection();

                    // ic.lineArray2d is used to highlight lines in 2D diagram
                    ic.lineArray2d = [];
                }
                if(ic.alnChains[chainid] !== undefined) 1.0 * Object.keys(ic.alnChains[chainid]).length / Object.keys(ic.chains[chainid]).length;

                if(!ic.bCtrl && !ic.bShift) {
                    ic.hAtoms = me.hashUtilsCls.cloneHash(atomSet); //ic.chains[chainid]);
                }
                else {
                    ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, atomSet); //ic.chains[chainid]);
                }

                // get the name array
                if(type == 'chain') {
                    if(!ic.bCtrl && !ic.bShift) {
                        ic.chainArray2d = [chainid];
                    }
                    else {
                        if(ic.chainArray2d === undefined) ic.chainArray2d = [];
                        ic.chainArray2d.push(chainid);
                    }

                    ic.hlUpdateCls.updateHlAll(ic.chainArray2d);
                }
                else {
                    ic.hlUpdateCls.updateHlAll();
                }

                // show selected chains in annotation window
                ic.annotationCls.showAnnoSelectedChains();

                let select = (type == 'chain') ? "select chain " + chainid : "select " + ic.resid2specCls.residueids2spec(residArray);
                me.htmlCls.clickMenuCls.setLogCmd(select, true);

                ic.bSelectResidue = false;
            });
        }

        initCartoonSvg() { let ic = this.icn3d, me = ic.icn3dui;
           ic.resizeRatioX = 1.0;
           ic.resizeRatioY = 1.0;
           $("#" + me.svgid_ct).empty();
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Ligplot {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        async drawLigplot(atomSet1, bDepiction) { let ic = this.icn3d, me = ic.icn3dui;
            if(bDepiction) {
                me.htmlCls.dialogCls.openDlg('dl_ligplot', '2D Depiction');
            }
            else {
                me.htmlCls.dialogCls.openDlg('dl_ligplot', 'Show ligand interactions with atom details');
            }

            let widthOri, heightOri, width = 100, height = 100;
            ic.len4ang = 80;

            // get SVG from backend
            let pdbStr = ic.saveFileCls.getAtomPDB(atomSet1);
            pdbStr = pdbStr.trim();
            pdbStr = pdbStr.replace(/\n\n/g, '\n'); // remove empty lines

            let dataObj = {'pdb2svg': pdbStr};
            let url = me.htmlCls.baseUrl + "openbabel/openbabel.cgi"; 
            let dataStr = await me.getAjaxPostPromise(url, dataObj, undefined, undefined, undefined, undefined, 'text');

            let lineArray = dataStr.split('\n');
            let lineSvg = '', nodeSvg = '', index2xy = {};
            let xsum = 0, ysum = 0, cnt = 0;
            ic.svgGridSize = ic.len4ang; // make the scg into many  grids to tell whether the grid is empty, 30 is about bond length (1.5 angstrom)
            ic.gridXY2used = {};
            for(let i = 0, il = lineArray.length; i < il; ++i) {
                let line = lineArray[i];
                if(line.indexOf('<svg width') == 0) { 
                    //<svg width="100" height="100" x="0" y="0" viewBox="0 0 634.256 380"
                    // get real width and height
                    let start = line.indexOf('viewBox="') + 9;
                    let linePart = line.substr(start);
                    let viewbox = linePart.substr(0, linePart.indexOf('"'));
                    let viewboxArray = viewbox.split(' ');
                    widthOri = parseFloat(viewboxArray[2]);
                    heightOri = parseFloat(viewboxArray[3]);
                    width = widthOri + 2*ic.len4ang;
                    height = heightOri + 2*ic.len4ang;
                }
                else if(line.indexOf('<line') == 0) { 
                    lineSvg += line + '\n';
                }
                else if(line.indexOf('<text') == 0) { 
                    if(line.indexOf('font-size="12"') != -1) { 
                        // index node
                        //<text x="40.000000" y="120.000000" fill="rgb(255,0,0)" stroke-width="0" font-weight="bold" font-size="12" >1</text>
                        let start = line.indexOf('>') + 1;
                        let indexPart = line.substr(start);
                        let index = parseInt(indexPart.substr(0, indexPart.indexOf('<')));
                        
                        start = line.indexOf('x="') + 3;
                        let xPart = line.substr(start);
                        let x = parseFloat(xPart.substr(0, xPart.indexOf('"')));

                        start = line.indexOf('y="') + 3;
                        let yPart = line.substr(start);
                        let y = parseFloat(yPart.substr(0, yPart.indexOf('"')));

                        index2xy[index] = {"x": x, "y": y};
                        let xGrid = parseInt(x / ic.svgGridSize);
                        let yGrid = parseInt(y / ic.svgGridSize);
                        ic.gridXY2used[xGrid + '_' + yGrid] = 1;

                        xsum += x;
                        ysum += y;
                        ++cnt;
                    }
                    else { // font-size > 12
                        nodeSvg += line + '\n';
                    }
                }
                else if(line.indexOf('</svg>') == 0) { 
                    break;
                }
            }

            let xcenter = xsum / cnt, ycenter = ysum / cnt;

            let id = me.ligplotid;
            ic.ligplotWidth = width;
            let graphWidth = ic.ligplotWidth;
            
            let textHeight = 30;
            let heightAll = height + textHeight;

            let offset = - ic.len4ang;
            let svgHtml = "<svg id='" + id + "' viewBox='" + offset + "," + offset + "," + width + "," + heightAll + "' width='" + graphWidth + "px' font-family='sans-serif' stroke='rgb(0,0,0)' stroke-width='2' stroke-linecap='round'>";

            if(bDepiction) {
                svgHtml += lineSvg + nodeSvg;
            }
            else {
                let xlen = parseInt(widthOri / ic.svgGridSize), ylen = parseInt(heightOri / ic.svgGridSize);
                let result = ic.viewInterPairsCls.getAllInteractionTable("save1", index2xy, xlen, ylen, xcenter, ycenter); // sort on the ligand/set1
                // ic.bLigplot = true;

                svgHtml += lineSvg + result.svgHtmlLine;

                svgHtml += nodeSvg + result.svgHtmlNode;
            }

            svgHtml += "</svg>";

            if(bDepiction) {
                $("#" + ic.pre + "ligplotDiv").html(svgHtml);
            }
            else {
                $("#" + ic.pre + "ligplotDiv").html(svgHtml);
                this.setEventsForLigplot();
            }  
        }

        
        getSvgPerPair(serialArray1, resid1, resid2, interactionType, index2xy, xlen, ylen, xcenter, ycenter, dist, bNotDrawNode, prevX2, prevY2) { let ic = this.icn3d, me = ic.icn3dui;
            let xOffset = 1, yOffset = -1;
            let bondLen = (interactionType == 'hbond' || interactionType == 'contact' || interactionType == 'halogen') ? ic.len4ang : ic.len4ang * 1.5; // real distance should be bout 120, not 80
            let shortBondLen = ic.len4ang / 2;
            let strokeWidth = (interactionType == 'contact') ? 1 : 2;

            let resid1Real = ic.getGraphCls.convertLabel2Resid(resid1);
            let atom1 = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid1Real]);
            let resid2Real = ic.getGraphCls.convertLabel2Resid(resid2);
            let atom2 = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid2Real]);

            let xSum = 0, ySum = 0, cntPoint = 0;
            let baseSerial = atom1.serial;
            for(let i = 0, il = serialArray1.length; i < il; ++i) {
                let index = serialArray1[i] - baseSerial + 1;
                xSum += index2xy[index].x;
                ySum += index2xy[index].y;
                ++cntPoint;
            }

            let x1 = xSum / cntPoint - xOffset;
            let y1 = ySum / cntPoint - yOffset;

            if(!ic.resid2cnt.hasOwnProperty(resid1)) {
                ic.resid2cnt[resid1] = 0;
            }
            else {
                ++ic.resid2cnt[resid1];
            }

            let x2, y2, angle;
            if(!bNotDrawNode && !ic.resid2ToXy.hasOwnProperty(resid2Real)) {
                // 1st and ideal way to find a position. If failed, use the 2nd way
                let xGrid = parseInt(x1 / ic.svgGridSize);
                let yGrid = parseInt(y1 / ic.svgGridSize);
                let gridArray = [];
                for(let i = 1; i >= -1; --i) { // try right-bottom first
                    for(let j = 1; j >= -1; --j) {
                        if(!(i == 0 && j == 0)) {
                            if(xGrid + i >= 0 && xGrid + i <= xlen && yGrid + j >= 0 && yGrid + j <= ylen) gridArray.push((xGrid + i) + '_' + (yGrid + j));
                        }
                    }
                }
                for(let i = 2; i >= -2; --i) { // try right-bottom first
                    for(let j = 2; j >= -2; --j) {
                        if(!(i >= -1 && i <= 1 && j >= -1 && j <= 1 )) {
                            if(xGrid + i >= 0 && xGrid + i <= xlen && yGrid + j >= 0 && yGrid + j <= ylen) gridArray.push((xGrid + i) + '_' + (yGrid + j));
                        }
                    }
                }

                let bFound = false, xyGrids;
                for(let i = 0, il = gridArray.length; i < il; ++i) {
                    if(!ic.gridXY2used[gridArray[i]]) { // found a spot to put the residue
                        xyGrids = gridArray[i].split('_');
                        x2 = (parseInt(xyGrids[0]) + 0.5) * ic.svgGridSize;
                        y2 = (parseInt(xyGrids[1]) + 0.5) * ic.svgGridSize;

                        let dist = Math.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));
                        let x2b = bondLen / dist * (x2 - x1) + x1;
                        let y2b = bondLen / dist * (y2 - y1) + y1;
                        x2 = x2b;
                        y2 = y2b;

                        ic.gridXY2used[gridArray[i]] = 1;
                        bFound = true;
                        break;
                    }
                }
                
                if(!bFound) {
                    // 2nd way to find a position from the center to the outside
                    let dx = x1 - xcenter;
                    let dy = y1 - ycenter;

                    let baseAngle = 0;
                    if(Math.abs(dx) > Math.abs(dy)) { // extend along x-axis
                        if(dx > 0) { // +x direction
                            baseAngle = 0;
                        }
                        else { // -x direction
                            baseAngle = 180;
                        }
                    }
                    else { // extend along y-axis
                        if(dy > 0) { // +y direction
                            baseAngle = 90;
                        }
                        else { // -y direction
                            baseAngle = 270;
                        }
                    }
                    angle = baseAngle - 10 + ic.resid2cnt[resid1] * 30; 

                    x2 = x1 + bondLen * Math.cos(angle * Math.PI/180);
                    y2 = y1 + bondLen * Math.sin(angle * Math.PI/180);
                }
            }

            let oneLetterRes = me.utilsCls.residueName2Abbr(atom2.resn.substr(0, 3));
            let resName2 = oneLetterRes + atom2.resi;
            let textColor2 = (atom2.color) ? atom2.color.getHexString() : '000';
            let lineColor = ic.lineGraphCls.getStrokecolor(undefined, interactionType);

            // let node = '<circle cx="' + x2 + '" cy="' + y2 + '" r="8" fill="#' + textColor2 + '" stroke-width="1" stroke="' + textColor2 + '" resid="' + resid2 + '"></circle>\n<text x="' + x2 + '" y="' + y2 + '" stroke="#000" stroke-width="1px" text-anchor="middle" alignment-baseline="central" font-size="8px">' + resName2 + '</text>';
          
            let node = '', line = '';

            // id can't contain comma and thus use '-'
            // sometimes the same ligand atom is used in both Hbond and contact. THus we add "interactionType"
            let idpair = resid2Real + '--' + serialArray1.join('-') + interactionType; 

            let interactionTypeStr;
            if(interactionType == 'hbond') {
                interactionTypeStr = 'H-Bonds';
            }
            else if(interactionType == 'ionic') {
                interactionTypeStr = 'Salt Bridge/Ionic';
            }
            else if(interactionType == 'halogen') {
                interactionTypeStr = 'Halogen Bonds';
            }
            else if(interactionType == 'pi-cation') {
                interactionTypeStr = '&pi;-Cation';
            }
            else if(interactionType == 'pi-stacking') {
                interactionTypeStr = '&pi;-Stacking';
            }
            else if(interactionType == 'contact') {
                interactionTypeStr = 'Contacts';
            }

            let id = resid2Real;
            if(bNotDrawNode || ic.resid2ToXy.hasOwnProperty(id)) {
                x2 = (ic.resid2ToXy.hasOwnProperty(id)) ? ic.resid2ToXy[id].x2 : prevX2;
                y2 = (ic.resid2ToXy.hasOwnProperty(id)) ? ic.resid2ToXy[id].y2 : prevY2;

                // draw a short line from x2, y2 to x1, y1 with the distance shortBondLen
                let x1b = x1, y1b = y1, bShort = 0;
                if(interactionType == 'contact') {
                    let dist = Math.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));
                    if(shortBondLen < dist) {
                        x1b = shortBondLen / dist * (x1 - x2) + x2;
                        y1b = shortBondLen / dist * (y1 - y2) + y2;
                        bShort = 1;
                    }
                }

                line +='<g><title>Interaction type: ' + interactionTypeStr + '; Distance: ' + parseFloat(dist).toFixed(1) + ' &#197;</title>';
                line += '<line class="icn3d-interaction" id="' + idpair + '" resid1="' + resid1Real + '" resid2="' + resid2Real + '" x1="' + x1b.toFixed(2)  + '" y1="' + y1b.toFixed(2)  + '" x2="' + x2.toFixed(2)  + '" y2="' + y2.toFixed(2)  + '" x0="' + x1.toFixed(2)  + '" y0="' + y1.toFixed(2)  + '" short="' + bShort + '" opacity="1.0" stroke="' + lineColor + '"  stroke-width="' + strokeWidth + '" stroke-dasharray="5,5"/>\n';
                line += '</g>\n';
            }
            else {
                node +='<g><title>' + resName2 + '</title>';
                // node += '<circle class='icn3d-ctnode' cx="' + x2.toFixed(2) + '" cy="' + y2.toFixed(2)  + '" r="10" fill="#' + textColor2 + '" stroke-width="1" stroke="' + textColor2 + '" resid="' + resid2Real + '"/>';
                let boxWidth = 28, boxHeight = 14;
                node += '<rect id="' + id + '_node" x="' + (x2 - boxWidth*0.5).toFixed(2) + '" y="' + (y2 - boxHeight*0.5).toFixed(2)  + '" width="' + boxWidth + '" height="' + boxHeight + '" rx="2" ry="2" fill="#' + textColor2 + '" stroke-width="1" stroke="' + textColor2 + '" resid="' + resid2Real + '"/>';

                node += '<text class="icn3d-ctnode" resid="' + id + '" id="' + id + '" x="' + x2.toFixed(2)  + '" y="' + y2.toFixed(2)  + '" fill="#000" stroke="none" text-anchor="middle" alignment-baseline="central" style="font-size:10px">' + resName2 + '</text>';
                node += '</g>\n';

                line +='<g><title>Interaction type: ' + interactionTypeStr + '; Distance: ' + parseFloat(dist).toFixed(1) + ' &#197;</title>';
                line += '<line class="icn3d-interaction" id="' + idpair + '" resid1="' + resid1Real + '" resid2="' + resid2Real + '" x1="' + x1.toFixed(2)  + '" y1="' + y1.toFixed(2)  + '" x2="' + x2.toFixed(2)  + '" y2="' + y2.toFixed(2)  + '" opacity="1.0" stroke="' + lineColor + '"  stroke-width="' + strokeWidth + '" stroke-dasharray="5,5"/>';
                line += '</g>\n';

                if(interactionType != 'contact') {
                    if(!ic.resid2ToXy.hasOwnProperty(resid2Real)) ic.resid2ToXy[resid2Real] = {x2: x2, y2: y2};
                }
            }

            if(!ic.nodeid2lineid.hasOwnProperty(id)) ic.nodeid2lineid[id] = [];
            ic.nodeid2lineid[id].push(idpair);

            return {node: node, line: line, x2: x2, y2: y2};
        }

        setEventsForLigplot() {  let ic = this.icn3d, me = ic.icn3dui;
            //https://stackoverflow.com/questions/1108480/svg-draggable-using-jquery-and-jquery-svg
            $("#" + me.ligplotid + " .icn3d-ctnode")
            .draggable({
                start: function( e, ui ) {
                    let oriX= parseFloat(e.target.getAttribute('x'));
                    let oriY = parseFloat(e.target.getAttribute('y'));
                    e.target.setAttribute('x', oriX);
                    e.target.setAttribute('y', oriY);
                },
                drag: function( e, ui ) {
                    let ligplotScale = (ic.ligplotScale) ? ic.ligplotScale : 1;

                    let offsetX = $("#" + me.ligplotid).offset().left + ic.len4ang * ligplotScale; // ic.len4ang was defined in svg viewbox
                    let offsetY = $("#" + me.ligplotid).offset().top + ic.len4ang * ligplotScale;

                    let id = e.target.getAttribute('resid');
                    let x = (e.clientX - offsetX) / ligplotScale;
                    let y = (e.clientY - offsetY) / ligplotScale;

                    let oriX = parseFloat(e.target.getAttribute('x'));
                    let oriY = parseFloat(e.target.getAttribute('y'));

                    // change for each step
                    // let dx = (x - oriX) / ic.resizeRatioX;
                    // let dy = (y - oriY) / ic.resizeRatioY;
                    let dx = (x - oriX);
                    let dy = (y - oriY);

                    // move the node
                    oriX = parseFloat($("#" + id + "_node").attr('x'));
                    oriY = parseFloat($("#" + id + "_node").attr('y'));

                    $("#" + id + "_node").attr('x', oriX + dx);
                    $("#" + id + "_node").attr('y', oriY + dy);

                    // update the center
                    e.target.setAttribute('x', x);
                    e.target.setAttribute('y', y);

                    // update the edges
                    if(ic.nodeid2lineid[id]) {
                        for(let i = 0, il = ic.nodeid2lineid[id].length; i < il; ++i) {
                            let idpair = ic.nodeid2lineid[id][i];

                            updateEdges(idpair, id);
                        }
                    }

                    function updateEdges(idpair, id) {
                        if(idpair && idpair.indexOf(id) != -1) {
                            let idArray = idpair.split('--');
                            if(idArray.length == 2) {
                                let id2;
                                id2 = idArray[0];

                                let x2 = parseFloat($("#" + id2).attr('x'));
                                let y2 = parseFloat($("#" + id2).attr('y'));

                                $("#" + idpair).attr('x2', x2);
                                $("#" + idpair).attr('y2', y2);

                                let x1 = $("#" + idpair).attr('x1');
                                let y1 = $("#" + idpair).attr('y1');
                                let x1b = x1, y1b = y1;

                                let bShort = parseInt($("#" + idpair).attr('short'));
                                if(bShort) { // adjust x1,y1
                                    x1 = $("#" + idpair).attr('x0');
                                    y1 = $("#" + idpair).attr('y0');

                                    let dist = Math.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));
                                    let shortBondLen = ic.len4ang / 2;
                                    
                                    if(shortBondLen < dist) {
                                        x1b = shortBondLen / dist * (x1 - x2) + x2;
                                        y1b = shortBondLen / dist * (y1 - y2) + y2;
                                    }
                                }

                                $("#" + idpair).attr('x1', x1b);
                                $("#" + idpair).attr('y1', y1b);
                            }
                        } // if
                    } // function
                }
            });
        }

        clickLigplot() { let ic = this.icn3d; ic.icn3dui;
            let thisClass = this;

            $(document).on("click", "#" + ic.pre + "dl_ligplot .icn3d-ctnode", function(e) { let ic = thisClass.icn3d;
                e.stopImmediatePropagation();

                ic.diagram2dCls.clickNode(this);
            });
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class ResizeCanvas {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Resize the canvas with the defined "width" and "height".
        resizeCanvas(width, height, bForceResize, bDraw) {var ic = this.icn3d, me = ic.icn3dui;
          if( bForceResize || me.cfg.resize ) {
            //var heightTmp = parseInt(height) - me.htmlCls.EXTRAHEIGHT;
            let heightTmp = height;
            $("#" + ic.pre + "canvas").width(width).height(heightTmp);
            $("#" + ic.pre + "viewer").width(width).height(height);

            //$("div:has(#" + ic.pre + "canvas)").width(width).height(heightTmp);
            $("#" + ic.divid + " div:has(#" + ic.pre + "canvas)").width(width).height(heightTmp);

            ic.applyCenterCls.setWidthHeight(width, heightTmp);

            if(ic.structures && Object.keys(ic.structures).length > 0 && (bDraw === undefined || bDraw)) {
                ic.drawCls.draw();
            }
          }
        }

        windowResize() { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            if(me.cfg.resize && !me.utilsCls.isMobile() ) {
                $(window).resize(function() { let ic = thisClass.icn3d;
                    //me.htmlCls.WIDTH = $( window ).width();
                    //me.htmlCls.HEIGHT = $( window ).height();
                    me.utilsCls.setViewerWidthHeight(ic.icn3dui);

                    let width = me.htmlCls.WIDTH; // - me.htmlCls.LESSWIDTH_RESIZE;
                    let height = me.htmlCls.HEIGHT; // - me.htmlCls.LESSHEIGHT - me.htmlCls.EXTRAHEIGHT;

                    if(ic !== undefined && !ic.bFullscreen) thisClass.resizeCanvas(width, height);
                });
            }
        }

        openFullscreen(elem) {var ic = this.icn3d, me = ic.icn3dui;
          if(me.bNode) return;

          if(!document.fullscreenElement && !document.mozFullScreenElement &&
            !document.webkitFullscreenElement && !document.msFullscreenElement) {
              if(elem.requestFullscreen) {
                elem.requestFullscreen();
              } else if(elem.mozRequestFullScreen) { // Firefox
                elem.mozRequestFullScreen();
              } else if(elem.webkitRequestFullscreen) { // Chrome, Safari and Opera
                elem.webkitRequestFullscreen();
              } else if(elem.msRequestFullscreen) { // IE/Edge
                elem.msRequestFullscreen();
              }
          }    
        }

        //Rotate the structure in one of the directions: "left", "right", "up", and "down".
        rotStruc(direction, bInitial) {var ic = this.icn3d; ic.icn3dui;
            let thisClass = this;

            if(ic.bStopRotate) return false;
            if(ic.transformCls.rotateCount > ic.transformCls.rotateCountMax) {
                // back to the original orientation
                ic.transformCls.resetOrientation();

                return false;
            }
            ++ic.transformCls.rotateCount;

            if(bInitial) {
                if(direction === 'left') {
                  ic.ROT_DIR = 'left';
                }
                else if(direction === 'right') {
                  ic.ROT_DIR = 'right';
                }
                else if(direction === 'up') {
                  ic.ROT_DIR = 'up';
                }
                else if(direction === 'down') {
                  ic.ROT_DIR = 'down';
                }
                else {
                  return false;
                }
            }

            if(direction === 'left' && ic.ROT_DIR === 'left') {
              ic.transformCls.rotateLeft(1);
            }
            else if(direction === 'right' && ic.ROT_DIR === 'right') {
              ic.transformCls.rotateRight(1);
            }
            else if(direction === 'up' && ic.ROT_DIR === 'up') {
              ic.transformCls.rotateUp(1);
            }
            else if(direction === 'down' && ic.ROT_DIR === 'down') {
              ic.transformCls.rotateDown(1);
            }
            else {
              return false;
            }

            setTimeout(function(){ thisClass.rotStruc(direction); }, 100);
        }

        //Go back one step. Basically the commands are sequentially executed, but with one less step.
        async back() {var ic = this.icn3d; ic.icn3dui;
          ic.backForward = true;
          ic.STATENUMBER--;
          // do not add to the array ic.commands
          ic.bAddCommands = false;
          ic.bAddLogs = false; // turn off log
          ic.bNotLoadStructure = true;
          if(ic.STATENUMBER < 1) {
            ic.STATENUMBER = 1;
          }
          else {
            await ic.loadScriptCls.execCommands(0, ic.STATENUMBER-1, ic.STATENUMBER, true);
          }
          ic.setStyleCls.adjustIcon();
          ic.bAddCommands = true;
          ic.bAddLogs = true;
        }

        //Go forward one step. Basically the commands are sequentially executed, but with one more step.
        async forward() {var ic = this.icn3d; ic.icn3dui;
          ic.backForward = true;
          ic.STATENUMBER++;
          // do not add to the array ic.commands
          ic.bAddCommands = false;
          ic.bAddLogs = false; // turn off log
          ic.bNotLoadStructure = true;
          if(ic.STATENUMBER > ic.commands.length) {
            ic.STATENUMBER = ic.commands.length;
          }
          else {
            await ic.loadScriptCls.execCommands(0, ic.STATENUMBER-1, ic.STATENUMBER, true);
          }
          ic.setStyleCls.adjustIcon();
          ic.bAddCommands = true;
          ic.bAddLogs = true;
        }

        async replayon() {var ic = this.icn3d; ic.icn3dui;
          ic.CURRENTNUMBER = 0;
          ic.bReplay = 1;
          $("#" + ic.pre + "replay").show();

          if(ic.commands.length > 0) {
              await ic.loadScriptCls.replayFirstStep(ic.CURRENTNUMBER);

              //ic.resizeCanvasCls.closeDialogs();
          }
        }
        async replayoff() {var ic = this.icn3d; ic.icn3dui;
            ic.bReplay = 0;
            $("#" + ic.pre + "replay").hide();
            // replay all steps
            ++ic.CURRENTNUMBER;
            await ic.loadScriptCls.execCommands(ic.CURRENTNUMBER, ic.STATENUMBER-1, ic.STATENUMBER);
        }

        closeDialogs() {var ic = this.icn3d, me = ic.icn3dui;
            //let itemArray = ['dl_selectannotations', 'dl_alignment', 'dl_2ddgm', 'dl_definedsets', 'dl_graph',
            //    'dl_linegraph', 'dl_scatterplot', 'dl_contactmap', 'dl_allinteraction', 'dl_copyurl',
            //    'dl_symmetry', 'dl_symd', 'dl_rmsd', 'dl_legend', 'dl_disttable'];
            let itemArray = ['dl_2ddgm', 'dl_2dctn', 'dl_alignment', 'dl_sequence2', 'dl_definedsets', 'dl_setsmenu', 'dl_command', 'dl_setoperations', 'dl_vast', 'dl_foldseek', 'dl_mmtfid', 'dl_pdbid', 'dl_afid', 'dl_opmid', 'dl_pdbfile', 'dl_pdbfile_app', 'dl_rescolorfile', 'dl_customcolor', 'dl_align', 'dl_alignaf', 'dl_chainalign', 'dl_chainalign2', 'dl_chainalign3', 'dl_mutation', 'dl_mol2file', 'dl_sdffile', 'dl_xyzfile', 'dl_clustalwfile', 'dl_fastafile', 'dl_afmapfile', 'dl_urlfile', 'dl_mmciffile', 'dl_mmcifid', 'dl_mmdbid', 'dl_mmdbafid', 'dl_blast_rep_id', 'dl_yournote', 'dl_proteinname', 'dl_refseqid', 'dl_cid', 'dl_pngimage', 'dl_state', 'dl_fixedversion', 'dl_selection', 'dl_dsn6', 'dl_dsn6url', 'dl_clr', 'dl_symmetry', 'dl_symd', 'dl_contact', 'dl_hbonds', 'dl_realign', 'dl_realignbystruct', 'dl_allinteracton', 'dl_interactionsorted', 'dl_linegraph', 'dl_linegraphcolor', 'dl_scatterplot', 'dl_scatterploitcolor', 'dl_contactmap', 'dl_alignerrormap', 'dl_elecmap2fofc', 'dl_elecmapfofc', 'dl_emmap', 'dl_aroundsphere', 'dl_adjustmem', 'dl_selectplane', 'dl_addlabel', 'dl_addlabelselection', 'dl_labelColor', 'dl_distance', 'dl_stabilizer', 'dl_disttwosets', 'dl_distmanysets', 'dl_stabilizer_rm', 'dl_thickness', 'dl_thickness2', 'dl_addtrack', 'dl_addtrack_tabs', 'dl_saveselection', 'dl_copyurl', 'dl_selectannotations', 'dl_annotations_tabs', 'dl_anno_view_tabs', 'dl_annotations', 'dl_graph', 'dl_svgcolor', 'dl_area', 'dl_colorbyarea', 'dl_rmsd', 'dl_buriedarea', 'dl_propbypercentout', 'dl_propbybfactor', 'dl_legend', 'dl_disttable', 'dl_translate'];

            for(let i in itemArray) {
                let item = itemArray[i];
                if(!me.cfg.notebook) {
                    if($('#' + ic.pre + item).hasClass('ui-dialog-content') && $('#' + ic.pre + item).dialog( 'isOpen' )) {
                        $('#' + ic.pre + item).dialog( 'close' ).remove();
                    }
                }
                else {
                    $('#' + ic.pre + item).hide();
                }
            }
            if(!me.cfg.notebook) this.resizeCanvas(me.htmlCls.WIDTH, me.htmlCls.HEIGHT, true);
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Transform {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Set the orientation to the original one, but leave the style, color, etc alone.
        resetOrientation() { let ic = this.icn3d; ic.icn3dui;
            let bSet = false;
            if(ic.commands.length > 0) {
                let commandTransformation = ic.commands[0].split('|||');

                if(commandTransformation.length == 2) {
                    let transformation = JSON.parse(commandTransformation[1]);

                    ic._zoomFactor = transformation.factor;

                    ic.mouseChange.x = transformation.mouseChange.x;
                    ic.mouseChange.y = transformation.mouseChange.y;

                    ic.quaternion._x = transformation.quaternion._x;
                    ic.quaternion._y = transformation.quaternion._y;
                    ic.quaternion._z = transformation.quaternion._z;
                    ic.quaternion._w = transformation.quaternion._w;

                    bSet = true;
                }
            }

            if(!bSet) {
                ic._zoomFactor = 1.0;
                ic.mouseChange = new THREE.Vector2(0,0);
                ic.quaternion = new THREE.Quaternion(0,0,0,1);
            }

            //reset ic.maxD
            ic.maxD = ic.oriMaxD;
            ic.center = ic.oriCenter.clone();

            if(ic.ori_chemicalbinding == 'show') {
                ic.bSkipChemicalbinding = false;
            }
            else if(ic.ori_chemicalbinding == 'hide') {
                ic.bSkipChemicalbinding = true;
            }
        }

        //Rotate the structure certain degree to the left, e.g., 5 degree.
        rotateLeft (degree) { let ic = this.icn3d, me = ic.icn3dui;
          let axis = new THREE.Vector3(0,1,0);
          let angle = -degree / 180.0 * Math.PI;

          if(ic.bControlGl && !me.bNode) {
              axis.applyQuaternion( window.cam.quaternion ).normalize();
          }
          else {
              axis.applyQuaternion( ic.cam.quaternion ).normalize();
          }

          let quaternion = new THREE.Quaternion();
          quaternion.setFromAxisAngle( axis, -angle );

          let para = {};
          para.quaternion = quaternion;
          para.update = true;

          if(ic.bControlGl && !me.bNode) {
              window.controls.update(para);
          }
          else {
              ic.controls.update(para);
          }

          if(ic.bRender) ic.drawCls.render();
        }

        //Rotate the structure certain degree to the right, e.g., 5 degree.
        rotateRight (degree) { let ic = this.icn3d, me = ic.icn3dui;
          let axis = new THREE.Vector3(0,1,0);
          let angle = degree / 180.0 * Math.PI;

          if(ic.bControlGl && !me.bNode) {
              axis.applyQuaternion( window.cam.quaternion ).normalize();
          }
          else {
              axis.applyQuaternion( ic.cam.quaternion ).normalize();
          }

          let quaternion = new THREE.Quaternion();
          quaternion.setFromAxisAngle( axis, -angle );

          let para = {};
          para.quaternion = quaternion;
          para.update = true;

          if(ic.bControlGl && !me.bNode) {
              window.controls.update(para);
          }
          else {
              ic.controls.update(para);
          }

          if(ic.bRender) ic.drawCls.render();
        }

        rotateUp (degree) { let ic = this.icn3d; ic.icn3dui;
            this.rotate_base(-degree);
        }

        //Rotate the structure certain degree to the bottom, e.g., 5 degree.
        rotateDown (degree) { let ic = this.icn3d; ic.icn3dui;
            this.rotate_base(degree);
        }

        //Rotate the structure certain degree to the top, e.g., 5 degree.
        rotate_base (degree) { let ic = this.icn3d, me = ic.icn3dui;
          let axis = new THREE.Vector3(1,0,0);
          let angle = degree / 180.0 * Math.PI;

          if(ic.bControlGl && !me.bNode) {
              axis.applyQuaternion( window.cam.quaternion ).normalize();
          }
          else {
              axis.applyQuaternion( ic.cam.quaternion ).normalize();
          }

          let quaternion = new THREE.Quaternion();
          quaternion.setFromAxisAngle( axis, -angle );

          let para = {};
          para.quaternion = quaternion;
          para.update = true;

          if(ic.bControlGl && !me.bNode) {
              window.controls.update(para);
          }
          else {
              ic.controls.update(para);
          }

          if(ic.bRender) ic.drawCls.render();
        }

        setRotation(axis, angle) { let ic = this.icn3d, me = ic.icn3dui;
          if(!axis) return;

          if(ic.bControlGl && !me.bNode && window.cam) {
              axis.applyQuaternion( window.cam.quaternion ).normalize();
          }
          else if(ic.cam) {
              axis.applyQuaternion( ic.cam.quaternion ).normalize();
          }

          let quaternion = new THREE.Quaternion();
          quaternion.setFromAxisAngle( axis, -angle );

          let para = {};
          para.quaternion = quaternion;
          para.update = true;

          if(ic.bControlGl && !me.bNode && window.controls) {
            window.controls.update(para);
          }
          else if(ic.controls) {
              ic.controls.update(para);
          }

          if(ic.bRender) ic.drawCls.render();
        }

        //Translate the structure certain distance to the left, e.g., "percentScreenSize" 1 means 1% of the screen width.
        translateLeft(percentScreenSize) {  let ic = this.icn3d; ic.icn3dui;
            this.translate_base(-percentScreenSize, 0);
        }

        //Translate the structure certain distance to the right, e.g., "percentScreenSize" 1 means 1% of the screen width.
        translateRight(percentScreenSize) {  let ic = this.icn3d; ic.icn3dui;
            this.translate_base(percentScreenSize, 0);
        }

        //Translate the structure certain distance to the top, e.g., "percentScreenSize" 1 means 1% of the screen height.
        translateUp(percentScreenSize) {  let ic = this.icn3d; ic.icn3dui;
            this.translate_base(0, -percentScreenSize);
        }

        //Translate the structure certain distance to the bottom, e.g., "percentScreenSize" 1 means 1% of the screen height.
        translateDown(percentScreenSize) {  let ic = this.icn3d; ic.icn3dui;
            this.translate_base(0, percentScreenSize);
        }

        translate_base(x, y) {  let ic = this.icn3d, me = ic.icn3dui;
          let mouseChange = new THREE.Vector2(0,0);

          mouseChange.x += x / 100.0;
          mouseChange.y += y / 100.0;

          let para = {};
          para.mouseChange = mouseChange;
          para.update = true;

          if(ic.bControlGl && !me.bNode) {
              window.controls.update(para);
          }
          else {
              ic.controls.update(para);
          }

          if(ic.bRender) ic.drawCls.render();
        }

        translateCoord(atoms, dx, dy, dz) { let ic = this.icn3d; ic.icn3dui;
            for(let i in atoms) {
                let atom = ic.atoms[i];
                atom.coord.x += dx;
                atom.coord.y += dy;
                atom.coord.z += dz;
            }
        }

        rotateCoord(atoms, mArray) { let ic = this.icn3d; ic.icn3dui;
            const m = new THREE.Matrix4(); 
            m.elements = mArray;

            for(let i in atoms) {
                let atom = ic.atoms[i];
                atom.coord = atom.coord.applyMatrix4(m);
            }
        }

        //Center on the selected atoms and zoom in.
        zoominSelection(atoms) { let ic = this.icn3d, me = ic.icn3dui;
           let para = {};

           para._zoomFactor = 1.0 / ic._zoomFactor;
           para.update = true;

           if(ic.bControlGl && !me.bNode) {
              if(window.controls) window.controls.update(para);
           }
           else {
              if(ic.controls) ic.controls.update(para);
           }

           if(atoms === undefined) {
               atoms = me.hashUtilsCls.hash2Atoms(ic.hAtoms, ic.atoms);
           }

           // center on the hAtoms if more than one residue is selected
           if(Object.keys(atoms).length > 1) {
                   let centerAtomsResults = ic.applyCenterCls.centerAtoms(atoms);

                   ic.maxD = centerAtomsResults.maxD;
                   if (ic.maxD < 5) ic.maxD = 5;

                   ic.center = centerAtomsResults.center;
                   ic.applyCenterCls.setCenter(ic.center);

                   // reset cameara
                   ic.cameraCls.setCamera();
           }
        }

        getTransformationStr(transformation) {var ic = this.icn3d; ic.icn3dui;
            let transformation2 = {"factor": 1.0, "mouseChange": {"x": 0, "y": 0}, "quaternion": {"_x": 0, "_y": 0, "_z": 0, "_w": 1} };
            transformation2.factor = parseFloat(transformation.factor).toPrecision(4);
            transformation2.mouseChange.x = parseFloat(transformation.mouseChange.x).toPrecision(4);
            transformation2.mouseChange.y = parseFloat(transformation.mouseChange.y).toPrecision(4);
            transformation2.quaternion._x = parseFloat(transformation.quaternion._x).toPrecision(4);
            transformation2.quaternion._y = parseFloat(transformation.quaternion._y).toPrecision(4);
            transformation2.quaternion._z = parseFloat(transformation.quaternion._z).toPrecision(4);
            transformation2.quaternion._w = parseFloat(transformation.quaternion._w).toPrecision(4);

            if(transformation2.factor == '1.0000') transformation2.factor = 1;
            if(transformation2.mouseChange.x == '0.0000') transformation2.mouseChange.x = 0;
            if(transformation2.mouseChange.y == '0.0000') transformation2.mouseChange.y = 0;

            if(transformation2.quaternion._x == '0.0000') transformation2.quaternion._x = 0;
            if(transformation2.quaternion._y == '0.0000') transformation2.quaternion._y = 0;
            if(transformation2.quaternion._z == '0.0000') transformation2.quaternion._z = 0;
            if(transformation2.quaternion._w == '1.0000') transformation2.quaternion._w = 1;

            return JSON.stringify(transformation2);
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class SaveFile {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Save the state file or the image file with "filename". "type" is either "text" for state file or "png" for image file.

        //Five types are used: command, png, html, text, and binary. The type "command" is used to save the statefile.
        //The type "png" is used to save the current canvas image. The type "html" is used to save html file with the
        //"data". This can be used to save any text. The type "text" is used to save an array of text, where "data" is
        //actually an array. The type "binary" is used to save an array of binary, where "data" is actually an array.
        saveFile(filename, type, text, bBlob) { let ic = this.icn3d, me = ic.icn3dui;
            let thisClass = this;

            //Save file
            let blob;

            if(type === 'command') {
                let dataStr =(ic.loadCmd) ? ic.loadCmd + '\n' : '';
                for(let i = 0, il = ic.commands.length; i < il; ++i) {
                    let command = ic.commands[i].trim();
                    if(i == il - 1) {
                       let command_tf = command.split('|||');

                       let transformation = {};
                       transformation.factor = ic._zoomFactor;
                       transformation.mouseChange = ic.mouseChange;
                       transformation.quaternion = ic.quaternion;

                       command = command_tf[0] + '|||' + ic.transformCls.getTransformationStr(transformation);
                    }

                    dataStr += command + '\n';
                }
                let data = decodeURIComponent(dataStr);

                blob = new Blob([data],{ type: "text;charset=utf-8;"});
            }
            else if(type === 'png') {
                //ic.scaleFactor = 1.0;
                let width = $("#" + ic.pre + "canvas").width();
                let height = $("#" + ic.pre + "canvas").height();
                ic.applyCenterCls.setWidthHeight(width, height);

                if(ic.bRender) ic.drawCls.render();

                let bAddURL = true;
                if(!window.File || !window.FileReader || !window.FileList || !window.Blob) {
                    bAddURL = false;
                }

                if(me.utilsCls.isIE()) {
                    blob = ic.renderer.domElement.msToBlob();

                    if(bAddURL) {
                        let reader = new FileReader();
                        reader.onload = function(e) {
                            let arrayBuffer = e.target.result; // or = reader.result;

                            let text = ic.shareLinkCls.getPngText();

                            blob = me.convertTypeCls.getBlobFromBufferAndText(arrayBuffer, text);

                            //if(window.navigator.msSaveBlob) navigator.msSaveBlob(blob, filename);
                            thisClass.saveBlob(blob, filename, bBlob, width, height);

                            return blob;
                        };

                        reader.readAsArrayBuffer(blob);
                    }
                    else {
                        //ic.createLinkForBlob(blob, filename);
                        thisClass.saveBlob(blob, filename, bBlob, width, height);

                        return blob;
                    }
                }
                else {
                    ic.renderer.domElement.toBlob(function(data) {
                        if(bAddURL) {
                            let reader = new FileReader();
                            reader.onload = function(e) {
                                let arrayBuffer = e.target.result; // or = reader.result;

                                let text = ic.shareLinkCls.getPngText();

                                blob = me.convertTypeCls.getBlobFromBufferAndText(arrayBuffer, text);

                                //ic.createLinkForBlob(blob, filename);
                                thisClass.saveBlob(blob, filename, bBlob, width, height);

                                return blob;
                            };

                            reader.readAsArrayBuffer(data);
                        }
                        else {
                            blob = data;

                            //ic.createLinkForBlob(blob, filename);
                            thisClass.saveBlob(blob, filename, bBlob, width, height);

                            return blob;
                        }
                    });
                }

                // reset the image size
                ic.scaleFactor = 1.0;
                ic.applyCenterCls.setWidthHeight(width, height);

                if(ic.bRender) ic.drawCls.render();
            }
            else if(type === 'html') {
                let dataStr = text;
                let data = decodeURIComponent(dataStr);

                blob = new Blob([data],{ type: "text/html;charset=utf-8;"});
            }
            else if(type === 'text') {
                //var dataStr = text;
                //var data = decodeURIComponent(dataStr);

                //blob = new Blob([data],{ type: "text;charset=utf-8;"});

                let data = text; // here text is an array of text

                blob = new Blob(data,{ type: "text;charset=utf-8;"});
            }
            else if(type === 'binary') {
                let data = text; // here text is an array of blobs

                //blob = new Blob([data],{ type: "application/octet-stream"});
                blob = new Blob(data,{ type: "application/octet-stream"});
            }

            if(type !== 'png') {
                //https://github.com/eligrey/FileSaver.js/
                saveAs(blob, filename);
            }

            return blob;
        }

        saveBlob(blob, filename, bBlob, width, height) { let ic = this.icn3d; ic.icn3dui;
            if(bBlob) {
                let urlCreator = window.URL || window.webkitURL;
                let imageUrl = urlCreator.createObjectURL(blob);

                let url = ic.shareLinkCls.shareLinkUrl();

                url = url.replace(/imageonly=1/g, '');

                let bTooLong =(url.length > 4000 || url.indexOf('http') !== 0) ? true : false;
    /*
                if(bTooLong || (ic.bInputfile && !ic.bInputUrlfile)) {
                    // $("#" + ic.pre + "viewer").html("<img src='" + imageUrl + "'/>");
                    $("#" + ic.pre + "mnlist").html("<img src='" + imageUrl + "'/>");
                }
                else {
                    // $("#" + ic.pre + "viewer").html("<a href='" + url + "' target='_blank'><img src='" + imageUrl + "'/></a>");
                    $("#" + ic.pre + "mnlist").html("<a href='" + url + "' target='_blank'><img src='" + imageUrl + "'/></a>");
                }
                
                // $("#" + ic.pre + "viewer").width(width);
                // $("#" + ic.pre + "viewer").height(height);
                $("#" + ic.pre + "mnlist").width(width);
                $("#" + ic.pre + "mnlist").height(height);

                $("#" + ic.pre + "cmdlog").hide();
                $("#" + ic.pre + "title").hide();

                //$("#" + ic.pre + "mnlist").hide();
                $("#" + ic.pre + "canvas").hide(); // "load mmdbid ..." may cause problems if canvas was removed
    */

                if(bTooLong || (ic.bInputfile && !ic.bInputUrlfile)) {
                    $("#" + ic.pre + "viewer").html("<img src='" + imageUrl + "'/>");
                }
                else {
                    $("#" + ic.pre + "viewer").html("<a href='" + url + "' target='_blank'><img src='" + imageUrl + "'/></a>");
                }

                $("#" + ic.pre + "viewer").width(width);
                $("#" + ic.pre + "viewer").height(height);

                $("#" + ic.pre + "cmdlog").hide();
                $("#" + ic.pre + "title").hide();
                $("#" + ic.pre + "mnlist").hide();

                if($("#" + ic.pre + "fullscreen").length > 0) $("#" + ic.pre + "fullscreen").hide();

                // clear memory
                ic = {};
            }
            else {
                saveAs(blob, filename);
            }
        }

        saveSvg(id, filename, bContactmap, bLigplot) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return '';
            
            let width = $("#" + id).width();
            let height = $("#" + id).height();

            if(bContactmap) height = width;

            if(bLigplot) {
                width += ic.len4ang;
                height += ic.len4ang;
            }

            let svgXml = this.getSvgXml(id, width, height, bContactmap, bLigplot);

            let blob = new Blob([svgXml], {type: "image/svg+xml"});
            saveAs(blob, filename);
        }

        getSvgXml(id, width, height, bContactmap, bLigplot) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return '';

            // font is not good
            let svg_data = document.getElementById(id).innerHTML; //put id of your svg element here

            let startX = (bLigplot) ? -30 : 0;
            let startY = (bLigplot) ? -30 : 0;
            let viewbox = (width && height) ? "<svg viewBox=\"" + startX + " " + startY + " " + width + " " + height + "\"" : "<svg";
            //let head = viewbox + " title=\"graph\" version=\"1.1\" xmlns:xl=\"http://www.w3.org/1999/xlink\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\">";
            let head = viewbox + " title=\"graph\" xmlns:xl=\"http://www.w3.org/1999/xlink\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\">";

            //if you have some additional styling like graph edges put them inside <style> tag
            let style = "<style>text {font-family: sans-serif; font-weight: bold; font-size: 18px;}</style>";

            let full_svg = head +  style + svg_data + "</svg>";

            return full_svg;
        }

        savePng(id, filename, bContactmap, bLigplot) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return '';

            let width = $("#" + id).width();
            let height = $("#" + id).height();

            if(bContactmap) height = width;

            // https://stackoverflow.com/questions/3975499/convert-svg-to-image-jpeg-png-etc-in-the-browser
            let svg = document.getElementById(id);
            let bbox = svg.getBBox();

            let copy = svg.cloneNode(true);
            if(!bLigplot) ic.lineGraphCls.copyStylesInline(copy, svg);
            let canvas = document.createElement("CANVAS");
            canvas.width = width;
            canvas.height = height;

            let ctx = canvas.getContext("2d");
            ctx.clearRect(0, 0, bbox.width, bbox.height);

            let data = this.getSvgXml(id, width, height, bContactmap); //(new XMLSerializer()).serializeToString(copy); //ic.saveFileCls.getSvgXml();
            let DOMURL = window.URL || window.webkitURL || window;
            let svgBlob = new Blob([data], {type: "image/svg+xml;charset=utf-8"});

            let img = new Image();
            img.src = DOMURL.createObjectURL(svgBlob);

            img.onload = function() {
                ctx.drawImage(img, 0, 0);
                DOMURL.revokeObjectURL(this.src);

                if(me.utilsCls.isIE()) {
                    let blob = canvas.msToBlob();

                    if(blob) {
                        saveAs(blob, filename);

                        canvas.remove();
                    }

                    return;
                }
                else {
                    canvas.toBlob(function(data) {
                        let blob = data;

                        if(blob) {
                            saveAs(blob, filename);

                            canvas.remove();
                        }

                        return;
                    });
                }
            };
        }

        exportCustomAtoms(bDetails) {var ic = this.icn3d; ic.icn3dui;
           let html = "";
           let nameArray =(ic.defNames2Residues !== undefined) ? Object.keys(ic.defNames2Residues).sort() : [];
           for(let i = 0, il = nameArray.length; i < il; ++i) {
             let name = nameArray[i];
             let residueArray = ic.defNames2Residues[name];
             ic.defNames2Descr[name];
             let command = ic.defNames2Command[name];
             command = command.replace(/,/g, ', ');

             html += this.exportResidues(name, residueArray, bDetails);
           } // outer for
           nameArray =(ic.defNames2Atoms !== undefined) ? Object.keys(ic.defNames2Atoms).sort() : [];
           for(let i = 0, il = nameArray.length; i < il; ++i) {
             let name = nameArray[i];
             let atomArray = ic.defNames2Atoms[name];
             ic.defNames2Descr[name];
             let command = ic.defNames2Command[name];
             command = command.replace(/,/g, ', ');
             let residueArray = ic.resid2specCls.atoms2residues(atomArray);

             html += this.exportResidues(name, residueArray, bDetails);
           } // outer for
           return html;
        }

        exportResidues(name, residueArray, bDetails) {var ic = this.icn3d, me = ic.icn3dui;
             let html = '';

             if(residueArray.length > 0) {
                 if(bDetails) {
                     let chainidHash = {};
                     for(let i = 0, il = residueArray.length; i < il; ++i) {
                         let resid = residueArray[i];
                         let atom = ic.firstAtomObjCls.getFirstAtomObj(ic.residues[resid]);
                         if(!atom) continue;
                         
                         let chainid = atom.structure + '_' + atom.chain;
                         let resnAbbr = me.utilsCls.residueName2Abbr(atom.resn);
                         let resName = resnAbbr + atom.resi;

                         if(!chainidHash.hasOwnProperty(chainid)) {
                             chainidHash[chainid] = [];
                         }

                         chainidHash[chainid].push(resName);
                     }

                     html += name + ":\n";
                     for(let chainid in chainidHash) {
                         let resStr = (chainidHash[chainid].length == 1) ? "residue" : "residues";
                         html += chainid + " (" + chainidHash[chainid].length + " " + resStr + "): ";
                         html += chainidHash[chainid].join(", ");
                         html += "\n";
                     }
                     html += "\n";
                 }
                 else {
                     html += name + "\tselect ";
                     html += ic.resid2specCls.residueids2spec(residueArray);
                     html += "\n";
                 }
             }

             return html;
        }

        printPrevSecondary(bHelix, bSheet, prevRealSsObj, ssCnt) { let ic = this.icn3d; ic.icn3dui;
            let ssText = '';

            // print prev
            if(prevRealSsObj) {
                if(bHelix) {
                    let helixType = 1;
                    ssText += prevRealSsObj.resn.padStart(5, ' ') + prevRealSsObj.chain.replace(/_/gi, '').substr(0, 2).padStart(2, ' ')
                        + prevRealSsObj.resi.toString().padStart(5, ' ') + '  ' + helixType + ssCnt.toString().padStart(36, ' ') + '\n';
                }
                else if(bSheet) {
                    let sense = 0;
                    ssText += prevRealSsObj.resn.padStart(5, ' ') + prevRealSsObj.chain.replace(/_/gi, '').substr(0, 2).padStart(2, ' ')
                        + prevRealSsObj.resi.toString().padStart(4, ' ') + '  ' + sense + '\n';
                }
            }

            return ssText;
        }

        //getAtomPDB: function(atomHash, bPqr, bPdb, bNoChem) { let ic = this.icn3d, me = ic.icn3dui;
        getAtomPDB(atomHash, bPqr, bNoChem, bNoHeader, chainResi2pdb, pdbid, bMergeIntoOne, bOneLetterChain) { let ic = this.icn3d, me = ic.icn3dui;
            let pdbStr = '';

            // get all phosphate groups in lipids
            let phosPHash = {}, phosOHash = {};
            for(let i in ic.chemicals) {
                let atom = ic.atoms[i];
                if(atom.elem == 'P') {
                    phosPHash[i] = 1;

                    for(let j = 0, jl = atom.bonds.length; j < jl; ++j) {
                        let serial = atom.bonds[j];
                        if(serial && ic.atoms[serial].elem == 'O') { // could be null
                            phosOHash[serial] = 1;
                        }
                    }
                }
            }
        /*
        HELIX    1  NT MET A    3  ALA A   12  1                                  10
                let startChain =(line.substr(19, 1) == ' ') ? 'A' : line.substr(19, 1);
                let startResi = parseInt(line.substr(21, 4));
                let endResi = parseInt(line.substr(33, 4));
        SHEET    1  B1 2 GLY A  35  THR A  39  0
                let startChain =(line.substr(21, 1) == ' ') ? 'A' : line.substr(21, 1);
                let startResi = parseInt(line.substr(22, 4));
                let endResi = parseInt(line.substr(33, 4));
        */

            let calphaHash = me.hashUtilsCls.intHash(atomHash, ic.calphas);
            let helixStr = 'HELIX', sheetStr = 'SHEET';

            let stru2header = {};
            for(let stru in ic.structures) {
                stru2header[stru] = '';
            }

    //        if(!bNoSs) {
                let prevResi, stru;
                let ssArray = [];
                for(let i in calphaHash) {
                    let atom = ic.atoms[i];
                    stru = atom.structure;
                    atom.structure + '_' + atom.chain;

                    let ssObj = {};
                    ssObj.chain = atom.chain;
                    ssObj.resn = atom.resn;
                    ssObj.resi = atom.resi;

                    if(parseInt(atom.resi) > parseInt(prevResi) + 1  || atom.ssbegin) {
                        let ssObj2 = me.hashUtilsCls.cloneHash(ssObj);
                        ssObj2.ss = ' ';
                        ssArray.push(ssObj2);
                    }

                    if(atom.ss == 'helix') {
                        ssObj.ss = 'H';
                        ssArray.push(ssObj);
                    }
                    else if(atom.ss == 'sheet') {
                        ssObj.ss = 'S';
                        ssArray.push(ssObj);
                    }
    /*
                    if(atom.ssend) {
                        let ssObj2 = me.hashUtilsCls.cloneHash(ssObj);
                        ssObj2.ss = ' ';
                        ssArray.push(ssObj2);
                    }
    */
                    prevResi = atom.resi;
                }

                let prevSs, prevRealSsObj, ssCnt = 0, bHelix = false, bSheet = false;
                for(let i = 0, il = ssArray.length; i < il; ++i) {
                    let ssObj = ssArray[i];

                    if(ssObj.ss != prevSs) {
                        // print prev
                        if(prevSs !== ' ') stru2header[stru] += this.printPrevSecondary(bHelix, bSheet, prevRealSsObj, ssCnt);

                        // print current
                        ssCnt = 0;
                        bHelix = false;
                        bSheet = false;
                        prevRealSsObj = undefined;

                        if(ssObj.ss !== ' ') {
                            if(ssObj.ss == 'H') {
                                bHelix = true;
                                prevRealSsObj = ssObj;
                                stru2header[stru] += helixStr.padEnd(15, ' ') + ssObj.resn.padStart(3, ' ') + ssObj.chain.replace(/_/gi, '').substr(0, 2).padStart(2, ' ')
                                    + ssObj.resi.toString().padStart(5, ' ');
                            }
                            else if(ssObj.ss == 'S') {
                                bSheet = true;
                                prevRealSsObj = ssObj;
                                stru2header[stru] += sheetStr.padEnd(17, ' ') + ssObj.resn.padStart(3, ' ') + ssObj.chain.replace(/_/gi, '').substr(0, 2).padStart(2, ' ')
                                    + ssObj.resi.toString().padStart(4, ' ');
                            }
                        }
                    }

                    if(ssObj.ss !== ' ') {
                        ++ssCnt;
                        prevRealSsObj = ssObj;
                    }

                    prevSs = ssObj.ss;
                }

                // print prev
                stru2header[stru] += this.printPrevSecondary(bHelix, bSheet, prevRealSsObj, ssCnt);

                // add a new line in case the structure is a subset
                stru2header[stru] += '\n';
    //        }

            // export assembly symmetry matrix "BIOMT"
            if(ic.biomtMatrices && Object.keys(atomHash).length == Object.keys(ic.atoms).length) {
                let stru = Object.keys(ic.structures)[0];
                for(let m = 0, ml = ic.biomtMatrices.length; m < ml; ++m) {
                    let mNum = m + 1;
                    for(let n = 0; n < 3; ++n) {
                        let nNum = n + 1;
                        stru2header[stru] += "REMARK 350   BIOMT" + nNum.toString() + "  " + mNum.toString().padStart(2, ' ')
                            + " " + ic.biomtMatrices[m].elements[n + 0].toFixed(6).toString().padStart(9, ' ')
                            + " " + ic.biomtMatrices[m].elements[n + 4].toFixed(6).toString().padStart(9, ' ')
                            + " " + ic.biomtMatrices[m].elements[n + 8].toFixed(6).toString().padStart(9, ' ')
                            + " " + ic.biomtMatrices[m].elements[n + 12].toFixed(6).toString().padStart(14, ' ') + "\n";
                    }
                }
            }

            // add missing residues "REMARK 465..."
            for(let chainid in ic.chainMissingResidueArray) {
                let pos = chainid.indexOf('_');
                let chain = chainid.substr(pos + 1, 2);
                let stru = chainid.substr(0, pos);

                for(let i = 0, il = ic.chainMissingResidueArray[chainid].length; i < il; ++i) {
                    let resi = ic.chainMissingResidueArray[chainid][i].resi;
                    let resn = me.utilsCls.residueAbbr2Name(ic.chainMissingResidueArray[chainid][i].name);

                    stru2header[stru] += "REMARK 465     " + resn.padStart(3, " ") + chain.padStart(2, " ") + " " + resi.toString().padStart(5, " ") + "\n";
                }
            }

            let connStr = '';
            let struArray = Object.keys(ic.structures);
            let bMulStruc =(struArray.length > 1) ? true : false;

            let molNum = 1, prevStru = '', prevChain = '';
            let chainIndex = 0, fakeChain = '', chainNameArray = 'abcdefghijklmnopqrstuvwxyz0123456789';

            let addedChainResiHash = {};
            for(let i in atomHash) {
                let atom = ic.atoms[i];

                // remove chemicals
                if(bNoChem && atom.het) continue;

                //if(bMulStruc && atom.structure != prevStru) {
                if(atom.structure != prevStru) {
                    if(!bMergeIntoOne || !bMulStruc) {
                        pdbStr += connStr;
                        connStr = '';

                        if(molNum > 1)  pdbStr += '\nENDMDL\n';

                        if(bMulStruc) pdbStr += 'MODEL        ' + molNum + '\n';
                    }

                    // add header            
                    let mutantInfo = (chainResi2pdb) ? "Mutated chain_residue " + Object.keys(chainResi2pdb) + '; ' : '';
                    if(!bNoHeader) {
                        //pdbStr += this.getPDBHeader(molNum - 1, stru2header, mutantInfo, pdbid);

                        // make sure the PDB ID is correct
                        if(!bMergeIntoOne || !bMulStruc) pdbStr += this.getPDBHeader(molNum - 1, stru2header, mutantInfo, atom.structure);

                        //pdbStr += '\n'; // separate from incomplete secondary structures 
                    }

                    //prevStru = atom.structure;
                    ++molNum;
                }

                //else {
                    //if(atom.chain != prevChain) {
                    if(atom.chain != prevChain && atom.structure == prevStru) {
                        // add a line "TER" to work with scap/profix to add missing atoms
                        if(prevChain) {
                            pdbStr += 'TER\n';
                        }
                        //prevChain = atom.chain;
                    }
                //}

                let chainResi = atom.chain + '_' + atom.resi;
                if(chainResi2pdb && chainResi2pdb.hasOwnProperty(chainResi)) {    
                    if(!addedChainResiHash.hasOwnProperty(chainResi)) {
                        pdbStr += chainResi2pdb[chainResi];
                        addedChainResiHash[chainResi] = 1;
                    }
                    continue;
                }

                let line = '';
        /*
        1 - 6 Record name "ATOM "
        7 - 11 Integer serial Atom serial number.
        13 - 16 Atom name Atom name.
        17 Character altLoc Alternate location indicator.
        18 - 20 Residue name resName Residue name.
        22 Character chainID Chain identifier.
        23 - 26 Integer resSeq Residue sequence number.
        27 AChar iCode Code for insertion of residues.
        31 - 38 Real(8.3) x Orthogonal coordinates for X in
        Angstroms.
        39 - 46 Real(8.3) y Orthogonal coordinates for Y in
        Angstroms.
        47 - 54 Real(8.3) z Orthogonal coordinates for Z in
        Angstroms.
        55 - 60 Real(6.2) occupancy Occupancy.
        61 - 66 Real(6.2) tempFactor Temperature factor.
        73 - 76 LString(4) segID Segment identifier, left-justified.
        77 - 78 LString(2) element Element symbol, right-justified.
        79 - 80 LString(2) charge Charge on the atom.
        */
                line +=(atom.het) ? 'HETATM' : 'ATOM  ';
                line += i.toString().padStart(5, ' ');
                line += ' ';

                let atomName = atom.name.trim();
                if(!isNaN(atomName.substr(0, 1)) ) atomName = atomName.substr(1) + atomName.substr(0, 1);

                if(atomName.length == 4) {
                    line += atomName;
                }
                else {
                    line += ' ';
                    atomName = atomName.replace(/\*/g, "'");
                    if(atomName == 'O1P') atomName = 'OP1';
                    else if(atomName == 'O2P') atomName = 'OP2';
                    else if(atomName == 'C5M') atomName = 'C7 ';
                    line += atomName.padEnd(3, ' ');
                }

                line += ' ';
                let resn = atom.resn;
        /*
                // add "D" in front of nucleotide residue names
                if(resn == 'A') resn = 'DA';
                else if(resn == 'T') resn = 'DT';
                else if(resn == 'C') resn = 'DC';
                else if(resn == 'G') resn = 'DG';
                else if(resn == 'U') resn = 'DU';
        */

                line +=(resn.length <= 3) ? resn.padStart(3, ' ') : resn.substr(0, 3);

                if(bMergeIntoOne && molNum > 2 && (ic.proteins.hasOwnProperty(atom.serial) || ic.nucleotides.hasOwnProperty(atom.serial))) {
                    if(atom.structure != prevStru || atom.chain != prevChain) {
                        fakeChain = (chainIndex < 36) ? chainNameArray[chainIndex] : '?';
                        ++chainIndex;
                    }

                    line += ' ' + fakeChain;
                }
                else {
                    //line += ' ';
                    //line +=(atom.chain.length <= 1) ? atom.chain.padStart(1, ' ') : atom.chain.substr(0, 1);
                    if(atom.chain.length >= 2) {
                        let chainTmp = atom.chain.replace(/_/gi, '').substr(0, 2);
                        if(bOneLetterChain) chainTmp = ' ' + chainTmp.substr(0,1); // VAST search only support one lettter chain ID
                        line += chainTmp;
                    }
                    else if(atom.chain.length == 1) {
                        line += ' ' + atom.chain.substr(0, 1);
                    }
                    else if(atom.chain.length == 0) {
                        line += ' A';
                    }
                }

                let resi = atom.resi;
                if(!isNaN(resi) && atom.chain.length > 3 && !isNaN(atom.chain.substr(3)) ) { // such as: chain = NAG2, resi=1 => chain = NAG, resi=2
                    resi = resi - 1 + parseInt(atom.chain.substr(3));
                }
                let resiInt = parseInt(resi);
                line +=(resiInt.toString().length <= 4) ? resiInt.toString().padStart(4, ' ') : resiInt.toString().substr(0, 4);
                //line += ' '.padStart(4, ' ');
                // insert
                let lastChar = atom.resi.toString().substr(atom.resi.toString().length - 1, 1);
                if(isNaN(lastChar)) {
                    line += lastChar;
                }
                else {
                    line += ' ';
                }
                line += ' '.padStart(3, ' ');

                line += atom.coord.x.toFixed(3).toString().padStart(8, ' ');
                line += atom.coord.y.toFixed(3).toString().padStart(8, ' ');
                line += atom.coord.z.toFixed(3).toString().padStart(8, ' ');

                //if((bPqr && atom.het) ||(phosPHash.hasOwnProperty(i) && !bPdb) ||(phosOHash.hasOwnProperty(i) && !bPdb) ) {
                //if((bPqr && atom.het) ||(phosPHash.hasOwnProperty(i)) ||(phosOHash.hasOwnProperty(i)) ) {
                if(bPqr && atom.het) {
                    let size = 1.5, charge = 0;

        /*
                    // use antechamber atom size
                    if(atom.elem == 'C') size = 1.7; //1.9080;
                    else if(atom.elem == 'N') size = 1.55; //1.8240;
                    else if(atom.elem == 'O') size = 1.52; //1.6612;
                    else if(atom.elem == 'H') size = 1.2; //1.2500;
                    else if(atom.elem == 'S') size = 1.8; //2.0000;
                    else if(atom.elem == 'P') size = 1.8; //2.1000;
                    else if(me.parasCls.vdwRadii.hasOwnProperty(atom.elem)) {
                        size = me.parasCls.vdwRadii[atom.elem];
                    }
        */

                    // use amber atom size
                    if(atom.elem == 'C') size = 1.9080;
                    else if(atom.elem == 'N') size = 1.8240;
                    else if(atom.elem == 'O') size = 1.6612;
                    else if(atom.elem == 'H') size = 1.2500;
                    else if(atom.elem == 'S') size = 2.0000;
                    else if(atom.elem == 'P') size = 2.1000;
                    else if(me.parasCls.vdwRadii.hasOwnProperty(atom.elem)) {
                        size = me.parasCls.vdwRadii[atom.elem];
                    }

                    if(me.cfg.cid !== undefined && atom.crg !== undefined) {
                        charge = atom.crg;
                    }
                    else if(phosPHash.hasOwnProperty(i)) {
                        charge = 1.3800; // P in phosphate
                    }
                    else if(phosOHash.hasOwnProperty(i)) {
                        charge = -0.5950; // O in phosphate
                    }
                    else if(me.parasCls.ionCharges.hasOwnProperty(atom.elem)) {
                        charge = me.parasCls.ionCharges[atom.elem];
                    }

                    line += charge.toFixed(4).toString().padStart(8, ' ');
                    line += size.toFixed(4).toString().padStart(7, ' ');
                }
                else {
                    line += "1.00".padStart(6, ' ');
                    // let defaultBFactor = (bOneLetterChain) ? "1.0" : " ";
                    let defaultBFactor = " ";
                    line +=(atom.b) ? parseFloat(atom.b).toFixed(2).toString().padStart(6, ' ') : defaultBFactor.padStart(6, ' ');
                    line += ' '.padStart(10, ' ');
                    line += atom.elem.padStart(2, ' ');
                    line += ' '.padStart(2, ' ');
                }

                // connection info
                if(atom.het && atom.bonds.length > 0) {
                    connStr += 'CONECT' + i.toString().padStart(5, ' ');
                    let bondHash = {};
                    for(let j = 0, jl = atom.bonds.length; j < jl; ++j) {
                        if(atom.bonds[j] && !bondHash.hasOwnProperty(atom.bonds[j])) { // could be null
                            connStr += atom.bonds[j].toString().padStart(5, ' ');
                            bondHash[atom.bonds[j]] = 1;
                        }
                    }
                    connStr += '\n';
                }

                pdbStr += line + '\n';

                prevStru = atom.structure;
                prevChain = atom.chain;
            }

            if(!bMergeIntoOne || !bMulStruc) {
                pdbStr += connStr;
                
                if(bMulStruc) pdbStr += '\nENDMDL\n';
            }

            return pdbStr;
        }

        getSecondary(atomHash) { let ic = this.icn3d, me = ic.icn3dui;
            let json = '{"data": [\n';

            let prevChainid = '', prevResi = '';
            let data = {};
            for(let i in atomHash) {
                let atom = ic.atoms[i];

                let chainid = atom.structure + '_' + atom.chain;
                let resi = atom.resi;
                let resn = me.utilsCls.residueName2Abbr(atom.resn);
                let ss = this.secondary2Abbr(atom.ss);
                if(atom.ssbegin) ss += ' begin';
                else if(atom.ssend) ss += ' end';

                if(chainid != prevChainid && !data[chainid]) {
                    data[chainid] = {"resi": [], "resn": [], "secondary": []};
                }

                if(chainid != prevChainid || resi != prevResi) {
                    data[chainid]["resi"].push(resi);
                    data[chainid]["resn"].push(resn);
                    data[chainid]["secondary"].push(ss);
                }

                prevChainid = chainid;
                prevResi = resi;
            }

            let chainidArray = Object.keys(data);
            let cnt = chainidArray.length;
            for(let i = 0; i < cnt; ++i) {
                let chainid = chainidArray[i];
                json += '{"chain": "' + chainid + '",\n';

                json += '"resi": "' + data[chainid]["resi"].join(',') + '",\n';
                json += '"resn": "' + data[chainid]["resn"].join(',') + '",\n';
                json += '"secondary": "' + data[chainid]["secondary"].join(',') + '"';

                if(i < cnt - 1) {
                    json += '},\n';
                }
                else {
                    json += '}\n';
                }
            }

            json += ']}\n';

            return json;
        }

        secondary2Abbr(ss) { let ic = this.icn3d; ic.icn3dui;
            if(ss == 'helix') {
                return 'H';
            }
            else if(ss == 'sheet') {
                return 'E';
            }
            else {
                return 'c';
            }
        }

        getSelectedResiduePDB() { let ic = this.icn3d, me = ic.icn3dui;
           let pdbStr = '';
    ///       pdbStr += this.getPDBHeader();

           let atoms = me.hashUtilsCls.intHash(ic.dAtoms, ic.hAtoms);
           pdbStr += this.getAtomPDB(atoms);

           return pdbStr;
        }
        getPDBHeader(struNum, stru2header, mutantInfo, pdbid) { let ic = this.icn3d; ic.icn3dui;
           if(struNum === undefined) struNum = 0;

           let pdbStr = '';
           let stru = (pdbid) ? pdbid : Object.keys(ic.structures)[struNum];
           let id = (mutantInfo) ? stru + '2' : stru;
           pdbStr += 'HEADER    PDB From iCn3D'.padEnd(62, ' ') + id + '\n';

           if(struNum == 0) {
               let title =(ic.molTitle.length > 50) ? ic.molTitle.substr(0,47) + '...' : ic.molTitle;
               // remove quotes
               if(title.indexOf('"') != -1) title = '';
               if(mutantInfo) {
                   title = mutantInfo + title;
               }
               pdbStr += 'TITLE     ' + title + '\n';
           }

           if(stru2header && stru2header[stru]) {
               pdbStr += stru2header[stru];
           }

           return pdbStr;
        }

        //Show the title and PDB ID of the PDB structure at the beginning of the viewer.
        showTitle() {var ic = this.icn3d, me = ic.icn3dui;
            // if(ic.molTitle !== undefined && ic.molTitle !== '') {
                let title = (ic.molTitle) ? ic.molTitle : '';

                let titlelinkColor =(ic.opts['background'] == 'black') ?  me.htmlCls.GREYD : 'black';

                if(ic.inputid === undefined) {
                    if(title.length > 40) title = title.substr(0, 40) + "...";

                    $("#" + ic.pre + "title").html(title);
                }
                else if(me.cfg.cid !== undefined) {
                    let url = this.getLinkToStructureSummary();

                    $("#" + ic.pre + "title").html("PubChem CID <a id='" + ic.pre + "titlelink' href='" + url + "' style='color:" + titlelinkColor + "' target='_blank'>" + ic.inputid.toUpperCase() + "</a>: " + title);
                }
                else if(me.cfg.smiles !== undefined) {
                    let text = decodeURIComponent(me.cfg.smiles);
                    if(text.length > 60) text = text.substr(0, 60) + "...";
                    $("#" + ic.pre + "title").html("SMILES: " + text);
                }
                else if(me.cfg.align !== undefined) {
                    title = 'VAST+ alignment of ' + Object.keys(ic.structures);

                    $("#" + ic.pre + "title").html(title);
                }
                else if(me.cfg.chainalign !== undefined) {
                    let chainidArray = me.cfg.chainalign.split(',');
                    title = 'Dynamic Structure Alignment of Chains: ' + chainidArray;

                    $("#" + ic.pre + "title").html(title);
                }
                else { //if(me.cfg.mmdbafid !== undefined) {
                    //let structureArray = Object.keys(ic.structures); //me.cfg.mmdbafid.split(',');
                    let structureArray = Object.keys(me.utilsCls.getStructures(ic.dAtoms));

                    if(structureArray.length > 1) {
                        title = 'Multiple structures: ';
                        for(let i = 0, il = structureArray.length; i < il; ++i) {
                            let url = (isNaN(structureArray[i]) && structureArray[i].length > 5) ? 'https://alphafold.ebi.ac.uk/entry/' + structureArray[i] : 'https://www.ncbi.nlm.nih.gov/structure/?term=' + structureArray[i];
                            title += '<a href="' + url + '" style="color:' + titlelinkColor + '" target="_blank">' + structureArray[i] + '</a>';
                            if(i < il - 1) title += ', ';
                        }
                        $("#" + ic.pre + "title").html(title);
                    }
                    else if(structureArray.length == 1) {
                        //let url = this.getLinkToStructureSummary();
                        let url = (isNaN(structureArray[0]) && structureArray[0].length > 5) ? 'https://alphafold.ebi.ac.uk/entry/' + structureArray[0] : 'https://www.ncbi.nlm.nih.gov/structure/?term=' + structureArray[0];

                        this.setStructureTitle(url, title, titlelinkColor);
                    }
                }
                // else {
                //     let url = this.getLinkToStructureSummary();
                //     this.setStructureTitle(url, title, titlelinkColor);
                // }
            // }
            // else {
            //     $("#" + ic.pre + "title").html("");
            // }
        }

        setStructureTitle(url, title, titlelinkColor) {var ic = this.icn3d, me = ic.icn3dui;
            if(title.length > 40) title = title.substr(0, 40) + "...";

            let inputid = ic.inputid;

            let text, idName;
            if(inputid.indexOf('http') != -1) {
                idName = "Data from";
                url = inputid;
                text = inputid;
            }
            else {
                let idHash = me.utilsCls.getHlStructures();

                let bPdb = false, bAlphaFold = false;
                for(let structureid in idHash) {
                    if(structureid.length > 5) {
                        bAlphaFold = true;
                    }
                    else {
                        bPdb = true;
                    }
                }

                let structureidArray = Object.keys(idHash);
                inputid = structureidArray.join(',');

                text = (me.cfg.refseqid || me.cfg.protein) ? ic.inputid : inputid.toUpperCase();

                //idName = (isNaN(inputid) && inputid.length > 5) ? "AlphaFold ID" : "PDB ID";
                if(bPdb && bAlphaFold) {
                    idName = "AlphaFold/PDB ID";
                }
                else if(bPdb) {
                    idName = "PDB ID";
                }
                else if(bAlphaFold) {
                    idName = "AlphaFold ID";
                }

                if(structureidArray.length > 1) {
                    idName += 's';
                }
                
                if(ic.molTitleHash) {
                    title = '';
                    for(let i = 0, il = structureidArray.length; i < il; ++i) {
                        title += ic.molTitleHash[structureidArray[i]];
                        if(i < il - 1) title += '; ';
                    }
                }
            }

            if(me.cfg.refseqid) {
                idName = 'NCBI Protein Acc.';
            }
            else if(me.cfg.protein) {
                idName = 'Protein/Gene Name';
            }

            if(!inputid || inputid.substr(0, 4) == ic.defaultPdbId) {
                $("#" + ic.pre + "title").html(title);
            }
            else if(me.cfg.blast_rep_id) {
                let query_id = (me.cfg.oriQuery_id) ? me.cfg.oriQuery_id : me.cfg.query_id;
                let blast_rep_id = (me.cfg.oriBlast_rep_id) ? me.cfg.oriBlast_rep_id : me.cfg.blast_rep_id;
                if(query_id.length > 20) query_id = query_id.substr(0, 17) + '...';
                
                text = 'Query: ' + query_id + '; target: ' + blast_rep_id;
                $("#" + ic.pre + "title").html(text + ", " + title);
            }
            else {
                $("#" + ic.pre + "title").html(idName + " <a id='" + ic.pre + "titlelink' href='" + url + "' style='color:" + titlelinkColor + "' target='_blank'>" + text + "</a>: " + title);
            }
        }

        getLinkToStructureSummary(bLog) {var ic = this.icn3d, me = ic.icn3dui;
           let url = "https://www.ncbi.nlm.nih.gov/structure/?term=";

           if(me.cfg.cid !== undefined) {
               url = "https://www.ncbi.nlm.nih.gov/pccompound/?term=";
           }
           else if(me.cfg.refseqid !== undefined) {
            url = "https://www.ncbi.nlm.nih.gov/protein/";
           }
           else if(me.cfg.afid !== undefined) {
               url = "https://alphafold.ebi.ac.uk/search/text/";
           }
           else {
               //if(ic.inputid.indexOf(",") !== -1) {
               if(Object.keys(ic.structures).length > 1) {
                   url = "https://www.ncbi.nlm.nih.gov/structure/?term=";
               }
               else {
                   //url = "https://www.ncbi.nlm.nih.gov/Structure/mmdb/mmdbsrv.cgi?uid=";
                   url = me.htmlCls.baseUrl + "pdb/";
               }
           }

           if(ic.inputid === undefined) {
               url = "https://www.ncbi.nlm.nih.gov/pccompound/?term=" + ic.molTitle;
           }
           else {
               let idArray = ic.inputid.split('_');

               if(idArray.length === 1) {
                   url += ic.inputid;
                   if(bLog) me.htmlCls.clickMenuCls.setLogCmd("link to " + ic.inputid + ": " + url, false);
               }
               else if(idArray.length === 2) {
                    if(me.cfg.afid) {
                        url += idArray[0] + " " + idArray[1];
                    }
                    else {
                        url += idArray[0] + " OR " + idArray[1];
                    }

                    if(bLog) me.htmlCls.clickMenuCls.setLogCmd("link to structures " + idArray[0] + " and " + idArray[1] + ": " + url, false);
               }
           }

           return url;
        }

        setEntrezLinks(db) {var ic = this.icn3d, me = ic.icn3dui;
          let structArray = Object.keys(ic.structures);
          let url;
          if(structArray.length === 1) {
              url = "https://www.ncbi.nlm.nih.gov/" + db + "/?term=" + structArray[0];
              me.htmlCls.clickMenuCls.setLogCmd("Entrez " + db + " about PDB " + structArray[0] + ": " + url, false);
              let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
              window.open(url, urlTarget);
          }
          else if(structArray.length === 2) {
              url = "https://www.ncbi.nlm.nih.gov/" + db + "/?term=" + structArray[0] + " OR " + structArray[1];
              me.htmlCls.clickMenuCls.setLogCmd("Entrez " + db + " about PDB " + structArray[0] + " OR " + structArray[1] + ": " + url, false);
              let urlTarget = (ic.structures && Object.keys(ic.structures).length > 0) ? '_blank' : '_self';
              window.open(url, urlTarget);
          }
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class ShareLink {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Generate a URL to capture the current state and open it in a new window. Basically the state
        //file (the command history) is concatenated in the URL to show the current state.
        async shareLink(bPngHtml, bPngOnly) { let ic = this.icn3d, me = ic.icn3dui;
            let url = this.shareLinkUrl();

            let bTooLong =(url.length > 4000 || url.indexOf('http') !== 0) ? true : false;
            //if(bPngHtml) url += "&random=" + parseInt(Math.random() * 1000); // generate a new shorten URL and thus image name every time
            
            //var inputid =(ic.inputid) ? ic.inputid : "custom";
            let inputid = Object.keys(ic.structures).join('_');
            if(inputid == ic.defaultPdbId) {
                if(ic.filename) {
                    inputid = ic.filename;
                }
                else if(ic.inputid) {
                    inputid = ic.inputid;
                }
            }

            if(!bPngHtml) {
                if(ic.bInputfile && !ic.bInputUrlfile) {
                    alert("Share Link does NOT work when the data are from custom files. Please save 'iCn3D PNG Image' in the File menu and open it in iCn3D.");
                    return;
                }
                if(bTooLong) {
                    alert("The url is more than 4000 characters and may not work. Please save 'iCn3D PNG Image' or 'State File' and open them in iCn3D.");
                    return;
                }
                me.htmlCls.clickMenuCls.setLogCmd("share link: " + url, false);
            }
            else {
                if(bPngOnly || ic.bInputfile || bTooLong) {
                    ic.saveFileCls.saveFile(inputid + '_icn3d_loadable.png', 'png');
                    return;
                }
            }

            let shorturl = 'Problem in getting shortened URL';

            if(!me.cfg.notebook) {
                let data = await this.getShareLinkPrms(url, bPngHtml);

                if(data.shortLink !== undefined) {
                    shorturl = data.shortLink;
                    if(bPngHtml) { // save png and corresponding html
                        let strArray = shorturl.split("/");
                        let shortName = strArray[strArray.length - 1];
                        ic.saveFileCls.saveFile(inputid + '-' + shortName + '.png', 'png');
                        let text = '<div style="float:left; border: solid 1px #0000ff; padding: 5px; margin: 10px; text-align:center;">';
                        text += '<a href="https://www.ncbi.nlm.nih.gov/Structure/icn3d/share.html?' + shortName + '" target="_blank">';
                        text += '<img style="height:300px" src ="' + inputid + '-' + shortName + '.png"><br>\n';
                        text += '<!--Start of your comments==================-->\n';
                        let yournote =(ic.yournote) ? ': ' + ic.yournote.replace(/\n/g, "<br>").replace(/; /g, ", ") : '';
                        text += 'PDB ' + inputid.toUpperCase() + yournote + '\n';
                        text += '<!--End of your comments====================-->\n';
                        text += '</a>';
                        text += '</div>\n\n';
                        ic.saveFileCls.saveFile(inputid + '-' + shortName + '.html', 'html', text);
                    }
                }

                if(bPngHtml && data.shortLink === undefined) {
                    ic.saveFileCls.saveFile(inputid + '_icn3d_loadable.png', 'png');
                }

                //shorturl: https://icn3d.page.link/NvbAh1Vmiwc4bgX87
                let urlArray = shorturl.split('page.link/');
                //if(urlArray.length == 2) shorturl = me.htmlCls.baseUrl + 'icn3d/share.html?' + urlArray[1];
                // When the baseURL is structure.ncbi.nlm.nih.gov, mmcifparser.cgi has a problem to pass posted data in Mac/iphone
                // So the base URL is still www.ncbi.nlm.nih.gov/Structure,just use short URL here
                if(urlArray.length == 2) shorturl = 'https://www.ncbi.nlm.nih.gov/Structure/icn3d/share.html?' + urlArray[1];

                $("#" + ic.pre + "short_url").val(shorturl);
                $("#" + ic.pre + "short_url_title").val(shorturl + '&t=' + ic.yournote);
            }

            let outputCmd = this.shareLinkUrl(undefined, true);
            let idStr = (me.cfg.url) ? "url=" + me.cfg.url : me.cfg.idname + "=" + me.cfg.idvalue; //"mmdbafid=" + ic.inputid;
            let jnCmd = "view = icn3dpy.view(q='" + idStr + "',command='" + outputCmd + "')\nview";
            if(me.cfg.url || me.cfg.idname) {
                $("#" + ic.pre + "jn_commands").val(jnCmd);
            }

            $("#" + ic.pre + "ori_url").val(url);

            if(!bPngHtml) me.htmlCls.dialogCls.openDlg('dl_copyurl', 'Copy a Share Link URL or Jupyter Notebook Commands');
        }

        getShareLinkPrms(url, bPngHtml) { let ic = this.icn3d, me = ic.icn3dui;
            //https://firebase.google.com/docs/dynamic-links/rest
            //Web API Key: AIzaSyBxl9CgM0dY5lagHL4UOhEpLWE1fuwdnvc
            let fdlUrl = "https://firebasedynamiclinks.googleapis.com/v1/shortLinks?key=AIzaSyBxl9CgM0dY5lagHL4UOhEpLWE1fuwdnvc";
            return new Promise(function(resolve, reject) {
                $.ajax({
                    url: fdlUrl,
                    type: 'POST',
                    //data : {'longDynamicLink': 'https://d55qc.app.goo.gl/?link=' + url, "suffix": {"option": "SHORT"}},
                    //data : {'longDynamicLink': 'https://d55qc.app.goo.gl/?link=' + encodeURIComponent(url)},
                    data : {'longDynamicLink': 'https://icn3d.page.link/?link=' + encodeURIComponent(url)},
                    dataType: 'json',
                    success: function(data) {
                        resolve(data);
                    },
                    error : function(xhr, textStatus, errorThrown ) {
                        let shorturl = 'Problem in getting shortened URL';
                        $("#" + ic.pre + "ori_url").val(url);
                        $("#" + ic.pre + "short_url").val(shorturl);
                        $("#" + ic.pre + "short_url_title").val(shorturl + '&t=' + ic.yournote);
                        if(!bPngHtml) me.htmlCls.dialogCls.openDlg('dl_copyurl', 'Copy a Share Link URL');
                    }
                });
            });
        }

        shareLinkUrl(bAllCommands, bOutputCmd, bStatefile) { let ic = this.icn3d, me = ic.icn3dui;
               let url = me.htmlCls.baseUrl + "icn3d/full_" + me.REVISION + ".html?";
               let outputCmd = '';
               if(me.cfg.bSidebyside) url = me.htmlCls.baseUrl + "icn3d/full2.html?";

               if(ic.bInputUrlfile) {
                   let urlArray = window.location.href.split('?');
                   url = urlArray[0] + '?' + ic.inputurl + '&';
               }

               let paraHash = {};
               for(let key in ic.cfg) {
                   let value = ic.cfg[key];
                   //if(key === 'inpara' || ic.key === 'command' || value === undefined) continue;
                   if(key === 'inpara' || key === 'command' || key === 'usepdbnum'
                     || key === 'date' || key === 'v' || value === undefined) continue;

                    // check the default values as defined at the beginning of full_ui.js
                    //if(key === 'command' && value === '') continue;

                    if(key === 'width' && value === '100%') continue;
                    if(key === 'height' && value === '100%') continue;

                    if(key === 'resize' && value === true) continue;
                    if(key === 'showmenu' && value === true) continue;
                    if(key === 'showtitle' && value === true) continue;
                    if(key === 'showcommand' && value === true) continue;

                    //if(key === 'simplemenu' && value === false) continue;
                    if(key === 'mobilemenu' && value === false) continue;
                    //if(key === 'closepopup' && value === false) continue;
                    if(key === 'showanno' && value === false) continue;
                    if(key === 'showseq' && value === false) continue;
                    if(key === 'showalignseq' && value === false) continue;
                    if(key === 'show2d' && value === false) continue;
                    if(key === 'showsets' && value === false) continue;

                    if(key === 'rotate' && value === 'right') continue;

                    // commands will be added in the for loop below: for(let il = ic.commands...
                    if(key === 'command') continue;

                   if(key === 'options') {
                       if(Object.keys(value).length > 0) {
                           //url += key + '=' + JSON.stringify(value) + '&';
                           paraHash[key] = JSON.stringify(value);
                       }
                   }
                   else if(value === true) {
                       //url += key + '=1&';
                       paraHash[key] = 1;
                   }
                   else if(value === false) {
                       //url += key + '=0&';
                       paraHash[key] = 0;
                   }
                   else if(value !== '') {
                       //url += key + '=' + value + '&';
                       paraHash[key] = value;
                   }
               }

               if(ic.bAfMem) {
                paraHash['afmem'] = 'on';
               }
               //else {
               else if(me.cfg.afid || (Object.keys(ic.structures).length == 1 && Object.keys(ic.structures)[0].length > 5) ) {
                paraHash['afmem'] = 'off';
               }

               let inparaWithoutCommand;
               let pos = -1;
               if(me.cfg.inpara !== undefined) pos = me.cfg.inpara.indexOf('&command=');
               inparaWithoutCommand =(pos !== -1 ) ? me.cfg.inpara.substr(0, pos) : me.cfg.inpara;

               let bPrevDate = false;
               if(!ic.bInputUrlfile) {
                   let inparaArray =(inparaWithoutCommand && inparaWithoutCommand.substr(1)) ? inparaWithoutCommand.substr(1).split('&') : [];
                   for(let i = 0, il = inparaArray.length; i < il; ++i) {
                       let key_value = inparaArray[i].split('=');
                       if(key_value.length == 2) paraHash[key_value[0]] = key_value[1];
                   }

                   if(me.cfg.idname && !paraHash[me.cfg.idname]) { // somehow it is not included
                        url += me.cfg.idname + '=' + me.cfg.idvalue + '&';
                   }

                   for(let key in paraHash) {
                       if(key === 'v') continue;

                       if(key === 'date') bPrevDate = true;
                       url += key + '=' + paraHash[key] + '&';
                   }
               }

               // add time stamp
               let dateAllStr = me.utilsCls.getDateDigitStr();
               if(!bPrevDate) url += 'date=' + dateAllStr + '&';
               url += 'v=' + me.REVISION + '&';

               url += 'command=';

               let start;
               //if(me.cfg.notebook) {
               if(bOutputCmd) {
                    start =(inparaWithoutCommand !== undefined) ? 1 : 0;
               }
               else {
                    start = 0;
               }

               if(bAllCommands || ic.bInputUrlfile) start = 0;

               let transformation = {};
               transformation.factor = ic._zoomFactor;
               transformation.mouseChange = ic.mouseChange;
               transformation.quaternion = ic.quaternion;

               let statefile = "";
               let prevCommandStr = "";

               let toggleStr = 'toggle highlight';
               let cntToggle = 0;

               if(ic.commands.length > start) {
                   let command_tf = ic.commands[start].split('|||');
                   let command_tf2 = command_tf[0].split('&command=');
                   prevCommandStr = command_tf2[0].trim();

                   //statefile += ic.commands[start] + "\n";

                   if(prevCommandStr.indexOf(toggleStr) !== -1) ++cntToggle;
               }

               let i = start + 1;
               let tmpUrl = '';

               for(let il = ic.commands.length; i < il; ++i) {
                   let command_tf = ic.commands[i].split('|||');
                   let command_tf2 = command_tf[0].split('&command=');
                   let commandStr = command_tf2[0].trim();

                   // only one load command
                   //if(prevCommandStr.substr(0, 5) == 'load ' && commandStr.substr(0, 5) == 'load ') {
                   //    continue;
                   //}

                   //statefile += ic.commands[i] + "\n";

                   // only output the most recent 'select sets...' without " | name ..."
                   // or those select without names
                   if(prevCommandStr.indexOf('select sets') == 0 && commandStr.indexOf('select sets') === 0 
                     && prevCommandStr.indexOf(' name ') === -1) ;
                   else if(prevCommandStr.indexOf('pickatom') !== -1 && commandStr.indexOf('pickatom') !== -1) ;
                   // remove all "show selection" except the last one
                   else if(prevCommandStr == 'show selection' && ic.commands.slice(i).toString().indexOf('show selection') != -1) ;
                   else if(prevCommandStr == commandStr) ;
                   else if(prevCommandStr.indexOf(toggleStr) !== -1) {
                       ++cntToggle;
                   }
                   else if(i === start + 1) {
                    //    if(prevCommandStr.substr(0, 4) !== 'load') {
                           tmpUrl += prevCommandStr;
                    //    }
                   }
                   else {
                       tmpUrl += (tmpUrl) ? '; ' + prevCommandStr : prevCommandStr;
                   }

                   // keep all commands in statefile
                   if(prevCommandStr.indexOf('load ') == -1) statefile += prevCommandStr + "\n";

                   prevCommandStr = commandStr;
               }

               // last command
               if(prevCommandStr) {
                   if(tmpUrl) tmpUrl += '; ';
                   if(cntToggle > 0 && cntToggle %2 == 0 && prevCommandStr !== toggleStr) tmpUrl += toggleStr + '; ';

                   tmpUrl += prevCommandStr + '|||' + ic.transformCls.getTransformationStr(transformation);
                   statefile += prevCommandStr + '|||' + ic.transformCls.getTransformationStr(transformation) + '\n';
               }

               url += tmpUrl;
               outputCmd = tmpUrl;

               statefile = statefile.replace(/!/g, Object.keys(ic.structures)[0] + '_');
               if(ic.bEsmfold || (ic.bInputfile && !ic.bInputUrlfile) || (ic.bInputUrlfile && ic.bAppend) || url.length > 4000) url = statefile;
               let id;
               if(ic.structures !== undefined && Object.keys(ic.structures).length == 1 && ic.inputid !== undefined) {
                   id = Object.keys(ic.structures)[0];
                   url = url.replace(new RegExp(id + '_','g'), '!');
                   outputCmd = outputCmd.replace(new RegExp(id + '_','g'), '!');
               }

               if(me.cfg.blast_rep_id !== undefined) {
                   url = url.replace(new RegExp('blast_rep_id=!','g'), 'blast_rep_id=' + id + '_');
               }

               return (bStatefile) ? statefile : (bOutputCmd) ? outputCmd : url;
        }

        getPngText() { let ic = this.icn3d; ic.icn3dui;
            let bAllCommands = true;

            let text = "";
    /*
            if(ic.bInputfile) {
                url = this.shareLinkUrl(bAllCommands); // output state file if ic.bInputfile is true or the URL is more than 4000 chars

                if(url.substr(0,4) == 'http') {
                    text += "\nShare Link: " + url;
                }
                else {
                    text += "\nStart of type file======\n";
                    // text += ic.InputfileType + "\n";
                    text += "pdb\n";
                    text += "End of type file======\n";

                    text += "Start of data file======\n";
                    //text += ic.InputfileData;
                    text += ic.saveFileCls.getAtomPDB(ic.atoms);

                    text += "End of data file======\n";

                    text += "Start of state file======\n";
                    text += url + "\n";
                    text += "End of state file======\n";
                }
            }
            else {
                url = this.shareLinkUrl();
                let bTooLong =(url.length > 4000 || url.indexOf('http') !== 0) ? true : false;
                if(bTooLong) {
                    url = this.shareLinkUrl(bAllCommands); // output state file if ic.bInputfile is true or the URL is more than 4000 chars

                    text += "\nStart of state file======\n";

                    text += url + "\n";
                    text += "End of state file======\n";
                }
                else {
                    text += "\nShare Link: " + url;
                }
            }
    */

            // always output PDB and commands
            text += "\nStart of type file======\n";
            text += "pdb\n";
            text += "End of type file======\n";

            text += "Start of data file======\n";
            text += ic.saveFileCls.getAtomPDB(ic.atoms);
            text += "End of data file======\n";

            let bStatefile = true;
            let commands = this.shareLinkUrl(bAllCommands, undefined, bStatefile);
            text += "Start of state file======\n";
            text += commands + "\n";
            text += "End of state file======\n";
    /*
            if(ic.bInputfile) {
                url = this.shareLinkUrl(bAllCommands); // output state file if ic.bInputfile is true or the URL is more than 4000 chars

                if(url.substr(0,4) == 'http') {
                    text += "\nShare Link: " + url;
                }
            }
            else {
                url = this.shareLinkUrl();
                let bTooLong =(url.length > 4000 || url.indexOf('http') !== 0) ? true : false;
                if(!bTooLong) {
                    text += "\nShare Link: " + url;
                }
            }
    */
            text = text.replace(/!/g, Object.keys(ic.structures)[0] + '_');

            return text;
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class ThreeDPrint {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        setThichknessFor3Dprint(  ){ let ic = this.icn3d, me = ic.icn3dui;
            ic.lineRadius = 1; //0.1; // hbonds, distance lines
            ic.coilWidth = 1.2; //0.3; // style cartoon-coil
            ic.cylinderRadius = 0.8; //0.4; // style stick
            ic.crosslinkRadius = 0.8; //0.4; // cross-linkage
            ic.traceRadius = 1; //0.4; // style c alpha trace, nucleotide stick
            ic.dotSphereScale = 0.6; //0.3; // style ball and stick, dot

            ic.sphereRadius = 1.5; // style sphere
            //ic.cylinderHelixRadius = 1.6; // style cylinder and plate

            ic.ribbonthickness = 1.0; //0.2; // style ribbon, nucleotide cartoon, stand thickness
            ic.helixSheetWidth = 2.0; //1.3; // style ribbon, stand thickness
            ic.nucleicAcidWidth = 1.4; //0.8; // nucleotide cartoon

            me.htmlCls.setHtmlCls.setCookieForThickness();
        }

        //Prepare for 3D printing by changing dashed lines to solid lines, changing the thickness of the model.
        prepareFor3Dprint(  ){ let ic = this.icn3d, me = ic.icn3dui;
            // turn off highlight
            ic.bShowHighlight = false;
            ic.hlObjectsCls.removeHlObjects();

            ic.bDashedLines = false;

            if(!ic.bSetThickness && me.cfg.cid === undefined) {
                this.setThichknessFor3Dprint();
            }

            // change hbond and distance lines from dashed to solid for 3d printing
            if(ic.lines['hbond'] !== undefined) {
                for(let i = 0, il = ic.lines['hbond'].length; i < il; ++i) {
                    let line = ic.lines['hbond'][i];
                    line.dashed = false;

                    ic.bDashedLines = true;
                }
            }

            if(ic.lines['distance'] !== undefined) {
                for(let i = 0, il = ic.lines['distance'].length; i < il; ++i) {
                    let line = ic.lines['distance'][i];
                    line.dashed = false;

                    ic.bDashedLines = true;
                }
            }

            ic.drawCls.draw();

            ic.bShowHighlight = true; // reset
        }

        //Reset the hydrogen bonds, distance lines to dashed lines. Reset the thickness to the default values.
        resetAfter3Dprint(){ let ic = this.icn3d, me = ic.icn3dui;
            // change hbond and distance lines from dashed to solid for 3d printing
            //if(ic.bDashedLines) {
              if(ic.lines['hbond'] !== undefined) {
                for(let i = 0, il = ic.lines['hbond'].length; i < il; ++i) {
                    let line = ic.lines['hbond'][i];
                    line.dashed = true;
                }
              }

              if(ic.lines['distance'] !== undefined) {
                for(let i = 0, il = ic.lines['distance'].length; i < il; ++i) {
                    let line = ic.lines['distance'][i];
                    line.dashed = true;
                }
              }

              ic.lineRadius = 0.1; // hbonds, distance lines
              ic.coilWidth = 0.3; // style cartoon-coil
              ic.cylinderRadius = 0.4; // style stick
              ic.crosslinkRadius = 0.4; // cross-linkage
              ic.traceRadius = 0.4; // style c alpha trace, nucleotide stick
              ic.dotSphereScale = 0.3; // style ball and stick, dot
              ic.sphereRadius = 1.5; // style sphere
              ic.cylinderHelixRadius = 1.6; // style cylinder and plate

              ic.ribbonthickness = 0.2; // style ribbon, nucleotide cartoon, stand thickness
              ic.helixSheetWidth = 1.3; // style ribbon, nucleotide cartoon, stand thickness
              ic.nucleicAcidWidth = 0.8; // nucleotide cartoon

              me.htmlCls.setHtmlCls.setCookieForThickness();

              //ic.drawCls.draw();
            //}
        }

        removeOneStabilizer(rmLineArray) { let ic = this.icn3d; ic.icn3dui;
            let index;
            for(let i = 0, il = ic.pairArray.length; i < il; i += 2) {
                let atom1 = this.getResidueRepAtom(ic.pairArray[i]);
                let atom2 = this.getResidueRepAtom(ic.pairArray[i+1]);

                if(rmLineArray != undefined) {
                    for(let j = 0, jl = rmLineArray.length; j < jl; j += 2) {
                        let atomb1 = this.getResidueRepAtom(rmLineArray[j]);
                        let atomb2 = this.getResidueRepAtom(rmLineArray[j+1]);
                        if((atom1.serial == atomb1.serial && atom2.serial == atomb2.serial)
                          ||(atom1.serial == atomb2.serial && atom2.serial == atomb1.serial)
                          ) {
                            index = i;
                            break;
                        }
                    }
                }

                if(index !== undefined) break;
            }

            if(index !== undefined) {
                ic.pairArray.splice(index, 2); // removetwoelements at index i
            }
        }

        //Output the selected residues in the residue dialog.
        outputSelection() { let ic = this.icn3d, me = ic.icn3dui;
            let residues = {};
            for(let i in ic.hAtoms) {
                let residueId = ic.atoms[i].structure + '_' + ic.atoms[i].chain + '_' + ic.atoms[i].resi;
                residues[residueId] = 1;
            }

            let residueArray = Object.keys(residues).sort(function(a, b) {
                        if(a !== '' && !isNaN(a)) {
                            return parseInt(a) - parseInt(b);
                        }
                        else {
                            let lastPosA = a.lastIndexOf('_');
                            let lastPosB = b.lastIndexOf('_');
                            if(a.substr(0, lastPosA) < b.substr(0, lastPosA)) return -1;
                            else if(a.substr(0, lastPosA) > b.substr(0, lastPosA)) return 1;
                            else if(a.substr(0, lastPosA) == b.substr(0, lastPosA)) {
                                if(parseInt(a.substr(lastPosA + 1)) < parseInt(b.substr(lastPosB + 1)) ) return -1;
                                else if(parseInt(a.substr(lastPosA + 1)) > parseInt(b.substr(lastPosB + 1)) ) return 1;
                                else if(parseInt(a.substr(lastPosA + 1)) == parseInt(b.substr(lastPosB + 1)) ) return 0;
                            }
                        }
                    });

            let output = "<table><tr><th>Structure</th><th>Chain</th><th>Residue Number</th></tr>";
            for(let i = 0, il = residueArray.length; i < il; ++i) {
                //if(typeof(residueArray[i]) === 'function') continue;

                let firstPos = residueArray[i].indexOf('_');
                let lastPos = residueArray[i].lastIndexOf('_');
                let structure = residueArray[i].substr(0, firstPos);
                let chain = residueArray[i].substr(firstPos + 1, lastPos - firstPos - 1);
                let resi = residueArray[i].substr(lastPos + 1);

                output += "<tr><td>" + structure + "</td><td>" + chain + "</td><td>" + resi + "</td></tr>";
            }

            let file_pref = Object.keys(me.utilsCls.getHlStructures()).join(',');
            ic.saveFileCls.saveFile(file_pref + '_residues.txt', 'html', output);

        }

        // within the display atoms, show the bonds between C alpha or nucleotide N3
        // 1. add hbonds in protein and nucleotide
        // 2. add stabilizer between chemicals/ions and proteins

        //Add stabilizers in the model for 3D printing. This is especially important for the cartoon display such as ribbons.
        addStabilizer() { let ic = this.icn3d, me = ic.icn3dui;
            let threshold = 3.5; //between 3.2 and 4.0

            let minHbondLen = 3.2;

            //ic.opts["water"] = "dot";

            if(Object.keys(ic.dAtoms).length > 0) {

                // 1. add hbonds in nucleotide
                let atomHbond = {};
                let chain_resi_atom;

                let maxlengthSq = threshold * threshold;
                let minlengthSq = minHbondLen * minHbondLen;

                for(let i in ic.dAtoms) {
                  let atom = ic.atoms[i];

                  // protein: N, O
                  // DNA: C: O2, N3, N4; G: N1, N2, O6; A: N1, N6; T: N1, N6
                  if(ic.nucleotides.hasOwnProperty(atom.serial) &&(atom.name === "N1" || atom.name === "N2"
                      || atom.name === "N3" || atom.name === "N4" || atom.name === "N6" || atom.name === "O2" || atom.name === "O6")
                      ) { // calculate hydrogen bond in residue backbone
                    chain_resi_atom = atom.structure + "_" + atom.chain + "_" + atom.resi + "_" + atom.name;

                    atomHbond[chain_resi_atom] = atom;
                  }
                } // end of for(let i in molecule) {

                let atomArray = Object.keys(atomHbond);
                let len = atomArray.length;

                if(ic.pairArray === undefined) ic.pairArray = [];
                for(let i = 0; i < len; ++i) {
                    for(let j = i + 1; j < len; ++j) {
                      let atomid1 = atomArray[i];
                      let atomid2 = atomArray[j];

                      let xdiff = Math.abs(atomHbond[atomid1].coord.x - atomHbond[atomid2].coord.x);
                      if(xdiff > threshold) continue;

                      let ydiff = Math.abs(atomHbond[atomid1].coord.y - atomHbond[atomid2].coord.y);
                      if(ydiff > threshold) continue;

                      let zdiff = Math.abs(atomHbond[atomid1].coord.z - atomHbond[atomid2].coord.z);
                      if(zdiff > threshold) continue;

                      let dist = xdiff * xdiff + ydiff * ydiff + zdiff * zdiff;
                      if(dist > maxlengthSq || dist < minlengthSq) continue;

                      // output hydrogen bonds
                      ic.pairArray.push(atomHbond[atomid1].serial);
                      ic.pairArray.push(atomHbond[atomid2].serial);
                    } // end of for(let j
                } // end of for(let i

                // 2. add stabilizer for chemicals/ions and proteins
                let maxDistance = 6; // connect within 6 angstrom, use 6 since some proteins such as 1FFK_A has large distance between residues

                //displayed residues
                let displayResidueHash = {};
                for(let i in ic.dAtoms) {
                    let atom = ic.atoms[i];

                    let residueid = atom.structure + "_" + atom.chain + "_" + atom.resi;
                    displayResidueHash[residueid] = 1;
                }

                // connect chemicals, ions, and every third protein residues to neighbors(within 4 angstrom)
                let residueHash = {};
                //chemicals
                for(let i in ic.chemicals) {
                    let atom = ic.atoms[i];

                    let residueid = atom.structure + "_" + atom.chain + "_" + atom.resi;
                    if(displayResidueHash.hasOwnProperty(residueid)) residueHash[residueid] = 1;
                }
                //ions
                for(let i in ic.ions) {
                    let atom = ic.atoms[i];

                    let residueid = atom.structure + "_" + atom.chain + "_" + atom.resi;
                    if(displayResidueHash.hasOwnProperty(residueid)) residueHash[residueid] = 1;
                }

                //every third protein residues
                let chainArray = Object.keys(ic.chains);
                for(let i = 0, il = chainArray.length; i < il; ++i) {
                    let chainid = chainArray[i];
                    let coilCnt = 0;
                    let residueid;
                    let prevResi = 0;
                    for(let j = 0, jl = ic.chainsSeq[chainid].length; j < jl; ++j) {
                        residueid = chainid + '_' + ic.chainsSeq[chainid][j].resi;
                        if(ic.secondaries[residueid] == 'c' || ic.secondaries[residueid] == 'E' || ic.secondaries[residueid] == 'H') {
                            // add every third residue
                            if(coilCnt % 3 == 0 || ic.resid2ncbi[ic.chainsSeq[chainid][j].resi] != ic.resid2ncbi[prevResi] + 1) {
                                if(displayResidueHash.hasOwnProperty(residueid)) residueHash[residueid] = 1;
                            }

                            ++coilCnt;

                            prevResi = ic.chainsSeq[chainid][j].resi;
                        }
                    }

                    // last residue
                    if(ic.secondaries[residueid] == 'c' || ic.secondaries[residueid] == 'E' || ic.secondaries[residueid] == 'H') {
                        if(displayResidueHash.hasOwnProperty(residueid)) residueHash[residueid] = 1;
                    }
                }

                let residueArray = Object.keys(residueHash);

                if(ic.pairArray === undefined) ic.pairArray = [];
                // displayed atoms except water
                let dAtomsNotWater = me.hashUtilsCls.exclHash(ic.dAtoms, ic.water);

                for(let i = 0, il = residueArray.length; i < il; ++i) {
                    let residueid = residueArray[i];
                    let ss = ic.secondaries[residueid];

                    let sphere = ic.contactCls.getNeighboringAtoms(dAtomsNotWater, me.hashUtilsCls.hash2Atoms(ic.residues[residueid], ic.atoms), maxDistance);

                    // original atoms
                    let sphereArray = Object.keys(sphere).sort();
                    let atomArray = Object.keys(ic.residues[residueid]).sort();

                    let bProtein = false;
                    if(ic.proteins.hasOwnProperty(atomArray[0])) { // protein
                        atomArray = [atomArray[0]]; // one atom from the residue

                        bProtein = true;

                        // remove the previous, current and the next residues, chemicals, and ions from "sphere"
                        //let resi = parseInt(residueid.substr(residueid.lastIndexOf('_') + 1));
                        let chainid = residueid.substr(0, residueid.lastIndexOf('_'));
                        let resi = ic.ParserUtilsCls.getResiNCBI(chainid, residueid.substr(residueid.lastIndexOf('_') + 1));

                        let simSphere = {};
                        for(let serial in sphere) {
                            if(ic.chemicals.hasOwnProperty(serial) || ic.ions.hasOwnProperty(serial)) continue;

                            let atom = ic.atoms[serial];
                            if(isNaN(atom.resi)) continue;
                            let atomResi = ic.ParserUtilsCls.getResiNCBI(chainid, atom.resi);

                            if((ss == 'c' &&(atomResi > resi + 1 || atomResi < resi - 1) )
                              ||(ss == 'E' &&(atomResi > resi + 2 || atomResi < resi - 2) )
                              ||(ss == 'H' &&(atomResi > resi + 4 || atomResi < resi - 4) )
                              ) {
                                simSphere[serial] = 1;
                            }
                        }

                        sphereArray = Object.keys(simSphere).sort();
                    }

                    // one line per each protein residue
                    if(sphereArray.length > 0 && atomArray.length > 0) {
                        if(bProtein) {
                                let inter2 = parseInt((sphereArray.length + 0.5) / 2.0);
                                ic.pairArray.push(atomArray[0]);
                                ic.pairArray.push(sphereArray[inter2]);
                        }
                        else { // chemicals or ions
                            let n = 10;
                            let step = parseInt(sphereArray.length /(n+1));

                            for(let j = 0, jl = atomArray.length; j < jl; ++j) {
                                if(j % n == 0) { // make one line for every other 10 atoms
                                    let sphereIndex = parseInt(j/n) * step;
                                    let inter2 =(sphereIndex < sphereArray.length) ?  sphereIndex : sphereArray.length - 1;
                                    ic.pairArray.push(atomArray[j]);
                                    ic.pairArray.push(sphereArray[inter2]);

                                    if(atomArray.length < n + 1) {
                                        ic.pairArray.push(atomArray[j]);
                                        ic.pairArray.push(sphereArray[sphereArray.length - 1]);
                                    }
                                }
                            }
                        } // else
                    } // if(sphereArray.length > 0) {
                } // for
            }
        }

        //Remove all the added stabilizers.
        hideStabilizer() { let ic = this.icn3d; ic.icn3dui;
            //ic.opts["stabilizer"] = "no";
            ic.pairArray = [];

            ic.lines['stabilizer'] = [];
            ic.stabilizerpnts = [];

            for(let i in ic.water) {
                ic.atoms[i].style = ic.opts["water"];
            }

            //ic.drawCls.draw();
        }

        getResidueRepAtom(serial) { let ic = this.icn3d; ic.icn3dui;
            let atomIn = ic.atoms[serial];
            let residueid = atomIn.structure + "_" + atomIn.chain + "_" + atomIn.resi;

            let foundAtom;
            if(!ic.proteins.hasOwnProperty(serial) && !ic.nucleotides.hasOwnProperty(serial)) { // chemicals or ions
                foundAtom = atomIn;
            }
            else {
                for(let i in ic.residues[residueid]) {
                    let atom = ic.atoms[i];
                    if(atom.name === 'CA' || atom.name === 'N3') { // protein: CA, nucleotide: N3
                        foundAtom = ic.atoms[i];
                        break;
                    }
                }
            }

            if(foundAtom === undefined) foundAtom = atomIn;

            return foundAtom;
        }

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Export3D {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        exportStlFile(postfix) { let ic = this.icn3d, me = ic.icn3dui;
           // assemblies
           if(ic.biomtMatrices !== undefined && ic.biomtMatrices.length > 1 && ic.bAssembly) {
                // use a smaller grid to build the surface for assembly
                ic.threshbox = 180 / Math.pow(ic.biomtMatrices.length, 0.33);
                ic.applyMapCls.removeSurfaces();
                ic.applyMapCls.applySurfaceOptions();
                ic.applyMapCls.removeMaps();
                ic.applyMapCls.applyMapOptions();
                ic.applyMapCls.removeEmmaps();
                ic.applyMapCls.applyEmmapOptions();
           }
           let text = this.saveStlFile();
           let file_pref = Object.keys(me.utilsCls.getHlStructures()).join(',');
           ic.saveFileCls.saveFile(file_pref + postfix + '.stl', 'binary', text);
           // assemblies
           if(ic.biomtMatrices !== undefined && ic.biomtMatrices.length > 1 && ic.bAssembly
             && Object.keys(ic.dAtoms).length * ic.biomtMatrices.length > ic.maxAtoms3DMultiFile ) {
                alert(ic.biomtMatrices.length + " files will be generated for this assembly. Please merge these files using some software and 3D print the merged file.");
                let identity = new THREE.Matrix4();
                identity.identity();
                let index = 1;
                for(let i = 0; i < ic.biomtMatrices.length; i++) {  // skip itself
                  let mat = ic.biomtMatrices[i];
                  if(mat === undefined) continue;
                  // skip itself
                  if(mat.equals(identity)) continue;
                  let time =(i + 1) * 100;
                  //https://stackoverflow.com/questions/1190642/how-can-i-pass-a-parameter-to-a-settimeout-callback
                  setTimeout(function(mat, index){
                      text = this.saveStlFile(mat);
                      ic.saveFileCls.saveFile(file_pref + postfix + index + '.stl', 'binary', text);
                      text = '';
                  }.bind(this, mat, index), time);
                  ++index;
                }
                // reset grid to build the surface for assembly
                ic.threshbox = 180;
           }
        }

        exportVrmlFile(postfix) { let ic = this.icn3d, me = ic.icn3dui;
           // assemblies
           if(ic.biomtMatrices !== undefined && ic.biomtMatrices.length > 1 && ic.bAssembly) {
                // use a smaller grid to build the surface for assembly
                ic.threshbox = 180 / Math.pow(ic.biomtMatrices.length, 0.33);
                ic.applyMapCls.removeSurfaces();
                ic.applyMapCls.applySurfaceOptions();
                ic.applyMapCls.removeMaps();
                ic.applyMapCls.applyMapOptions();
                ic.applyMapCls.removeEmmaps();
                ic.applyMapCls.applyEmmapOptions();
           }
           let text = this.saveVrmlFile();
           let file_pref = Object.keys(me.utilsCls.getHlStructures()).join(',');
           ic.saveFileCls.saveFile(file_pref + postfix + '.wrl', 'text', text);
           //ic.saveFileCls.saveFile(file_pref + postfix + '.vrml', 'text', text);
           // assemblies
           if(ic.biomtMatrices !== undefined && ic.biomtMatrices.length > 1 && ic.bAssembly
             && Object.keys(ic.dAtoms).length * ic.biomtMatrices.length > ic.maxAtoms3DMultiFile ) {
                alert(ic.biomtMatrices.length + " files will be generated for this assembly. Please merge these files using some software and 3D print the merged file.");
                let identity = new THREE.Matrix4();
                identity.identity();
                let index = 1;
                for(let i = 0; i < ic.biomtMatrices.length; i++) {  // skip itself
                  let mat = ic.biomtMatrices[i];
                  if(mat === undefined) continue;
                  // skip itself
                  if(mat.equals(identity)) continue;
                  let time =(i + 1) * 100;
                  //https://stackoverflow.com/questions/1190642/how-can-i-pass-a-parameter-to-a-settimeout-callback
                  setTimeout(function(mat, index){
                      text = this.saveVrmlFile(mat);
                      ic.saveFileCls.saveFile(ic.inputid + postfix + index + '.wrl', 'text', text);
                      //ic.saveFileCls.saveFile(file_pref + postfix + index + '.vrml', 'text', text);
                      text = '';
                  }.bind(this, mat, index), time);
                  ++index;
                }
                // reset grid to build the surface for assembly
                ic.threshbox = 180;
           }
        }

        // generate a binary STL file for 3D printing
        // https://en.wikipedia.org/wiki/STL_(file_format)#Binary_STL
        /*
        UINT8[80]  Header
        UINT32  Number of triangles

        foreach triangle
        REAL32[3]  Normal vector
        REAL32[3]  Vertex 1
        REAL32[3]  Vertex 2
        REAL32[3]  Vertex 3
        UINT16  Attribute byte count
        end
        */

        getFaceCnt( mdl ){ let ic = this.icn3d; ic.icn3dui;
            let cntFaces = 0;
            for(let i = 0, il = mdl.children.length; i < il; ++i) {
                 let mesh = mdl.children[i];
                 if(mesh.type === 'Sprite') continue;

                 let geometry = mesh.geometry;

    //             let faces = geometry.faces;
    //             if(faces !== undefined) {
    //                 for(let j = 0, jl = faces.length; j < jl; ++j) {
    //                     ++cntFaces;
    //                 }
    //             }

                 let indexArray = geometry.getIndex().array;
                 cntFaces += indexArray.length / 3;

            }

            return cntFaces;
        }

        //Save the binary STL file for 3D monocolor printing.
        saveStlFile( mat ){ let ic = this.icn3d, me = ic.icn3dui;
            if(Object.keys(ic.dAtoms).length > 70000) {
                alert('Please display a subset of the structure to export 3D files. Then merge the files for 3D printing...');
                return [''];
            }

            ic.threeDPrintCls.prepareFor3Dprint();

            let cntFaces = 0;

            cntFaces += this.getFaceCnt(ic.mdl);
            cntFaces += this.getFaceCnt(ic.mdl_ghost);

            let blobArray = []; // hold blobs

            let stlArray = new Uint8Array(84);

            // UINT8[80]  Header
            let title = 'STL file for the structure(s) ';
            let structureArray = Object.keys(ic.structures);
            for(let i = 0, il = structureArray.length; i < il; ++i) {
                title += structureArray[i];
                if(i < il - 1) title += ', ';
            }

            if(title.length > 80) title = title.substr(0, 80);

            for(let i = 0; i < 80; ++i) {
                if(i < title.length) {
                    stlArray[i] = me.convertTypeCls.passInt8([title.charCodeAt(i)])[0];
                }
                else {
                    stlArray[i] = me.convertTypeCls.passInt8([' '.charCodeAt(0)])[0];
                }
            }

            // UINT32  Number of triangles
            if(ic.biomtMatrices !== undefined && ic.biomtMatrices.length > 1 && ic.bAssembly
              && Object.keys(ic.dAtoms).length * ic.biomtMatrices.length <= ic.maxAtoms3DMultiFile ) {
                stlArray = this.updateArray( stlArray, me.convertTypeCls.passInt32([cntFaces * ic.biomtMatrices.length]), 80 );
            }
            else {
                stlArray = this.updateArray( stlArray, me.convertTypeCls.passInt32([cntFaces]), 80 );
            }

            blobArray.push(new Blob([stlArray],{ type: "application/octet-stream"}));

            blobArray = this.processStlMeshGroup( ic.mdl, blobArray, mat );

            blobArray = this.processStlMeshGroup( ic.mdl_ghost, blobArray, mat );

           // assemblies
           if(ic.biomtMatrices !== undefined && ic.biomtMatrices.length > 1 && ic.bAssembly
             && Object.keys(ic.dAtoms).length * ic.biomtMatrices.length <= ic.maxAtoms3DMultiFile ) {
                let identity = new THREE.Matrix4();
                identity.identity();

                for(let i = 0; i < ic.biomtMatrices.length; i++) {  // skip itself
                  let mat1 = ic.biomtMatrices[i];
                  if(mat1 === undefined) continue;

                  // skip itself
                  if(mat1.equals(identity)) continue;

                  blobArray = this.processStlMeshGroup( ic.mdl, blobArray, mat1 );

                  blobArray = this.processStlMeshGroup( ic.mdl_ghost, blobArray, mat1 );
                }
            }

            ic.threeDPrintCls.resetAfter3Dprint();

            return blobArray;
        }

        updateArray( array, inArray, indexBase ){ let ic = this.icn3d; ic.icn3dui;
            for( let i = 0, il = inArray.length; i < il; ++i ){
                array[indexBase + i] = inArray[i];
            }
            return array;
        }

        processStlMeshGroup( mdl, blobArray, mat ){ let ic = this.icn3d, me = ic.icn3dui;
            for(let i = 0, il = mdl.children.length; i < il; ++i) {
                 let mesh = mdl.children[i];
                 if(mesh.type === 'Sprite') continue;

                 let geometry = mesh.geometry;

                 let positionArray = geometry.getAttribute('position').array;
                 let indexArray = geometry.getIndex().array;

                 let position = mesh.position;
                 let scale = mesh.scale;

                 let matrix = mesh.matrix;

                 let stlArray = new Uint8Array(indexArray.length / 3 * 50);

                 let index = 0;

                 for(let j = 0, jl = indexArray.length; j < jl; j += 3) {
                     let a = indexArray[j];
                     let b = indexArray[j+1];
                     let c = indexArray[j+2];

                     let va = new THREE.Vector3(positionArray[3*a], positionArray[3*a+1], positionArray[3*a+2]);
                     let vb = new THREE.Vector3(positionArray[3*b], positionArray[3*b+1], positionArray[3*b+2]);
                     let vc = new THREE.Vector3(positionArray[3*c], positionArray[3*c+1], positionArray[3*c+2]);

                     let v1, v2, v3;

                     if(geometry.type == 'SphereGeometry' || geometry.type == 'BoxGeometry') {
                         v1 = va.clone().multiply(scale).add(position);
                         v2 = vb.clone().multiply(scale).add(position);
                         v3 = vc.clone().multiply(scale).add(position);
                     }
                      else if(geometry.type == 'CylinderGeometry') {
                         v1 = va.clone().applyMatrix4(matrix);
                         v2 = vb.clone().applyMatrix4(matrix);
                         v3 = vc.clone().applyMatrix4(matrix);
                     }
                     else {
                         v1 = va.clone();
                         v2 = vb.clone();
                         v3 = vc.clone();
                     }

                     {
                         stlArray = this.updateArray( stlArray, me.convertTypeCls.passFloat32([0.0, 0.0, 0.0]), index );
                         index += 12;
                     }

                     if(mat !== undefined) {
                         v1.applyMatrix4(mat);
                         v2.applyMatrix4(mat);
                         v3.applyMatrix4(mat);
                     }

                     stlArray = this.updateArray( stlArray, me.convertTypeCls.passFloat32([v1.x, v1.y, v1.z]), index );
                     index += 12;
                     stlArray = this.updateArray( stlArray, me.convertTypeCls.passFloat32([v2.x, v2.y, v2.z]), index );
                     index += 12;
                     stlArray = this.updateArray( stlArray, me.convertTypeCls.passFloat32([v3.x, v3.y, v3.z]), index );
                     index += 12;

                     v1 = v2 = v3 = undefined;

                     stlArray = this.updateArray( stlArray, me.convertTypeCls.passInt16([0]), index );
                     index += 2;
                 }

                 blobArray.push(new Blob([stlArray],{ type: "application/octet-stream"}));
                 stlArray = null;
            }

            return blobArray;
        }

        //http://gun.teipir.gr/VRML-amgem/spec/part1/examples.html
        //Save the VRML file for 3D color printing.
        saveVrmlFile( mat ){ let ic = this.icn3d; ic.icn3dui;
            if(Object.keys(ic.dAtoms).length > 50000) {
                alert('Please display a subset of the structure to export 3D files. Then merge the files for 3D printing...');
                return [''];
            }

            ic.threeDPrintCls.prepareFor3Dprint();

            let vrmlStrArray = [];
            vrmlStrArray.push('#VRML V2.0 utf8\n');

            let vertexCnt = 0;
            let result = this.processVrmlMeshGroup( ic.mdl, vrmlStrArray, vertexCnt, mat );
            vrmlStrArray = result.vrmlStrArray;
            vertexCnt = result.vertexCnt;

            result = this.processVrmlMeshGroup( ic.mdl_ghost, vrmlStrArray, vertexCnt, mat );
            vrmlStrArray = result.vrmlStrArray;
            vertexCnt = result.vertexCnt;

           // assemblies
           if(ic.biomtMatrices !== undefined && ic.biomtMatrices.length > 1 && ic.bAssembly
             && Object.keys(ic.dAtoms).length * ic.biomtMatrices.length <= ic.maxAtoms3DMultiFile ) {
                let identity = new THREE.Matrix4();
                identity.identity();

                for(let i = 0; i < ic.biomtMatrices.length; i++) {  // skip itself
                  let mat1 = ic.biomtMatrices[i];
                  if(mat1 === undefined) continue;

                  // skip itself
                  if(mat1.equals(identity)) continue;

                    result = this.processVrmlMeshGroup( ic.mdl, vrmlStrArray, vertexCnt, mat1 );
                    vrmlStrArray = result.vrmlStrArray;
                    vertexCnt = result.vertexCnt;

                    result = this.processVrmlMeshGroup( ic.mdl_ghost, vrmlStrArray, vertexCnt, mat1 );
                    vrmlStrArray = result.vrmlStrArray;
                    vertexCnt = result.vertexCnt;
                }
            }

            return vrmlStrArray;
        }

        // The file lost face color after being repaired by https://service.netfabb.com/. It only works with vertex color
        // convert face color to vertex color
        processVrmlMeshGroup( mdl, vrmlStrArray, vertexCnt, mat ) { let ic = this.icn3d, me = ic.icn3dui;
            for(let i = 0, il = mdl.children.length; i < il; ++i) {
                let mesh = mdl.children[i];
                if(mesh.type === 'Sprite') continue;

                let geometry = mesh.geometry;

                mesh.material.type;
                (geometry.type == 'Surface') ? true : false;

                let positionArray = geometry.getAttribute('position').array;
                let colorArray = (geometry.getAttribute('color')) ? geometry.getAttribute('color').array : [];
                let indexArray = geometry.getIndex().array;

                let position = mesh.position;
                let scale = mesh.scale;

                let matrix = mesh.matrix;

                let meshColor = me.parasCls.thr(1, 1, 1);
                if(geometry.type == 'SphereGeometry' || geometry.type == 'BoxGeometry' || geometry.type == 'CylinderGeometry') {
                    if(mesh.material !== undefined) meshColor = mesh.material.color;
                }

                vrmlStrArray.push('Shape {\n');
                vrmlStrArray.push('geometry IndexedFaceSet {\n');

                vrmlStrArray.push('coord Coordinate { point [ ');

                let vertexColorStrArray = [];
                for(let j = 0, jl = positionArray.length; j < jl; j += 3) {
                    let va = new THREE.Vector3(positionArray[j], positionArray[j+1], positionArray[j+2]);

                    let vertex;
                    if(geometry.type == 'SphereGeometry' || geometry.type == 'BoxGeometry') {
                        vertex = va.clone().multiply(scale).add(position);
                    }
                    else if(geometry.type == 'CylinderGeometry') {
                        vertex = va.clone().applyMatrix4(matrix);
                    }
                    else {
                        vertex = va.clone();
                    }

                    if(mat !== undefined) vertex.applyMatrix4(mat);

                    vrmlStrArray.push(vertex.x.toPrecision(5) + ' ' + vertex.y.toPrecision(5) + ' ' + vertex.z.toPrecision(5));
                    vertex = undefined;

                    if(j < jl - 3) vrmlStrArray.push(', ');

                    vertexColorStrArray.push(me.parasCls.thr(1, 1, 1));
                }
                vrmlStrArray.push(' ] }\n');

                let coordIndexStr = '', colorStr = '';

                for(let j = 0, jl = indexArray.length; j < jl; j += 3) {
                    let a = indexArray[j];
                    let b = indexArray[j+1];
                    let c = indexArray[j+2];

                    let color;
                    if(geometry.type == 'SphereGeometry' || geometry.type == 'BoxGeometry' || geometry.type == 'CylinderGeometry') {
                        color = meshColor;
                    }
                    else {
                        color = new THREE.Color(colorArray[3*a], colorArray[3*a+1], colorArray[3*a+2]);
                    }

                    coordIndexStr += a + ' ' + b + ' ' + c;
                    // http://www.lighthouse3d.com/vrml/tutorial/index.shtml?indfs
                    // use -1 to separate polygons
                    if(j < jl - 3) coordIndexStr += ', -1, ';

                    // update vertexColorStrArray
                    vertexColorStrArray[a] = color;
                    vertexColorStrArray[b] = color;
                    vertexColorStrArray[c] = color;
                }

                for(let j = 0, jl = vertexColorStrArray.length; j < jl; ++j) {
                    let color = vertexColorStrArray[j];
                    colorStr += color.r.toPrecision(3) + ' ' + color.g.toPrecision(3) + ' ' + color.b.toPrecision(3);
                    if(j < jl - 1) colorStr += ', ';
                }

                vrmlStrArray.push('coordIndex [ ' + coordIndexStr + ' ]\n');
                vrmlStrArray.push('color Color { color [ ' + colorStr + ' ] } colorPerVertex TRUE\n');

                vrmlStrArray.push('  }\n');
                vrmlStrArray.push('}\n');
            }

            return {'vrmlStrArray': vrmlStrArray,'vertexCnt': vertexCnt};
        }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Ray {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        rayCaster(e, bClick) { let ic = this.icn3d; ic.icn3dui;
          if(!ic.opts || ic.opts['effect'] == 'none') {
            this.rayCasterBase(e, bClick);
          }
        }

        rayCasterBase(e, bClick) { let ic = this.icn3d; ic.icn3dui;
        // if(ic.bChainAlign) return; // no picking for chain alignment

            let x = e.pageX, y = e.pageY;
            if (e.originalEvent.targetTouches && e.originalEvent.targetTouches[0]) {
                x = e.originalEvent.targetTouches[0].pageX;
                y = e.originalEvent.targetTouches[0].pageY;
            }

            let left = ic.oriContainer.offset().left;
            let top = ic.oriContainer.offset().top;

            let containerWidth = ic.oriContainer.width();
            let containerHeight = ic.oriContainer.height();

            let popupX = x - left;
            let popupY = y - top;

            //ic.isDragging = true;

            // see ref http://soledadpenades.com/articles/three-js-tutorials/object-pk/
            //if(ic.pk && (e.altKey || e.ctrlKey || e.shiftKey || e.keyCode === 18 || e.keyCode === 16 || e.keyCode === 17 || e.keyCode === 224 || e.keyCode === 91) ) {
            //    ic.highlightlevel = ic.pk;

                ic.mouse.x = ( popupX / containerWidth ) * 2 - 1;
                ic.mouse.y = - ( popupY / containerHeight ) * 2 + 1;

                let mouse3 = new THREE.Vector3();
                mouse3.x = ic.mouse.x;
                mouse3.y = ic.mouse.y;
                //mouse3.z = 0.5;
                if(ic.cam_z > 0) {
                  mouse3.z = -1.0; // between -1 to 1. The z positio of mouse in the real world should be between the camera and the target."-1" worked in our case.
                }
                else {
                  mouse3.z = 1.0; // between -1 to 1. The z positio of mouse in the real world should be between the camera and the target."-1" worked in our case.
                }

                // similar to setFromCamera() except mouse3.z is the opposite sign from the value in setFromCamera()
                // use itsown camera for picking

                if(ic.cam === ic.perspectiveCamera) { // perspective
                    if(ic.cam_z > 0) {
                      mouse3.z = -1.0;
                    }
                    else {
                      mouse3.z = 1.0;
                    }
                    //ic.projector.unprojectVector( mouse3, ic.cam );  // works for all versions
                    mouse3.unproject(ic.cam );  // works for all versions
                    ic.raycaster.set(ic.cam.position, mouse3.sub(ic.cam.position).normalize()); // works for all versions
                }
                else if(ic.cam === ic.orthographicCamera) {  // orthographics
                    if(ic.cam_z > 0) {
                      mouse3.z = 1.0;
                    }
                    else {
                      mouse3.z = -1.0;
                    }
                    //ic.projector.unprojectVector( mouse3, ic.cam );  // works for all versions
                    mouse3.unproject(ic.cam );  // works for all versions
                    ic.raycaster.set(mouse3, new THREE.Vector3(0,0,-1).transformDirection( ic.cam.matrixWorld )); // works for all versions
                }

                let bFound = this.isIntersect(ic.objects, ic.mdl, bClick, popupX, popupY);

                if(!bFound) {
                    bFound = this.isIntersect(ic.objects_ghost, ic.mdl_ghost, bClick, popupX, popupY);
                }
            //}
        }

        isIntersect(objects, mdl, bClick, popupX, popupY) { let ic = this.icn3d; ic.icn3dui;
            let intersects = ic.raycaster.intersectObjects( objects ); // not all "mdl" group will be used for pk

            let bFound = false;

            let position = mdl.position;
            if ( intersects.length > 0 ) {
                // the intersections are sorted so that the closest point is the first one.
                intersects[ 0 ].point.sub(position); // mdl.position was moved to the original (0,0,0) after reading the molecule coordinates. The raycasting was done based on the original. The position of the original should be subtracted.

                let threshold = ic.rayThreshold; //0.5;
                let atom = this.getAtomsFromPosition(intersects[ 0 ].point, threshold); // the second parameter is the distance threshold. The first matched atom will be returned. Use 1 angstrom, not 2 angstrom. If it's 2 angstrom, other atom will be returned.

                while(!atom && threshold < 10) {
                    threshold = threshold + 0.5;
                    atom = this.getAtomsFromPosition(intersects[ 0 ].point, threshold);
                }

                if(atom) {
                    bFound = true;
                    if(ic.pickpair) {
                        if(bClick) {
                          if(ic.pAtomNum % 2 === 0) {
                            ic.pAtom = atom;
                          }
                          else {
                            ic.pAtom2 = atom;
                          }

                          ++ic.pAtomNum;
                        }
                    }
                    else {
                      ic.pAtom = atom;
                    }

                    if(bClick) {
                      ic.pickingCls.showPicking(atom);
                    }
                    else {
                      ic.pickingCls.showPicking(atom, popupX, popupY);
                    }
                }
                else {
                    console.log("No atoms were found in 10 andstrom range");
                }
            } // end if

            return bFound;
        }

         // from iview (http://istar.cse.cuhk.edu.hk/iview/)
         getAtomsFromPosition(point, threshold, atoms) { let ic = this.icn3d, me = ic.icn3dui;
            let i;

            if(threshold === undefined || threshold === null) {
              threshold = 1;
            }

            //for (i in ic.atoms) {
            let atomHash = (atoms) ? atoms : ic.dAtoms;
            for (i in atomHash) {
               let atom = ic.atoms[i];

               if(ic.ions.hasOwnProperty(i) && ic.opts['ions'] === 'sphere') {
                   let adjust = me.parasCls.vdwRadii[atom.elem.toUpperCase()];

                   if(Math.abs(atom.coord.x - point.x) - adjust > threshold) continue;
                   if(Math.abs(atom.coord.y - point.y) - adjust > threshold) continue;
                   if(Math.abs(atom.coord.z - point.z) - adjust > threshold) continue;
               }
               else {
                   if(atom.coord.x < point.x - threshold || atom.coord.x > point.x + threshold) continue;
                   if(atom.coord.y < point.y - threshold || atom.coord.y > point.y + threshold) continue;
                   if(atom.coord.z < point.z - threshold || atom.coord.z > point.z + threshold) continue;
               }

               return atom;
            }

            return null;
         }
    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Control {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        setControl() { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            let thisClass = this;

            // adjust the size
            ic.WIDTH = ic.container.width(), ic.HEIGHT = ic.container.height();
            ic.applyCenterCls.setWidthHeight(ic.WIDTH, ic.HEIGHT);

            ic._zoomFactor = 1.0;
            ic.mouseChange = new THREE.Vector2(0,0);
            ic.quaternion = new THREE.Quaternion(0,0,0,1);

            ic.container.bind('contextmenu', function (e) {
            //document.getElementById(ic.id).addEventListener('contextmenu', function (e) {
                e.preventDefault();
            });

            // key event has to use the document because it requires the focus
            ic.typetext = false;

            //http://unixpapa.com/js/key.html
            $(document).bind('keyup', function (e) {
            //document.addEventListener('keyup', function (e) {
              if(e.keyCode === 16) { // shiftKey
                  ic.bShift = false;
              }
              if(e.keyCode === 17 || e.keyCode === 224 || e.keyCode === 91) { // ctrlKey or apple command key
                  ic.bCtrl = false;
              }
            });

            $('input[type=text], textarea').focus(function() {
                ic.typetext = true;
            });

            $('input[type=text], textarea').blur(function() {
                ic.typetext = false;
            });

            $(document).bind('keydown', async function (e) {
            //document.addEventListener('keydown', function (e) {
              if(e.shiftKey || e.keyCode === 16) {
                  ic.bShift = true;
              }
              if(e.ctrlKey || e.keyCode === 17 || e.keyCode === 224 || e.keyCode === 91) {
                  ic.bCtrl = true;
              }

              if ((!ic.bControlGl && !ic.controls) || (ic.bControlGl && !window.controls)) return;

              ic.bStopRotate = true;

              let rotAngle = (ic.bShift) ? 90 : 5;

              if(!ic.typetext) {
                // zoom
                if(e.keyCode === 90 ) { // Z
                  let para = {};

                  if(ic.bControlGl && !me.bNode) {
                      if(window.cam === ic.perspectiveCamera) { // perspective
                        para._zoomFactor = 0.9;
                      }
                      else if(window.cam === ic.orthographicCamera) {  // orthographics
                        if(ic._zoomFactor < 0.1) {
                          ic._zoomFactor = 0.1;
                        }
                        else if(ic._zoomFactor > 1) {
                          ic._zoomFactor = 1;
                        }

                        para._zoomFactor = ic._zoomFactor * 0.8;
                        if(para._zoomFactor < 0.1) para._zoomFactor = 0.1;
                      }
                  }
                  else {
                      if(ic.cam === ic.perspectiveCamera) { // perspective
                        para._zoomFactor = 0.9;
                      }
                      else if(ic.cam === ic.orthographicCamera) {  // orthographics
                        if(ic._zoomFactor < 0.1) {
                          ic._zoomFactor = 0.1;
                        }
                        else if(ic._zoomFactor > 1) {
                          ic._zoomFactor = 1;
                        }

                        para._zoomFactor = ic._zoomFactor * 0.8;
                        if(para._zoomFactor < 0.1) para._zoomFactor = 0.1;
                      }
                  }

                  para.update = true;
                  if(ic.bControlGl && !me.bNode) {
                      window.controls.update(para);
                  }
                  else {
                      ic.controls.update(para);
                  }
                  if(ic.bRender) ic.drawCls.render();
                }
                else if(e.keyCode === 88 ) { // X
                  let para = {};

                  if(ic.bControlGl && !me.bNode) {
                      if(window.cam === ic.perspectiveCamera) { // perspective
                        //para._zoomFactor = 1.1;
                        para._zoomFactor = 1.03;
                      }
                      else if(window.cam === ic.orthographicCamera) {  // orthographics
                        if(ic._zoomFactor > 10) {
                          ic._zoomFactor = 10;
                        }
                        else if(ic._zoomFactor < 1) {
                          ic._zoomFactor = 1;
                        }

                        para._zoomFactor = ic._zoomFactor * 1.01;
                        if(para._zoomFactor > 10) para._zoomFactor = 10;
                      }
                  }
                  else {
                      if(ic.cam === ic.perspectiveCamera) { // perspective
                        //para._zoomFactor = 1.1;
                        para._zoomFactor = 1.03;
                      }
                      else if(ic.cam === ic.orthographicCamera) {  // orthographics
                        if(ic._zoomFactor > 10) {
                          ic._zoomFactor = 10;
                        }
                        else if(ic._zoomFactor < 1) {
                          ic._zoomFactor = 1;
                        }

                        para._zoomFactor = ic._zoomFactor * 1.01;
                        if(para._zoomFactor > 10) para._zoomFactor = 10;
                      }
                  }

                  para.update = true;
                  if(ic.bControlGl && !me.bNode) {
                      window.controls.update(para);
                  }
                  else {
                      ic.controls.update(para);
                  }
                  if(ic.bRender) ic.drawCls.render();
                }

                // rotate
                else if(e.keyCode === 76 ) { // L, rotate left
                  let axis = new THREE.Vector3(0,1,0);
                  let angle = -rotAngle / 180.0 * Math.PI;

                  ic.transformCls.setRotation(axis, angle);
                }
                else if(e.keyCode === 74 ) { // J, rotate right
                  let axis = new THREE.Vector3(0,1,0);
                  let angle = rotAngle / 180.0 * Math.PI;

                  ic.transformCls.setRotation(axis, angle);
                }
                else if(e.keyCode === 73 ) { // I, rotate up
                  let axis = new THREE.Vector3(1,0,0);
                  let angle = -rotAngle / 180.0 * Math.PI;

                  ic.transformCls.setRotation(axis, angle);
                }
                else if(e.keyCode === 77 ) { // M, rotate down
                  let axis = new THREE.Vector3(1,0,0);
                  let angle = rotAngle / 180.0 * Math.PI;

                  ic.transformCls.setRotation(axis, angle);
                }

                else if(e.keyCode === 65 ) { // A, alternate
                   if(Object.keys(ic.structures).length > 1) {
                     await ic.alternateCls.alternateWrapper();
                   }
                }

              }
            });

            ic.container.bind('mouseup', function (e) {
            //document.getElementById(ic.id).addEventListener('mouseup', function (e) {
                ic.isDragging = false;
            });
            ic.container.bind('touchend', function (e) {
            //document.getElementById(ic.id).addEventListener('touchend', function (e) {
                ic.isDragging = false;
            });

            ic.container.bind('mousedown', function (e) {
            //document.getElementById(ic.id).addEventListener('mousedown', function (e) {
                //e.preventDefault();
                ic.isDragging = true;

                if (!ic.scene) return;

                ic.bStopRotate = true;

                if(ic.pk && (e.altKey || e.ctrlKey || e.shiftKey || e.keyCode === 18 || e.keyCode === 16 || e.keyCode === 17 || e.keyCode === 224 || e.keyCode === 91) ) {
                    ic.highlightlevel = ic.pk;

                    let bClick = true;
                    ic.rayCls.rayCaster(e, bClick);
                }

                if(ic.bControlGl && !me.bNode) {
                  window.controls.handleResize();
                  window.controls.update();
                }
                else {
                  ic.controls.handleResize();
                  ic.controls.update();
                }

                if(ic.bRender) ic.drawCls.render();
            });

            ic.container.bind('touchstart', function (e) {
            //document.getElementById(ic.id).addEventListener('touchstart', function (e) {
                //e.preventDefault();
                e.preventDefault();
                ic.isDragging = true;

                if (!ic.scene) return;

                ic.bStopRotate = true;

                //$("[id$=popup]").hide();
                $("#" + ic.pre + "popup").hide();

                //var bClick = false;
                let bClick = true;
                ic.rayCls.rayCaster(e, bClick);

                if(ic.bControlGl && !me.bNode) {
                  window.controls.handleResize();
                  window.controls.update();
                }
                else {
                  ic.controls.handleResize();
                  ic.controls.update();
                }

                if(ic.bRender) ic.drawCls.render();
            });

            ic.container.bind('mousemove touchmove', function (e) {
                thisClass.mouseMove(e);
            });
    /*
            document.getElementById(ic.id).addEventListener('mousemove', function (e) {
                thisClass.mouseMove(e);
            });
            document.getElementById(ic.id).addEventListener('touchmove', function (e) {
                thisClass.mouseMove(e);
            });
    */
            ic.container.bind('mousewheel', function (e) {
            //document.getElementById(ic.id).addEventListener('mousewheel', function (e) {
                //e.preventDefault();
                e.preventDefault();
                if (!ic.scene) return;

                ic.bStopRotate = true;

                if(ic.bControlGl && !me.bNode) {
                  window.controls.handleResize();
                  window.controls.update();
                }
                else {
                  ic.controls.handleResize();
                  ic.controls.update();
                }

                if(ic.bRender) ic.drawCls.render();
            });
            ic.container.bind('DOMMouseScroll', function (e) {
            //document.getElementById(ic.id).addEventListener('DOMMouseScroll', function (e) {
                //e.preventDefault();
                e.preventDefault();
                if (!ic.scene) return;

                ic.bStopRotate = true;

                if(ic.bControlGl && !me.bNode) {
                  window.controls.handleResize();
                  window.controls.update();
                }
                else {
                  ic.controls.handleResize();
                  ic.controls.update();
                }

                if(ic.bRender) ic.drawCls.render();
            });
        }

        mouseMove(e) { let ic = this.icn3d, me = ic.icn3dui;
            if(me.bNode) return;

            //e.preventDefault();
            e.preventDefault();
            if (!ic.scene) return;
            // no action when no mouse button is clicked and no key was down
            //if (!ic.isDragging) return;

            //$("[id$=popup]").hide();
            $("#" + ic.pre + "popup").hide();

            let bClick = false;
            ic.rayCls.rayCaster(e, bClick);

            if(ic.bControlGl && !me.bNode) {
              window.controls.handleResize();
              window.controls.update();

              for(let divid in window.icn3duiHash) {
                  let icTmp = window.icn3duiHash[divid].icn3d;
                  if(icTmp.bRender) icTmp.drawCls.render();
              }
            }
            else {
              ic.controls.handleResize();
              ic.controls.update();

              if(ic.bRender) ic.drawCls.render();
            }
        }

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class Picking {
        constructor(icn3d) {
            this.icn3d = icn3d;
        }

        //Define actions when an atom is picked. By default, the atom information
        //($[structure id].[chain id]:[residue number]@[atom name]) is displayed.
        showPicking(atom, x, y) { let ic = this.icn3d, me = ic.icn3dui;
          //me = ic.setIcn3dui(ic.id);
          if(me.cfg.cid !== undefined && ic.pk != 0) {
              ic.pk = 1; // atom
          }
          ic.highlightlevel = ic.pk;
          this.showPickingBase(atom, x, y);

          if(ic.pk != 0) {
              if(x !== undefined && y !== undefined) { // mouse over
                if(me.cfg.showmenu != undefined && me.cfg.showmenu == true) {
                    y += me.htmlCls.MENU_HEIGHT;
                }
                let text =(ic.pk == 1) ? atom.resn + atom.resi + '@' + atom.name : atom.resn + atom.resi;
                let chainid = atom.structure + '_' + atom.chain;
                let textWidth;
                if(ic.structures !== undefined && Object.keys(ic.structures).length > 1) {
                    text = chainid + ' ' + text;
                    textWidth = (ic.chainid2refpdbname && ic.chainid2refpdbname[chainid]) ? 160 + 80 : 160;
                    $("#" + ic.pre + "popup").css("width", textWidth + "px");
                }
                else {
                    textWidth = (ic.chainid2refpdbname && ic.chainid2refpdbname[chainid]) ? 80 + 80 : 80;
                    $("#" + ic.pre + "popup").css("width", textWidth + "px");
                }

                
                if(ic.chainid2refpdbname && ic.chainid2refpdbname[chainid]) {
                    let refnumLabel = ic.resid2refnum[chainid + '_' + atom.resi];

                    if(refnumLabel) text += ', Ig: ' + refnumLabel;
                }

                $("#" + ic.pre + "popup").html(text);
                $("#" + ic.pre + "popup").css("top", y).css("left", x+20).show();
              }
              else {
                  // highlight the sequence background
                  ic.hlUpdateCls.updateHlAll();
                  let transformation = {};
                  transformation.factor = ic._zoomFactor;
                  transformation.mouseChange = ic.mouseChange;
                  //transformation.quaternion = ic.quaternion;
                  transformation.quaternion = {};
                  transformation.quaternion._x = parseFloat(ic.quaternion._x).toPrecision(5);
                  transformation.quaternion._y = parseFloat(ic.quaternion._y).toPrecision(5);
                  transformation.quaternion._z = parseFloat(ic.quaternion._z).toPrecision(5);
                  transformation.quaternion._w = parseFloat(ic.quaternion._w).toPrecision(5);

                  /*
                  if(ic.bAddCommands) {
                      ic.commands.push('pickatom ' + atom.serial + '|||' + ic.transformCls.getTransformationStr(transformation));
                      ic.optsHistory.push(me.hashUtilsCls.cloneHash(ic.opts));
                      ic.optsHistory[ic.optsHistory.length - 1].hlatomcount = Object.keys(ic.hAtoms).length;
                      if(me.utilsCls.isSessionStorageSupported()) ic.setStyleCls.saveCommandsToSession();
                      ic.STATENUMBER = ic.commands.length;
                  }
                  ic.logs.push('pickatom ' + atom.serial + '(chain: ' + atom.structure + '_' + atom.chain + ', residue: ' + atom.resn + ', number: ' + atom.resi + ', atom: ' + atom.name + ')');
                  if( $( "#" + ic.pre + "logtext" ).length )  {
                    $("#" + ic.pre + "logtext").val("> " + ic.logs.join("\n> ") + "\n> ").scrollTop($("#" + ic.pre + "logtext")[0].scrollHeight);
                  }
                  */
                  me.htmlCls.clickMenuCls.setLogCmd('pickatom ' + atom.serial, true);

                  ic.selectionCls.saveSelInCommand();

                  // update the interaction flag
                  ic.bSphereCalc = false;
                  //me.htmlCls.clickMenuCls.setLogCmd('set calculate sphere false', true);
                  ic.bHbondCalc = false;
                  //me.htmlCls.clickMenuCls.setLogCmd('set calculate hbond false', true);
              }
          }
        }

        showPickingBase(atom, x, y) { let ic = this.icn3d; ic.icn3dui;
          if(x === undefined && y === undefined) { // NOT mouse over
              this.showPickingHilight(atom); // including render step
          }
        }

        getPickedAtomList(pk, atom) {  let ic = this.icn3d; ic.icn3dui;
            let pickedAtomList = {};
            if(pk === 1) {
              pickedAtomList[atom.serial] = 1;
            }
            else if(pk === 2) {
              let residueid = atom.structure + '_' + atom.chain + '_' + atom.resi;
              pickedAtomList = ic.residues[residueid];
            }
            else if(pk === 3) {
              pickedAtomList = this.selectStrandHelixFromAtom(atom);
            }
            else if(pk === 4) {
              pickedAtomList = this.select3ddomainFromAtom(atom);
            }
            else if(pk === 5) {
              let chainid = atom.structure + '_' + atom.chain;
              pickedAtomList = ic.chains[chainid];
            }

            return pickedAtomList;
        }   

        showPickingHilight(atom) {  let ic = this.icn3d, me = ic.icn3dui;
          if(!ic.bShift && !ic.bCtrl) ic.hlObjectsCls.removeHlObjects();

          ic.pickedAtomList = this.getPickedAtomList(ic.pk, atom);

          if(ic.pk === 0) {
              ic.bShowHighlight = false;
          }
          else {
              ic.bShowHighlight = true;
          }

          let intersectAtoms = (Object.keys(ic.hAtoms).length == Object.keys(ic.atoms).length) ? {} : me.hashUtilsCls.intHash(ic.hAtoms, ic.pickedAtomList);
          let intersectAtomsSize = Object.keys(intersectAtoms).length;

          if(!ic.bShift && !ic.bCtrl) {
              //if(intersectAtomsSize > 0) {
              //    ic.hAtoms = me.hashUtilsCls.exclHash(ic.hAtoms, ic.pickedAtomList);
              //}
              //else {
              //    ic.hAtoms = me.hashUtilsCls.cloneHash(ic.pickedAtomList);
              //}
              ic.hAtoms = me.hashUtilsCls.cloneHash(ic.pickedAtomList);
          }
          else if(ic.bShift) { // select a range

            if(ic.prevPickedAtomList === undefined) {
                ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.pickedAtomList);
            }
            else {
                let prevAtom = ic.firstAtomObjCls.getFirstAtomObj(ic.prevPickedAtomList);
                let currAtom = ic.firstAtomObjCls.getFirstAtomObj(ic.pickedAtomList);

                let prevChainid = prevAtom.structure + '_' + prevAtom.chain;
                let currChainid = currAtom.structure + '_' + currAtom.chain;

                if(prevChainid != currChainid) {
                    ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.pickedAtomList);
                }
                else { // range in the same chain only
                    let combinedAtomList;
                    combinedAtomList = me.hashUtilsCls.unionHash(combinedAtomList, ic.prevPickedAtomList);
                    combinedAtomList = me.hashUtilsCls.unionHash(combinedAtomList, ic.pickedAtomList);

                    let firstAtom = ic.firstAtomObjCls.getFirstAtomObj(combinedAtomList);
                    let lastAtom = ic.firstAtomObjCls.getLastAtomObj(combinedAtomList);

                    for(let i = firstAtom.serial; i <= lastAtom.serial; ++i) {
                        ic.hAtoms[i] = 1;
                    }
                }
            }

            // remember this shift selection
            ic.prevPickedAtomList = me.hashUtilsCls.cloneHash(ic.pickedAtomList);
          }
          else if(ic.bCtrl) {
              if(intersectAtomsSize > 0) {
                  ic.hAtoms = me.hashUtilsCls.exclHash(ic.hAtoms, ic.pickedAtomList);
              }
              else {
                  ic.hAtoms = me.hashUtilsCls.unionHash(ic.hAtoms, ic.pickedAtomList);
              }
          }

          ic.hlObjectsCls.removeHlObjects();
          ic.hlObjectsCls.addHlObjects();
        }

        select3ddomainFromAtom(atom) { let ic = this.icn3d, me = ic.icn3dui;
            let chainid = atom.structure + '_' + atom.chain;
            let resid = chainid + '_' + atom.resi;

            let domainid;
            for(let id in ic.tddomains) { // 3GVU_A_3d_domain_1
                let pos = id.indexOf('_3d_domain');
                if(id.substr(0, pos) == chainid) {
                    if(Object.keys(ic.tddomains[id]).indexOf(resid) !== -1) {
                        domainid = id;
                        break;
                    }
                }
            }

            let atomList = {};
            for(let resid in ic.tddomains[domainid]) {
                atomList = me.hashUtilsCls.unionHash(atomList, ic.residues[resid]);
            }

            return atomList;
        }

        //For an "atom", select all atoms in the same strand, helix, or coil.
        selectStrandHelixFromAtom(atom) { let ic = this.icn3d, me = ic.icn3dui;
            let firstAtom = atom;
            let lastAtom = atom;

            let atomsHash = {};

            // fill the beginning
            let beginResi = firstAtom.resi;
            if(!firstAtom.ssbegin && !isNaN(firstAtom.resi)) {
                for(let i = firstAtom.resi - 1; i > 0; --i) {
                    let residueid = firstAtom.structure + '_' + firstAtom.chain + '_' + i;
                    if(!ic.residues.hasOwnProperty(residueid)) break;

                    let atom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[residueid]);
                    beginResi = atom.resi;

                    if( (firstAtom.ss !== 'coil' && atom.ss === firstAtom.ss && atom.ssbegin)
                      || (firstAtom.ss === 'coil' && atom.ss !== firstAtom.ss) ) {
                        if(firstAtom.ss === 'coil' && atom.ss !== firstAtom.ss) {
                            beginResi = parseInt(atom.resi) + 1;
                        }
                        break;
                    }
                }

                for(let i = beginResi; i <= firstAtom.resi; ++i) {
                    let residueid = firstAtom.structure + '_' + firstAtom.chain + '_' + i;
                    atomsHash = me.hashUtilsCls.unionHash(atomsHash, me.hashUtilsCls.hash2Atoms(ic.residues[residueid], ic.atoms));
                }
            }

            // fill the end
            let endResi = lastAtom.resi;
            let endChainResi = ic.firstAtomObjCls.getLastAtomObj(ic.chains[lastAtom.structure + '_' + lastAtom.chain]).resi;
            for(let i = parseInt(lastAtom.resi) + 1; i <= parseInt(endChainResi); ++i) {
                let residueid = lastAtom.structure + '_' + lastAtom.chain + '_' + i;
                if(!ic.residues.hasOwnProperty(residueid)) break;

                let atom = ic.firstAtomObjCls.getFirstCalphaAtomObj(ic.residues[residueid]);
                endResi = atom.resi;

                if( (lastAtom.ss !== 'coil' && atom.ss === lastAtom.ss && atom.ssend) || (lastAtom.ss === 'coil' && atom.ss !== lastAtom.ss) ) {
                    if(lastAtom.ss === 'coil' && atom.ss !== lastAtom.ss && !isNaN(atom.resi)) {
                        endResi = atom.resi - 1;
                    }
                    break;
                }
            }

            for(let i = parseInt(lastAtom.resi) + 1; i <= parseInt(endResi); ++i) {
                let residueid = lastAtom.structure + '_' + lastAtom.chain + '_' + i;
                atomsHash = me.hashUtilsCls.unionHash(atomsHash, me.hashUtilsCls.hash2Atoms(ic.residues[residueid], ic.atoms));
            }

            return atomsHash;
        }
    }

    //https://github.com/mrdoob/three.js/blob/master/examples/webxr_vr_cubes.html

    class VRButton {
        constructor(icn3d) {
            this.icn3d = icn3d;

            //static xrSessionIsGranted = false;
            this.xrSessionIsGranted = false;
        }

        //static createButton( renderer, options ) {
        createButton( renderer, options ) { let ic = this.icn3d, me = ic.icn3dui;

            if ( options ) {

                console.error( 'THREE.VRButton: The "options" parameter has been removed. Please set the reference space type via renderer.xr.setReferenceSpaceType() instead.' );

            }

            const button = document.createElement( 'button' );

            function showEnterVR( /*device*/ ) {

                let currentSession = null;

                async function onSessionStarted( session ) {

                    session.addEventListener( 'end', onSessionEnded );

                    await renderer.xr.setSession( session );
                    button.textContent = 'EXIT VR';

                    currentSession = session;

                }

                function onSessionEnded( /*event*/ ) {
                    // reset orientation after VR
                    ic.transformCls.resetOrientation();
                    
                    ic.bVr = false;
                    //ic.mdl.scale.copy(new THREE.Vector3( 1, 1, 1 )); 

                    ic.drawCls.draw();

                    currentSession.removeEventListener( 'end', onSessionEnded );

                    button.textContent = 'ENTER VR';

                    currentSession = null;

                }

                //

                button.style.display = '';

                button.style.cursor = 'pointer';
                //button.style.left = 'calc(50% - 50px)';
                button.style.left = 'calc(33% - 50px)';
                button.style.width = '100px';

                button.textContent = 'ENTER VR';

                button.onmouseenter = function () {

                    button.style.opacity = '1.0';

                };

                button.onmouseleave = function () {

                    button.style.opacity = '0.8'; //'0.5';

                };

                button.onclick = function () {       
                    // imposter didn't work well in VR
                    ic.bImpo = false;
                    //ic.bInstanced = false;
                    
                    ic.bVr = true;
                    //ic.mdl.scale.copy(ic.mdl.scale.multiplyScalar(0.2));

                    ic.drawCls.draw(ic.bVr);

                    if ( currentSession === null ) {

                        // WebXR's requestReferenceSpace only works if the corresponding feature
                        // was requested at session creation time. For simplicity, just ask for
                        // the interesting ones as optional features, but be aware that the
                        // requestReferenceSpace call will fail if it turns out to be unavailable.
                        // ('local' is always available for immersive sessions and doesn't need to
                        // be requested separately.)

                        const sessionInit = { optionalFeatures: [ 'local-floor', 'bounded-floor', 'hand-tracking', 'layers' ] };
                        navigator.xr.requestSession( 'immersive-vr', sessionInit ).then( onSessionStarted );

                    } else {

                        currentSession.end();

                    }

                };

            }

            function disableButton() {

                button.style.display = '';

                button.style.cursor = 'auto';
                button.style.left = 'calc(33% - 75px)'; //'calc(50% - 75px)';
                button.style.width = '150px';

                button.onmouseenter = null;
                button.onmouseleave = null;

                button.onclick = null;

            }

            function showWebXRNotFound() {

                disableButton();

                //button.textContent = 'VR NOT SUPPORTED';
                button.style.display = 'none';

            }

            function showVRNotAllowed( exception ) {

                disableButton();

                console.warn( 'Exception when trying to call xr.isSessionSupported', exception );

                //button.textContent = 'VR NOT ALLOWED';
                button.style.display = 'none';

            }

            function stylizeElement( element ) {

                element.style.position = 'absolute';
                element.style.bottom = '20px';
                element.style.padding = '12px 6px';
                element.style.border = '1px solid #fff';
                element.style.borderRadius = '4px';
                element.style.background = '#000'; //'rgba(0,0,0,0.5)';
                element.style.color = '#f8b84e'; //'#1c94c4'; //'#fff';
                element.style.font = 'bold 13px sans-serif';
                element.style.textAlign = 'center';
                element.style.opacity = '0.8';
                element.style.outline = 'none';
                element.style.zIndex = '999';

            }

            let thisClass = this;

            if ( 'xr' in navigator ) {

                button.id = me.pre + 'VRButton'; //'VRButton';
                button.style.display = 'none';

                stylizeElement( button );

                navigator.xr.isSessionSupported( 'immersive-vr' ).then( function ( supported ) {

                    supported ? showEnterVR() : showWebXRNotFound();
                    
                    //if ( supported && VRButton.xrSessionIsGranted ) {
                    if ( supported && thisClass.xrSessionIsGranted ) {

                        button.click();

                    }

                } ).catch( showVRNotAllowed );

                return button;

            } else {
                const message = document.createElement( 'span' );
                return message;
            }

        }

        //static xrSessionIsGranted = false;

        //static registerSessionGrantedListener() {
        registerSessionGrantedListener() {

            if ( 'xr' in navigator ) {

                navigator.xr.addEventListener( 'sessiongranted', () => {

                    //VRButton.xrSessionIsGranted = true;
                    this.xrSessionIsGranted = true;

                } );

            }

        }

    }

    //https://github.com/mrdoob/three.js/blob/master/examples/webxr_ar_cones.html
    //https://github.com/NikLever/Learn-WebXR/blob/master/libs/ARButton.js

    class ARButton {
        constructor(icn3d) {
            this.icn3d = icn3d;

            //static xrSessionIsGranted = false;
            this.xrSessionIsGranted = false;
        }

    	//static createButton( renderer, sessionInit = {} ) {
    	createButton( renderer, sessionInit = {} ) { let ic = this.icn3d, me = ic.icn3dui;

    		const button = document.createElement( 'button' );

    		function showStartAR( ) {

    			if ( sessionInit.domOverlay === undefined ) {

    				const overlay = document.createElement( 'div' );
    				overlay.style.display = 'none';
    				document.body.appendChild( overlay );

    				const svg = document.createElementNS( 'http://www.w3.org/2000/svg', 'svg' );
    				svg.setAttribute( 'width', 38 );
    				svg.setAttribute( 'height', 38 );
    				svg.style.position = 'absolute';
    				svg.style.right = '20px';
    				svg.style.top = '20px';
    				svg.addEventListener( 'click', function () {

    					currentSession.end();

    				} );
    				overlay.appendChild( svg );

    				const path = document.createElementNS( 'http://www.w3.org/2000/svg', 'path' );
    				path.setAttribute( 'd', 'M 12,12 L 28,28 M 28,12 12,28' );
    				path.setAttribute( 'stroke', '#fff' );
    				path.setAttribute( 'stroke-width', 2 );
    				svg.appendChild( path );

    				if ( sessionInit.optionalFeatures === undefined ) {

    					sessionInit.optionalFeatures = [];

    				}

    				sessionInit.optionalFeatures.push( 'dom-overlay' );
    				sessionInit.domOverlay = { root: overlay };

    			}

    			//

    			let currentSession = null;

    			async function onSessionStarted( session ) {

    				session.addEventListener( 'end', onSessionEnded );

    				renderer.xr.setReferenceSpaceType( 'local' );

    				await renderer.xr.setSession( session );

    				button.textContent = 'STOP AR';
    				sessionInit.domOverlay.root.style.display = '';

    				currentSession = session;

    			}

    			function onSessionEnded( ) {
    				// reset orientation after AR
    				ic.transformCls.resetOrientation();

    				ic.bAr = false;
    				//ic.mdl.scale.copy(new THREE.Vector3( 1, 1, 1 ));

    				ic.drawCls.draw();

    				currentSession.removeEventListener( 'end', onSessionEnded );

    				button.textContent = 'START AR';
    				sessionInit.domOverlay.root.style.display = 'none';

    				currentSession = null;

    			}

    			//

    			button.style.display = '';

    			button.style.cursor = 'pointer';
    			//button.style.left = 'calc(50% - 50px)';
    			button.style.left = 'calc(66% - 50px)';
    			button.style.width = '100px';

    			button.textContent = 'START AR';

    			button.onmouseenter = function () {

    				button.style.opacity = '1.0';

    			};

    			button.onmouseleave = function () {

    				button.style.opacity = '0.8'; //'0.5';

    			};

    			button.onclick = function () {
                    // imposter didn't work well in AR
                    ic.bImpo = false;

                    // important to keet the background transparent
    				ic.opts['background'] = 'transparent';
                    
                    ic.bAr = true;
    				//ic.mdl.scale.copy(ic.mdl.scale.multiplyScalar(0.2));

    				ic.drawCls.draw(ic.bAr);

    				if ( currentSession === null ) {

    					navigator.xr.requestSession( 'immersive-ar', sessionInit ).then( onSessionStarted );

    				} else {

    					currentSession.end();

    				}

    			};

    		}

    		function disableButton() {

    			button.style.display = '';

    			button.style.cursor = 'auto';
    			button.style.left = 'calc(66% - 50px)'; //'calc(50% - 75px)';
    			button.style.width = '150px';

    			button.onmouseenter = null;
    			button.onmouseleave = null;

    			button.onclick = null;

    		}

    		function showARNotSupported() {

    			disableButton();

    			//button.textContent = 'AR NOT SUPPORTED';
                button.style.display = 'none';

    		}

            function showARAndroidPhone() {

    			disableButton();

    			//button.textContent = 'Chrome in Android Required';
                button.style.display = 'none';

    		}

    		function showARNotAllowed( exception ) {

    			disableButton();

    			console.warn( 'Exception when trying to call xr.isSessionSupported', exception );

    			//button.textContent = 'AR NOT ALLOWED';
                button.style.display = 'none';

    		}

    		function stylizeElement( element ) {

    			element.style.position = 'absolute';
    			element.style.bottom = '20px';
    			element.style.padding = '12px 6px';
    			element.style.border = '1px solid #fff';
    			element.style.borderRadius = '4px';
    			element.style.background = '#000'; //'rgba(0,0,0,0.1)';
    			element.style.color = '#f8b84e'; //'#fff';
    			element.style.font = 'bold 13px sans-serif';
    			element.style.textAlign = 'center';
    			element.style.opacity = '0.8'; //'0.5';
    			element.style.outline = 'none';
    			element.style.zIndex = '999';

    		}

    		if(!me.utilsCls.isAndroid() || !me.utilsCls.isChrome()) {
                button.id = me.pre + 'ARButton'; //'ARButton';
    			button.style.display = 'none';

    			stylizeElement( button );

                showARAndroidPhone();

                return button;
            }
            else if ( 'xr' in navigator ) {

    			button.id = me.pre + 'ARButton'; //'ARButton';
    			button.style.display = 'none';

    			stylizeElement( button );

    			navigator.xr.isSessionSupported( 'immersive-ar' ).then( function ( supported ) {

    				supported ? showStartAR() : showARNotSupported();

    			} ).catch( showARNotAllowed );

    			return button;

    		} else {
               
    			// const message = document.createElement( 'a' );

    			// if ( window.isSecureContext === false ) {

    			// 	message.href = document.location.href.replace( /^http:/, 'https:' );
    			// 	message.innerHTML = 'WEBXR NEEDS HTTPS'; // TODO Improve message

    			// } else {

    			// 	message.href = 'https://immersiveweb.dev/';
    			// 	message.innerHTML = 'WEBXR NOT AVAILABLE';

    			// }

    			// message.style.left = 'calc(66% - 90px)'; //'calc(50% - 90px)';
    			// message.style.width = '180px';
    			// message.style.textDecoration = 'none';

    			// stylizeElement( message );

    			// return message;

                const message = document.createElement( 'span' );
                return message;
    		}

    	}

    }

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class iCn3D {
      constructor(icn3dui) { let me = icn3dui;
        this.icn3dui = icn3dui;
        this.id = this.icn3dui.pre + 'canvas';

        //A prefix for all custom html element id. It ensures all html elements have specific ids,
        //even when multiple iCn3D viewers are shown together.
        this.pre = this.icn3dui.pre; //this.id.substr(0, this.id.indexOf('_') + 1);

        this.container = $('#' + this.id);
        this.oriContainer = $('#' + this.id);

        this.bControlGl = false;

        this.maxatomcnt = 100000; // for a biological assembly, use instancing when the total number of atomsis greater than "maxatomcnt"

        this.overdraw = 0;

        this.bDrawn = false;
        this.bOpm = false; // true if the PDB data is from OPM for transmembrane proteins
        this.crossstrucinter = 0;

        this.bSecondaryStructure = false;

        //If its value is 1, the selected atoms will be highlighted with outlines around the structure.
        //If its value is 2, the selected atoms will be highlighted with transparent 3D objects such as
        //boxes, ribbons, cylinders, etc. If its value is undefined, no highlight will be shown.
        this.bHighlight = 1; // undefined: no highlight, 1: highlight by outline, 2: highlight by 3D object
        this.renderOrderPicking = -1; // less than 0, the default order is 0

        this.bInitial = true; // first 3d display

        this.bDoublecolor = false;

        this.originSize = 1; // radius

        this.ALTERNATE_STRUCTURE = -1;

        this.bUsePdbNum = true;

        let bWebGL, bWebGL2, bVR;
        if(!this.icn3dui.bNode) {
            let canvas = document.createElement( 'canvas' );
            bWebGL = !! ( window.WebGLRenderingContext && ( canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) ) );
            canvas.remove();

            canvas = document.createElement( 'canvas' );
            bWebGL2 = !! ( window.WebGLRenderingContext && ( canvas.getContext( 'webgl2' ) ) );
            canvas.remove();

            bVR = ( 'xr' in navigator ); // possibly support VR

            if(bWebGL){
                //https://discourse.threejs.org/t/three-js-r128-ext-frag-depth-and-angle-instanced-arrays-extensions-are-not-supported/26037
                //this.renderer = new THREE.WebGL1Renderer({
                if ( bWebGL2 && bVR) {                
                    this.renderer = new THREE.WebGLRenderer({
                        canvas: this.oriContainer.get(0), //this.container.get(0),
                        antialias: true,
                        preserveDrawingBuffer: true,
                        sortObjects: false,
                        alpha: true
                    });
                    // Enable VR
                    this.renderer.xr.enabled = true;
                    //https://www.udemy.com/course/learn-webxr/learn/lecture/20512848#questions/18941376
                    //this.renderer.getContext().makeXRCompatible();
                }
                else {
                    this.renderer = new THREE.WebGL1Renderer({
                        canvas: this.oriContainer.get(0), //this.container.get(0),
                        antialias: true,
                        preserveDrawingBuffer: true,
                        sortObjects: false,
                        alpha: true
                    });
                }

                this.effects = {
                    //'anaglyph': new THREE.AnaglyphEffect(this.renderer),
                    //'parallax barrier': new THREE.ParallaxBarrierEffect(this.renderer),
                    //'oculus rift': new THREE.OculusRiftEffect(this.renderer),
                    'stereo': new THREE.StereoEffect(this.renderer),
                    'none': this.renderer
                };

                this.overdraw = 0;
            }
            else {
                alert("Currently your web browser has a problem on WebGL. If you are using Chrome, open a new tab for the same URL and WebGL may work again.");
            }
        }

        this.frac = new THREE.Color(0.1, 0.1, 0.1);
        this.shininess = 40; //30
        this.emissive = 0x111111; //0x000000

        this.light1 = 0.8; //0.6; //1
        this.light2 = 0.4;
        this.light3 = 0.2;

        //This is the line radius for stabilizers, hydrogen bonds, and distance lines. It's 0.1 by default.
        this.lineRadius = 0.1; // hbonds, distance lines
        //This is the coil radius for coils. It's 0.3 by default.
        this.coilWidth = 0.3; //0.4; // style cartoon-coil
        //This is the stick radius. It's 0.4 by default.
        this.cylinderRadius = 0.4; // style stick
        //This is the cross-linkage radius. It's 0.4 by default.
        this.crosslinkRadius = 0.4; // cross-linkage
        //This is the stick radius for C alpha trace and O3' trace. It's 0.4 by default.
        this.traceRadius = 0.4; //0.4; // c alpha trace, nucleotide stick
        //This is the ball scale for styles 'Ball and Stick' and 'Dot'. It's 0.3 by default.
        this.dotSphereScale = 0.3; // style ball and stick, dot
        //This is the sphere radius for the style 'Sphere'. It's 1.5 by default.
        this.sphereRadius = 1.5; // style sphere
        //This is the cylinder radius for the style 'Cylinder and Plate'. It's 1.6 by default.
        this.cylinderHelixRadius = 1.6; // style cylinder and plate

        //This is the ribbon thickness for helix and sheet ribbons, and nucleotide ribbons. It's 0.4 by default.
        this.ribbonthickness = 0.2; // 0.4; // style ribbon, nucleotide cartoon, stand thickness
        //This is the width of protein ribbons. It's 1.3 by default.
        this.helixSheetWidth = 1.3; // style ribbon, nucleotide cartoon, stand thickness
        //This is the width of nucleotide ribbons. It's 0.8 by default.
        this.nucleicAcidWidth = 0.8; // nucleotide cartoon

        // mobile has a problem when the scaleFactor is 2.0
        // the scaleFactor improve the image quality, but it has some centering and picking problems in some Mac when it is not 1
        this.scaleFactor = 1.0;

        // scale all labels
        this.labelScale = 1.0; //0.3; //1.0;

        this.resizeRatioX = 1;
        this.resizeRatioY = 1;

        // Impostor shaders
        // This is a flag to turn on the rendering of spheres and cylinders using shaders instead of geometries.
        // It's true by default if the browser supports the EXT_frag_depth extension.
        this.bImpo = true;
        this.bInstanced = true;

        this.chainMissingResidueArray = {};
        this._zoomFactor = 1.0;

        this.transparentRenderOrder = false; // false: regular transparency; true: expensive renderOrder for each face

        this.AFUniprotVersion = 'v4';
        this.defaultPdbId = 'stru';

        if(!this.icn3dui.bNode) {
            if ( bWebGL2 && bVR) { 
                // if(bVR) { // Meta browser (VR) has problems with imposter. The positions are wrong.
                //     this.bExtFragDepth = false;
                //     this.bImpo = false; 
                // }
                // else { // WebGL2 supports EXT_frag_depth and ANGLE_instanced_arrays
                    this.bExtFragDepth = true;
                    this.bImpo = true; 

                    //console.log('WebGL2 is supported. Thus EXT_frag_depth and ANGLE_instanced_arrays are supported. All spheres and cylinders are drawn using shaders. Assembly is drawn with one copy of the asymmetric unit using hardware instancing.');
                // }

                this.bInstanced = true;
            }
            else {
                this.bExtFragDepth = this.renderer.extensions.get( "EXT_frag_depth" );
                if(!this.bExtFragDepth) {
                    this.bImpo = false;
                    console.log('EXT_frag_depth is NOT supported. All spheres and cylinders are drawn using geometry.');
                }
                else {
                    console.log('EXT_frag_depth is supported. All spheres and cylinders are drawn using shaders.');
                }

                this.bInstanced = this.renderer.extensions.get( "ANGLE_instanced_arrays" );
                if(!this.bInstanced) {
                    console.log('ANGLE_instanced_arrays is NOT supported. Assembly is drawn by making copies of the asymmetric unit.');
                }
                else {
                    console.log('ANGLE_instanced_arrays is supported. Assembly is drawn with one copy of the asymmetric unit using hardware instancing.');
                }
            }
        }

        // cylinder impostor
        this.posArray = new Array();
        this.colorArray = new Array();

        this.pos2Array = new Array();
        this.color2Array = new Array();

        this.radiusArray = new Array();

        // sphere impostor
        this.posArraySphere = new Array();
        this.colorArraySphere = new Array();
        this.radiusArraySphere = new Array();

        this.axis = false;  // used to turn on and off xyz axes

        // pk
        //If its value is 1, selecting an atom will select the atom. If its value is 2, selecting an atom
        //will select the residue containing this atom. If its value is 3, selecting an atom will select
        //the strand or helix or coil containing this atom. If its value is 0, no selecting will work.
        this.pk = 1; // 0: no pk, 1: pk on atoms, 2: pk on residues, 3: pk on strand/helix/coil, 4: pk on domain, 5: pk on chain, 6: structure
        this.highlightlevel = 1; // 1: highlight on atoms, 2: highlight on residues, 3: highlight on strand/helix/coil 4: highlight on chain 5: highlight on structure

        this.pickpair = false; // used for pk pair of atoms for label and distance
        this.pAtomNum = 0;

        //"pAtom" has the value of the atom index of the picked atom.
        this.pAtom = undefined;
        //When two atoms are required to be selected (e.g., for measuring distance),
        //"pAtom2" has the value of the atom index of the 2nd picked atom.
        this.pAtom2 = undefined;

        this.bCtrl = false; // if true, union selection on sequence window or on 3D structure
        this.bShift = false; // if true, select a range on 3D structure

        //Once clicked, this flag can be set as "true" to the automatic rotation. It's false by default.
        this.bStopRotate = false; // by default, do not stop the possible automatic rotation
        this.bCalphaOnly = false; // by default the input has both Calpha and O, used for drawing strands. If atoms have Calpha only, the orientation of the strands is random
    //    this.bSSOnly = false; // a flag to turn on when only helix and bricks are available to draw 3D dgm

    //    this.bAllAtoms = true; // no need to adjust atom for strand style

        this.bConsiderNeighbors = false; // a flag to show surface considering the neighboring atoms or not

        this.bShowCrossResidueBond = true;

        this.bExtrude = true;

        this.maxD = 500; // size of the molecule
        this.oriMaxD = this.maxD; // size of the molecule
        //this.cam_z = -150;

        this.cam_z = this.maxD * 2; // when zooming in, it gets dark if the camera is in front
        //this.cam_z = -this.maxD * 2;

        // these variables will not be cleared for each structure
        this.commands = []; // a list of commands, ordered by the operation steps. Each operation will be converted into a command. this command list can be used to go backward and forward.
        this.optsHistory = []; // a list of options corresponding to this.commands.
        this.logs = []; // a list of comands and other logs, ordered by the operation steps.

        //This is a flag to turn off the rendering part if a sequence of commands are executed. It's true by default.
        this.bRender = true; // a flag to turn off rendering when loading state file

        // Default values
        //This defines the highlight color.
    //    this.hColor = new THREE.Color(0xFFFF00);
        this.hColor = new THREE.Color(0xFFFF33);

        this.sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
        this.boxGeometry = new THREE.BoxGeometry(1, 1, 1);
        this.cylinderGeometry = new THREE.CylinderGeometry(1, 1, 1, 32, 1);
        this.cylinderGeometryOutline = new THREE.CylinderGeometry(1, 1, 1, 32, 1, true);
        this.axisDIV = 5 * 3; //5; // 3;
        this.strandDIV = 6;
        this.tubeDIV = 8;
        this.nucleicAcidStrandDIV = 6; //4;

        this.linewidth = 1;
        this.hlLineRadius = 0.1; // style line, highlight
        //this.curveWidth = 3;

        this.threshbox = 180; // maximum possible boxsize, default 180
        this.maxAtoms3DMultiFile = 40000; // above the threshold, multiple files will be output for 3D printing

        this.tsHbond = 3.8;
        this.tsIonic = 6;
        this.tsContact = 4;
        this.tsHalogen = 3.8;
        this.tsPication = 6;
        this.tsPistacking = 5.5;

        this.LABELSIZE = 30;

        this.rayThreshold = 0.5; // threadshold for raycast
        this.colorBlackbkgd = '#ffff00';
        this.colorWhitebkgd = '#000000';

        //The default display options
        this.optsOri = {};
        this.optsOri['camera']             = 'perspective';        //perspective, orthographic
        this.optsOri['effect']             = 'none';               //stereo, none
        this.optsOri['background']         = 'black';              //transparent, black, grey, white
        this.optsOri['color']              = 'chain';              //spectrum, secondary structure, charge, hydrophobic, conserved, chain, residue, atom, b factor, red, green, blue, magenta, yellow, cyan, white, grey, custom, ig strand
        this.optsOri['proteins']           = 'ribbon';             //ribbon, strand, cylinder and plate, schematic, c alpha trace, backbone, b factor tube, lines, stick, ball and stick, sphere, nothing
        this.optsOri['sidec']              = 'nothing';            //lines2, stick2, ball and stick2, sphere2, nothing
        this.optsOri['nucleotides']        = 'nucleotide cartoon'; //nucleotide cartoon, o3 trace, backbone, schematic, lines, stick,
                                                                  // nucleotides ball and stick, sphere, nothing
        this.optsOri['ntbase']             = 'nothing';            //lines2, stick2, ball and stick2, sphere2, nothing

        this.optsOri['surface']            = 'nothing';            //Van der Waals surface, molecular surface, solvent accessible surface, nothing
        this.optsOri['opacity']            = '1.0';                //1.0, 0.9, 0.8, 0.7, 0.6, 0.5
        this.optsOri['wireframe']          = 'no';                 //yes, no
        this.optsOri['map']                = 'nothing';            //2fofc, fofc, nothing
        this.optsOri['mapwireframe']       = 'yes';                //yes, no
        this.optsOri['emmap']              = 'nothing';            //em, nothing
        this.optsOri['emmapwireframe']     = 'yes';                //yes, no
        this.optsOri['phimap']             = 'nothing';            //phi, nothing
        this.optsOri['phimapwireframe']    = 'yes';                //yes, no
        this.optsOri['phisurface']         = 'nothing';            //phi, nothing
        this.optsOri['phisurftype']        = 'nothing';            //Van der Waals surface, molecular surface, solvent accessible surface, nothing
        this.optsOri['phisurfop']          = '1.0';                //1.0, 0.9, 0.8, 0.7, 0.6, 0.5
        this.optsOri['phisurfwf']          = 'yes';                //yes, no
        this.optsOri['chemicals']          = 'stick';              //lines, stick, ball and stick, schematic, sphere, nothing
        this.optsOri['water']              = 'nothing';            //sphere, dot, nothing
        this.optsOri['ions']               = 'sphere';             //sphere, dot, nothing
        this.optsOri['hbonds']             = 'no';                 //yes, no
        this.optsOri['saltbridge']         = 'no';                 //yes, no
        this.optsOri['contact']            = 'no';                 //yes, no
        this.optsOri['halogen']            = 'no';                 //yes, no
        this.optsOri['pi-cation']          = 'no';                 //yes, no
        this.optsOri['pi-stacking']        = 'no';                 //yes, no
        //this.optsOri['stabilizer']         = 'no';                 //yes, no
        this.optsOri['ssbonds']            = 'yes';                 //yes, no
        this.optsOri['clbonds']            = 'yes';                 //yes, no
        this.optsOri['rotationcenter']     = 'molecule center';    //molecule center, pick center, display center
        this.optsOri['axis']               = 'no';                 //yes, no
        this.optsOri['fog']                = 'no';                 //yes, no
        this.optsOri['slab']               = 'no';                 //yes, no
        this.optsOri['pk']                 = 'residue';            //no, atom, residue, strand, chain
        this.optsOri['chemicalbinding']    = 'hide';               //show, hide

        this.opts = me.hashUtilsCls.cloneHash(this.optsOri);

        this.sheetcolor = 'green';
        this.bShowHighlight = true;
        this.mapData = {};

        // previously in iCn3DUI
        this.bFullUi = true;
        this.divid = this.icn3dui.cfg.divid;

        this.inputid = '';
        this.setOperation = 'or'; // by default the set operation is 'or'
        this.ROT_DIR = 'right';
        //this.prevCommands = "";
        this.currSelectedSets = []; // for selecting multiple sets in sequence & annotations
        this.selectedResidues = {};

        this.ncbi2resid = {}; // convert from NCBI residue ID (structure_chain_resi) to PDB residue ID (structure_chain_resi)
        this.resid2ncbi = {}; // convert from PDB residue ID (structure_chain_resi) to NCBI residue ID (structure_chain_resi) 

        this.shapeCmdHash = {}; // remember the spheres/cubes for sets

        this.bHideSelection = true;
        this.bSelectResidue = false;
        this.bSelectAlignResidue = false;
        //A flag to remember whether the annotation window was set.
        this.bAnnoShown = false;
        //A flag to remember whether the menu of defined sets was set.
        this.bSetChainsAdvancedMenu = false;
        //A flag to remember whether the 2D interaction diagram was set.
        this.b2DShown = false;
        this.bCrashed = false;
        //A flag to determine whether to add current step into the command history.
        this.bAddCommands = true;
        //A flag to determine whether to add current step into the log window.
        this.bAddLogs = true;
        //A flag to determine whether to load the coordinates of the structure. When resetting the view,
        //it is true so that the coordinates of the structure will not be loaded again.
        this.bNotLoadStructure = false;

        this.InputfileData = '';
        this.bVr = false; // cflag to indicate whether in VR state
        this.bAr = false; // cflag to indicate whether in VR state

        // default color range for Add Custom Color button in the Sequence & Annotation window
        this.startColor = 'blue';
        this.midColor = 'white';
        this.endColor = 'red';
        this.startValue = 0;
        this.midValue = 50;
        this.endValue = 100;

        this.crosslinkRadius = 0.4; 

        // classes
        this.sceneCls = new Scene(this);
        this.cameraCls = new Camera(this);
        this.fogCls = new Fog(this);

        this.boxCls = new Box(this);
        this.brickCls = new Brick(this);
        this.curveStripArrowCls = new CurveStripArrow(this);
        this.curveCls = new Curve(this);
        this.cylinderCls = new Cylinder(this);
        this.lineCls = new Line$1(this);
        this.reprSubCls = new ReprSub(this);
        this.sphereCls = new Sphere$1(this);
        this.stickCls = new Stick(this);
        this.strandCls = new Strand(this);
        this.stripCls = new Strip(this);
        this.tubeCls = new Tube(this);
        this.cartoonNuclCls = new CartoonNucl(this);
        this.surfaceCls = new Surface(this);
        this.labelCls = new Label(this);
        this.axesCls = new Axes(this);
        this.glycanCls = new Glycan(this);

        this.applyCenterCls = new ApplyCenter(this);
        this.applyClbondsCls = new ApplyClbonds(this);
        this.applyMissingResCls = new ApplyMissingRes(this);
        
        this.applyDisplayCls = new ApplyDisplay(this);
        this.applyMapCls = new ApplyMap(this);
        this.applyOtherCls = new ApplyOther(this);
        this.applySsbondsCls = new ApplySsbonds(this);
        this.applySymdCls = new ApplySymd(this);

        this.hlObjectsCls = new HlObjects(this);
        this.residueLabelsCls = new ResidueLabels(this);
        this.alternateCls = new Alternate(this);

        this.drawCls = new Draw(this);
        this.firstAtomObjCls = new FirstAtomObj(this);

        this.impostorCls = new Impostor(this);
        this.instancingCls = new Instancing(this);

        this.contactCls = new Contact(this);
        this.hBondCls = new HBond(this);
        this.piHalogenCls = new PiHalogen(this);
        this.saltbridgeCls = new Saltbridge(this);

        this.loadPDBCls = new LoadPDB(this);
        this.loadCIFCls = new LoadCIF(this);
        this.vastplusCls = new Vastplus(this);
        this.transformCls = new Transform(this);

        this.setStyleCls = new SetStyle(this);
        this.setColorCls = new SetColor(this);

        // classes from icn3dui
        this.threeDPrintCls = new ThreeDPrint(this);
        this.export3DCls = new Export3D(this);

        this.annoCddSiteCls = new AnnoCddSite(this);
        this.annoContactCls = new AnnoContact(this);
        this.annoPTMCls = new AnnoPTM(this);
        this.annoIgCls = new AnnoIg(this);
        this.annoCrossLinkCls = new AnnoCrossLink(this);
        this.annoDomainCls = new AnnoDomain(this);
        this.annoSnpClinVarCls = new AnnoSnpClinVar(this);
        this.annoSsbondCls = new AnnoSsbond(this);
        this.annoTransMemCls = new AnnoTransMem(this);
        this.domain3dCls = new Domain3d(this);

        this.addTrackCls = new AddTrack(this);
        this.annotationCls = new Annotation(this);
        this.showAnnoCls = new ShowAnno(this);
        this.showSeqCls = new ShowSeq(this);

        this.hlSeqCls = new HlSeq(this);
        this.hlUpdateCls = new HlUpdate(this);

        this.lineGraphCls = new LineGraph(this);
        this.getGraphCls = new GetGraph(this);
        this.showInterCls = new ShowInter(this);
        this.viewInterPairsCls = new ViewInterPairs(this);
        this.drawGraphCls = new DrawGraph(this);
        this.contactMapCls = new ContactMap(this);

        this.alignParserCls = new AlignParser(this);
        this.chainalignParserCls = new ChainalignParser(this);
        this.dsn6ParserCls = new Dsn6Parser(this);
        this.ccp4ParserCls = new Ccp4Parser(this);
        this.mtzParserCls = new MtzParser(this);
        this.mmcifParserCls = new MmcifParser(this);
        this.mmdbParserCls = new MmdbParser(this);
        this.bcifParserCls = new BcifParser(this);
        this.mol2ParserCls = new Mol2Parser(this);
        this.opmParserCls = new OpmParser(this);
        this.pdbParserCls = new PdbParser(this);
        this.sdfParserCls = new SdfParser(this);
        this.xyzParserCls = new XyzParser(this);
        this.msaParserCls = new MsaParser(this);
        this.realignParserCls = new RealignParser(this);
        this.densityCifParserCls = new DensityCifParser(this);
        this.ParserUtilsCls = new ParserUtils(this);
        this.loadAtomDataCls = new LoadAtomData(this);
        this.setSeqAlignCls = new SetSeqAlign(this);

        this.applyCommandCls = new ApplyCommand(this);
          this.definedSetsCls = new DefinedSets(this);
          this.selectCollectionsCls = new SelectCollections(this);
        this.legendTableCls = new LegendTable(this);
        this.loadScriptCls = new LoadScript(this);
        this.selByCommCls = new SelectByCommand(this);
        this.selectionCls = new Selection(this);
        this.resid2specCls = new Resid2spec(this);

        this.delphiCls = new Delphi(this);
        this.dsspCls = new Dssp(this);
        this.refnumCls = new Refnum(this);
        this.scapCls = new Scap(this);
        this.symdCls = new Symd(this);
        this.alignSWCls = new AlignSW(this);

        this.analysisCls = new Analysis(this);
        this.resizeCanvasCls = new ResizeCanvas(this);
        this.saveFileCls = new SaveFile(this);
        this.setOptionCls = new SetOption(this);
        this.shareLinkCls = new ShareLink(this);
        this.diagram2dCls = new Diagram2d(this);
        this.cartoon2dCls = new Cartoon2d(this);
        this.ligplotCls = new Ligplot(this);

        this.rayCls = new Ray(this);
        this.controlCls = new Control(this);
        this.pickingCls = new Picking(this);

        this.VRButtonCls = new VRButton(this);
        this.ARButtonCls = new ARButton(this);

        // set this.matShader
        //This defines the highlight color using the outline method. It can be defined using the function setOutlineColor().
        this.matShader = this.setColorCls.setOutlineColor('yellow');
      }
    }
    //When users first load a structure, call this function to empty previous settings.
    iCn3D.prototype.init = function (bKeepCmd) {
        this.init_base();

        this.molTitle = "";

        this.ssbondpnts = {}; // disulfide bonds for each structure
        this.clbondpnts = {}; // cross-linkages for each structure

        //this.inputid = {"idtype": undefined, "id":undefined}; // support pdbid, mmdbid

        this.biomtMatrices = [];
        this.bAssembly = true; //false; 

        this.bDrawn = false;
        this.bSecondaryStructure = false;

        this.bHighlight = 1; // undefined: no highlight, 1: highlight by outline, 2: highlight by 3D object

        this.axes = [];
    };

    iCn3D.prototype.init_base = function (bKeepCmd) {
        this.resetConfig();
        
        this.structures = {}; // structure name -> array of chains
        this.chains = {}; // structure_chain name -> atom hash
        this.tddomains = {}; // structure_chain_3d_domain_# name -> residue id hash such as {'structure_chain_3d_domain_1': 1, ...}
        this.residues = {}; // structure_chain_resi name -> atom hash
        this.secondaries = {}; // structure_chain_resi name -> secondary structure: 'c', 'H', or 'E'
        this.alnChains = {}; // structure_chain name -> atom hash

        this.chainsSeq = {}; // structure_chain name -> array of sequence
        this.chainsColor = {}; // structure_chain name -> color, show chain color in sequence display for mmdbid and align input
        this.chainsGene = {}; // structure_chain name -> gene, show chain gene symbol in sequence display for mmdbid and align input
        this.chainsAn = {}; // structure_chain name -> array of annotations, such as residue number
        this.chainsAnTitle = {}; // structure_chain name -> array of annotation title

        this.chainsMapping = {}; // structure_chain name -> residue id hash such as {'structure_chain_resi1': 'reference residue such as K10', ...}
        this.resid2refnum = {}; // residue id -> reference number, e.g.,  {'1WIO_A_16': '2150', ...}
        this.residIgLoop = {}; // residue ids in the loop regions of ig domain
        this.refnum2residArray = {}; // reference number -> array of residue id, e.g.,  {'2150': ['1WIO_A_16', ...], ...}
        this.bShowRefnum = false;
        
        this.alnChainsSeq = {}; // structure_chain name -> array of residue object: {mmdbid, chain, resi, resn, aligned}
        this.alnChainsAnno = {}; // structure_chain name -> array of annotations, such as residue number
        this.alnChainsAnTtl = {}; // structure_chain name -> array of annotation title

        //this.dAtoms = {}; // show selected atoms
        //this.hAtoms = {}; // used to change color or display type for certain atoms

        this.pickedAtomList = {}; // used to switch among different highlight levels

        this.prevHighlightObjects = [];
        this.prevHighlightObjects_ghost = [];

        this.prevSurfaces = [];
        this.prevMaps = [];
        this.prevEmmaps = [];
        this.prevPhimaps = [];

        this.prevOtherMesh = [];

        this.defNames2Residues = {}; // custom defined selection name -> residue array
        this.defNames2Atoms = {}; // custom defined selection name -> atom array
        this.defNames2Descr = {}; // custom defined selection name -> description
        this.defNames2Command = {}; // custom defined selection name -> command

        this.residueId2Name = {}; // structure_chain_resi -> one letter abbreviation

        this.atoms = {};
        //This is a hash used to store all atoms to be displayed. The key is the atom index. Its value is set as 1.
        this.dAtoms = {};
        //This is a hash used to store all atoms to be highlighted. The key is the atom index. Its value is set as 1.
        this.hAtoms = {};
        this.proteins = {};
        this.sidec = {};
        this.ntbase = {};
        this.nucleotides = {};
        this.nucleotidesO3 = {};

        this.chemicals = {};
        this.ions = {};
        this.water = {};
        this.calphas = {};
        //this.mem = {}; // membrane for OPM pdb

        this.hbondpnts = [];
        this.saltbridgepnts = [];
        this.contactpnts = [];
        this.stabilizerpnts = [];

        this.halogenpnts = [];
        this.picationpnts = [];
        this.pistackingpnts = [];

        this.distPnts = [];

        this.doublebonds = {};
        this.triplebonds = {};
        this.aromaticbonds = {};

        this.atomPrevColors = {};

        this.style2atoms = {}; // style -> atom hash, 13 styles: ribbon, strand, cylinder and plate, nucleotide cartoon, o3 trace, schematic, c alpha trace, b factor tube, lines, stick, ball and stick, sphere, dot, nothing
        this.labels = {};     // hash of name -> a list of labels. Each label contains 'position', 'text', 'size', 'color', 'background'
                            // label name could be custom, residue, schematic, distance
        this.lines = {};     // hash of name -> a list of solid or dashed lines. Each line contains 'position1', 'position2', 'color', and a boolean of 'dashed'
                            // line name could be custom, hbond, ssbond, distance

        // used for interactions
        this.resids2inter = {};
        this.resids2interAll = {};

        this.transformCls.rotateCount = 0;
        this.transformCls.rotateCountMax = 20;

        if(bKeepCmd) this.commands = [];

        this.axes = [];

        this.bGlycansCartoon = 0;
        this.bMembrane = 1;
        this.bCmdWindow = 0;

        //this.chainid2offset = {};

        this.chainMissingResidueArray = {};
        this.nTotalGap = 0;
    };

    //Reset parameters for displaying the loaded structure.
    iCn3D.prototype.reinitAfterLoad = function () { let ic = this, me = ic.icn3dui;
        ic.resetConfig();

        ic.setStyleCls.setAtomStyleByOptions();
        ic.setColorCls.setColorByOptions(ic.opts, ic.atoms);

        ic.dAtoms = me.hashUtilsCls.cloneHash(ic.atoms); // show selected atoms
        ic.hAtoms = me.hashUtilsCls.cloneHash(ic.atoms); // used to change color or display type for certain atoms

        ic.prevHighlightObjects = [];
        ic.prevHighlightObjects_ghost = [];

        ic.prevSurfaces = [];
        ic.prevMaps = [];
        ic.prevEmmaps = [];
        ic.prevPhimaps = [];

        ic.prevOtherMesh = [];

        ic.labels = {};   // hash of name -> a list of labels. Each label contains 'position', 'text', 'size', 'color', 'background'
                            // label name could be custom, residue, schematic, distance
        ic.lines = {};    // hash of name -> a list of solid or dashed lines. Each line contains 'position1', 'position2', 'color', and a boolean of 'dashed'
                            // line name could be custom, hbond, ssbond, distance

        ic.shapeCmdHash = {};

        ic.bAssembly = true; //false;
    };

    iCn3D.prototype.resetConfig = function () { let ic = this, me = ic.icn3dui;
        this.opts = me.hashUtilsCls.cloneHash(this.optsOri);

        if(me.cfg.align !== undefined || me.cfg.chainalign !== undefined) {
            this.opts['color'] = 'identity';
            this.opts['proteins'] = 'c alpha trace';
            this.opts['nucleotides'] = 'o3 trace';
        }

        if(me.cfg.cid !== undefined || me.cfg.smiles !== undefined) {
            this.opts['color'] = 'atom';

            this.opts['pk'] = 'atom';
            this.opts['chemicals'] = 'ball and stick';
        }

        if(me.cfg.afid !== undefined || ic.bEsmfold) {
            this.opts['color'] = 'confidence';
        }

        if(me.cfg.blast_rep_id !== undefined) this.opts['color'] = 'conservation';
        if(me.cfg.mmdbafid !== undefined) {
            let idArray = me.cfg.mmdbafid.split(',');
            if(idArray.length > 1) {
                ic.opts['color'] = 'structure';
            }
            else if(idArray.length == 1) {
                let struct = idArray[0];
                if(isNaN(struct) && struct.length > 5) {
                    this.opts['color'] = 'confidence';
                }
                else {
                    ic.opts['color'] = 'chain';
                }
            }
        }

        if(me.cfg.options !== undefined) $.extend(this.opts, me.cfg.options);
    };

    /**
     * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
     */

    class iCn3DUI {
      constructor(cfg) {
        //A hash containing all input parameters.
        this.cfg = cfg;
        //A prefix for all custom html element id. It ensures all html elements have specific ids,
        //even when multiple iCn3D viewers are shown together.
        this.pre = this.cfg.divid + "_";

        this.REVISION = '3.42.0';

        // In nodejs, iCn3D defines "window = {navigator: {}}"
        this.bNode = (Object.keys(window).length < 2) ? true : false;

        if(this.cfg.command === undefined) this.cfg.command = '';
        if(this.cfg.width === undefined) this.cfg.width = '100%';
        if(this.cfg.height === undefined) this.cfg.height = '100%';
        if(this.cfg.resize === undefined) this.cfg.resize = true;
        if(this.cfg.showmenu === undefined) this.cfg.showmenu = true;
        if(this.cfg.showtitle === undefined) this.cfg.showtitle = true;
        if(this.cfg.showcommand === undefined) this.cfg.showcommand = true;
        //if(this.cfg.simplemenu === undefined) this.cfg.simplemenu = false;
        if(this.cfg.mobilemenu === undefined) this.cfg.mobilemenu = false;
        if(this.cfg.imageonly === undefined) this.cfg.imageonly = false;
        if(this.cfg.closepopup === undefined) this.cfg.closepopup = false;
        if(this.cfg.showanno === undefined) this.cfg.showanno = false;
        if(this.cfg.showseq === undefined) this.cfg.showseq = false;
        if(this.cfg.showalignseq === undefined) this.cfg.showalignseq = false;
        if(this.cfg.show2d === undefined) this.cfg.show2d = false;
        if(this.cfg.showsets === undefined) this.cfg.showsets = false;
        if(this.cfg.rotate === undefined) this.cfg.rotate = 'right';
        if(this.cfg.hidelicense === undefined) this.cfg.hidelicense = false;

        // classes
        this.hashUtilsCls = new HashUtilsCls(this);
        this.utilsCls = new UtilsCls(this);
        this.parasCls = new ParasCls(this);
        this.myEventCls = new MyEventCls(this);
        this.rmsdSuprCls = new RmsdSuprCls(this);
        this.subdivideCls = new SubdivideCls(this);
        this.convertTypeCls = new ConvertTypeCls(this);

        this.htmlCls = new Html(this);
      }

      //You can add your custom events in this function if you want to add new links in the function setTools.
      allCustomEvents() {
          // add custom events here
      }

    }

    // show3DStructure is the main function to show 3D structure
    iCn3DUI.prototype.show3DStructure = async function(pdbStr) { let me = this;
      let thisClass = this;
    //   me.deferred = $.Deferred(function() {
        if(me.cfg.menuicon) {
            me.htmlCls.wifiStr = '<i class="icn3d-wifi" title="requires internet">&nbsp;</i>';
            me.htmlCls.licenseStr = '<i class="icn3d-license" title="requires license">&nbsp;</i>';
        }
        else {
            me.htmlCls.wifiStr = '';
            me.htmlCls.licenseStr = '';
        }

        me.setIcn3d();
        let ic = me.icn3d;

        if(me.utilsCls.isSessionStorageSupported()) ic.setStyleCls.getCommandsBeforeCrash();

        let width = me.htmlCls.WIDTH; // - me.htmlCls.LESSWIDTH_RESIZE;
        let height = me.htmlCls.HEIGHT; // - me.htmlCls.LESSHEIGHT - me.htmlCls.EXTRAHEIGHT;
        me.oriWidth = width;
        me.oriHeight = height;

        me.htmlCls.eventsCls.allEventFunctions();
        thisClass.allCustomEvents();

        let extraHeight = 0;
        if(me.cfg.showmenu == undefined || me.cfg.showmenu) {
            //extraHeight += 2*me.htmlCls.MENU_HEIGHT;
            extraHeight += me.htmlCls.MENU_HEIGHT;
        }
        if(me.cfg.showcommand == undefined || me.cfg.showcommand) {
            extraHeight += me.htmlCls.CMD_HEIGHT;
        }
        if(me.cfg.showmenu != undefined && me.cfg.showmenu == false) {
          me.htmlCls.setMenuCls.hideMenu();
        }
        else {
          me.htmlCls.setMenuCls.showMenu();
        }
        if(me.cfg.showtitle != undefined && me.cfg.showtitle == false) {
          $("#" + ic.pre + "title").hide();
        }
        else {
          $("#" + ic.pre + "title").show();
        }
        $("#" + ic.pre + "viewer").width(width).height(parseInt(height) + extraHeight);
        $("#" + ic.pre + "canvas").width(width).height(parseInt(height));
        $("#" + ic.pre + "canvas").resizable({
          resize: function( event, ui ) {
            me.htmlCls.WIDTH = ui.size.width; //$("#" + ic.pre + "canvas").width();
            me.htmlCls.HEIGHT = ui.size.height; //$("#" + ic.pre + "canvas").height();
            if(ic !== undefined && !me.icn3d.bFullscreen) {
                ic.resizeCanvasCls.resizeCanvas(me.htmlCls.WIDTH, me.htmlCls.HEIGHT, true);
            }
          }
        });

        if(me.cfg.usepdbnum !== undefined) {
            me.icn3d.bUsePdbNum = me.cfg.usepdbnum;
        }
        else {
            if(me.cfg.date !== undefined) {
                me.icn3d.bUsePdbNum =(parseInt(me.cfg.date) >= 20201222) ? true : false;
            }
            else {
                // iCn3D paper
                if(me.cfg.mmdbid == '1tup' && me.cfg.showanno == 1 && me.cfg.show2d == 1 && me.cfg.showsets == 1) {
                    me.icn3d.bUsePdbNum = false;
                }
                //https://link.springer.com/article/10.1007/s00239-020-09934-4/figures/1
                else if(me.cfg.mmdbid == '118496' && me.cfg.showanno == 0 && me.cfg.inpara.indexOf('bu=1') != -1) {
                    me.icn3d.bUsePdbNum = false;
                }
                //https://link.springer.com/article/10.1007/s00239-020-09934-4/figures/6
                else if(me.cfg.align == '163605,1,91105,1,1,1' && me.cfg.inpara.indexOf('atype=1') != -1) {
                    me.icn3d.bUsePdbNum = false;
                }
                else {
                    me.icn3d.bUsePdbNum = true;
                }
            }
        }

        if(me.cfg.replay) {
            ic.bReplay = 1;
            $("#" + ic.pre + "replay").show();
        }
        else {
            ic.bReplay = 0;
            $("#" + ic.pre + "replay").hide();
        }
        if(me.utilsCls.isMobile()) ic.threshbox = 60;
        if(me.cfg.controlGl) {
            ic.bControlGl = true;
            ic.container =(ic.bControlGl && !me.bNode) ? $(document) : $('#' + ic.id);
        }
        //ic.controlCls.setControl(); // rotation, translation, zoom, etc
        ic.setStyleCls.handleContextLost();
        ic.applyCenterCls.setWidthHeight(width, height);
        ic.ori_chemicalbinding = ic.opts['chemicalbinding'];
        // if(me.cfg.bCalphaOnly !== undefined) ic.bCalphaOnly = me.cfg.bCalphaOnly;
        ic.opts = me.hashUtilsCls.cloneHash(ic.opts);
        ic.STATENUMBER = ic.commands.length;
        // If previously crashed, recover it
        if(me.utilsCls.isSessionStorageSupported() && ic.bCrashed) {
            ic.bCrashed = false;
            let loadCommand = ic.commandsBeforeCrash.split('|||')[0];
            let id = loadCommand.substr(loadCommand.lastIndexOf(' ') + 1);
            // reload only if viewing the same structure
            if(id === me.cfg.bcifid || id === me.cfg.mmtfid || id === me.cfg.pdbid || id === me.cfg.opmid || id === me.cfg.mmdbid || id === me.cfg.gi  || id === me.cfg.blast_rep_id
              || id === me.cfg.cid || id === me.cfg.mmcifid || id === me.cfg.align || id === me.cfg.chainalign || id === me.cfg.mmdbafid) {
                await ic.loadScriptCls.loadScript(ic.commandsBeforeCrash, true);
                return;
            }
        }
        ic.molTitle = '';
        ic.loadCmd;

        // set menus 
        me.htmlCls.clickMenuCls.getHiddenMenusFromCache();
        me.htmlCls.clickMenuCls.applyShownMenus();

        if(pdbStr) { // input pdbStr
            ic.init();

            ic.bInputfile = true;
            ic.InputfileType = 'pdb';
            ic.InputfileData = (ic.InputfileData) ? ic.InputfileData + '\nENDMDL\n' + pdbStr : pdbStr;

            await ic.pdbParserCls.loadPdbData(pdbStr);

            // // use NCBI residue numbers if using VAST
            // me.icn3d.bUsePdbNum = 0;

            if(me.cfg.resdef !== undefined && me.cfg.chains !== undefined) {
                let structureArray = Object.keys(ic.structures);
                let chainArray = me.cfg.chains.split(' | ');
                let chainidArray = [];
                if(structureArray.length == chainArray.length) {
                    for(let i = 0, il = structureArray.length; i  < il; ++i) {
                        chainidArray.push(structureArray[i] + '_' + chainArray[i]);
                    }

                    chainidArray = ic.chainalignParserCls.addPostfixForChainids(chainidArray);

                    let bRealign = true, bPredefined = true;
                    await ic.realignParserCls.realignChainOnSeqAlign(undefined, chainidArray, bRealign, bPredefined);
                }
            }
            // else if(me.cfg.resdef !== undefined && me.cfg.matchedchains !== undefined) {
            else if(me.cfg.matchedchains !== undefined) {
                let stru_t = Object.keys(ic.structures)[0];

                let chain_t = stru_t + '_' + me.cfg.masterchain;
                let domainidArray = me.cfg.matchedchains.split(',');
                let chainidArray = [];
                for(let i = 0, il = domainidArray.length; i  < il; ++i) {
                    let pos = domainidArray[i].lastIndexOf('_');
                    let lastId = domainidArray[i].substr(pos + 1);
                    if(!isNaN(lastId)) { // lastId is domain id
                        chainidArray.push(domainidArray[i].substr(0, pos));
                    }
                    else {
                        chainidArray.push(domainidArray[i]);
                    }
                }

                // get the matched structures, do not include the template
                let mmdbafid = '';
                for(let i = 0, il = chainidArray.length; i < il; ++i) {
                    if(i > 0) mmdbafid += ',';
                    mmdbafid += chainidArray[i].substr(0, chainidArray[i].indexOf('_'));
                }

                // realign, include the template
                ic.chainidArray = [chain_t].concat(chainidArray);
                ic.chainidArray = ic.chainalignParserCls.addPostfixForChainids(ic.chainidArray);

                // me.htmlCls.clickMenuCls.setLogCmd('resdef ' + me.cfg.resdef, true);

                ic.loadCmd = 'vast_search_chainid ' + ic.chainidArray;
                me.htmlCls.clickMenuCls.setLogCmd(ic.loadCmd, true);

                // load multiple PDBs
                // ic.bNCBI = true;
                ic.bMmdbafid = true;

                let bQuery = true;
                await ic.chainalignParserCls.downloadMmdbAf(mmdbafid, bQuery);
            }
        }
        else if(me.cfg.url !== undefined) {
            ic.bInputUrlfile = true;

            let type_url = me.cfg.url.split('|');
            let type = type_url[0];
            let url = type_url[1];
            ic.molTitle = "";
            ic.inputid = url;
            ic.inputurl = 'type=' + type + '&url=' + encodeURIComponent(url);

            ic.loadCmd = 'load url ' + url + ' | type ' + type;
            me.htmlCls.clickMenuCls.setLogCmd(ic.loadCmd, true);
            await ic.pdbParserCls.downloadUrl(url, type, me.cfg.command);
        }
        else if(me.cfg.mmtfid !== undefined) {
           ic.inputid = me.cfg.mmtfid;
           ic.loadCmd = 'load mmtf ' + me.cfg.mmtfid;
           me.htmlCls.clickMenuCls.setLogCmd(ic.loadCmd, true);
           await ic.bcifParserCls.downloadBcif(me.cfg.mmtfid);
        }
        else if(me.cfg.bcifid !== undefined) {
            ic.inputid = me.cfg.bcifid;
            ic.loadCmd = 'load bcif ' + me.cfg.bcifid;
            me.htmlCls.clickMenuCls.setLogCmd(ic.loadCmd, true);
            await ic.bcifParserCls.downloadBcif(me.cfg.bcifid);
         }
        else if(me.cfg.pdbid !== undefined) {
           ic.inputid = me.cfg.pdbid;
           ic.loadCmd = 'load pdb ' + me.cfg.pdbid;
           me.htmlCls.clickMenuCls.setLogCmd(ic.loadCmd, true);
           await ic.pdbParserCls.downloadPdb(me.cfg.pdbid);
        }
        else if(me.cfg.afid !== undefined) {
           ic.inputid = me.cfg.afid;
           ic.loadCmd = 'load af ' + me.cfg.afid;
           me.htmlCls.clickMenuCls.setLogCmd(ic.loadCmd, true);
           let bAf = true;

           //ic.pdbParserCls.downloadPdb(me.cfg.afid, bAf);
           await ic.pdbParserCls.downloadPdb(me.cfg.afid, bAf);
           //await ic.loadScriptCls.loadScript(me.cfg.command, undefined, true);
        }
        else if(me.cfg.opmid !== undefined) {
           ic.inputid = me.cfg.opmid;
           ic.loadCmd = 'load opm ' + me.cfg.opmid;
           me.htmlCls.clickMenuCls.setLogCmd(ic.loadCmd, true);
           await ic.opmParserCls.downloadOpm(me.cfg.opmid);
        }
        else if(me.cfg.mmdbid !== undefined) {
           ic.inputid = me.cfg.mmdbid;
           // ic.bNCBI = true;
           ic.loadCmd = 'load mmdb ' + me.cfg.mmdbid + ' | parameters ' + me.cfg.inpara;
           me.htmlCls.clickMenuCls.setLogCmd(ic.loadCmd, true);
           await ic.mmdbParserCls.downloadMmdb(me.cfg.mmdbid);
        }
        else if(me.cfg.gi !== undefined) {
            // ic.bNCBI = true;
            ic.loadCmd = 'load gi ' + me.cfg.gi;
            me.htmlCls.clickMenuCls.setLogCmd(ic.loadCmd, true);
            await ic.mmdbParserCls.downloadGi(me.cfg.gi);
        }
        else if(me.cfg.refseqid !== undefined) {
            ic.inputid = me.cfg.refseqid;

            // ic.bNCBI = true;
            ic.loadCmd = 'load refseq ' + me.cfg.refseqid;
            me.htmlCls.clickMenuCls.setLogCmd(ic.loadCmd, true);
            await ic.mmdbParserCls.downloadRefseq(me.cfg.refseqid);
        }
        else if(me.cfg.protein !== undefined) {
            ic.inputid = me.cfg.protein;

            // ic.bNCBI = true;
            ic.loadCmd = 'load protein ' + me.cfg.protein;
            me.htmlCls.clickMenuCls.setLogCmd(ic.loadCmd, true);
            await ic.mmdbParserCls.downloadProteinname(me.cfg.protein);
        }
        else if(me.cfg.blast_rep_id !== undefined) {
           // ic.bNCBI = true;
           ic.inputid =  me.cfg.query_id + ',' + me.cfg.blast_rep_id;

           me.cfg.oriQuery_id = me.cfg.query_id;
           me.cfg.oriBlast_rep_id = me.cfg.blast_rep_id;

           // custom sequence has query_id such as "Query_78989" in BLAST
           if(me.cfg.query_id.substr(0,5) !== 'Query' && me.cfg.rid === undefined) {
                // make it backward compatible for  figure 2 in iCn3D paper: https://academic.oup.com/bioinformatics/article/36/1/131/5520951
                if(me.cfg.from == 'icn3d' && me.cfg.blast_rep_id == '1TSR_A' && me.cfg.query_id == 'NP_001108451.1') {
                    me.cfg.command = 'view annotations; set annotation cdd; set annotation site; set view detailed view; select chain 1TSR_A; show selection';
                }

                if(me.cfg.alg == 'smithwm') {
                    ic.loadCmd = 'load seq_struct_ids_smithwm ' + me.cfg.query_id + ',' + me.cfg.blast_rep_id;
                    ic.bSmithwm = true;
                }
                else if(me.cfg.alg == 'local_smithwm') {
                    ic.loadCmd = 'load seq_struct_ids_local_smithwm ' + me.cfg.query_id + ',' + me.cfg.blast_rep_id;
                    ic.bLocalSmithwm = true;
                }
                else {
                    ic.loadCmd = 'load seq_struct_ids ' + me.cfg.query_id + ',' + me.cfg.blast_rep_id;
                    ic.bSmithwm = false;
                    ic.bLocalSmithwm = false;
                }

                me.htmlCls.clickMenuCls.setLogCmd(ic.loadCmd, true);
                await ic.mmdbParserCls.downloadBlast_rep_id(me.cfg.query_id + ',' + me.cfg.blast_rep_id);
           }
           else if(me.cfg.rid !== undefined) {
                let url = "https://blast.ncbi.nlm.nih.gov/Blast.cgi?RESULTS_FILE=on&FORMAT_TYPE=JSON2_S&FORMAT_OBJECT=Alignment&CMD=Get&RID=" + me.cfg.rid; // e.g., RID=EFTRU3W5014
                let data = await me.getAjaxPromise(url, 'json', false, 'The RID ' + me.cfg.rid + ' may have expired...');

                for(let q = 0, ql = data.BlastOutput2.length; q < ql; ++q) {

                    let hitArray;
                    if(data.BlastOutput2[q].report.results.iterations) { // psi-blast may have "iterations". Use the last iteration.
                        let nIterations = data.BlastOutput2[q].report.results.iterations.length;
                        if(data.BlastOutput2[q].report.results.iterations[nIterations - 1].search.query_id != me.cfg.query_id) continue;
                        hitArray = data.BlastOutput2[q].report.results.iterations[nIterations - 1].search.hits;
                    }
                    else { // blastp may not have "iterations"
                        if(data.BlastOutput2[q].report.results.search.query_id != me.cfg.query_id) continue;
                        hitArray = data.BlastOutput2[q].report.results.search.hits;
                    }

                    let qseq = undefined;
                    for(let i = 0, il = hitArray.length; i < il; ++i) {
                        let hit = hitArray[i];
                        let bFound = false;
                        for(let j = 0, jl = hit.description.length; j < jl; ++j) {
                            let acc = hit.description[j].accession;
                            if(acc == me.cfg.blast_rep_id) {
                                bFound = true;
                                break;
                            }
                        }
                        if(bFound) {
                            qseq = hit.hsps[0].qseq;
                            //remove gap '-'
                            qseq = qseq.replace(/-/g, '');
                            break;
                        }
                    }
                    if(qseq !== undefined) me.cfg.query_id = qseq;
                    ic.inputid = me.cfg.query_id + '_' + me.cfg.blast_rep_id;
                    ic.loadCmd = 'load seq_struct_ids ' + me.cfg.query_id + ',' + me.cfg.blast_rep_id;
                    me.htmlCls.clickMenuCls.setLogCmd(ic.loadCmd, true);
                    await ic.mmdbParserCls.downloadBlast_rep_id(me.cfg.query_id + ',' + me.cfg.blast_rep_id);
                    break;
                }
           }
           else {
               alert('BLAST "RID" is a required parameter...');
           }
        }
        else if(me.cfg.cid !== undefined) {
            if(isNaN(me.cfg.cid)) {
                let urlCid = me.htmlCls.baseUrl + "vastdyn/vastdyn.cgi?compound2cid=" + me.cfg.cid;
                let cidJson = await me.getAjaxPromise(urlCid, 'jsonp');
                if(cidJson.cid && cidJson.cid[0]) {
                    me.cfg.cid = cidJson.cid[0];
                }
                else {
                    alert("Please input an valid PubChem CID...");
                    return;
                }
            }

            ic.inputid = me.cfg.cid;

            let url = "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" + ic.inputid + "/description/jsonp";

            let data = await me.getAjaxPromise(url, 'jsonp', false);

            if(data.InformationList !== undefined && data.InformationList.Information !== undefined) ic.molTitle = data.InformationList.Information[0].Title;

            ic.loadCmd = 'load cid ' + me.cfg.cid;
            me.htmlCls.clickMenuCls.setLogCmd(ic.loadCmd, true);
            await ic.sdfParserCls.downloadCid(me.cfg.cid);
        }
        else if(me.cfg.smiles !== undefined) {
            ic.inputid = me.cfg.smiles;
            ic.loadCmd = 'load smiles ' + me.cfg.smiles;
            me.htmlCls.clickMenuCls.setLogCmd(ic.loadCmd, true);
            await ic.sdfParserCls.downloadSmiles(me.cfg.smiles);
        }
        else if(me.cfg.mmcifid !== undefined) {
            ic.inputid = me.cfg.mmcifid;
            ic.loadCmd = 'load mmcif ' + me.cfg.mmcifid;
            me.htmlCls.clickMenuCls.setLogCmd(ic.loadCmd, true);
            await ic.mmcifParserCls.downloadMmcif(me.cfg.mmcifid);
        }
        else if(me.cfg.align !== undefined) {
            // ic.bNCBI = true;

            let alignArray = me.cfg.align.split(','); // e.g., 6 IDs: 103701,1,4,68563,1,167 [mmdbid1,biounit,molecule,mmdbid2,biounit,molecule], or 2IDs: 103701,68563 [mmdbid1,mmdbid2]
            if(alignArray.length === 6) {
                ic.inputid = alignArray[0] + "_" + alignArray[3];
            }
            else if(alignArray.length === 2) {
                ic.inputid = alignArray[0] + "_" + alignArray[1];
            }

            ic.loadCmd = 'load alignment ' + me.cfg.align + ' | parameters ' + me.cfg.inpara;
            me.htmlCls.clickMenuCls.setLogCmd(ic.loadCmd, true);
            if(me.cfg.inpara && me.cfg.inpara.indexOf('atype=2') == -1) {
                await ic.alignParserCls.downloadAlignment(me.cfg.align);
            }
            else {
                let vastplusAtype = 2; // Tm-align
                await ic.chainalignParserCls.downloadMmdbAf(me.cfg.align, undefined, vastplusAtype);
            }
        }
        else if(me.cfg.chainalign !== undefined) {
            // ic.bNCBI = true;

            ic.bChainAlign = true;
            ic.inputid = me.cfg.chainalign;
            let resrangeStr = (me.cfg.resrange) ? ' | resrange ' + decodeURIComponent(me.cfg.resrange) : '';
            let resdef = (me.cfg.resdef) ? me.cfg.resdef : '';
            ic.loadCmd = 'load chainalignment ' + me.cfg.chainalign + ' | resnum ' + me.cfg.resnum + ' | resdef ' + resdef + ' | aligntool ' + me.cfg.aligntool + ' | parameters ' + me.cfg.inpara + resrangeStr;
            me.htmlCls.clickMenuCls.setLogCmd(ic.loadCmd, true);
            await ic.chainalignParserCls.downloadChainalignment(me.cfg.chainalign);
        }
        else if(me.cfg.mmdbafid !== undefined) {
            // ic.bNCBI = true;

            // remove space
            me.cfg.mmdbafid = me.cfg.mmdbafid.replace(/\s+/g, '').toUpperCase();

            ic.bMmdbafid = true;
            ic.inputid = me.cfg.mmdbafid;
            if(me.cfg.bu == 1) {
                ic.loadCmd = 'load mmdbaf1 ' + me.cfg.mmdbafid + ' | parameters ' + me.cfg.inpara;
            }
            else {
                ic.loadCmd = 'load mmdbaf0 ' + me.cfg.mmdbafid + ' | parameters ' + me.cfg.inpara;
            }
            me.htmlCls.clickMenuCls.setLogCmd(ic.loadCmd, true);

            await ic.chainalignParserCls.downloadMmdbAf(me.cfg.mmdbafid);
            //await ic.loadScriptCls.loadScript(me.cfg.command, undefined, true);
        }
        else if(me.cfg.command !== undefined && me.cfg.command !== '') {
            if(me.cfg.command.indexOf('url=') !== -1) ic.bInputUrlfile = true;
            //await ic.loadScriptCls.loadScript(me.cfg.command, undefined, true);
        }
        else {
            //alert("Please use the \"File\" menu to retrieve a structure of interest or to display a local file.");
            //me.htmlCls.dialogCls.openDlg('dl_mmdbid', 'Please input MMDB or PDB ID');
            me.htmlCls.dialogCls.openDlg('dl_mmdbafid', 'Please input PDB/MMDB/AlphaFold UniProt IDs');

            return;
        }

        await ic.loadScriptCls.loadScript(me.cfg.command, undefined, true);
    //   });
    //   return me.deferred.promise();
    };

    iCn3DUI.prototype.setIcn3d = function() { let me = this;
        let str1 = "<label class='icn3d-switch'><input id='" + me.pre + "modeswitch' type='checkbox'><div class='icn3d-slider icn3d-round' style='width:34px; height:18px; margin: 6px 0px 0px 3px;' title='Left(\"All atoms\"): Style and color menu options will be applied to all atoms in the structure&#13;Right(\"Selection\"): Style and color menu options will be applied only to selected atoms'></div></label>";
        let str2 = "<span id='" + me.pre + "modeall' title='Style and color menu options will be applied to all atoms in the structure'>All atoms&nbsp;&nbsp;</span><span id='" + me.pre + "modeselection' class='icn3d-modeselection' style='display:none;' title='Style and color menu options will be applied only to selected atoms'>Selection&nbsp;&nbsp;</span></div></div></td>";

        //me.htmlCls.WIDTH = $( window ).width() - me.htmlCls.LESSWIDTH;
        //me.htmlCls.HEIGHT = $( window ).height() - me.htmlCls.EXTRAHEIGHT - me.htmlCls.LESSHEIGHT;

        me.utilsCls.setViewerWidthHeight(me);

        if(me.utilsCls.isMobile() || me.cfg.mobilemenu) {
            me.htmlCls.setMenuCls.setTopMenusHtmlMobile(me.cfg.divid, str1, str2);
        }
        else {
            me.htmlCls.setMenuCls.setTopMenusHtml(me.cfg.divid, str1, str2);
        }

        me.icn3d = new iCn3D(me); // (ic.pre + 'canvas');

        me.icn3d.controlCls.setControl(); // rotation, translation, zoom, etc

        me.setDialogAjax();
    };

    iCn3DUI.prototype.getMmtfPromise = function(mmtfid) {    return new Promise(function(resolve, reject) {
            MMTF.fetch(
                mmtfid,
                // onLoad callback
                async function( mmtfData ){
                    resolve(mmtfData);
                },
                // onError callback
                function( error ){
                    //alert('This PDB structure is not found at RCSB...');
                    //console.error( error )
                    reject('error');
                }
            );
        });
    };

    iCn3DUI.prototype.getMmtfReducedPromise = function(mmtfid) {    return new Promise(function(resolve, reject) {
            MMTF.fetchReduced(
                mmtfid,
                // onLoad callback
                async function( mmtfData ){
                    resolve(mmtfData);
                },
                // onError callback
                function( error ){
                    //alert('This PDB structure is not found at RCSB...');
                    //console.error( error )
                    reject('error');
                }
            );
        });
    };

    iCn3DUI.prototype.getXMLHttpRqstPromise = function(url, dataType, responseType, mapType) { let me = this;
        return new Promise(function(resolve, reject) {
            let oReq = new XMLHttpRequest();
            oReq.open(dataType, url, true);
            oReq.responseType = responseType;

            oReq.onreadystatechange = function() {
                if (this.readyState == 4) {
                   if(this.status == 200) {
                       let arrayBuffer = oReq.response;
                       resolve(arrayBuffer);
                    }
                    else {
                       if(mapType == '2fofc' || mapType == 'fofc') {
                           alert("Density server at EBI has no corresponding electron density map for this structure.");
                       }
                       else if(mapType == 'em') {
                           alert("Density server at EBI has no corresponding EM density map for this structure.");
                       }
                       else if(mapType == 'rcsbEdmaps') {
                           alert("RCSB server has no corresponding electron density map for this structure.");
                       }
                       else {
                           alert("The " + mapType + " file is unavailable...");
                       }

                       reject('error');
                    }
                }
                else {
                    me.icn3d.ParserUtilsCls.showLoading();
                }
            };

            oReq.send();
        });
    };

    iCn3DUI.prototype.getAjaxPromise = function(url, dataType, beforeSend, alertMess, logMess, complete, bNode) { let me = this;
        // if(!bNode || dataType != 'json') {
            return new Promise(function(resolve, reject) {
                $.ajax({
                    url: url,
                    dataType: dataType,
                    cache: true,
                    beforeSend: function() {
                        if(beforeSend) me.icn3d.ParserUtilsCls.showLoading();
                    },
                    complete: function() {
                        if(complete) me.icn3d.ParserUtilsCls.hideLoading();
                    },
                    success: function(data) {
                        resolve(data);
                    },
                    error : function() {
                        if(alertMess) alert(alertMess);
                        if(logMess) console.log(logMess);

                        reject('error');
                    }
                });
            });
        // }
        // else {
        //     return new Promise(async function(resolve, reject) {
        //         const response = await fetch(url);

        //         response.json().then(function(data) {
        //             resolve(data);
        //         }).catch(function(error) {
        //             reject('error');
        //         });
        //     });
        // }
    };

    iCn3DUI.prototype.getAjaxPostPromise = async function(url, data, beforeSend, alertMess, logMess, complete, dataType, bNode) { let me = this;
        dataType = (dataType) ? dataType : 'json';

        // if(!bNode || dataType != 'json') {
            return new Promise(function(resolve, reject) {
                $.ajax({
                    url: url,
                    type: 'POST',
                    data : data,
                    dataType: dataType,
                    cache: true,
                    beforeSend: function() {
                        if(beforeSend) me.icn3d.ParserUtilsCls.showLoading();
                    },
                    complete: function() {
                        if(complete) me.icn3d.ParserUtilsCls.hideLoading();
                    },
                    success: function(data) {
                        resolve(data);
                    },
                    error : function() {
                        //if(alertMess) alert(alertMess);
                        if(!me.bNode && alertMess) console.log(alertMess);
                        if(!me.bNode && logMess) console.log(logMess);

                        // reject('error');
                        // keep running the program
                        resolve('error');
                    }
                });
            });
        // }
        // else {
        //     return new Promise(async function(resolve, reject) {
        //         const response = await fetch(url, {
        //             method: 'POST',
        //             headers: {
        //                 'Accept': 'application/json',
        //                 'Content-Type': 'application/json'
        //             },
        //             body: data
        //         });

        //         response.json().then(function(data) {
        //             resolve(data);
        //         }).catch(function(error) {
        //             reject('error');
        //         });
        //     });
        // }
    };

    iCn3DUI.prototype.setDialogAjax = function() { let me = this;
        // make dialog movable outside of the window
        // http://stackoverflow.com/questions/6696461/jquery-ui-dialog-drag-question
        if(!me.bNode && !$.ui.dialog.prototype._makeDraggableBase) {
            $.ui.dialog.prototype._makeDraggableBase = $.ui.dialog.prototype._makeDraggable;
            $.ui.dialog.prototype._makeDraggable = function() {
                this._makeDraggableBase();
                this.uiDialog.draggable("option", "containment", false);
            };
        }

        // https://gist.github.com/Artistan/c8d9d439c70117c8b9dd3e9bd8822d2c
        $.ajaxTransport("+binary", function(options, originalOptions, jqXHR) {
            // check for conditions and support for blob / arraybuffer response type
            if(window.FormData &&((options.dataType &&(options.dataType == 'binary')) ||(options.data &&((window.ArrayBuffer && options.data instanceof ArrayBuffer) ||(window.Blob && options.data instanceof Blob))))) {
                return {
                    // create new XMLHttpRequest
                    send: function(headers, callback) {
                        // setup all variables
                        let xhr = new XMLHttpRequest(),
                            url = options.url,
                            type = options.type,
                            async = options.async || true,
                            // blob or arraybuffer. Default is blob
                            responseType = options.responseType || "blob",
                            data = options.data || null;

                        xhr.addEventListener('load', function() {
                            let data = {};
                            data[options.dataType] = xhr.response;
                            // make callback and send data
                            callback(xhr.status, xhr.statusText, data, xhr.getAllResponseHeaders());
                        });

                        xhr.open(type, url, async);

                        // setup custom headers
                        for(let i in headers) {
                            xhr.setRequestHeader(i, headers[i]);
                        }

                        xhr.responseType = responseType;
                        xhr.send(data);
                    },
                    abort: function() {
                        jqXHR.abort();
                    }
                }
            }
        });
    };

    /*
    iCn3DUI.prototype.setIcn3dui = function(id) { let me = this;
        let idArray = id.split('_'); // id: div0_reload_pdbfile
        ic.pre = idArray[0] + "_";
        if(window.icn3duiHash !== undefined && window.icn3duiHash.hasOwnProperty(idArray[0])) { // for multiple 3D display
           me = window.icn3duiHash[idArray[0]];
        }
        return me;
    };
    */


    // required by npm
    class printMsg {
      constructor() {
        console.log("This is a message from the icn3d package");
      }
    }

    exports.ARButton = ARButton;
    exports.AddTrack = AddTrack;
    exports.AlignParser = AlignParser;
    exports.AlignSW = AlignSW;
    exports.AlignSeq = AlignSeq;
    exports.Alternate = Alternate;
    exports.Analysis = Analysis;
    exports.AnnoCddSite = AnnoCddSite;
    exports.AnnoContact = AnnoContact;
    exports.AnnoCrossLink = AnnoCrossLink;
    exports.AnnoDomain = AnnoDomain;
    exports.AnnoSnpClinVar = AnnoSnpClinVar;
    exports.AnnoSsbond = AnnoSsbond;
    exports.AnnoTransMem = AnnoTransMem;
    exports.Annotation = Annotation;
    exports.ApplyCenter = ApplyCenter;
    exports.ApplyClbonds = ApplyClbonds;
    exports.ApplyCommand = ApplyCommand;
    exports.ApplyDisplay = ApplyDisplay;
    exports.ApplyMap = ApplyMap;
    exports.ApplyOther = ApplyOther;
    exports.ApplySsbonds = ApplySsbonds;
    exports.ApplySymd = ApplySymd;
    exports.Axes = Axes;
    exports.Box = Box;
    exports.Brick = Brick;
    exports.Camera = Camera;
    exports.CartoonNucl = CartoonNucl;
    exports.ChainalignParser = ChainalignParser;
    exports.ClickMenu = ClickMenu;
    exports.Contact = Contact;
    exports.Control = Control;
    exports.ConvertTypeCls = ConvertTypeCls;
    exports.Curve = Curve;
    exports.CurveStripArrow = CurveStripArrow;
    exports.Cylinder = Cylinder;
    exports.DefinedSets = DefinedSets;
    exports.Delphi = Delphi;
    exports.DensityCifParser = DensityCifParser;
    exports.Diagram2d = Diagram2d;
    exports.Dialog = Dialog;
    exports.Domain3d = Domain3d;
    exports.Draw = Draw;
    exports.DrawGraph = DrawGraph;
    exports.Dsn6Parser = Dsn6Parser;
    exports.Dssp = Dssp;
    exports.ElectronMap = ElectronMap;
    exports.Events = Events;
    exports.Export3D = Export3D;
    exports.FirstAtomObj = FirstAtomObj;
    exports.Fog = Fog;
    exports.GetGraph = GetGraph;
    exports.Glycan = Glycan;
    exports.HBond = HBond;
    exports.HashUtilsCls = HashUtilsCls;
    exports.HlObjects = HlObjects;
    exports.HlSeq = HlSeq;
    exports.HlUpdate = HlUpdate;
    exports.Html = Html;
    exports.Impostor = Impostor;
    exports.Instancing = Instancing;
    exports.Label = Label;
    exports.Line = Line$1;
    exports.LineGraph = LineGraph;
    exports.LoadAtomData = LoadAtomData;
    exports.LoadCIF = LoadCIF;
    exports.LoadPDB = LoadPDB;
    exports.LoadScript = LoadScript;
    exports.MarchingCube = MarchingCube;
    exports.MmcifParser = MmcifParser;
    exports.MmdbParser = MmdbParser;
    exports.Mol2Parser = Mol2Parser;
    exports.MsaParser = MsaParser;
    exports.MyEventCls = MyEventCls;
    exports.OpmParser = OpmParser;
    exports.ParasCls = ParasCls;
    exports.ParserUtils = ParserUtils;
    exports.PdbParser = PdbParser;
    exports.PiHalogen = PiHalogen;
    exports.Picking = Picking;
    exports.ProteinSurface = ProteinSurface;
    exports.Ray = Ray;
    exports.RealignParser = RealignParser;
    exports.Refnum = Refnum;
    exports.ReprSub = ReprSub;
    exports.Resid2spec = Resid2spec;
    exports.ResidueLabels = ResidueLabels;
    exports.ResizeCanvas = ResizeCanvas;
    exports.RmsdSuprCls = RmsdSuprCls;
    exports.Saltbridge = Saltbridge;
    exports.SaveFile = SaveFile;
    exports.Scap = Scap;
    exports.Scene = Scene;
    exports.SdfParser = SdfParser;
    exports.SelectByCommand = SelectByCommand;
    exports.Selection = Selection;
    exports.SetColor = SetColor;
    exports.SetDialog = SetDialog;
    exports.SetHtml = SetHtml;
    exports.SetMenu = SetMenu;
    exports.SetOption = SetOption;
    exports.SetSeqAlign = SetSeqAlign;
    exports.SetStyle = SetStyle;
    exports.ShareLink = ShareLink;
    exports.ShowAnno = ShowAnno;
    exports.ShowInter = ShowInter;
    exports.ShowSeq = ShowSeq;
    exports.Sphere = Sphere$1;
    exports.Stick = Stick;
    exports.Strand = Strand;
    exports.Strip = Strip;
    exports.SubdivideCls = SubdivideCls;
    exports.Surface = Surface;
    exports.Symd = Symd;
    exports.ThreeDPrint = ThreeDPrint;
    exports.Transform = Transform;
    exports.Tube = Tube;
    exports.UtilsCls = UtilsCls;
    exports.VRButton = VRButton;
    exports.Vastplus = Vastplus;
    exports.ViewInterPairs = ViewInterPairs;
    exports.XyzParser = XyzParser;
    exports.iCn3D = iCn3D;
    exports.iCn3DUI = iCn3DUI;
    exports.printMsg = printMsg;

    Object.defineProperty(exports, '__esModule', { value: true });

    return exports;

})({});
